#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

global issue_1489_log_file
global issue_1489_lck_file

# set check_root_access_needs "no"


# define a level initialization procedure:
set check_init_level_procedure "issue_1489_init_level"

# define test's name and run level descriptions
set check_name            "issue_1489"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   0
set check_description(0)  "termination script may not be ignored, when job submited with -notify"

# define test's dependencies
set check_needs           "init_core_system" 


# setup and cleanup functions
set check_setup_function "issue_1489_setup"
set check_cleanup_function "issue_1489_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "issue_1489_run"


proc issue_1489_init_level {} {
   global CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE
   global test_array_jobs 

  switch -- $CHECK_ACT_LEVEL {
     "0" { 
           return 0    
     } 
  } 

  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

proc issue_1489_setup {} {
   global CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_ARCH CHECK_PROTOCOL_DIR
   global add_queue
   global issue_1489_log_file issue_1489_lck_file

   #
   #  the termination_method script and the infinty job will log into
   #  this file
   #
   set issue_1489_log_file "$CHECK_PROTOCOL_DIR/issue_1489.log"
   
   #
   #  the inifinty job will create this file and it will run until
   #  this file exits
   #
   set issue_1489_lck_file "$CHECK_PROTOCOL_DIR/issue_1489.lck"
   
   # create a queue with a termination_method
   
   set queue_conf(terminate_method)  "$CHECK_ACTUAL_TEST_PATH/termtest.sh \$host \$job_owner \$job_id \$job_name \$queue \$job_pid $issue_1489_log_file"
   set queue_conf(shell_start_mode)  "unix_behavior"   
   set queue_conf(notify)            "00:00:20"
   
   add_queue "iz_1489" "@allhosts" queue_conf 1
   
   delete_file $issue_1489_lck_file 0
   delete_file $issue_1489_log_file 0
   set_error 0 "ok"
}

proc issue_1489_cleanup  {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_MASTER
   global issue_1489_log_file issue_1489_lck_file del_queue
  
   delete_all_jobs
   wait_for_end_of_all_jobs 60
  
   puts $CHECK_OUTPUT "delete test queue"
   del_queue "iz_1489" "@allhosts" 0 1
  
   puts $CHECK_OUTPUT "cleaning up log and lck files"

   delete_file $issue_1489_lck_file 0
   delete_file $issue_1489_log_file 0

   set_error 0 "ok"
}

proc issue_1489_run {} {
   global CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_PROTOCOL_DIR 
   global submitresult delete_job
   global issue_1489_log_file issue_1489_lck_file
   
   set option "-o /dev/null -e /dev/null"
   #set option "-o $CHECK_PROTOCOL_DIR/iz_1489.stdout -e $CHECK_PROTOCOL_DIR/iz_1489.stderr"
   
   # -notify
   
   set my_job [ submit_job "-q iz_1489  $option $CHECK_ACTUAL_TEST_PATH/infinity.sh $issue_1489_lck_file" ]
   if {$my_job < 0 } {
     set_error 1 "submit job failed"
     return
   }
   
   puts $CHECK_OUTPUT "waiting for file $issue_1489_lck_file"
#   waiting only 10 seconds for the lock file is to short for NFS directories
#   set res [ wait_for_file $issue_1489_lck_file 10 0 ]
   set res [ wait_for_file $issue_1489_lck_file 70 0 ]

   
   if { $res == 0 } {
      puts $CHECK_OUTPUT "lock file $issue_1489_lck_file has been created, job $my_job is running"
   } else {   
      set_error 1 "lock file $issue_1489_lck_file has not been created, job $my_job has not started"
      return
   }
   
   set del_result [ delete_job $my_job ]
   
   if { $del_result != 0 } {
     set_error -1 "qdel of job $my_job failed"
      return
   }
   
   # wait 30 seconds (notify is 20 seconds)  for the deletion of the lock file
   # CR -> wait longer 70 seconds (because of NFS timeouts)
   set res [ wait_for_file $issue_1489_lck_file 70 1 ]

   if { $res == 0 } {
      puts $CHECK_OUTPUT "lock file $issue_1489_lck_file has been deleted, job $my_job gots the TERM signal"
   } else {
      set_error 1 "lock file $issue_1489_lck_file has not been deleted, job $my_job did not get the TERM signal"
      return
   }
   
   set_error 0 "ok"
}


