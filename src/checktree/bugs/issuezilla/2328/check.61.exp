#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "issue_2328_init_level"

# define test's name and run level descriptions
set check_name            "issue_2328"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "Check test for IZ 2328"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function issue_2328_setup
set check_cleanup_function issue_2328_cleanup

# define test's procedure order
set check_functions ""
lappend check_functions "issue_2328"

proc issue_2328_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" { 
         return 0
      } 
   } 

   return -1  ;# no other level 
}

proc issue_2328_setup  {} {
   global CHECK_OUTPUT ts_config max_queue_count  

   # 1. Setup the complex FOO1-F0010

   set tmp_complex(F001) "F001 INT  <= YES YES 0 0"
   set tmp_complex(F002) "F002 INT  <= YES YES 0 0"
   set tmp_complex(F003) "F003 INT  <= YES YES 0 0"
   set tmp_complex(F004) "F004 INT  <= YES YES 0 0"
   set tmp_complex(F005) "F005 INT  <= YES YES 0 0"
   set tmp_complex(F006) "F006 INT  <= YES YES 0 0"
   set tmp_complex(F007) "F007 INT  <= YES YES 0 0"
   set tmp_complex(F008) "F008 INT  <= YES YES 0 0"
   set tmp_complex(F009) "F009 INT  <= YES YES 0 0"
   set tmp_complex(F0010) "F0010 INT  <= YES YES 0 0"

   set_complex tmp_complex
   
   # Modify the scheduler fast
   set mysched_config(params) "PROFILE=true"
   set mysched_config(max_reservation) "1000"

   puts $CHECK_OUTPUT "Modify schedd fast ...\n"
   mod_schedd_config mysched_config

   # Modify the global cluster 
   set my_cluster_conf(complex_values) "F001=100,F002=100,F003=100,F004=100,F005=100,\
                     F006=100,F007=100,F008=100,F009=100,F0010=100"
   set_config my_cluster_conf "global"

   # Set up 80 queues for 5 hosts - 400 queues
   # We do it here so as not to affect the rest of qsub tests.
   
   set max_queue_count "80"
   
   for  {set queue_counter "1"} { $queue_counter <= $max_queue_count } { incr queue_counter 1} {
      set queue_name "qsub_ts$queue_counter.q"
      set queue_conf(slots) 10
      puts $CHECK_OUTPUT "Add queue $queue_name"
      set result [add_queue $queue_name "@allhosts" queue_conf 1]
      sleep 1
      if { $result < 0 } {
         add_proc_error "issue_2328_setup" -1 "add qsub_ts_$queue_counter.q failed ($result)"
      }
   }
   
   # Check that we created $max_queue_count queues....
   # We subtract 1 for all.q, which we don't want to count
   
   set queues_made [llength [start_sge_bin "qconf" "-sql"]]
   set number_queues_made [expr  $queues_made - 1]
   puts $CHECK_OUTPUT "we created $number_queues_made queues and we wanted $max_queue_count queues \n"
   
   if { $number_queues_made != $max_queue_count } {
               add_proc_error "issue_2328_setup" -1 "we did not make all the required queues"
   }
   
   # Create 5 projects
   for { set prj_counter "1"} { $prj_counter <= "5"} { incr prj_counter 1} {
      set prj_config(name) "Project$prj_counter"
      add_prj prj_config
   }

    
   # 4. Add rqs a_new_rqs
   set rqs_name              "perf_rqs"
   set rules                  ""
   lappend rules              "projects {*} to F001=1,F002=1,F003=1,F004=1,F005=1, \
                              F006=1,F007=1,F008=1,F009=1,F0010=1"             
   set rqs_charray($rqs_name,limit)   "$rules"
   set rqs_charray($rqs_name,enabled) "true"
   set rqs_charray($rqs_name,description) "global"
   
   add_rqs rqs_charray

}

proc issue_2328_cleanup  {} {
   global CHECK_OUTPUT ts_config max_queue_count  lines_with_time


   delete_all_jobs
   wait_for_end_of_all_jobs
   
   if {[get_rqs_list rqs_names "" "" 0] == 0} {
      foreach elem $rqs_names {
         puts $CHECK_OUTPUT "Removing resource quota sets $elem ...\n"
         del_rqs $elem
      }
   }
   
   # Delete all the new queues we created earlier
   # We do it here so as not to affect the rest of qsub tests.

   for  {set queue_counter "1"} { $queue_counter <= $max_queue_count } { incr queue_counter 1} {
      del_queue "qsub_ts$queue_counter.q"  "" 1 1
   }
   
   
   # Delete the  5 projects
   for { set prj_counter "1"} { $prj_counter <= "5"} { incr prj_counter 1} {
      set prj_config(name) "Project$prj_counter"
      del_prj $prj_config(name)
   }
   
   sleep 2
   
   set tmp_complex(F001) ""
   set tmp_complex(F002) ""
   set tmp_complex(F003) ""
   set tmp_complex(F004) ""
   set tmp_complex(F005) ""
   set tmp_complex(F006) ""
   set tmp_complex(F007) ""
   set tmp_complex(F008) ""
   set tmp_complex(F009) ""
   set tmp_complex(F0010) ""

   set_complex tmp_complex
   
   # Clear global cluster of F** complexes
   set my_cluster_conf(complex_values) ""
   set_config my_cluster_conf "global"
   
   
   # Reset the scheduler back 
   reset_schedd_config

   # Print out again the job dispatch time
   puts $CHECK_OUTPUT "the lines with time are \n$lines_with_time "

}

#************************************************************
#  NAME
#     issue_2328() -- Testcase for  IZ 2328.
#
#  SYNOPSIS
#
#   0. Setup, cleanup in check_qsub_setup check_qsub_cleanup
#  
#   1. qmod -d "*"
#
#   2.  Submit 1000 jobs like this
# 
#    for i=1-10
#      for j=1-5
#         for k=1-20
#            qsub -R y -P Project{j} -l F00{i}=1 -b y /bin/sleep 5
#
#   3. qmod -e "*"
#
#   4. Watch the "job dispatching took" lines in sge_schedd(8) messages file
#
#  FUNCTION
#     Check if IZ 2328 has been fixed.
#  INPUTS
#
#*******************************************************************************
proc issue_2328 {} {
   
   global ts_config env lines_with_time               
   global CHECK_OUTPUT CHECK_USER CHECK_ACTUAL_TEST_PATH
   
   # For this test we need at least 5 hosts
   set number_of_execds [llength [start_sge_bin "qconf" "-sel"]]
   
   if { $number_of_execds < 5 } {
       add_proc_error "issue_2328" -3 "Need at least 5 hosts for this test. \
                  We only have $number_of_execds \n"
   }   
   set host $ts_config(master_host)
   
   set SGE_ROOT $ts_config(product_root)
   set SGE_CELL $ts_config(cell)
      
   set sched_messg_file "$SGE_ROOT/$SGE_CELL/spool/qmaster/schedd/messages"

   # Remove SGE_ROOT/$SGE_CELL/spool/qmaster/schedd/messages file
   # so that we catch only the latest job dispatch messages from this run
   
   file delete $sched_messg_file

   # Disable all queues first
   
   puts $CHECK_OUTPUT "disable queues.... \n"
   
   set qmod_result [start_sge_bin "qmod" "-d \'\*\'"]
   if { $qmod_result < 0 } {
      add_proc_error "issue_2328" -1 "qmod -d \* in 146 failed ($qmod_result)"

   }
   
   set i_max "10"
   set k_max "20"

   #Submit the jobs now: i to 10, j to 5, k to 20
   
   for {set i "1"} { $i <= $i_max} {incr i 1} {
      for {set j "1"} { $j <= "5"} {incr j 1} {
         for {set k "1"} { $k <= $k_max} {incr k 1} {
            submit_job " -R y -P Project$j -l F00$i=1 -b y /bin/sleep 5" 1 30

         }
      }
   }
   
   #Enable all queues now
   
   puts $CHECK_OUTPUT "enable queues now .... \n"
   
   set qmod_result [start_sge_bin "qmod" "-e \'\*\'"]
   if { $qmod_result < 0 } {
      add_proc_error "issue_2328" -1 "qmod -e \* in 146 failed ($qmod_result)"
   }
   
   trigger_scheduling
   
   sleep 6 
      
   # tail -f schedd reporting file
   set pattern "job dispatching"
   set timeout 200
   
   init_logfile_wait $ts_config(master_host) $sched_messg_file
   logfile_wait $pattern $timeout 0

   # Look now in $sched_messg_file for lines with "job dispatching took" or
   # "scheduled in"
   
   sleep 10
   
   puts $CHECK_OUTPUT "look now in $sched_messg_file file for dispatch time \n"
   
   set lines_with_time [exec grep "job dispatching took" $sched_messg_file]
   puts $CHECK_OUTPUT "the lines with time are \n$lines_with_time \n"
   
   delete_all_jobs
   wait_for_end_of_all_jobs
      
   # shutdown tail -f
   close_logfile_wait
   
}   
