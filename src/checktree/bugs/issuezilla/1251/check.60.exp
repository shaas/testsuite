#!/vol2/TCL_TK/glinux/bin/expect --
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr check_highest_level
global check_init_level_procedure check_category
global check_root_access_needs
global prj_count node_count stree tmp_name

set check_init_level_procedure "issue_1251_init_level"

set check_category            "COMPATIBILITY SYSTEM VERIFIED"
set check_name                "issue_1251"
set check_description(0)      "qconf -sstree segfaults when sharetree is very large"
set check_needs               "init_core_system"      ;# dependencies of this check (name of other check)
set check_root_access_needs   "no"

# setup and cleanup functions
set check_setup_function issue_1251_setup
set check_cleanup_function issue_1251_cleanup

# define test's procedure order
set check_functions           ""
lappend check_functions       "issue_1251_run"   ;# functions to call (in order)
set check_highest_level       0
set my_pid [pid]
set tmp_name "/tmp/tmp1251.$my_pid"

proc issue_1251_init_level {} {
   global CHECK_ACT_LEVEL

   # setup levels 
   switch -- $CHECK_ACT_LEVEL {
      "0"  {
         return 0
      }
   }

   return -1
}

proc issue_1251_setup {} {
   global project_names

   # here we'll remember which projects were created during the test
   set project_names {}

   # delete a possibly existing sharetree
   del_sharetree

   set_error 0 "ok"
}

proc issue_1251_cleanup {} {
   global project_names

   # delete the sharetree
   del_sharetree

   # delete the projects that were created during the test
   foreach project $project_names {
      del_prj $project
   }

   set_error 0 "ok"
}

proc issue_1251_run  {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH tmp_name prj_count node_count stree CHECK_OUTPUT

   set prj_count 0
   set node_count 0
   set stree ""

   issue_1251_build_share_tree 5

   set f [ open "$tmp_name" w ]
   puts $f $stree
   close $f

   # Add new share tree
   catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Astree $tmp_name" } result

   # Remove temp file
   catch { eval exec "rm $tmp_name" } result

   # Print share tree
   set catch_result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sstree" ">&/dev/null" } result ]

   if {$catch_result != 0} {
      add_proc_error "issue_1251_run" "-1" "qconf failed to display share tree: $result"
      set_error -1 "Issue 1251: qconf -sstree unable to display large share tree"
   } else {
      set_error 0 "ok"
   }
}

proc issue_1251_build_share_tree { depth } {
   global prj_count node_count stree

   set parent $node_count
   set child1 [ expr $parent + 1 ]
   set child2 [ expr $child1 + 1 ]
   incr node_count 1

   if { $depth > 0 } {
      set stree "${stree}id=$parent\n"
      set stree "${stree}name=ThisIsAVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongName.Node$parent\n"
      set stree "${stree}type=0\n"
      set stree "${stree}shares=1\n"
      set stree "${stree}childnodes=$child1,$child2\n"

      issue_1251_build_share_tree [ expr $depth - 1 ]
      issue_1251_build_share_tree [ expr $depth - 1 ]
   } else {
      issue_1251_add_project "prj$prj_count"

      set stree "${stree}id=$parent\n"
      set stree "${stree}name=prj$prj_count\n"
      set stree "${stree}type=0\n"
      set stree "${stree}shares=1\n"
      set stree "${stree}childnodes=NONE\n"

      incr prj_count 1
   }
}

proc issue_1251_add_project { name } {
   global tmp_name CHECK_PRODUCT_ROOT CHECK_ARCH
   global project_names

   lappend project_names $name

   set f [ open "$tmp_name" w ]
   puts $f "name $name"
   puts $f "oticket 0"
   puts $f "fshare 0"
   puts $f "acl NONE"
   puts $f "xacl NONE"
   close $f

   # Add new project
   catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aprj $tmp_name" } result
   # Remove temp file
   catch { eval exec "rm $tmp_name" } result
}
