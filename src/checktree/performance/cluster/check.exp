#!/vol2/TCL_TK/glinux/bin/expect --
# expect script 
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__


# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr check_highest_level
global check_init_level_procedure check_category

set check_init_level_procedure "cluster_perf_init_level"
set check_name                 "cluster_perf"
set check_category             "PERFORMANCE"
set check_description(0)       "cluster_perf job count (functional)"
set check_description(300)     "cluster_perf job counts with 5000 jobs"


set check_needs               "init_core_system"      ;# dependencies of this check (name of other check)
set check_functions           "cluster_perf_setup"          ;# functions to call (in order)
lappend check_functions       "cluster_perf_do_perform_test"
lappend check_functions       "cluster_perf_make_analysis"
lappend check_functions       "cluster_perf_cleanup"
set check_highest_level       300

global job_steps
global nr_queues
global max_jobs
global pending_jobs
global queue_list
global host_list
global job_times
global stored_configuration
global start_time pending_time end_time
global submit_results
global schedule_results
global scan_time
global schedule_interval
#                                                             max. column:     |
#****** performance/init_level() ******
# 
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc cluster_perf_init_level {} {
  global CHECK_ACT_LEVEL CHECK_CORE_EXECD CHECK_OUTPUT
  global nr_queues 
  global max_jobs
  global pending_jobs schedule_interval schedule_results
  global job_times submit_results job_steps
  global scan_time FLUSH_FINISH_SEC FLUSH_SUBMIT_SEC

  set submit_results ""
  set schedule_results ""
  set schedule_interval "00:00:05"
  
  switch -- $CHECK_ACT_LEVEL {
  "0"   { 
           set nr_queues 24
           set max_jobs  50
           set job_steps 2
           set job_times "30"
           set FLUSH_SUBMIT_SEC 0
           set FLUSH_FINISH_SEC 0
           return 0  
        }

  "300" { 
           set nr_queues 50
           set max_jobs  100
           set job_steps 5
           set job_times "30"
           set FLUSH_SUBMIT_SEC 0
           set FLUSH_FINISH_SEC 0
           return  0 
        }
  }

  return -1
}

#                                                             max. column:     |
#****** performance/setup_queues() ******
# 
#  NAME
#     setup_queues -- ??? 
#
#  SYNOPSIS
#     setup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc cluster_perf_setup {} {
   global ts_config
   global CHECK_CORE_EXECD save_queue_values
   global nr_queues CHECK_CORE_MASTER
   global queue_list
   global host_list
   global stored_configuration schedule_interval
   global FLUSH_FINISH_SEC FLUSH_SUBMIT_SEC

  
   if { [info exists stored_configuration] } {
      unset stored_configuration
   }
   get_config stored_configuration

   set myconfig(loglevel)         "log_warning"
   set myconfig(load_report_time) "0:0:60"
  
   if { $ts_config(gridengine_version) == 53 } {
      if { $FLUSH_SUBMIT_SEC == -1 && $FLUSH_FINISH_SEC == -1 } {
         set myconfig(schedd_params)    $stored_configuration(schedd_params)
      } else {
         set myconfig(schedd_params)    "$stored_configuration(schedd_params),FLUSH_SUBMIT_SEC=${FLUSH_SUBMIT_SEC},FLUSH_FINISH_SEC=${FLUSH_FINISH_SEC}"
      }
   }  
   else {
      if { $FLUSH_SUBMIT_SEC > 0}  {
         set my_schedd_config(flush_submit_sec)    "$FLUSH_SUBMIT_SEC"
      }
      if { $FLUSH_FINISH_SEC > 0}  {
         set my_schedd_config(flush_finish_sec)    "$FLUSH_FINISH_SEC"
      }
   }
   set_config myconfig
  
   set my_schedd_config(schedule_interval)          "$schedule_interval"
   set my_schedd_config(job_load_adjustments)       "none"
   set my_schedd_config(load_adjustment_decay_time) "0:0:0"
   set my_schedd_config(schedd_job_info)            "false"
   set_schedd_config my_schedd_config
  
   set host_list ""
   set dis_list ""
   foreach elem $CHECK_CORE_EXECD {
      lappend dis_list $elem.q
#      if { [string compare $elem $CHECK_CORE_MASTER] == 0 } { 
#         continue;
#      }
      lappend host_list $elem
   }
   disable_queue $dis_list 
 
   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** performance/cleanup_queues() ******
# 
#  NAME
#     cleanup_queues -- ??? 
#
#  SYNOPSIS
#     cleanup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc cluster_perf_cleanup {} {
   global CHECK_CORE_EXECD save_queue_values
   global nr_queues CHECK_CORE_MASTER
   global host_list
   global stored_configuration


   set en_list ""
   foreach elem $CHECK_CORE_EXECD {
      lappend en_list $elem.q
   }
   enable_queue $en_list 
   reset_schedd_config
   set_config stored_configuration

   set_error 0 "no errors"
}




proc cluster_perf_add_submit_results { hostlist } {
   global submit_results CHECK_PROTOCOL_DIR

   foreach elem $hostlist {
      set file_p [open "$CHECK_PROTOCOL_DIR/$elem.submit.log" "r" ]
      while { [gets $file_p line] >= 0 } {
         append submit_results "$line\n"
      }
      close $file_p
   }
}

#
#                                                             max. column:     |
#
#****** check/cluster_perf_make_analysis() ******
#  NAME
#     cluster_perf_make_analysis() -- ??? 
#
#  SYNOPSIS
#     cluster_perf_make_analysis { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc cluster_perf_make_analysis {} {
   global start_time pending_time end_time
   global CHECK_PROTOCOL_DIR host_list submit_results 
   global schedule_results pending_jobs max_jobs job_times
   global CHECK_PRODUCT_ROOT CHECK_ARCH nr_queues
   global CHECK_CORE_EXECD CHECK_OUTPUT


   puts $CHECK_OUTPUT $schedule_results
   puts $CHECK_OUTPUT $submit_results 

   set global_results ""
   set result ""
   catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -sconf" } result
   set help [split $result "\n"]
   foreach elem $help {
      append global_results "|qconf -sconf:|$elem|\n"
   }
   set result ""
   catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ssconf" } result
   set help [split $result "\n"]
   foreach elem $help {
      append global_results "|qconf -ssconf:|$elem|\n"
   }



   set file_p [ open "$CHECK_PROTOCOL_DIR/schedule.txt" "a" ]
   puts $file_p $global_results
   puts $file_p "|Start Date&Time|End Date&Time|Runtime|JobTime|JobCount|TotalRunTime|NrQueues|NrHosts|NrQueues/Host|QueueErrors"
   set help [ split $schedule_results "\n" ]
   
   foreach line $help {
      puts $file_p $line
   } 
   close $file_p

   set file_p [ open "$CHECK_PROTOCOL_DIR/submit.txt" "a" ]
   puts $file_p $global_results
   puts $file_p "|Date&Time|Time|Submit run time|Job ID|Hostname"
   set help [ split $submit_results "\n" ]
   foreach line $help {
      if { [ string first "S|" $line ] == 0 } {
         set data [ split $line "|" ]
         set date [lindex $data 1]
         set time [lindex $data 2]
         set hostname [lindex $data 3] 
      }

      if { [ string first "your job" $line ] >= 0 } {
         set job_id [lindex $line 2]
      }

      if { [ string first "E|" $line ] == 0 } {
         set data [ split $line "|" ]
         set date2 [lindex $data 1]
         set time2 [lindex $data 2]


         scan $time "%d:%d:%d" time_h time_m time_s
         set time_h [ expr ( $time_h * 3600 ) ]
         set time_m [ expr ( $time_m * 60 ) ]
         set seconds1 [ expr ( $time_h + $time_m + $time_s ) ] 

         scan $time2 "%d:%d:%d" time_h time_m time_s
         set time_h [ expr ( $time_h * 3600 ) ]
         set time_m [ expr ( $time_m * 60 ) ]
         set seconds2 [ expr ( $time_h + $time_m + $time_s )  ]  

         set submit_run_time [ expr ( $seconds2 - $seconds1 )]
         puts $file_p "|$date $time|$time|$submit_run_time|$job_id|$hostname"
      }
   } 
   close $file_p
 

   set_error 0 "ok"
}

proc cluster_perf_do_perform_test {} {
   global max_jobs CHECK_CORE_EXECD CHECK_PRODUCT_ROOT
   global pending_jobs CHECK_ARCH
   global CHECK_OUTPUT CHECK_PROTOCOL_DIR
   global queue_list 
   global host_list nr_queues scan_time
   global start_time pending_time end_time schedule_results
   global nr_queues job_steps job_times




   set max_hosts [ llength $host_list ]
   for { set hosts 1 } { $hosts <= $max_hosts } { incr hosts 1 } {
       set host_queues [expr ( $nr_queues / $hosts )]
       set host_names ""
       for  { set x 1 } { $x <= $hosts } { incr x 1 } {
          lappend host_names [ lindex $host_list [ expr ( $x - 1 ) ] ] 
       }
       puts $CHECK_OUTPUT "\njobs  : $max_jobs"
       puts $CHECK_OUTPUT "time  : $job_times"
       puts $CHECK_OUTPUT "hosts : $hosts ($host_names)"
       puts $CHECK_OUTPUT "queues: $nr_queues"
       puts $CHECK_OUTPUT "each execution hosts(nr=$hosts) will ..."
       puts $CHECK_OUTPUT "have $host_queues queues."

       # add queues
       set queue_names ""
       foreach host $host_names { 
          set change_array(hostname) "$host"
          set change_array(slots) "1"
          set change_array(load_thresholds) "none"
         
          for {set i 0} {$i < $host_queues} {incr i 1} {
             set change_array(qname) "${host}_m${i}"
             add_queue change_array fast
             lappend queue_names "${host}_m${i}"
          }
       }
       

       for { set step 1 } { $step <= $job_steps } { incr step 1 } {
          set job_time  [ expr ( $job_times * $step     ) ]
          set job_count [ expr ( $max_jobs / $step      ) ]
          set runtime   [ expr ( $job_time * $job_count ) ]

          puts $CHECK_OUTPUT "job time is $job_time"
          puts $CHECK_OUTPUT "job count is $job_count"
          puts $CHECK_OUTPUT "real runtime is $runtime"

          
          set current_job_id [ submit_job "-e /dev/null -o /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10" ]
          wait_for_end_of_all_jobs 300 

          puts $CHECK_OUTPUT "disable all queues ..."
          disable_queue $queue_names


          puts $CHECK_OUTPUT "submitting $job_count jobs ..." 
          set last_job_id [ expr ( $job_count + $current_job_id ) ]
          cluster_perf_submit_jobs $host_names $job_time $last_job_id
      
          for { set deljob $current_job_id } { $deljob <= $last_job_id } {incr deljob 1 } {
             file delete $CHECK_PROTOCOL_DIR/$deljob
          }
          file delete $CHECK_PROTOCOL_DIR/0
          wait_for_jobpending $last_job_id "Sleeper" 3000
          

          set jobs_submitted 0
          foreach h $host_names {
             set catch_return [catch { eval exec "tail -1 $CHECK_PROTOCOL_DIR/$h.submitted" } jobs_sub]
             if { $catch_return == 0 } {
                 incr jobs_submitted $jobs_sub
             } else {
                 puts $CHECK_OUTPUT "submitted jobs file not found"
             }
          }
          set last_job_id [ expr ( $jobs_submitted + $current_job_id ) ]
          cluster_perf_add_submit_results $host_names
 
          puts $CHECK_OUTPUT "enable all queues ..."
          enable_queue $queue_names

          puts $CHECK_OUTPUT "saving start time ..."
          set start_time_stamp [timestamp]
          set start_time_text  [ eval exec "date +%H:%M:%S" ]
          set start_date_text  [ eval exec "date +%m/%d/20%y" ]

        
          puts $CHECK_OUTPUT "wait for last job ..."
          
          for { set w1 [ expr ( $current_job_id + 1 ) ] } { $w1 <= [ expr ( $last_job_id ) ] } { incr w1 1 } {
             puts $CHECK_OUTPUT "waiting for job $w1 (last job is: $last_job_id)"
             set while_start_time [timestamp]
             set stop 0
             while { [file isfile $CHECK_PROTOCOL_DIR/$w1] != 1 && $stop != 1 } {
                puts -nonewline $CHECK_OUTPUT "."
                flush $CHECK_OUTPUT
                sleep 2
                set now_time [timestamp]
                if { $now_time - $while_start_time > 300 } {
                    add_proc_error "cluster_perf_do_perform_test" -1 "timeout waiting for job file ${CHECK_PROTOCOL_DIR}/${w1}"
                    set stop 1
                }
             }
          }
          wait_for_end_of_all_jobs 300 
          puts $CHECK_OUTPUT "all jobs done." 
          puts $CHECK_OUTPUT "saving end time ..."
          set end_time_stamp [timestamp]
          set end_time_text  [ eval exec "date +%H:%M:%S" ]
          set end_date_text  [ eval exec "date +%m/%d/20%y" ]
          set run_time_sec   [ expr ( $end_time_stamp - $start_time_stamp ) ]     

          puts $CHECK_OUTPUT "checking queues ..."

          set queue_state_errors 0
          foreach host1 $host_names { 
             for {set i1 0} {$i1 < $host_queues} {incr i1 1} {
             puts -nonewline $CHECK_OUTPUT "                         \r${host1}_m${i1}"
             flush $CHECK_OUTPUT
             set state [ get_queue_state "${host1}_m${i1}" ]
                if { [ string compare "" $state ] != 0 } { 
                   puts $CHECK_OUTPUT "queue_state of ${host1}_m${i1}: $state"
                   incr queue_state_errors 1
                }
             }
          }   

          set log_data "\|$start_date_text $start_time_text\|$end_date_text $end_time_text\|$run_time_sec\|$job_time\|$job_count\|$runtime\|$nr_queues\|$hosts\|$host_queues\|$queue_state_errors\n"
          puts $CHECK_OUTPUT $log_data
          append schedule_results $log_data

          for { set deljob $current_job_id } { $deljob <= $last_job_id } {incr deljob 1 } {
             file delete $CHECK_PROTOCOL_DIR/$deljob
          }
          file delete $CHECK_PROTOCOL_DIR/0

       }


       # delete queues
       
       foreach host $host_names { 
          for {set i 0} {$i < $host_queues} {incr i 1} {
             del_queue "${host}_m${i}"
          }
       }
   } 

   sleep 2
   set_error 0 "ok"
   return
}


proc cluster_perf_submit_jobs { hosts job_time max_job_id } {
   global ts_config
   global CHECK_PROTOCOL_DIR CHECK_OUTPUT CHECK_USER
   global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
   global CHECK_PRODUCT_ROOT
   
    foreach elem $hosts {
       puts $CHECK_OUTPUT "starting submit until job id $max_job_id accurs on host $elem ..."
       set command "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/remote_submit_log.sh"
       set args "\"$CHECK_PRODUCT_ROOT\" \"$ts_config(cell)\" \"$max_job_id\" \"$CHECK_PROTOCOL_DIR\" \"$job_time\" \"$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/sleeper.sh\" \"$CHECK_PROTOCOL_DIR\""
       puts $CHECK_OUTPUT [start_remote_prog $elem $CHECK_USER $command $args prg_exit_state 300 1]
    }

}
