#!/vol2/TCL_TK/glinux/bin/expect --
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr check_highest_level
global check_init_level_procedure check_category

set check_init_level_procedure "scheduler_perf_init_level"
set check_category            "PERFORMANCE"
set check_name                "scheduler"
set check_description(0)      "Functional test"
set check_description(1)      "Standard test"
set check_description(2)      "Test host_complexes without job requests" 
set check_description(3)      "Test global_complexes with job requests" 
set check_description(4)      "Test global_complexes with job requests, but no queue thresholds" 
set check_description(99)     "Make analysis"

set check_description(100)    "test"

set check_needs               "init_core_system"      ;# dependencies of this check (name of other check)

set check_functions           ""
lappend check_functions       "scheduler_setup"          ;# functions to call (in order)
lappend check_functions       "scheduler_test_run"
lappend check_functions       "scheduler_cleanup"
# set check_functions       "show_all_schedd_test_data"
set check_highest_level       100

global scheduler_test_level 
global scheduler_queue_list
global scheduler_complex_count

proc scheduler_perf_init_level {} {
   global CHECK_ACT_LEVEL CHECK_PRODUCT_TYPE
   global scheduler_test_level scheduler_complex_count




   switch -- $CHECK_ACT_LEVEL {
      "0"  { 
         set scheduler_test_level "functional"
         return 0
      }
      "1" { 
         set scheduler_test_level "standard"
         return 0
      }
      "2" {
         set scheduler_test_level "host_complexes"
         set scheduler_complex_count 15
         return 0
      }
      "3" {
         set scheduler_test_level "global_complexes"
         set scheduler_complex_count 15
         return 0
      }
      "4" {
         set scheduler_test_level "glob_complexes_no_threshold"
         set scheduler_complex_count 15
         return 0
      }

      "99" {
         set scheduler_test_level "analysis"
         return 0
      }
      "100"  { 
         return -1
      }
   }
   return -1
}


proc scheduler_setup {} {
   global ts_config
   global stored_configuration CHECK_OUTPUT scheduler_test_level
   global scheduler_queue_list CHECK_CORE_EXECD 
   global scheduler_complex_count

   if { [string match "analysis" $scheduler_test_level] == 0 } {
      puts $CHECK_OUTPUT "saving configuration ..."
      if { [info exists stored_configuration] } {
         unset stored_configuration
      }
      get_config stored_configuration
   
      set scheduler_queue_list ""
      foreach host $CHECK_CORE_EXECD {
         # disable default queues
         disable_queue $host.q
         set queue(hostname) $host
         set queue(slots) 4
         set queue(load_thresholds) "np_load_avg=11.75"
         for { set q_nr 1 } { $q_nr <= 20 } { incr q_nr 1 } {
            set queue(qname) "$host.q${q_nr}"
            add_queue queue 1
            lappend scheduler_queue_list $queue(qname)
         }
      }  

      



      # cluster configuration 
      puts $CHECK_OUTPUT "setup configuration ..."

      set myconfig(loglevel)         "log_warning"
      if { $ts_config(gridengine_version) == 53 } {
         set my_schedd_params "PROFILE=1"
         if { [string compare "none" $stored_configuration(schedd_params)] != 0 } {
            append my_schedd_params ",$stored_configuration(schedd_params)"
         }
         set myconfig(schedd_params)    "$my_schedd_params"
      }
      else{
         get_schedd_config stored_schedd_config
         if { [string compare "none" $stored_schedd_config(params)] != 0 } {
            append my_schedd_params ",$stored_schedd_config(params)"
         }
         set my_schedd_config(params)      "$my_schedd_params"
      } 
      set_config myconfig
      
      # scheduler configuration
      puts $CHECK_OUTPUT "setup scheduler configuration ..."

      set my_schedd_config(schedule_interval)  "0:30:00"
      set my_schedd_config(job_load_adjustments) "none"
      set my_schedd_config(schedd_job_info)      "false"
      set_schedd_config my_schedd_config

      if { [string match "host_complexes" $scheduler_test_level] } {
         # complexes
         puts $CHECK_OUTPUT "setup complexes"
         for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} { 
            set host_complex(complex_$i) "c$i INT 55 <= yes yes 0"
         } 
         set_complex host_complex "host"
         foreach queue_member $scheduler_queue_list {
            set myqueue(load_thresholds) "np_load_avg=11.75"
            for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} {
               append myqueue(load_thresholds) ",complex_$i=10.00"
            }
            set_queue $queue_member myqueue
         }

         set my_host_config(complex_values) "complex_1=20000"
         for { set i 2 } { $i <= $scheduler_complex_count} { incr i 1} {
            append my_host_config(complex_values) ",complex_$i=20000"
         }
         foreach host $CHECK_CORE_EXECD {
            set_exechost my_host_config $host
         }
      }

      if { [string match "global_complexes" $scheduler_test_level] } {
         # complexes
         puts $CHECK_OUTPUT "setup complexes"
         for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} { 
            set host_complex(complex_$i) "c$i INT 55 <= yes yes 0"
         } 
         
         set_complex host_complex global 
         foreach queue_member $scheduler_queue_list {
            set myqueue(load_thresholds) "np_load_avg=11.75"
            for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} {
               append myqueue(load_thresholds) ",complex_$i=10.00"
            }
            set_queue $queue_member myqueue
         }
         set my_host_config(complex_values) "complex_1=20000"
         for { set i 2 } { $i <= $scheduler_complex_count} { incr i 1} {
            append my_host_config(complex_values) ",complex_$i=20000"
         }
         set_exechost my_host_config global
      }
      if { [string match "glob_complexes_no_threshold" $scheduler_test_level] } {
         # complexes
         puts $CHECK_OUTPUT "setup complexes"
         for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} { 
            set host_complex(complex_$i) "c$i INT 55 <= yes yes 0"
         } 
         
         set_complex host_complex global 

         set my_host_config(complex_values) "complex_1=20000"
         for { set i 2 } { $i <= $scheduler_complex_count} { incr i 1} {
            append my_host_config(complex_values) ",complex_$i=20000"
         }
         set_exechost my_host_config global


      }
   }
   set_error 0 "ok"
}


proc scheduler_measurement { repeat_count job_count } {

   global CHECK_OUTPUT CHECK_CORE_MASTER CHECK_PRODUCT_ROOT CHECK_ARCH

   set repeats $repeat_count

   if { $repeats < 1 || $job_count < 1 } {
      return -1.0
   }

   set schedd_messages_file [check_schedd_messages 2]
   debug_puts "scheduler messages file: $schedd_messages_file"
   set schedd_messages_sid [ open_remote_spawn_process $CHECK_CORE_MASTER "ts_def_con" "tail" "-f $schedd_messages_file"]
   set schedd_messages_id [lindex $schedd_messages_sid 1]

   set schedd_nr 0
   set running 1
   set test_started 0
   set timeout_time 5
   set schedd_measurement 0.0
   while { $running } {
      set timeout $timeout_time
      expect {
         -i $schedd_messages_id full_buffer {
            add_proc_error "scheduler_test" -1 "expect full_buffer error (1)"
            set running 0
         }
         -i $schedd_messages_id timeout {
            if { $test_started } {
               add_proc_error "scheduler_measurement" -1 "timeout"
               set running 0
            } else {
               set test_started 1
               set wait_for_schedd_nr $schedd_nr 
               puts $CHECK_OUTPUT "test start ..."
               set timeout_time 600
            }
         }
         -i $schedd_messages_id eof {
            add_proc_error "scheduler_test" -1 "got eof from host $host_name\n$expect_out(0,string)"
            set running 0
         }
         -i $schedd_messages_id -- "*\r\n" {
            set output $expect_out(0,string) 
            set output [ split $output "\n" ]
            foreach help $output {
               set line [string trim $help]
               if { [string match "*scheduled in*" $line] } {
                  set st_pos [string first "|I|" $line ]
                  incr st_pos 3
                  set schedd_string [ string range $line $st_pos end ]

                  if { [ string compare "PROF:" [lindex $schedd_string 0]] == 0 } {
                      set schedd_string [ string range $schedd_string 6 end ]
                  }


                  if { [ string compare "in" [lindex $schedd_string 1 ]] != 0 } {
                      close_spawn_process $schedd_messages_sid
                      set_error -1 "format error for orders (1)"
                      return -1
                   }
                   set schedd_time [ lindex $schedd_string 2 ]  ;# this is wall clock time 
                   if { [string match "*orders*" [lindex $schedd_string 9]] == 0 } {
                      set schedd_time [ lindex $schedd_string 9 ]  ;# this is system + user time (plus "):" )
                      set schedd_time_length [string length $schedd_time]
                      incr schedd_time_length -3
                      set schedd_time [ string range $schedd_time 0 $schedd_time_length ]
                   }
                   for { set s_index 0 } { $s_index < [llength $schedd_string] } { incr s_index 1 } {
                      if { [string compare [lindex $schedd_string $s_index] "orders," ] == 0  } {
                         break
                      }
                   }
                   if { [ string compare "orders," [lindex $schedd_string $s_index ]] != 0 } {
                      close_spawn_process $schedd_messages_sid
                      set_error -1 "format error for orders (2)"
                      return -1
                   }
                   incr s_index -1
                   set orders_value [ lindex $schedd_string $s_index ]
#                   puts $CHECK_OUTPUT "schedd_time: $schedd_time"
#                   puts $CHECK_OUTPUT "orders: $orders_value"
                   set schedd_data($schedd_nr,system_time)   [timestamp] 
                   set schedd_data($schedd_nr,schedd_time)   $schedd_time
                   set schedd_data($schedd_nr,schedd_orders) $orders_value
                   set schedd_data($schedd_nr,data_line)     $schedd_string
                   set schedd_data(count) $schedd_nr
                   incr schedd_nr 1
                   debug_puts "\[$schedd_nr\]last scheduler run time: $schedd_time"
                   if { $test_started } {
                      set schedd_measurement [ expr ( $schedd_measurement + $schedd_time )  ]
                   }
               }
            }
         }
      }
      if { $test_started && $wait_for_schedd_nr == $schedd_nr } {
         incr repeats -1
         if { $repeats < 0 } {
            set running 0
            continue
         } 

         scheduler_setup_test_conditions $job_count
         puts $CHECK_OUTPUT "sleeping ..."
         sleep 5
         trigger_scheduling
         set wait_for_schedd_nr $schedd_nr
         incr wait_for_schedd_nr 1 
      }
   }
   close_spawn_process $schedd_messages_sid
   set schedd_measurement [ expr ( $schedd_measurement / $repeat_count ) ]
   return $schedd_measurement
}


proc scheduler_test_run {} {

   global CHECK_OUTPUT CHECK_CORE_MASTER CHECK_PRODUCT_ROOT CHECK_ARCH
   global scheduler_test_level CHECK_PROTOCOL_DIR check_name

   set sched_output_dir $CHECK_PROTOCOL_DIR/$check_name
   set sched_output_gif_dir $sched_output_dir/gif
   set data_file $sched_output_dir/$check_name.dat
   set html_file $sched_output_dir/$check_name.html

   file mkdir $sched_output_dir
   file mkdir $sched_output_gif_dir

   set run_nr 1
   read_array_from_file $data_file "content" test_data_array
   if { [info exists test_data_array(test_data_count)] } {
      set run_nr $test_data_array(test_data_count)
   }

   if { [string match "analysis" $scheduler_test_level] == 0 } {
      puts $CHECK_OUTPUT "running $scheduler_test_level test ..."
      set job_counts "625 1250 2500 5000 7500 10000"
      set repeats 3

      
      if { [string match "functional" $scheduler_test_level] } {
         set job_counts "10 20 30"
         set repeats 1
      }

      set test_data_array($run_nr,$scheduler_test_level,job_counts) ""

      foreach jc $job_counts {
         set jobcount $jc
         lappend test_data_array($run_nr,$scheduler_test_level,job_counts) $jobcount
         set schedd_time [scheduler_measurement $repeats $jobcount]
         set test_data_array($run_nr,$scheduler_test_level,$jobcount,schedd_time) $schedd_time
         puts $CHECK_OUTPUT "$jobcount jobs scheduled in $schedd_time seconds"
      }
      spool_array_to_file $data_file "content" test_data_array 0

   } else {

     # only make analysis
     puts $CHECK_OUTPUT "make analysis ..." 
     set error 0
     set test_data_array($run_nr,version) [get_version_info]
     set test_data_array($run_nr,date) [timestamp]

     if {[info exists test_data_array($run_nr,functional,job_counts)]} {
        puts $CHECK_OUTPUT "functional test ..."
        set  job_counts $test_data_array($run_nr,functional,job_counts)
        foreach jc $job_counts {
           puts $CHECK_OUTPUT "$jc jobs scheduled in $test_data_array($run_nr,functional,$jc,schedd_time)"
        }
     } else {
        set error 1
     }
     puts $CHECK_OUTPUT ""
     set test_name_row "standard host_complexes global_complexes glob_complexes_no_threshold"

     puts $CHECK_OUTPUT "date: [clock format $test_data_array($run_nr,date) -format "%d.%m.%Y-%H:%M:%S"]" 

     foreach act_test_name $test_name_row {
        if {[info exists test_data_array($run_nr,$act_test_name,job_counts)]} {
           puts $CHECK_OUTPUT "$act_test_name test for $test_data_array($run_nr,version) ..."
           set  job_counts $test_data_array($run_nr,$act_test_name,job_counts)
           set avg_time 0.0
           foreach jc $job_counts {
              set time $test_data_array($run_nr,$act_test_name,$jc,schedd_time)
              puts $CHECK_OUTPUT "$jc jobs scheduled in $time"
              set avg_time [ expr ( $avg_time + $time ) ]
           }
           set avg_time [ expr ( $avg_time / [llength $job_counts] )  ]
           puts $CHECK_OUTPUT "avg. schedule time: $avg_time"
           puts $CHECK_OUTPUT ""
           set test_data_array($run_nr,$act_test_name,avg_schedule_time) $avg_time
        } else {
           set error 1
        }
     }

     if { $error == 0 } {
        incr run_nr 1
        set test_data_array(test_data_count) $run_nr
        spool_array_to_file $data_file "content" test_data_array 0
        generate_all_gif_files $data_file
     }
   }

   set_error 0 "ok"
}

proc show_all_schedd_test_data {  } {
   global CHECK_OUTPUT CHECK_PROTOCOL_DIR check_name

   set sched_output_dir $CHECK_PROTOCOL_DIR/$check_name
   set sched_output_gif_dir $sched_output_dir/gif
   set data_file $sched_output_dir/$check_name.dat


   read_array_from_file $data_file "content" test_data_array
   if { [info exists test_data_array(test_data_count)] } {
      set run_nr $test_data_array(test_data_count)
      incr run_nr -1
      
      set test_name_row "standard host_complexes global_complexes glob_complexes_no_threshold"

      set test_date $test_data_array($run_nr,date)

      set lines_count 0
      foreach act_test_name $test_name_row {
         if {[info exists test_data_array($run_nr,$act_test_name,job_counts)]} {
            puts $CHECK_OUTPUT "\n$test_data_array($run_nr,version) test results for: $act_test_name"
            set  job_counts $test_data_array($run_nr,$act_test_name,job_counts)
            set dcount 0
            foreach jc $job_counts {
              set time $test_data_array($run_nr,$act_test_name,$jc,schedd_time)
              puts $CHECK_OUTPUT "$jc jobs scheduled in $time"
              incr dcount 1
            }
            puts $CHECK_OUTPUT "avg. schedule time: $test_data_array($run_nr,$act_test_name,avg_schedule_time)"
            incr lines_count 1
         }
      }
   } else {
      return 0
   }
}

proc generate_all_gif_files { data_file } {
   
   global CHECK_OUTPUT CHECK_PROTOCOL_DIR check_name

   set sched_output_dir $CHECK_PROTOCOL_DIR/$check_name
   set sched_output_gif_dir $sched_output_dir/gif
   set data_file $sched_output_dir/$check_name.dat
   set html_file $sched_output_dir/$check_name.html
   file mkdir $sched_output_dir
   file mkdir $sched_output_gif_dir


   read_array_from_file $data_file "content" test_data_array
   if { [info exists test_data_array(test_data_count)] } {
      set run_nr $test_data_array(test_data_count)
      incr run_nr -1
      
      set test_name_row "standard host_complexes global_complexes glob_complexes_no_threshold"

      set test_date $test_data_array($run_nr,date)

      set lines_count 0
      foreach act_test_name $test_name_row {
         if {[info exists test_data_array($run_nr,$act_test_name,job_counts)]} {
            puts $CHECK_OUTPUT "generate_all_gif_files(): $act_test_name"
            set  job_counts $test_data_array($run_nr,$act_test_name,job_counts)
            set dcount 0
            foreach jc $job_counts {
              set time $test_data_array($run_nr,$act_test_name,$jc,schedd_time)
              puts $CHECK_OUTPUT "$jc jobs scheduled in $time"
              set xydata($lines_count,$dcount,x) $jc
              set xydata($lines_count,$dcount,y) $time
              incr dcount 1
            }
            set xydata($lines_count,drawmode) lines
            set xydata($lines_count,title) $act_test_name
            set xydata($lines_count,show) 1
            incr lines_count 1
         }
      }
      set drawing(output_file) [get_tmp_file_name]
      set drawing(xlabel)      "job count"
      set drawing(ylabel)      "time \[s\]"
      set drawing(title)       "$test_data_array($run_nr,version) [clock format $test_data_array($run_nr,date)]"
      
      create_gnuplot_xy_gif drawing xydata
      set gif_file_name "schedd_[clock format $test_data_array($run_nr,date) -format "%d.%m.%Y-%H:%M:%S"]"
      file copy -force -- $drawing(output_file) $sched_output_gif_dir/$gif_file_name.gif

      # create historical runtime diagram for all test results
      set lines_count 0
      for { set run 1 } { $run <= $run_nr } { incr run 1 } {
         set dcount 0
         foreach act_test_name $test_name_row {
            if {[info exists test_data_array($run,$act_test_name,job_counts)]} {
               puts $CHECK_OUTPUT "$act_test_name test for $test_data_array($run,version) ..."
               set xydata2($dcount,$lines_count,x) $lines_count
               set xydata2($dcount,$lines_count,y) $test_data_array($run,$act_test_name,avg_schedule_time)
               set xydata2($dcount,drawmode) lines
               set xydata2($dcount,title) "avg. $act_test_name"
               set xydata2($dcount,show) 1
               incr dcount 1
            }
         }
         incr lines_count 1
      }
      set drawing2(output_file) [get_tmp_file_name]
      set drawing2(xlabel)      "test run"
      set drawing2(ylabel)      "time \[s\]"
      set drawing2(title)       "historical avg. scheduling times"
      
      create_gnuplot_xy_gif drawing2 xydata2
      set gif_file_name "historical"
      file copy -force -- $drawing2(output_file) $sched_output_dir/$gif_file_name.gif

   } else {
      return 0
   }
   
}

proc scheduler_setup_test_conditions { nr_of_jobs } {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global scheduler_test_level scheduler_complex_count

   set running_jobs -1


   set my_timeout [timestamp]
   incr my_timeout [ expr ( 60 * 5 ) ]  ;# 5 min timeout
   while { $running_jobs != 0 && $my_timeout > [timestamp]} {
      set catch_return [ catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -s r" } result ]
      set rjobout [split $result "\n"]
      set running_jobs [llength $rjobout]
      if { $running_jobs > 0 } {
         incr running_jobs -2 ;# 2 header lines
      }
      sleep 1
   }
   if { $my_timeout < [timestamp] } {
      add_proc_error "scheduler_setup_test_conditions" -1 "timeout error(1)"
   }



   set pending_jobs 0
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1"


   set my_timeout [timestamp]
   incr my_timeout [ expr ( 60 * 30 ) ]  ;# 30 min timeout
   while { $pending_jobs != $nr_of_jobs && $my_timeout > [timestamp] } {
      
      set catch_return [ catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -s p" } result ]
      set rjobout [split $result "\n"]
      set pending_jobs [llength $rjobout]
      if { $pending_jobs > 0 } {
         incr pending_jobs -2 ;# 2 header lines
      }
      puts $CHECK_OUTPUT "pending jobs: $pending_jobs"
      if { $pending_jobs > $nr_of_jobs } {
         set catch_result [delete_all_jobs]
      }
      set submit_count [expr ( $nr_of_jobs - $pending_jobs ) ]
      puts $CHECK_OUTPUT "submitting $submit_count jobs ..."
      set help 1
      for { set i 1 } { $i <= $submit_count } { incr i 1 } {
         if { [string match "global_complexes" $scheduler_test_level] ||
              [string match "glob_complexes_no_threshold" $scheduler_test_level] || 
              [string match "host_complexes" $scheduler_test_level]
            } {
            # request consumable
            set arguments "$my_outputs -l complex_$help=1 $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1"
            puts $CHECK_OUTPUT $arguments
            incr help  1 
            if { $help > $scheduler_complex_count } {
               set help 1
            }
         } 
         set catch_return [ catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qsub $arguments" } result ]
         puts -nonewline $CHECK_OUTPUT "\r$i"
         flush $CHECK_OUTPUT
      }
      puts $CHECK_OUTPUT ""
   }
   if { $my_timeout < [timestamp] } {
      add_proc_error "scheduler_setup_test_conditions" -1 "timeout error(2)"
   }
   puts $CHECK_OUTPUT "sleeping ..."
   sleep 5 ;# let qmaster time to send jobs to scheduler
}

proc scheduler_cleanup {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH stored_configuration CHECK_OUTPUT
   global scheduler_test_level scheduler_queue_list
   global scheduler_complex_count CHECK_CORE_EXECD

   if { [string match "analysis" $scheduler_test_level] == 0 } {
 
      puts $CHECK_OUTPUT "delete all jobs ..."
      set catch_result [delete_all_jobs]
   
      puts $CHECK_OUTPUT "wait for end of all jobs ..."
      wait_for_end_of_all_jobs 120
   
   
      puts $CHECK_OUTPUT "resetting scheduler configuration ..."
      reset_schedd_config
   
      puts $CHECK_OUTPUT "restoring old configuration ..."
      set_config stored_configuration

      puts $CHECK_OUTPUT "deleting queues ..."
      foreach queue $scheduler_queue_list {
         del_queue $queue
      }
      puts $CHECK_OUTPUT "enable default queues ..."
      foreach host $CHECK_CORE_EXECD {
         enable_queue $host.q
      }


      if { [string match "host_complexes" $scheduler_test_level] } {
         puts $CHECK_OUTPUT "setting host_complexes to NONE"
         set my_host_config(complex_values) "NONE"
         foreach host $CHECK_CORE_EXECD {
            set_exechost my_host_config $host
         }

         puts $CHECK_OUTPUT "restoring old complex lists ..."
         for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} {
            set host_complex(complex_$i) ""
         }
         set_complex host_complex "host"     
      } 

      if { [string match "global_complexes" $scheduler_test_level] } {
         puts $CHECK_OUTPUT "setting host_complexes to NONE"
         set my_host_config(complex_values) "NONE"
         set_exechost my_host_config global

         puts $CHECK_OUTPUT "restoring old complex lists ..."
         for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} {
            set host_complex(complex_$i) ""
         }
         set_complex host_complex global 0
      } 

      if { [string match "glob_complexes_no_threshold" $scheduler_test_level] } {
         puts $CHECK_OUTPUT "setting host_complexes to NONE"
         set my_host_config(complex_values) "NONE"
         set_exechost my_host_config global

         puts $CHECK_OUTPUT "restoring old complex lists ..."
         for { set i 1 } { $i <= $scheduler_complex_count} { incr i 1} {
            set host_complex(complex_$i) ""
         }
         set_complex host_complex global 0
      } 


   }

   set_error 0 "ok"

}



















