#!/vol2/TCL_TK/glinux/bin/expect --
# expect script 
# global variables ... (defined in main check routine, but you can use it)
#
# global CHECK_CHECKTREE_ROOT              ;# path where checktree lies
# global CHECK_ACT_PATH          ;# actual checkpath
# global CHECK_PRODUCT_ROOT  ;# path to sge/sgeee system
# global CHECK_PRODUCT_TYPE       ;# "sgeee" or "sge"         
# global CHECK_COMMD_PORT        ;# commd port
# global CHECK_USER              ;# user who start test
# global CHECK_ARCH              ;# architecture of this system (e.g. irix6)
# global CHECK_HOST              ;# hostname of this system (e.g. DWAIN)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr check_highest_level
global check_init_level_procedure check_category

set check_init_level_procedure "general_perf_init_level"
set check_category            "PERFORMANCE"
set check_name                "general_performance"
set check_description(0)       "<num_hosts> jobs, 1 sec sleeper"
set check_description(1)       "<num_hosts> jobs, 2 sec sleeper"
set check_description(2)       "<num_hosts> jobs, 4 sec sleeper"
set check_description(3)       "<num_hosts> jobs, 8 sec sleeper"
set check_description(100)     "<num_hosts> * 10 jobs, 1 sec sleeper"
set check_description(101)     "<num_hosts> * 10 jobs, 2 sec sleeper"
set check_description(102)     "<num_hosts> * 10 jobs, 4 sec sleeper"
set check_description(103)     "<num_hosts> * 10 jobs, 8 sec sleeper"
set check_description(104)     "<num_hosts> * 10 jobs, 16 sec sleeper"
set check_description(200)     "<num_hosts> * 50 jobs, 1 sec sleeper"
set check_description(201)     "<num_hosts> * 50 jobs, 2 sec sleeper"
set check_description(202)     "<num_hosts> * 50 jobs, 4 sec sleeper"
set check_description(203)     "<num_hosts> * 50 jobs, 8 sec sleeper"
set check_description(204)     "<num_hosts> * 50 jobs, 16 sec sleeper"
set check_description(205)     "<num_hosts> * 50 jobs, 32 sec sleeper"
set check_description(400)     "<num_hosts> * 100 jobs, 24 sec sleeper, 10 x 10 steps"
set check_needs               "init_core_system"      ;# dependencies of this check (name of other check)
set check_functions           "setup_queues"          ;# functions to call (in order)
lappend check_functions       "setup_schedd_params"   ;# set FLUSH_FINISH_SEC and FLUSH_SUBMIT_SEC
lappend check_functions       "do_perform_test"
lappend check_functions       "cleanup_queues"
lappend check_functions       "cleanup_schedd_params"
set check_errno              "-1"                    ;# 0 -> OK , != 0 means error
set check_errstr               "was never running"     ;# string for error description
set check_highest_level       400

global last_job
global perf_jobs 
global perf_jobtime 
global save_queue_values
global long_flag
global stored_configuration

proc general_perf_init_level {} {
  global CHECK_ACT_LEVEL CHECK_CORE_EXECD CHECK_OUTPUT
  global perf_jobs perf_jobtime long_flag

  set num_hosts [llength $CHECK_CORE_EXECD]

  switch -- $CHECK_ACT_LEVEL {
  "0"  { set perf_jobs $num_hosts ; set perf_jobtime 1 ; set long_flag 0 ; return 0  }
  "1"  { set perf_jobs $num_hosts ; set perf_jobtime 2 ; set long_flag 0 ; return 0  }
  "2"  { set perf_jobs $num_hosts ; set perf_jobtime 4 ; set long_flag 0 ; return 0  }
  "3"  { set perf_jobs $num_hosts ; set perf_jobtime 8 ; set long_flag 0 ; return 0  }

  "100" { set perf_jobs [expr 10 * $num_hosts] ; set perf_jobtime 1 ; set long_flag 0 ; return 0  }
  "101" { set perf_jobs [expr 10 * $num_hosts] ; set perf_jobtime 2 ; set long_flag 0 ; return 0  }
  "102" { set perf_jobs [expr 10 * $num_hosts] ; set perf_jobtime 4 ; set long_flag 0 ; return 0  }
  "103" { set perf_jobs [expr 10 * $num_hosts] ; set perf_jobtime 8 ; set long_flag 0 ; return 0  }
  "104" { set perf_jobs [expr 10 * $num_hosts] ; set perf_jobtime 16 ; set long_flag 0 ; return 0  }

  "200" { set perf_jobs [expr 50 * $num_hosts] ; set perf_jobtime 1 ; set long_flag 0 ; return 0  }
  "201" { set perf_jobs [expr 50 * $num_hosts] ; set perf_jobtime 2 ; set long_flag 0 ; return 0  }
  "202" { set perf_jobs [expr 50 * $num_hosts] ; set perf_jobtime 4 ; set long_flag 0 ; return 0  }
  "203" { set perf_jobs [expr 50 * $num_hosts] ; set perf_jobtime 8 ; set long_flag 0 ; return 0  }
  "204" { set perf_jobs [expr 50 * $num_hosts] ; set perf_jobtime 16 ; set long_flag 0 ; return 0  }
  "205" { set perf_jobs [expr 50 * $num_hosts] ; set perf_jobtime 32 ; set long_flag 0 ; return 0  }

  "400" { set perf_jobs [expr 100 * $num_hosts]  ; set perf_jobtime 10 ; set long_flag 1 ; return 0  }
  }
  return -1
}

#                                                             max. column:     |
#****** performance/setup_queues() ******
# 
#  NAME
#     setup_queues -- ??? 
#
#  SYNOPSIS
#     setup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_queues {} {
   global CHECK_CORE_EXECD save_queue_values

   set save_queue_values ""
   foreach elem $CHECK_CORE_EXECD {
      set change_array(slots) "0" 
      get_queue "$elem.q" "change_array"
      lappend save_queue_values [set change_array(slots)]
      unset change_array
      set change_array(slots) "1" 
      set_queue "$elem.q" "change_array"
   }

   set_error 0 "no errors"
}

proc setup_schedd_params {} {
   global stored_configuration

   get_config stored_configuration
   set default_array(schedd_params)   "$stored_configuration(schedd_params),FLUSH_SUBMIT_SEC=0,FLUSH_FINISH_SEC=0"
   set_config default_array
   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** performance/cleanup_queues() ******
# 
#  NAME
#     cleanup_queues -- ??? 
#
#  SYNOPSIS
#     cleanup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc cleanup_queues {} {
   global CHECK_CORE_EXECD save_queue_values

   set change_array(slots) "1"
   set i 0
   foreach elem $CHECK_CORE_EXECD {
      set change_array(slots) [lindex $save_queue_values $i] 
      set_queue "$elem.q" "change_array"
      incr i 1
   }

   set_error 0 "no errors"
}

proc cleanup_schedd_params {} {
   global stored_configuration

   set_config stored_configuration
   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** performance/submit_jobs() ******
# 
#  NAME
#     submit_jobs -- ??? 
#
#  SYNOPSIS
#     submit_jobs { job_count job_time } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     job_count - ??? 
#     job_time  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc submit_jobs { job_count job_time } {
   global CHECK_PRODUCT_ROOT last_job CHECK_CORE_EXECD 

   set max_execd [llength $CHECK_CORE_EXECD]
   set cur_execd 0
   for { set i 0 } { $i < $job_count } { incr i 1 } {

     set elem [lindex $CHECK_CORE_EXECD $cur_execd]
     incr cur_execd 1
     if { $cur_execd == $max_execd } {
        set cur_execd 0
     }

     set jobargs "-q ${elem}.q -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh $job_time"
     set last_job [submit_job $jobargs] 
     if {$last_job < 0 } {
        return -1
     }
   }
   return 0
}


#                                                             max. column:     |
#****** performance/performance_test() ******
# 
#  NAME
#     performance_test -- ??? 
#
#  SYNOPSIS
#     performance_test { job_count_loops job_run_loops } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     job_count_loops - ??? 
#     job_run_loops   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc performance_test {job_count_loops job_run_loops} {

   global last_job CHECK_OUTPUT CHECK_CORE_EXECD CHECK_ACT_LEVEL
   global perf_jobs CHECK_PROTOCOL_DIR
   global perf_jobtime

   if { [expr $CHECK_ACT_LEVEL % 100] == 0 } {
      catch { eval exec "mv $CHECK_PROTOCOL_DIR/performance.data $CHECK_PROTOCOL_DIR/performance.data.[timestamp]" }
      set output [open "$CHECK_PROTOCOL_DIR/performance.data" "w"]
      puts $output "\n\n[exec date]"
   
      get_schedd_config schedd_values
      set value_names [array names schedd_values]
      foreach elem $value_names {
         puts $output "$elem             =  $schedd_values($elem)"
      } 
      puts $output "jobs\tjobtime\tsubmit_time\trun_time\tsub/second\truns/second\treal_time\toverhead"
   } else {
      set output [open "$CHECK_PROTOCOL_DIR/performance.data" "a"]
   }

   set job_count_step [ expr ( $perf_jobs / $job_count_loops ) ]
   set job_run_step   [ expr ( $perf_jobtime / $job_run_loops ) ]

   if {$job_run_step < 1 } {
      set job_run_step 1 
   }
   if {$job_count_step < 1 } {
      set job_count_step 1 
   }

   puts $CHECK_OUTPUT "job_count_step = $job_count_step"
   puts $CHECK_OUTPUT "job_run_step   = $job_run_step"

   for {set tcount 1} { $tcount <= $job_run_loops } { incr tcount} {
      set cur_job_time [ expr ( $tcount * $job_run_step ) ]
      set cur_job_time [ expr $cur_job_time * $cur_job_time ]
      for {set jcount 1} { $jcount <= $job_count_loops } { incr jcount} {
         set cur_job_count [ expr ( $jcount * $job_count_step) ] 

         puts $CHECK_OUTPUT "submitting $cur_job_count jobs with runtime $cur_job_time"

         set start_time [timestamp]
      
         set result [ submit_jobs $cur_job_count $cur_job_time ]
         if {$result < 0 } {
              set_error -1 "sub_01 - error in job submit"
              close $output
              return
           }
         set end_time [timestamp]

         # submit_time, run_time
         set submit_time [expr ( $end_time - $start_time) ] 
      
         set job_decr 0 
         foreach elem $CHECK_CORE_EXECD {
            while { [ was_job_running [ expr ( $last_job - $job_decr) ] 0] == -1 } {
               puts $CHECK_OUTPUT "waiting for last job to run ..."
               sleep 5
            }
            incr job_decr 1
         }
      
         set end_time [timestamp]
         set run_time [expr ( $end_time - $start_time) ]

         # submit_time, run_time
         if {$submit_time > 0} {                    
            set submits_per_second [ expr ($cur_job_count/$submit_time.0) ]
         } else {
            set submits_per_second "-"
         }
         if {$run_time > 0} {    
            set runs_per_second    [ expr ($cur_job_count/$run_time.0   ) ]
         } else {
            set runs_per_second "-"
         }
         # overhead
         set real_time [ expr ( $cur_job_count * $cur_job_time / [llength $CHECK_CORE_EXECD].0 ) ]
        
         if {$real_time > 0} { 
            set overhead [ expr ( $run_time.0 / ($real_time ) ) ] 
         } else {
            set overhead "-"
         }

         puts $output "$cur_job_count\t$cur_job_time\t$submit_time\t$run_time\t$submits_per_second\t$runs_per_second\t$real_time\t$overhead"
         flush $output
         sleep 10 
         if {$job_count_loops <= 1 } {
            break; 
         }      

      }   ;# jobcount
      
      if { $job_run_loops <= 1 } {
            break; 
         }
   }   ;# jobtime
   close $output
   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** performance/do_perform_test() ******
# 
#  NAME
#     do_perform_test -- ??? 
#
#  SYNOPSIS
#     do_perform_test { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc do_perform_test {} {
   
    global long_flag
    
    if { $long_flag == 1} {
       performance_test 10 6         ;# 10 x 6 different runns
    } else {
       performance_test 1 1 
    }
}

