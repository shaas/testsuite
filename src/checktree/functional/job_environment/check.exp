#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs

# set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "job_environment_init_level"

# define test's name and run level descriptions
set check_name            "job_environment"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "test job environment variables"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "job_environment_setup"
set check_cleanup_function "job_environment_cleanup"

# define test's procedure order
set check_functions ""
#lappend check_functions "job_environment_amount"
#lappend check_functions "job_environment_JOB_NAME"

####### job_environment_init_level() ###########################################
#  NAME
#     job_environment_init_level() -- init the job env test
#
#  SYNOPSIS
#     job_environment_init_level {}
#
#  FUNCTION
#     Initialize the job environment test
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_init_level {} {
   global CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE
   global test_array_jobs 

  switch -- $CHECK_ACT_LEVEL {
     "0" { 
           return 0    
     } 
     "1" {
           return -1
     }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------


####### job_environment_setup() ################################################
#  NAME
#     job_environment_setup() -- setup the job env test
#
#  SYNOPSIS
#     job_environment_setup { } 
#
#  FUNCTION
#     Do required setup for the job environment test, including running the 6.0
#     setup routine if appropriate.
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_setup_60()
################################################################################
proc job_environment_setup  {} {
   global ts_config
   global CHECK_OUTPUT
   global queue job_environment_exec_host job_environment_config

   puts $CHECK_OUTPUT "setup ..."
   set job_environment_exec_host [lindex $ts_config(execd_hosts) 0]
   set queue [get_queue_instance "all.q" $job_environment_exec_host]

   get_config job_environment_config

   if {$ts_config(gridengine_version) >= 60} {
      job_environment_setup_60
   }

   set_error 0 "ok"
}

####### job_environment_parse_env_test_output() ################################
#  NAME
#     job_environment_parse_env_test_output() -- parse jobenv.sh output
#
#  SYNOPSIS
#     job_environment_parse_env_test_output { file array } 
#
#  FUNCTION
#     Parses the output file from the jobenv.sh script and places the results
#     in the given array.  This function will wait until the output file is
#     available if it does not exist at the time this function is run.
#
#  INPUTS
#     file     the name of the jobenv.sh output file
#     array    the name of the array in which results will be placed
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_parse_env_test_output { file array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER

   upvar $array job_env_array

   if { [info exists job_env_array] } {
      unset job_env_array
   }

   puts $CHECK_OUTPUT "waiting for file $file on host $CHECK_HOST as user $CHECK_USER ..."
   if {[wait_for_remote_file $CHECK_HOST $CHECK_USER $file] == 0} {
      set o_file [ open "$file" "r" ]
      
      set variable_names_list ""
      while { [gets $o_file line] >= 0 } {
         set pos [ string first "=" $line ]
         incr pos -1
         set variable [ string range $line 0 $pos ]
         incr pos 2
         set value [ string range $line $pos end ]
         debug_puts "variable=\"$variable\", value=\"$value\""
         set job_env_array($variable) $value
         lappend variable_names_list $variable
      }

      set job_env_array(index) $variable_names_list
      close $o_file
      file delete $file
      wait_for_file $file 60 1
      
   }
}

####### job_environment_qsub_job() #############################################
#  NAME
#     job_environment_qsub_job() -- qsub jobenv.sh
#
#  SYNOPSIS
#     job_environment_qsub_job { jobname array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qsub and parse the resulting output file.
#
#  INPUTS
#     jobname     the name the job will have when submitted
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qsub
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qsub_job { jobname array arguments } {
   global CHECK_TESTSUITE_ROOT CHECK_PROTOCOL_DIR CHECK_SCRIPT_FILE_DIR
   global queue CHECK_OUTPUT
   upvar $array job_env_array

   set ret 1
   puts $CHECK_OUTPUT "job environment should be written to $CHECK_PROTOCOL_DIR"
   set job_id [submit_job "$arguments -q $queue $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/jobenv.sh $CHECK_PROTOCOL_DIR"]

   if {$job_id <= 0} {
      set ret 0
   }

   if {$ret && [wait_for_jobstart $job_id $jobname 120 1 1] != 0} {
      set ret 0
      delete_all_jobs
   }

   if {$ret && [wait_for_jobend $job_id $jobname 120] != 0} {
      set ret 0
      delete_all_jobs
   }

   if {$ret} {
      job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
   }

   return $ret
}

####### job_environment_qresub_job() ###########################################
#  NAME
#     job_environment_qresub_job() -- qresub jobenv.sh
#
#  SYNOPSIS
#     job_environment_qresub_job { jobname array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qsub, then again via qresub, and parse the
#     resulting output file.
#
#  INPUTS
#     jobname     the name the job will have when submitted
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qsub
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qresub_job { jobname array arguments } {
   global CHECK_TESTSUITE_ROOT CHECK_PROTOCOL_DIR CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_SCRIPT_FILE_DIR
   global CHECK_OUTPUT
   global queue

   upvar $array job_env_array
   set job_id [ submit_job "$arguments -q $queue -h $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/jobenv.sh $CHECK_PROTOCOL_DIR" ]
   
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qresub" "$job_id" } result
   puts $CHECK_OUTPUT $result
   set new_job_id [expr $job_id + 1]
   wait_for_jobstart $new_job_id $jobname 60 1 1
   wait_for_jobend $new_job_id $jobname 60
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
   delete_job $job_id
}

####### job_environment_qalter_job() ###########################################
#  NAME
#     job_environment_qalter_job() -- qalter jobenv.sh
#
#  SYNOPSIS
#     job_environment_qalter_job { jobname array qsub_args qalter_args } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qsub in a hold state, change it via
#     qalter, then release is via qrls, and parse the resulting output file.
#
#  INPUTS
#     jobname        the name the job will have when submitted
#     array          the name of the array in which results will be placed
#     qsub_args      switches to be passed to qsub
#     qalter_args    switches to be passed to qalter
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qalter_job { jobname array qsub_args qalter_args } {
   global CHECK_TESTSUITE_ROOT CHECK_PROTOCOL_DIR CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_SCRIPT_FILE_DIR
   global CHECK_OUTPUT
   global queue

   upvar $array job_env_array
   set job_id [ submit_job "$qsub_args -q $queue -h $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/jobenv.sh $CHECK_PROTOCOL_DIR" ]
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter" $qalter_args $job_id } result
   puts $CHECK_OUTPUT $result
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrls" $job_id } result
   puts $CHECK_OUTPUT $result
   wait_for_jobstart $job_id $jobname 60 1 1
   wait_for_jobend $job_id $jobname 60
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
}

####### job_environment_qrsh_job() #############################################
#  NAME
#     job_environment_qrsh_job() -- qrsh jobenv.sh
#
#  SYNOPSIS
#     job_environment_qrsh_job { jobname array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qrsh and parse the resulting output file.
#
#  INPUTS
#     jobname     the name the job will have when submitted
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qrsh
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qrsh_job { array arguments } {
   global CHECK_TESTSUITE_ROOT CHECK_PROTOCOL_DIR CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_OUTPUT CHECK_SCRIPT_FILE_DIR
   global queue

   upvar $array job_env_array
   
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh" "$arguments -q $queue" $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/jobenv.sh $CHECK_PROTOCOL_DIR } result
   puts $CHECK_OUTPUT $result
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
}

####### job_environment_qsh_job() ##############################################
#  NAME
#     job_environment_qsh_job() -- qsh jobenv.sh
#
#  SYNOPSIS
#     job_environment_qsh_job { array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via execution with qsh and parse the resulting
#     output file.
#
#  INPUTS
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qsh
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qsh_job { array arguments } {
   global CHECK_TESTSUITE_ROOT CHECK_PROTOCOL_DIR CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_USER
   global CHECK_OUTPUT CHECK_SCRIPT_FILE_DIR
   global queue job_environment_exec_host

   upvar $array job_env_array

   # create a script file to be executed by xterm -e <script> / qsh -S <script>
   set script_name "$CHECK_PROTOCOL_DIR/qsh.sh"
   set f [open $script_name "w" "0755"]
   puts $f "#!/bin/sh"
   puts $f "exec $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/jobenv.sh $CHECK_PROTOCOL_DIR"
   close $f

   # wait for host to appear on the remote host
   wait_for_remote_file $job_environment_exec_host $CHECK_USER $script_name

   puts $CHECK_OUTPUT "starting qsh $arguments -q $queue -S $script_name ..."
   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qsh" "$arguments -q $queue -S $script_name"]
   puts $CHECK_OUTPUT $output

   # check results
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array

   # cleanup
   file delete $script_name
}

#****** job_environment_amount() ***********************************************
#  NAME
#     job_environment_amount() -- test job environment
#
#  SYNOPSIS
#     job_environment_amount { } 
#
#  FUNCTION
#     Check that all required environment variables are set by the shepherd
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_var_test()
#*******************************************************************************
proc job_environment_amount {} {
   global CHECK_OUTPUT
   set errors ""

   puts $CHECK_OUTPUT "Testing list of environment variables with execd_param=none"

   # Set exced_params=none
   set new_config(execd_params) "none"
   set_config_and_propogate new_config

   job_environment_var_test missing

   if {[llength $missing] != 0} {
      set missing_vars ""

      foreach missing_var $missing {
         append missing_vars " $missing_var"
      }

      add_proc_error "job_environment_amount" -1 "The following environment variables should have been set but were not, with execd_params=none: [string trim $missing_vars]"
   }

   set_error 0 "ok"
}

####### job_environment_var_test() #############################################
#  NAME
#     job_environment_var_test() -- test job environment
#
#  SYNOPSIS
#     job_environment_var_test { missing {extra ""} } 
#
#  FUNCTION
#     Check that all required environment variables are set by the shepherd.
#     Variables which should be present but are not, are placed in the missing
#     array.  If the extra array is given, variables which are unrecognised are
#     placed in the extra array.
#
#  INPUTS
#     missing     the name of the array in which to place missing env vars
#     extra       the name of the array in which to place extra env vars
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_var_test {missing {extra ""}} {
   global ts_config
   global CHECK_OUTPUT env
   upvar $missing missing_variables
   upvar $extra extra_variables

   set missing_variables ""
   set extra_variables ""

   set known_variables ""
   lappend known_variables "SGE_ROOT"
   lappend known_variables "SGE_CELL"
   lappend known_variables "SGE_ARCH"
   lappend known_variables "SGE_O_HOME"
   lappend known_variables "SGE_O_HOST"
   lappend known_variables "SGE_O_LOGNAME"
   lappend known_variables "SGE_O_MAIL"
   lappend known_variables "SGE_O_PATH"
   lappend known_variables "SGE_O_SHELL"

   # JG: TZ is only set by N1GE, if it is available in the 
   # sge_execd's environment.
   # So if we want to check for existence of SGE_O_TZ, we would have 
   # to check first, if TZ is set on the exec host (root shell).
   #if { [ info exists env(TZ)] } {
   #   lappend known_variables "SGE_O_TZ"
   #}
   lappend known_variables "SGE_O_WORKDIR"
   lappend known_variables "ARC"
   lappend known_variables "SGE_ACCOUNT"
   lappend known_variables "SGE_CKPT_ENV"
   lappend known_variables "SGE_CKPT_DIR"
   lappend known_variables "SGE_CWD_PATH"
   lappend known_variables "SGE_STDERR_PATH"
   lappend known_variables "SGE_STDOUT_PATH"
   lappend known_variables "SGE_BINARY_PATH"
   lappend known_variables "SGE_JOB_SPOOL_DIR"
   lappend known_variables "SGE_TASK_ID"
   lappend known_variables "SGE_TASK_FIRST"
   lappend known_variables "SGE_TASK_LAST"
   lappend known_variables "SGE_TASK_STEPSIZE"
   lappend known_variables "ENVIRONMENT"
   lappend known_variables "HOME"
   lappend known_variables "HOSTNAME"
   lappend known_variables "JOB_ID"
   lappend known_variables "JOB_NAME"
   lappend known_variables "JOB_SCRIPT"
   lappend known_variables "LOGNAME"
   lappend known_variables "NQUEUES"
   lappend known_variables "NSLOTS"
   lappend known_variables "NHOSTS"
   lappend known_variables "PATH"
   lappend known_variables "PE"
   lappend known_variables "PE_HOSTFILE"
   lappend known_variables "QUEUE"
   lappend known_variables "REQUEST"
   lappend known_variables "SHELL"
   lappend known_variables "TMPDIR"
   lappend known_variables "TMP"
   lappend known_variables "USER"
   lappend known_variables "RESTARTED"

   if { $ts_config(gridengine_version) == 53} {
      lappend known_variables "COMMD_PORT"
      lappend known_variables "FIRST_HOST"
      lappend known_variables "LAST_HOST"
   } else {
      lappend known_variables "SGE_STDIN_PATH"
      lappend known_variables "SGE_QMASTER_PORT"
      lappend known_variables "SGE_EXECD_PORT"
   }

   # Build list of allowed_variables
   set allowed_variables "TZ"
   lappend allowed_variables "SGE_O_TZ"
   lappend allowed_variables "REQNAME"

   puts $CHECK_OUTPUT "checking number of environment variables ..."

   if {[job_environment_qsub_job "jobenv.sh" job_env "-o /dev/null -e /dev/null -ckpt testcheckpointobject -pe mytestpe 2"]} {
      foreach var $known_variables {
         if { [info exists job_env($var)] } {
            set value $job_env($var)

            if { [string length $value] == 0 } {
               lappend missing_variables $var
            }

            # Remove each known_variable from job_env
            array unset job_env $var
         } else {
            lappend missing_variables $var
         }
      }

      # If doing exclusive test...
      if { $extra != "" } {
         # Remove each allowed_variable from job_env
         foreach var $allowed_variables {
            if { [info exists job_env($var)] } {
               if { [string length $job_env($var)] != 0 } {
                  array unset job_env $var
               }
            }
         }

         # Test if job_env contains any extra variables
         foreach var [array names job_env] {
            if { [string compare $var "index"] != 0 } {
                lappend extra_variables $var
            }
         }
      }
   }
}

####### job_environment_check_env_value() ######################################
#  NAME
#     job_environment_check_env_value() -- test an env var value
#
#  SYNOPSIS
#     job_environment_check_env_value { env_name should_be is_name } 
#
#  FUNCTION
#     The value of the environment value is tested against the expected value.
#
#  INPUTS
#     env_name    the name of the environment variable
#     should_be   the value of the environment variable should have
#     is_name     the name of the variable containing the actual value of the
#                 environment variable
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_check_env_value { env_name should_be is_name } {
   global ts_config
   global CHECK_OUTPUT

   upvar $is_name is

   puts -nonewline $CHECK_OUTPUT "checking environment \"$env_name\" ..."

   if {![info exists is]} {
      add_proc_error "job_environment_check_job_name" -1 "environment variable \"$env_name\" is not set"
   } else {
      set had_error 0
      if { [ string compare $should_be $is ] != 0 } {
         set had_error 1
         puts -nonewline $CHECK_OUTPUT " failed."
      } else {
         puts -nonewline $CHECK_OUTPUT " ok."
      }
      puts $CHECK_OUTPUT " ($env_name=$is)"
      if { $had_error == 1 } {
         if { $ts_config(gridengine_version) == 53 && [ string compare $env_name "JOB_NAME" ] == 0 } {
            set message "environment variable \"$env_name\" is set to \"$is\", should be \"$should_be\"\n\n"
            append message "This bug is not fixed for version [get_version_info]\n"
            append message "Workaround: Use \"REQNAME\" or \"REQUEST\" instead of \"$env_name\"\n"
            append message "in your job scripts!!!\n"
            add_proc_error "job_environment_check_job_name" -3 $message
         } else {
            add_proc_error "job_environment_check_job_name" -1 "environment variable \"$env_name\" is set to \"$is\", should be \"$should_be\""
         } 
      }
   }
}

#****** job_environment_JOB_NAME() *********************************************
#  NAME
#     job_environment_JOB_NAME() -- test the job name env vars
#
#  SYNOPSIS
#     job_environment_JOB_NAME { {stand_alone 1} } 
#
#  FUNCTION
#     Tests whether the shepherd correctly sets the job name environment
#     variables
#
#  INPUTS
#     stand_alone    whether this test is running directly or being called from
#                    another test
#
#  RESULT
#     0 -> ok   1 -> error
#*******************************************************************************
proc job_environment_JOB_NAME {{stand_alone 1}} {
   global CHECK_OUTPUT CHECK_TESTSUITE_ROOT CHECK_PROTOCOL_DIR
  
   if {$stand_alone == 1} {
      puts $CHECK_OUTPUT "Testing presence of job env vars with execd_params=none"

      # Set exced_params=none
      set new_config(execd_params) "none"
      set_config_and_propogate new_config
   }

   puts $CHECK_OUTPUT "\nqsub ..."
   if {[job_environment_qsub_job "jobenv.sh" job_env "-o /dev/null -e /dev/null"]} {
      job_environment_check_env_value "JOB_NAME" "jobenv.sh" job_env(JOB_NAME)
      job_environment_check_env_value "REQNAME" "jobenv.sh" job_env(REQNAME)
      job_environment_check_env_value "REQUEST" "jobenv.sh" job_env(REQUEST)
   }

   puts $CHECK_OUTPUT "\nqsub -N ..."
   if {[job_environment_qsub_job "newnam" job_env "-o /dev/null -e /dev/null -N newnam"]} {
      job_environment_check_env_value "JOB_NAME" "newnam" job_env(JOB_NAME)
      job_environment_check_env_value "REQNAME" "newnam" job_env(REQNAME)
      job_environment_check_env_value "REQUEST" "newnam" job_env(REQUEST)
   }

   puts $CHECK_OUTPUT "\nqresub ..."
   job_environment_qresub_job "jobenv.sh" job_env "-o /dev/null -e /dev/null"
   job_environment_check_env_value "JOB_NAME" "jobenv.sh" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "jobenv.sh" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "jobenv.sh" job_env(REQUEST)

   puts $CHECK_OUTPUT "\nqalter ..."
   job_environment_qalter_job "newnam" job_env "-o /dev/null -e /dev/null" "-N newnam" 
   job_environment_check_env_value "JOB_NAME" "newnam" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "newnam" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "newnam" job_env(REQUEST)

   puts $CHECK_OUTPUT "\nqsh ..."
   job_environment_qsh_job job_env ""
   job_environment_check_env_value "JOB_NAME" "INTERACTIVE" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "INTERACTIVE" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "INTERACTIVE" job_env(REQUEST)
     
#   can't test qlogin, need password to login !!!
#   puts $CHECK_OUTPUT "\nqlogin ..."
#   puts $CHECK_OUTPUT "job name is \"$job_env(JOB_NAME)\""

   puts $CHECK_OUTPUT "\nqrsh ..."
   job_environment_qrsh_job job_env ""
   job_environment_check_env_value "JOB_NAME" "jobenv.sh" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "jobenv.sh" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "jobenv.sh" job_env(REQUEST)

   set_error 0 "ok"
}

####### job_environment_cleanup() ##############################################
#  NAME
#     job_environment_cleanup() -- clean up after the job env test
#
#  SYNOPSIS
#     job_environment_cleanup { } 
#
#  FUNCTION
#     Clean up changes made during the job environment test.  This function
#     calls the 6.0 cleanup function if appropriate.
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_cleanup_60()
################################################################################
proc job_environment_cleanup {} {
   global CHECK_OUTPUT
   global ts_config job_environment_config

   puts $CHECK_OUTPUT "cleanup ..."
   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set_config job_environment_config

   if {$ts_config(gridengine_version) >= 60} {
      job_environment_cleanup_60
   }

   set_error 0 "ok"
}
