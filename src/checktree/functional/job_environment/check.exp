#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs

# set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "job_environment_init_level"

# define test's name and run level descriptions
set check_name            "job_environment"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "test job environment variables"

# define test's dependencies
set check_needs           "init_core_system display_test" 

# setup and cleanup functions
set check_setup_function "job_environment_setup"
set check_cleanup_function "job_environment_cleanup"

# define test's procedure order
set check_functions {}
lappend check_functions "job_environment_amount"
lappend check_functions "job_environment_JOB_NAME"

####### job_environment_init_level() ###########################################
#  NAME
#     job_environment_init_level() -- init the job env test
#
#  SYNOPSIS
#     job_environment_init_level {}
#
#  FUNCTION
#     Initialize the job environment test
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------


####### job_environment_setup() ################################################
#  NAME
#     job_environment_setup() -- setup the job env test
#
#  SYNOPSIS
#     job_environment_setup { } 
#
#  FUNCTION
#     Do required setup for the job environment test, including running the 6.0
#     setup routine if appropriate.
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_setup_60()
################################################################################
proc job_environment_setup {} {
   global ts_config
   global queue job_environment_exec_host job_environment_config

   # we do qsh, this doesn't work on windows, and in our lab also not on hp
   set job_environment_exec_host [host_conf_get_suited_hosts 1 {} {} {hp11 hp11-64 win32-x86} 1]
   set queue [get_queue_instance "all.q" $job_environment_exec_host]

   get_config job_environment_config $job_environment_exec_host

   if {$ts_config(gridengine_version) >= 60} {
      job_environment_setup_60
   }
}

####### job_environment_cleanup() ##############################################
#  NAME
#     job_environment_cleanup() -- clean up after the job env test
#
#  SYNOPSIS
#     job_environment_cleanup { } 
#
#  FUNCTION
#     Clean up changes made during the job environment test.  This function
#     calls the 6.0 cleanup function if appropriate.
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_cleanup_60()
################################################################################
proc job_environment_cleanup {} {
   global ts_config job_environment_config job_environment_exec_host

   ts_log_fine "cleanup ..."
   delete_all_jobs
   wait_for_end_of_all_jobs

   reset_config_and_propagate job_environment_config $job_environment_exec_host

   if {$ts_config(gridengine_version) >= 60} {
      job_environment_cleanup_60
   }
}

####### job_environment_parse_env_test_output() ################################
#  NAME
#     job_environment_parse_env_test_output() -- parse jobenv.sh output
#
#  SYNOPSIS
#     job_environment_parse_env_test_output { file array } 
#
#  FUNCTION
#     Parses the output file from the jobenv.sh script and places the results
#     in the given array.  This function will wait until the output file is
#     available if it does not exist at the time this function is run.
#
#  INPUTS
#     file     the name of the jobenv.sh output file
#     array    the name of the array in which results will be placed
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_parse_env_test_output {file array} {
   global CHECK_USER
   global ts_config

   upvar $array job_env_array

   if {[info exists job_env_array]} {
      unset job_env_array
   }

   ts_log_fine "waiting for file $file on host $ts_config(master_host) as user $CHECK_USER ..."
   if {[wait_for_remote_file $ts_config(master_host) $CHECK_USER $file] == 0} {
      set o_file [open "$file" "r"]
      
      set variable_names_list ""
      while {[gets $o_file line] >= 0} {
         set pos [string first "=" $line]
         incr pos -1
         set variable [string range $line 0 $pos]
         incr pos 2
         set value [string range $line $pos end]
         ts_log_finest "variable=\"$variable\", value=\"$value\""
         set job_env_array($variable) $value
         lappend variable_names_list $variable
      }

      set job_env_array(index) $variable_names_list
      close $o_file
      file delete $file
      wait_for_file $file 60 1
   }
}

####### job_environment_qsub_job() #############################################
#  NAME
#     job_environment_qsub_job() -- qsub jobenv.sh
#
#  SYNOPSIS
#     job_environment_qsub_job { jobname array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qsub and parse the resulting output file.
#
#  INPUTS
#     jobname     the name the job will have when submitted
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qsub
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qsub_job { jobname array arguments {job_id_array_name ""}} {
   global ts_config
   global CHECK_PROTOCOL_DIR
   global queue
   upvar $array job_env_array
   if {$job_id_array_name != ""} {
      upvar $job_id_array_name job_id
   }

   set ret 1
   ts_log_fine "job environment should be written to $CHECK_PROTOCOL_DIR"
   set job_id [submit_job "$arguments -q $queue $ts_config(testsuite_root_dir)/scripts/jobenv.sh $CHECK_PROTOCOL_DIR"]

   if {$job_id <= 0} {
      set ret 0
   }

   if {$ret && [wait_for_jobstart $job_id $jobname 120 1 1] != 0} {
      set ret 0
      delete_all_jobs
   }

   if {$ret && [wait_for_jobend $job_id $jobname 120 0] != 0} {
      set ret 0
      delete_all_jobs
   }

   if {$ret} {
      job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
   }

   return $ret
}

####### job_environment_qresub_job() ###########################################
#  NAME
#     job_environment_qresub_job() -- qresub jobenv.sh
#
#  SYNOPSIS
#     job_environment_qresub_job { jobname array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qsub, then again via qresub, and parse the
#     resulting output file.
#
#  INPUTS
#     jobname     the name the job will have when submitted
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qsub
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qresub_job { jobname array arguments } {
   global ts_config
   global CHECK_PROTOCOL_DIR CHECK_USER
   global queue

   upvar $array job_env_array
   set job_id [submit_job "$arguments -q $queue -h $ts_config(testsuite_root_dir)/scripts/jobenv.sh $CHECK_PROTOCOL_DIR"]
   set result [start_sge_bin "qresub" "$job_id"]
   ts_log_fine $result

   set new_job_id [expr $job_id + 1]
   wait_for_jobstart $new_job_id $jobname 60 1 1
   wait_for_jobend $new_job_id $jobname 60 0
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
   delete_job $job_id
}

####### job_environment_qalter_job() ###########################################
#  NAME
#     job_environment_qalter_job() -- qalter jobenv.sh
#
#  SYNOPSIS
#     job_environment_qalter_job { jobname array qsub_args qalter_args } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qsub in a hold state, change it via
#     qalter, then release is via qrls, and parse the resulting output file.
#
#  INPUTS
#     jobname        the name the job will have when submitted
#     array          the name of the array in which results will be placed
#     qsub_args      switches to be passed to qsub
#     qalter_args    switches to be passed to qalter
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qalter_job { jobname array qsub_args qalter_args } {
   global ts_config
   global CHECK_PROTOCOL_DIR
   global queue

   upvar $array job_env_array
   set job_id [submit_job "$qsub_args -q $queue -h $ts_config(testsuite_root_dir)/scripts/jobenv.sh $CHECK_PROTOCOL_DIR"]
   set result [start_sge_bin "qalter" "$qalter_args $job_id"]
   ts_log_fine $result

   set result [start_sge_bin "qrls" "$job_id"]
   ts_log_fine $result

   wait_for_jobstart $job_id $jobname 60 1 1
   wait_for_jobend $job_id $jobname 60 0
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
}

####### job_environment_qrsh_job() #############################################
#  NAME
#     job_environment_qrsh_job() -- qrsh jobenv.sh
#
#  SYNOPSIS
#     job_environment_qrsh_job { jobname array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via qrsh and parse the resulting output file.
#
#  INPUTS
#     jobname     the name the job will have when submitted
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qrsh
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qrsh_job { array arguments } {
   global ts_config
   global CHECK_PROTOCOL_DIR
   global queue

   upvar $array job_env_array
   
   set result [start_sge_bin "qrsh" "$arguments -q $queue $ts_config(testsuite_root_dir)/scripts/jobenv.sh $CHECK_PROTOCOL_DIR"]
   ts_log_fine $result

   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array
}

####### job_environment_qsh_job() ##############################################
#  NAME
#     job_environment_qsh_job() -- qsh jobenv.sh
#
#  SYNOPSIS
#     job_environment_qsh_job { array arguments } 
#
#  FUNCTION
#     Submit the jobenv.sh script via execution with qsh and parse the resulting
#     output file.
#
#  INPUTS
#     array       the name of the array in which results will be placed
#     arguments   switches to be passed to qsh
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_parse_env_test_output()
################################################################################
proc job_environment_qsh_job { array arguments } {
   global ts_config
   global CHECK_PROTOCOL_DIR CHECK_USER
   global queue job_environment_exec_host

   upvar $array job_env_array

   # create a script file to be executed by xterm -e <script> / qsh -S <script>
   set script_name "$CHECK_PROTOCOL_DIR/qsh.sh"
   set f [open $script_name "w" "0755"]
   puts $f "#!/bin/sh"
   puts $f "exec $ts_config(testsuite_root_dir)/scripts/jobenv.sh $CHECK_PROTOCOL_DIR"
   close $f

   # wait for host to appear on the remote host
   wait_for_remote_file $job_environment_exec_host $CHECK_USER $script_name

   ts_log_fine "starting qsh $arguments -q $queue -S $script_name ..."
   set output [start_sge_bin "qsh" "$arguments -q $queue -S $script_name"]
   ts_log_fine $output

   # check results
   job_environment_parse_env_test_output $CHECK_PROTOCOL_DIR/job_env.out job_env_array

   # cleanup
   file delete $script_name
}

#****** job_environment_amount() ***********************************************
#  NAME
#     job_environment_amount() -- test job environment
#
#  SYNOPSIS
#     job_environment_amount { } 
#
#  FUNCTION
#     Check that all required environment variables are set by the shepherd
#
#  RESULT
#     0 -> ok   1 -> error
#
#  SEE ALSO
#     job_environment_var_test()
#*******************************************************************************
proc job_environment_amount {} {
   global job_environment_exec_host
   set errors ""

   ts_log_fine "Testing list of environment variables with execd_param=none"

   # Set exced_params=none
   set new_config(execd_params) "none"
   set_config_and_propagate new_config $job_environment_exec_host

   job_environment_var_test missing

   if {[llength $missing] != 0} {
      set missing_vars ""

      foreach missing_var $missing {
         append missing_vars " $missing_var"
      }

      ts_log_severe "The following environment variables should have been set but were not, with execd_params=none: [string trim $missing_vars]"
   }
}

####### job_environment_var_test() #############################################
#  NAME
#     job_environment_var_test() -- test job environment
#
#  SYNOPSIS
#     job_environment_var_test { missing {extra ""} } 
#
#  FUNCTION
#     Check that all required environment variables are set by the shepherd.
#     Variables which should be present but are not, are placed in the missing
#     array.  If the extra array is given, variables which are unrecognised are
#     placed in the extra array.
#
#  INPUTS
#     missing     the name of the array in which to place missing env vars
#     extra       the name of the array in which to place extra env vars
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_var_test {missing {extra ""}} {
   global ts_config
   global env
   upvar $missing missing_variables
   upvar $extra extra_variables

   set missing_variables ""
   set extra_variables ""

   set known_variables ""
   lappend known_variables "SGE_ROOT"
   lappend known_variables "SGE_CELL"
   lappend known_variables "SGE_ARCH"
   lappend known_variables "SGE_O_HOME"
   lappend known_variables "SGE_O_HOST"
   lappend known_variables "SGE_O_LOGNAME"
   lappend known_variables "SGE_O_MAIL"
   lappend known_variables "SGE_O_PATH"
   lappend known_variables "SGE_O_SHELL"

   # JG: TZ is only set by N1GE, if it is available in the 
   # sge_execd's environment.
   # So if we want to check for existence of SGE_O_TZ, we would have 
   # to check first, if TZ is set on the exec host (root shell).
   #if { [ info exists env(TZ)] } {
   #   lappend known_variables "SGE_O_TZ"
   #}
   lappend known_variables "SGE_O_WORKDIR"
   lappend known_variables "ARC"
   lappend known_variables "SGE_ACCOUNT"
   lappend known_variables "SGE_CKPT_ENV"
   lappend known_variables "SGE_CKPT_DIR"
   lappend known_variables "SGE_CWD_PATH"
   lappend known_variables "SGE_STDERR_PATH"
   lappend known_variables "SGE_STDOUT_PATH"
   lappend known_variables "SGE_BINARY_PATH"
   lappend known_variables "SGE_JOB_SPOOL_DIR"
   lappend known_variables "SGE_TASK_ID"
   lappend known_variables "SGE_TASK_FIRST"
   lappend known_variables "SGE_TASK_LAST"
   lappend known_variables "SGE_TASK_STEPSIZE"
   lappend known_variables "ENVIRONMENT"
   lappend known_variables "HOME"
   lappend known_variables "HOSTNAME"
   lappend known_variables "JOB_ID"
   lappend known_variables "JOB_NAME"
   lappend known_variables "JOB_SCRIPT"
   lappend known_variables "LOGNAME"
   lappend known_variables "NQUEUES"
   lappend known_variables "NSLOTS"
   lappend known_variables "NHOSTS"
   lappend known_variables "PATH"
   lappend known_variables "PE"
   lappend known_variables "PE_HOSTFILE"
   lappend known_variables "QUEUE"
   lappend known_variables "REQUEST"
   lappend known_variables "SHELL"
   lappend known_variables "TMPDIR"
   lappend known_variables "TMP"
   lappend known_variables "USER"
   lappend known_variables "RESTARTED"

   if {$ts_config(gridengine_version) == 53} {
      lappend known_variables "COMMD_PORT"
      lappend known_variables "FIRST_HOST"
      lappend known_variables "LAST_HOST"
   } else {
      lappend known_variables "SGE_STDIN_PATH"
      lappend known_variables "SGE_QMASTER_PORT"
      lappend known_variables "SGE_EXECD_PORT"
   }

   # Build list of allowed_variables
   set allowed_variables "TZ"
   lappend allowed_variables "SGE_O_TZ"
   lappend allowed_variables "REQNAME"
   # the following might are set by many GE engineers shell rc files
   lappend allowed_variables "ARCH"
   lappend allowed_variables "TERM"

   ts_log_fine "checking number of environment variables ..."

   if {[job_environment_qsub_job "jobenv.sh" job_env "-o /dev/null -e /dev/null -ckpt testcheckpointobject -pe mytestpe 2"]} {
      foreach var $known_variables {
         if {[info exists job_env($var)]} {
            set value $job_env($var)

            if {[string length $value] == 0} {
               lappend missing_variables $var
            }

            # Remove each known_variable from job_env
            array unset job_env $var
         } else {
            lappend missing_variables $var
         }
      }

      # If doing exclusive test...
      if {$extra != ""} {
         # Remove each allowed_variable from job_env
         foreach var $allowed_variables {
            if {[info exists job_env($var)]} {
               if {[string length $job_env($var)] != 0} {
                  array unset job_env $var
               }
            }
         }

         # Test if job_env contains any extra variables
         foreach var [array names job_env] {
            if {[string compare $var "index"] != 0} {
                lappend extra_variables $var
            }
         }
      }
   }
}

####### job_environment_check_env_value() ######################################
#  NAME
#     job_environment_check_env_value() -- test an env var value
#
#  SYNOPSIS
#     job_environment_check_env_value { env_name should_be is_name } 
#
#  FUNCTION
#     The value of the environment value is tested against the expected value.
#
#  INPUTS
#     env_name    the name of the environment variable
#     should_be   the value of the environment variable should have
#     is_name     the name of the variable containing the actual value of the
#                 environment variable
#
#  RESULT
#     0 -> ok   1 -> error
################################################################################
proc job_environment_check_env_value {env_name should_be is_name} {
   global ts_config

   upvar $is_name is

   ts_log_fine "checking environment \"$env_name\" ..."

   if {![info exists is]} {
      ts_log_severe "environment variable \"$env_name\" is not set"
   } else {
      set had_error 0
      if {[ string compare $should_be $is] != 0} {
         set had_error 1
         ts_log_fine " failed."
      } else {
         ts_log_fine " ok."
      }
      ts_log_fine " ($env_name=$is)"
      if {$had_error == 1} {
         if {$ts_config(gridengine_version) == 53 && [string compare $env_name "JOB_NAME"] == 0} {
            set message "environment variable \"$env_name\" is set to \"$is\", should be \"$should_be\"\n\n"
            append message "This bug is not fixed for GE version 53 and JOB_NAME environment variable!\n"
            append message "Workaround: Use \"REQNAME\" or \"REQUEST\" instead of \"$env_name\"\n"
            append message "in your job scripts!!!\n"
            ts_log_info $message
         } else {
            ts_log_severe "environment variable \"$env_name\" is set to \"$is\", should be \"$should_be\""
         } 
      }
   }
}

#****** job_environment_JOB_NAME() *********************************************
#  NAME
#     job_environment_JOB_NAME() -- test the job name env vars
#
#  SYNOPSIS
#     job_environment_JOB_NAME { {stand_alone 1} } 
#
#  FUNCTION
#     Tests whether the shepherd correctly sets the job name environment
#     variables
#
#  INPUTS
#     stand_alone    whether this test is running directly or being called from
#                    another test
#
#  RESULT
#     0 -> ok   1 -> error
#*******************************************************************************
proc job_environment_JOB_NAME {{stand_alone 1}} {
   global ts_config CHECK_PROTOCOL_DIR job_environment_exec_host
  
   if {$stand_alone == 1} {
      ts_log_fine "Testing presence of job env vars with execd_params=none"

      # Set exced_params=none
      set new_config(execd_params) "none"
      set_config_and_propagate new_config $job_environment_exec_host
   }

   ts_log_fine "\nqsub ..."
   if {[job_environment_qsub_job "jobenv.sh" job_env "-o /dev/null -e /dev/null"]} {
      job_environment_check_env_value "JOB_NAME" "jobenv.sh" job_env(JOB_NAME)
      job_environment_check_env_value "REQNAME" "jobenv.sh" job_env(REQNAME)
      job_environment_check_env_value "REQUEST" "jobenv.sh" job_env(REQUEST)
   }

   ts_log_fine "\nqsub -N ..."
   if {[job_environment_qsub_job "newnam" job_env "-o /dev/null -e /dev/null -N newnam"]} {
      job_environment_check_env_value "JOB_NAME" "newnam" job_env(JOB_NAME)
      job_environment_check_env_value "REQNAME" "newnam" job_env(REQNAME)
      job_environment_check_env_value "REQUEST" "newnam" job_env(REQUEST)
   }

   ts_log_fine "\nqresub ..."
   job_environment_qresub_job "jobenv.sh" job_env "-o /dev/null -e /dev/null"
   job_environment_check_env_value "JOB_NAME" "jobenv.sh" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "jobenv.sh" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "jobenv.sh" job_env(REQUEST)

   ts_log_fine "\nqalter ..."
   job_environment_qalter_job "newnam" job_env "-o /dev/null -e /dev/null" "-N newnam" 
   job_environment_check_env_value "JOB_NAME" "newnam" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "newnam" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "newnam" job_env(REQUEST)

   ts_log_fine "\nqsh ..."
   job_environment_qsh_job job_env ""
   job_environment_check_env_value "JOB_NAME" "INTERACTIVE" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "INTERACTIVE" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "INTERACTIVE" job_env(REQUEST)
     
#   can't test qlogin, need password to login !!!
#   ts_log_fine "\nqlogin ..."
#   ts_log_fine "job name is \"$job_env(JOB_NAME)\""

   ts_log_fine "\nqrsh ..."
   job_environment_qrsh_job job_env ""
   job_environment_check_env_value "JOB_NAME" "jobenv.sh" job_env(JOB_NAME)
   job_environment_check_env_value "REQNAME" "jobenv.sh" job_env(REQNAME)
   job_environment_check_env_value "REQUEST" "jobenv.sh" job_env(REQUEST)
}
