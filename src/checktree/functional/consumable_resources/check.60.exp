#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Test description:
# ------------------
#
# Scenario 1) Consumable resources on global level
#
#   setup:
#      - add following complex attribute ( test1 t1 INT <=  YES YES 0 1000)
#      - add the attribute to the global host complex_values     test1=5
#   
#   a) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs without resource requests 
#      => All jobs will run
#
#   b) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with (-l test1=1) resource request
#      => 5 jobs will run the 6th has to wait because:
#         (-l test1=1) cannot run globally because it offers only gc:test1=0.000000
#
#   mod:
#    - add following complex attribute (test1 t1 INT <= YES YES 1 1000)
#
#   c) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs without resource requests
#      => 5 jobs will run the 6th has to wait because:
#         (-l test1=1) cannot run globally because it offers only gc:test1=0.000000
#
#   d) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with (-l test1=0) resource request
#      => 6 jobs will run 
#
#   e) - define a consumable load threashold (t1=3)
#      - submit 6 jobs
#     => 2 jobs will run, 
#        queue instance "all.q@carc" dropped because it is overloaded: test1=8.000000 (no load value) <= 8
#
# Scenario 2) Consumable resource on host level
#
#   setup:
#      - add following complex attribute ( test1 t1 INT <=  YES YES 0 1000)
#      - add the attribute to the global host complex_values     test1=5
#
#   a) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a)
#      => All jobs will run
#
#   b) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a,test2=1)
#      => 5 jobs will run the 6th has to wait because: 
#      (-l hostname=carc,test2=1) cannot run at host "carc.germany.sun.com" because it offers only hc:test2=0.000000
#      
#   mod:
#    - add following complex attribute (test1 t1 INT <= YES YES 1 1000)
#
#   c) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a)
#      => 5 jobs will run the 6th has to wait because:
#         (-l hostname=carc) cannot run at host "carc.germany.sun.com" because for default request it offers only hc:test2=0.000000
#
#   d) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a,test2=0)
#      => 6 jobs will run 
#
#   e) - define a consumable load threashold (t1=3)
#      - submit 6 jobs
#     => 2 jobs will run, 
#        queue instance "all.q@carc" dropped because it is overloaded: test1=8.000000 (no load value) <= 8
#
# and more, issue 1212 coveres most of it
#
#
#
# Bugfixes:
# - Issue: 1306, Bugster: 6287862 - qhost -l for complexes broken
# - Issue: 1761, Bugster: 6315111 -	Doing a qalter -l rsc=val on running jobs breaks consumable debitation
# - Issue: 1745

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

#set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "consumable_resources_init_level"

# define test's name and run level descriptions
set check_name            "consumable_resources"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   8
set check_description(0)  "Consumable resources on global level"
set check_description(1)  "Consumable resources on host level"
set check_description(2)  "Consumable resources on queue level"
set check_description(3)  "Consumable resources on global/host/queue level"
set check_description(4)  "Force request of consumable resource"
set check_description(5)  "Consumable resources as load_thresholds"
set check_description(6)  "Consumable resources and rescheduling"
set check_description(7)  "Consumable resources and load sensors"
set check_description(8)  "Consumable resources and 2 load sensor scripts"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function consumable_resources_setup
set check_cleanup_function consumable_resources_cleanup

# define test's procedure order
set check_functions "consumable_resources_test"


global consumable_resources_test_hosts
global consumable_resources_saved_slot_count

proc consumable_resources_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" { 
         return 0
      } 
      "1" {
         return 0
      }
      "2" {
         return 0
      }
      "3" {
         return 0
      }
      "4" {
         return 0
      }
      "5" {
         return 0
      }
      "6" {
         return 0
      }
      "7" {
         return 0
      }
      "8" {
         return 0
      }
   } 

   return -1  ;# no other level 
}




# -------- local test procedures: initialization------------------------------


proc consumable_resources_setup  {} {
   global ts_config
   global consumable_resources_test_hosts
   global consumable_resources_saved_slot_count
   global consumable_complex_backup
   global CHECK_OUTPUT

   # backup complex - we will modify it during the test
   get_complex consumable_complex_backup

   set consumable_resources_test_hosts {}
   set consumable_resources_saved_slot_count ""
   set execd_count 0
   foreach host $ts_config(execd_nodes) {
      if { $execd_count < 2 } {
         incr execd_count 1
         lappend consumable_resources_test_hosts "$host"
         puts $CHECK_OUTPUT "using host $host"
      } 
   }

   set queue_list {}
   foreach host $ts_config(execd_nodes) {
      lappend queue_list [get_queue_instance "all.q" $host]
   }

   disable_queue $queue_list
   puts $CHECK_OUTPUT "disabled $queue_list"
   
   set pe(pe_name)           "round_robin"
   set pe(slots)             "999"
   set pe(allocation_rule)   "\$round_robin"
   add_pe pe

   set queue_settings(slots) 1000
   set queue_settings(load_thresholds) "np_load_avg=11.75"
   set queue_settings(pe_list)          "round_robin"
   set qname "res.q"
   add_queue $qname $consumable_resources_test_hosts queue_settings
   puts $CHECK_OUTPUT "added queue $qname for hosts $consumable_resources_test_hosts"

   set_error 0 "ok"
}

proc consumable_resources_cleanup  {} {
   global CHECK_OUTPUT ts_config
   global consumable_resources_test_hosts
   global consumable_resources_saved_slot_count
   global consumable_complex_backup

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set queue_list {}
   foreach host $ts_config(execd_nodes) {
      lappend queue_list [get_queue_instance "all.q" $host]
   }
   enable_queue $queue_list
   puts $CHECK_OUTPUT "disabled $queue_list"


   set qname "res.q"
   del_queue $qname $consumable_resources_test_hosts  0 1

   del_pe        "round_robin"

   # restore complex
   set_complex consumable_complex_backup

   set_error 0 "ok"
}

# Issue: 1306, Bugster: 6287862 - qhost -l for complexes broken
proc check_qhost_broken { complex count } {
   global ts_config CHECK_ARCH CHECK_OUTPUT CHECK_USER CHECK_HOST

   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qhost" "-l $complex -F | grep arch | wc -l"]
   if { $output != $count } {
      add_proc_error "check_qhost_broken" -2 "qhost is broken - see Issue: 1306, returned $output hosts but $count is expected"
      set error 1
   }
}

proc consumable_resources_submit_jobs_and_alter { job_arguments resource resource2 case } {
   global ts_config CHECK_OUTPUT CHECK_ARCH CHECK_USER

   set job_id [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]

   while { 1 } {
      trigger_scheduling
      set running_jobs 0
      set error 0

      set job_state [is_job_running $job_id "leeper"]
      if { $job_state == 1 } {
         incr running_jobs 1
      }
      if { $job_state == -1 } {
         add_proc_error "case $case) consumable_resources_submit_jobs_and_wait" -2 "job was not submitted - stop"
         set error 1
         break
      }

      puts $CHECK_OUTPUT "running jobs count: $running_jobs"
      if { $running_jobs == 1 || $error != 0 } {
         break
      }
   }

   
   set arch [resolve_arch $ts_config(master_host)]

   set alter_result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-l $resource=4 $job_id" exit_code ]
   if { $exit_code != 1 } {
      puts $CHECK_OUTPUT "Issue 1761 found!"
      puts $CHECK_OUTPUT "qalter -l $resource=4 $job_id"
      puts $CHECK_OUTPUT "qalter result: $alter_result - $exit_code"
      set error 1
   }

   set alter_result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-l $resource=4,$resource2=2 $job_id" exit_code ]
   if { $exit_code != 1 } {
      puts $CHECK_OUTPUT "Issue 1761 found!"
      puts $CHECK_OUTPUT "qalter -l $resource=4 $job_id"
      puts $CHECK_OUTPUT "qalter result: $alter_result - $exit_code"
      set error 1
   }

   set alter_result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-l $resource2=1 $job_id" exit_code ]
   if { $exit_code != 1 } {
      puts $CHECK_OUTPUT "Issue 1761 found!"
      puts $CHECK_OUTPUT "qalter -l $resource=4 $job_id"
      puts $CHECK_OUTPUT "qalter result: $alter_result - $exit_code"
      set error 1
   }

   set alter_result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-l $resource=1 $job_id" exit_code ]
   if { $exit_code != 0 } {
      puts $CHECK_OUTPUT "Issue 1761 found!"
      puts $CHECK_OUTPUT "qalter -l $resource=1 $job_id"
      puts $CHECK_OUTPUT "qalter result: $alter_result - $exit_code"
      set error 1
   }

   set alter_result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-l \"\" $job_id" exit_code ]
   if { $exit_code != 1 } {
      puts $CHECK_OUTPUT "Issue 1761 found!"
      puts $CHECK_OUTPUT "qalter -l \"\" $job_id"
      puts $CHECK_OUTPUT "qalter result: $alter_result - $exit_code"
      set error 1
   }
 
   delete_all_jobs  
   wait_for_end_of_all_jobs 60
}

proc consumable_resources_submit_pejobs_and_wait { job_arguments job_count run_job_count case } {
   global ts_config CHECK_OUTPUT CHECK_ARCH

   set job_id [submit_job "-pe round_robin 1-$job_count $job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]

   while { 1 } {
      trigger_scheduling
      set running_jobs 0
      set error 0
      
      set job_state [is_job_running $job_id "leeper"]
      if { $job_state == 1 } {
         set job_std_state [get_standard_job_info  $job_id 1 ]

         set running_jobs [llength $job_std_state]
      }

      if { $job_state == -1 } {
         add_proc_error "case $case) consumable_resources_submit_jobs_and_wait" -2 "job was not submitted - stop"
         set error 1
         break
      }

      puts $CHECK_OUTPUT "running jobs count: $running_jobs"
      if { $running_jobs == $run_job_count || $error != 0 } {
         break
      }
      if { $running_jobs != 0 } {
         add_proc_error "case $case) consumable_resources_submit_jobs_and_wait" -2 "job ran with the wrong slot count $running_jobs expected $run_job_count"
         set error 1
         break
      }
   }

   delete_all_jobs  
   wait_for_end_of_all_jobs 60
}

proc consumable_resources_submit_jobs_and_wait { job_arguments job_count run_job_count job_arguments2 case { schedd_info "" } { queue_state "" } { schedd_info_err "" } } {
   global ts_config CHECK_OUTPUT CHECK_ARCH

   if { $job_arguments2 == "" } {
      for { set i 0 } { $i < $job_count } { incr i 1 } {
         set job_id($i) [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
      }
   } else {
      for { set i 0 } { $i < $job_count } { incr i 1 } {
         set job_id($i) [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
         incr i 1
         set job_id($i) [submit_job "$job_arguments2 $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
      }
   }

   while { 1 } {
      trigger_scheduling
      set running_jobs 0
      set error 0
      for { set i 0 } { $i < $job_count } { incr i 1 } {
         set job_state [is_job_running $job_id($i) "leeper"]
         set job_id($i,running) $job_state
         if { $job_state == 1 } {
            incr running_jobs 1
         }
         if { $job_state == -1 } {
            add_proc_error "case $case) consumable_resources_submit_jobs_and_wait" -2 "job was not submitted - stop"
            set error 1
            break
         }
      }
      puts $CHECK_OUTPUT "running jobs count: $running_jobs"
      if { $running_jobs == $run_job_count || $error != 0 } {
         break
      }
   }

   if { $queue_state != "" } {
      wait_for_queue_state [lindex $queue_state 0] [lindex $queue_state 1] 60
   }

   if { $job_count != $run_job_count } {
      if { $schedd_info == "" } {
         add_proc_error "case $case) consumable_resources_submit_jobs_and_wait" -2 "got not running job, but no schedule info to search for"
      } else {
         set sched_info_tries 10
         set ok 0
         while { $sched_info_tries > 0 } {      
            trigger_scheduling
            for { set i 0 } { $i < $job_count } { incr i 1 } {
               if { $job_id($i,running) == 0 } {
                  puts $CHECK_OUTPUT "job $job_id($i) is not running, checking schedd job info message ..."
                  puts $CHECK_OUTPUT "looking for \"$schedd_info\" of job $job_id($i)"
                  get_qstat_j_info $job_id($i)
                  if { $schedd_info_err != "" } {
                     if { [string match "*$schedd_info_err*" $qstat_j_info(scheduling info)] } {
                        add_proc_error "consumable_resources_submit_jobs_and_wait_error" -2 "found issue 1894 (scheduling info contains: $schedd_info_err) - stop"
                        set error 1
                        set ok 1
                     }
                  }
                  if { [string match "*$schedd_info*" $qstat_j_info(scheduling info)] } {
                     puts $CHECK_OUTPUT "found matching scheduling info"
                     set ok 1
                  }
               }
            }
            if { $ok == 1 } {
               break
            }
            incr sched_info_tries -1
            after 1000
         }
         if { $ok != 1 } {
            add_proc_error "case $case) consumable_resources_submit_jobs_and_wait" -2 "can't find matching scheduler info:\nexpected: $schedd_info\ngot: $qstat_j_info(scheduling info)"
         }
      }
   }
 
   delete_all_jobs  
   wait_for_end_of_all_jobs 60
}



proc consumable_resources_test {} {
   global consumable_resources_test_hosts check_description CHECK_ARCH
   global CHECK_OUTPUT ts_config CHECK_CORE_MASTER CHECK_ACT_LEVEL CHECK_SCRIPT_FILE_DIR


   puts $CHECK_OUTPUT $check_description($CHECK_ACT_LEVEL)

   if { $CHECK_ACT_LEVEL == 0 } {

      set GLOBALLY [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS] "*" "*test1=0*"]
   
      # case a)
      #           all jobs will run
      puts $CHECK_OUTPUT "\ncase a)"

      # create test1 complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
   
      # get original global host coniguration
      get_exechost orig_global_host global
   
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global
   
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a"  
  
      # case b) 
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase b)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" 
   
      # case c)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase c)"
      set test1_complex(test1) "t1 INT <= YES YES 1 1000"
      set_complex test1_complex
      
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "c" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" 

      # case d)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase d)"
      set job_arguments "-l test1=0 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "d" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" 

      # case e)
      #        2 jobs run, 4 have to wait
      set GLOBALLY [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_QUEUEOVERLOADED_SS] "*" "*"]

      
      puts $CHECK_OUTPUT "\ncase e)"
      set job_arguments "-o /dev/null -e /dev/null"
      set queue_settings(load_thresholds) "test1=3"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_count 6
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "e" $GLOBALLY

# this tests issue 1745. enable the code, when the issue is fixed.
      puts $CHECK_OUTPUT "---> found issue 1745"
#      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count 
      
      #clean up
      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global
      
      set test1_complex(test1) ""
      set_complex test1_complex
      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 1 } {
      set RUNATHOST  [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNATHOST_SSS]  "*" "*" "*test2=0*"]
   
      # case a)
      #           all jobs will run
      puts $CHECK_OUTPUT "\ncase a)"

      # create test2 complex
      set test2_complex(test2) "t2 INT <= YES YES 0 1000"
      set test2_complex(test3) "t3 int <= YES YES 0 1000"
      set_complex test2_complex

      set host_a [lindex $consumable_resources_test_hosts 0]

      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
   
      # modify complex_values of host_a host
      set host_a_host(complex_values) "test2=5,test3=5"
      set_exechost host_a_host $host_a
      check_qhost_broken "test2=1" 1

      set job_arguments "-l h=$host_a -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" 
   
      # case b) 
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase b)"
      
      set job_arguments "-l h=$host_a,test2=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b"
     
      # case ba)
      #   issue : 1761
      #   checks wether qalter can modify a consumable
      puts $CHECK_OUTPUT "\ncase ba  - Issue: 1761)"
      set job_arguments "-l h=$host_a,test2=1 -o /dev/null -e /dev/null"
      consumable_resources_submit_jobs_and_alter $job_arguments "test2" "test3" "f"  

      # case c)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase c)"
      set test2_complex(test2) "t2 INT <= YES YES 1 1000"
      set_complex test2_complex

      
      set job_arguments "-l h=$host_a -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "c" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" 
   
      # case d)
      #           6 jobs run, 0 have to wait
      puts $CHECK_OUTPUT "\ncase d)"
      set job_arguments "-l h=$host_a,test2=0 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "d" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d"  

      # case e)
      #        2 jobs run, 4 have to wait
      
      set RUNATHOST [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_QUEUEOVERLOADED_SS] "*" "*"]

      puts $CHECK_OUTPUT "\ncase e)"
      set job_arguments "-o /dev/null -e /dev/null"
      set queue_settings(load_thresholds) "test2=3"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_count 6
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "e" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "e" 

      #clean up
      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set test2_complex(test2) ""
      set_complex test2_complex
      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 2 } {
      set RUNINQUEUE [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS] "*" "*" "*test3=0*"]
  
      # case a)
      #           all jobs will run
      puts $CHECK_OUTPUT "\ncase a)"

      # create complex
      set test3_complex(test3) "t3 INT <= YES YES 0 1000"
      set_complex test3_complex

      set queue_settings(complex_values) "test3=5"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      check_qhost_broken "test3=1" 0

      # case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 11
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a"  

      # case b
      set WRONGGLOBAL [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS] "*" "*"]
      puts $CHECK_OUTPUT "\ncase b)"
      puts $CHECK_OUTPUT $WRONGGLOBAL
      set job_arguments "-l test3=1 -o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $RUNINQUEUE "" $WRONGGLOBAL
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b"  

      # case c
      puts $CHECK_OUTPUT "\ncase c)"
      set test3_complex(test3) "t3 INT <= YES YES 1 1000"
      set_complex test3_complex

      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "c" $RUNINQUEUE
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c"  

      set RUNINQUEUE [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS] "*" "*" "*test3=2*"]
      #case d
      puts $CHECK_OUTPUT "\ncase d)"
      set job_arguments "-l test3=3 -o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "d" $RUNINQUEUE
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d"  

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings


      # remove test3 complex 
      set test3_complex(test3) ""
      set_complex test3_complex

      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 3 } {
      set RUNINQUEUE [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS] "*" "*" "*test1=0*"]
      set RUNATHOST  [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNATHOST_SSS]  "*" "*" "*test1=0*"]
      set GLOBALLY [translate $CHECK_CORE_MASTER 1 0 0   [sge_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS] "*" "*test1=0*"]

      # create complex
      set test1_complex(test1) "t2 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=3"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=1"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      check_qhost_broken "test1=1" "[llength $ts_config(execd_nodes)]"


      #case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 3
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a" $RUNINQUEUE
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" 

      #case aa
      puts $CHECK_OUTPUT "\ncase aa)"
      set queue_settings(complex_values) "test1=4"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1,h=$host_a  -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 3
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "aa" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "aa"      

      #case ab
      puts $CHECK_OUTPUT "\ncase ab)"
      set queue_settings(complex_values) "test1=4"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1  -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "ab" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count  "ab"

      #case b
      puts $CHECK_OUTPUT "\ncase b)"
      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_count 4
      set run_job_count 3
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" 

      #case c
      puts $CHECK_OUTPUT "\ncase c)"
      set job_arguments1 "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_arguments2 "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "c" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments2 $job_count $run_job_count "c" 

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      
      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }
   
   if { $CHECK_ACT_LEVEL == 4 } {
      set FORCED [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_NOTREQFORCEDRES_SS] "test1" "*"]

      # create complex
      set test1_complex(test1) "t1 INT <= FORCED YES 0 1000"
      set_complex test1_complex
  
      set queue_settings(complex_values) "test1=1"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments1 "-o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 0
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "a" $FORCED
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "a" 


      # case b
      puts $CHECK_OUTPUT "\ncase b)"
      set job_arguments1 "-l test1=1 -o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 1
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "b"
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "b"  

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }
    

   if { $CHECK_ACT_LEVEL == 5 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=4"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=3"
      set queue_settings(load_thresholds) "np_load_avg=11.75,test1=2"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings


      # case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments1 "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 1
      set queue_check {}
      lappend queue_check "res.q@$host_a"
      lappend queue_check "a"

      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "" "a" $queue_check
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "a"  

      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings


      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 6 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=4"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=3"
      set queue_settings(load_thresholds) "np_load_avg=11.75,test1=2"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings


      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-F | grep test" } qstat_F_1
      set job_id [submit_job "-l test1=1,h=$host_a -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
      wait_for_jobstart $job_id "leeper" 60

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-F | grep test" } qstat_F_2


      puts $CHECK_OUTPUT "setting hold state of job $job_id"
      hold_job $job_id

      puts $CHECK_OUTPUT "reschedule job $job_id"
      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qmod" "-f -r $job_id" } catch_result
      puts $CHECK_OUTPUT $catch_result

      wait_for_jobpending $job_id "leeper" 60
      set state [get_queue_state "res.q@$host_a"]
      puts $CHECK_OUTPUT "queue state of queue \"res.q@$host_a\": \"$state\""
      if { $state != "" } {
         add_proc_error "consumable_resources_test" -1 "queue did not free alarm state"
      }
      
      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-F | grep test" } qstat_F_3

      puts $CHECK_OUTPUT "qstat1 (before job was started)   :\n$qstat_F_1"
      puts $CHECK_OUTPUT "qstat2 (when job is running)      :\n$qstat_F_2"
      puts $CHECK_OUTPUT "qstat3 (after job was rescheduled):\n$qstat_F_3"

      if { [string compare $qstat_F_1 $qstat_F_3] != 0 } {
         puts $CHECK_OUTPUT "resource wasn't freed"
         add_proc_error "consumable_resources_test" -1 "resources of rescheduled job wasn't freed"
      }

      delete_all_jobs  
      wait_for_end_of_all_jobs 60

      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings


      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }
   
   if { $CHECK_ACT_LEVEL == 7 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=15"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=10"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=5"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # setup load script
      get_config execd_config_a_host $host_a

            
      catch {  eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test1_6_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output


      set load_sensor_script_path "$ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh"
      if { [info exists execd_config_a_host(load_sensor)] } {
         set new_config_a_host(load_sensor) "$execd_config_a_host(load_sensor),$load_sensor_script_path"
      } else {
         set new_config_a_host(load_sensor) "$load_sensor_script_path"
         set execd_config_a_host(load_sensor) ""
      }
      if { [info exists execd_config_a_host(load_report_time)] == 0 } {
         set execd_config_a_host(load_report_time) ""
      }

      set new_config_a_host(load_report_time) "00:00:05"
      set_config new_config_a_host $host_a


      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test1" } test_grep
         puts $CHECK_OUTPUT "waiting for test1=6 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test1=6*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test1 is set to value 6 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test1=6 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
      if { [string match "*test1=6*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test1=6 load value"
      }

      catch {  eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test1_3_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output

      
      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test1" } test_grep
         puts $CHECK_OUTPUT "waiting for test1=3 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test1=3*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test1 is set to value 3 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test1=3 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
      if { [string match "*test1=3*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test1=3 load value"
      }

      

      # restore execd config
      set_config execd_config_a_host $host_a

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global

      set test_grep "test1" 
      set retries 45
      while { [string match "*test1*" $test_grep] && $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
         puts $CHECK_OUTPUT "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         puts $CHECK_OUTPUT "$test_grep"
         incr retries -1
         sleep 5
      }

      if { [string match "*test1*" $test_grep] } {
         add_proc_error "consumable_resources_test" -1 "load sensor report test1 does not disappear"
      }
      
      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output

      puts $CHECK_OUTPUT "done"
   }
   
   if { $CHECK_ACT_LEVEL == 8 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set test1_complex(test2) "t2 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=15,test2=15"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=10,test2=10"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=5,test2=5"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # setup load script
      get_config execd_config_a_host $host_a

            
      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test1_6_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test2_3_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output



      set load_sensor_script_path "$ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh,$ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh"
      if { [info exists execd_config_a_host(load_sensor)] } {
         set new_config_a_host(load_sensor) "$execd_config_a_host(load_sensor),$load_sensor_script_path"
      } else {
         set new_config_a_host(load_sensor) "$load_sensor_script_path"
         set execd_config_a_host(load_sensor) ""
      }
      if { [info exists execd_config_a_host(load_report_time)] == 0 } {
         set execd_config_a_host(load_report_time) ""
      }

      set new_config_a_host(load_report_time) "00:00:05"
      set_config new_config_a_host $host_a


      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test1" } test_grep
         puts $CHECK_OUTPUT "waiting for test1=6 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test1=6*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test1 is set to value 6 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }
      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test1=6 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
      if { [string match "*test1=6*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test1=6 load value"
      }

      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test2" } test_grep
         puts $CHECK_OUTPUT "waiting for test2=3 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test2=3*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test2 is set to value 3 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }
      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test2=3 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test2" } test_grep
      if { [string match "*test2=3*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test2=3 load value"
      }


      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output


      # restore execd config
      set_config execd_config_a_host $host_a

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global

      set test_grep "test1" 
      set retries 45
      while { [string match "*test1*" $test_grep] && $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
         puts $CHECK_OUTPUT "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         puts $CHECK_OUTPUT "$test_grep"
         incr retries -1
         sleep 5
      }

      if { [string match "*test1*" $test_grep] } {
         add_proc_error "consumable_resources_test" -1 "load sensor report test1 does not disappear"
      }

      set test_grep "test2" 
      set retries 45
      while { [string match "*test2*" $test_grep] && $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test2" } test_grep
         puts $CHECK_OUTPUT "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         puts $CHECK_OUTPUT "$test_grep"
         incr retries -1
         sleep 5
      }

      if { [string match "*test2*" $test_grep] } {
         add_proc_error "consumable_resources_test" -1 "load sensor report test2 does not disappear"
      }

      
      # remove test1 and test2 complex 
      set test1_complex(test1) ""
      set test1_complex(test2) ""
      set_complex test1_complex

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output

      puts $CHECK_OUTPUT "done"
   }
   
   set_error 0 "ok"
}


