#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Test description:
# ------------------
#
# Scenario 1) Consumable resources on global level
#
#   setup:
#      - add following complex attribute ( test1 t1 INT <=  YES YES 0 1000)
#      - add the attribute to the global host complex_values     test1=5
#   
#   a) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs without resource requests 
#      => All jobs will run
#
#   b) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with (-l test1=1) resource request
#      => 5 jobs will run the 6th has to wait because:
#         (-l test1=1) cannot run globally because it offers only gc:test1=0.000000
#
#   mod:
#    - add following complex attribute (test1 t1 INT <= YES YES 1 1000)
#
#   c) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs without resource requests
#      => 5 jobs will run the 6th has to wait because:
#         (-l test1=1) cannot run globally because it offers only gc:test1=0.000000
#
#   d) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with (-l test1=0) resource request
#      => 6 jobs will run 
#
#   e) - define a consumable load threashold (t1=3)
#      - submit 6 jobs
#     => 2 jobs will run, 
#        queue instance "all.q@carc" dropped because it is overloaded: test1=8.000000 (no load value) <= 8
#
# Scenario 2) Consumable resource on host level
#
#   setup:
#      - add following complex attribute ( test1 t1 INT <=  YES YES 0 1000)
#      - add the attribute to the global host complex_values     test1=5
#
#   a) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a)
#      => All jobs will run
#
#   b) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a,test2=1)
#      => 5 jobs will run the 6th has to wait because: 
#      (-l hostname=carc,test2=1) cannot run at host "carc.germany.sun.com" because it offers only hc:test2=0.000000
#      
#   mod:
#    - add following complex attribute (test1 t1 INT <= YES YES 1 1000)
#
#   c) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a)
#      => 5 jobs will run the 6th has to wait because:
#         (-l hostname=carc) cannot run at host "carc.germany.sun.com" because for default request it offers only hc:test2=0.000000
#
#   d) - default cluster with two execution hosts and unlimited slots
#      - submit 6 jobs with following request (-l h=host_a,test2=0)
#      => 6 jobs will run 
#
#   e) - define a consumable load threashold (t1=3)
#      - submit 6 jobs
#     => 2 jobs will run, 
#        queue instance "all.q@carc" dropped because it is overloaded: test1=8.000000 (no load value) <= 8
#
# and more, issue 1212 coveres most of it
#
#
#
# Bugfixes:
# - Issue: 1306, Bugster: 6287862 - qhost -l for complexes broken
# - Issue: 1761, Bugster: 6315111 -	Doing a qalter -l rsc=val on running jobs breaks consumable debitation
# - Issue: 1745

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

#set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "consumable_resources_init_level"

# define test's name and run level descriptions
set check_name            "consumable_resources"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   8
set check_description(0)  "Consumable resources on global level"
set check_description(1)  "Consumable resources on host level"
set check_description(2)  "Consumable resources on queue level"
set check_description(3)  "Consumable resources on global/host/queue level"
set check_description(4)  "Force request of consumable resource"
set check_description(5)  "Consumable resources as load_thresholds"
set check_description(6)  "Consumable resources and rescheduling"
set check_description(7)  "Consumable resources and load sensors"
set check_description(8)  "Consumable resources and 2 load sensor scripts"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function consumable_resources_setup
set check_cleanup_function consumable_resources_cleanup

# define test's procedure order
set check_functions "consumable_resources_test"

global consumable_resources_test_hosts
global consumable_resources_saved_slot_count

proc consumable_resources_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      0 -
      1 -
      2 -
      3 -
      4 -
      5 -
      6 -
      7 -
      8 {
         return 0
      }
   }

   return -1  ;# no other level
}

# -------- local test procedures: initialization------------------------------

proc consumable_resources_setup {} {
   global ts_config
   global consumable_resources_test_hosts
   global consumable_resources_saved_slot_count
   global consumable_complex_backup
   global consumable_host_config_setup

   # backup complex - we will modify it during the test
   get_complex consumable_complex_backup
   
   set consumable_resources_test_hosts [host_conf_get_suited_hosts 2]
   set consumable_resources_saved_slot_count ""
   set host_a [lindex $consumable_resources_test_hosts 0]
   get_config consumable_host_config_setup $host_a
   
   set queue_list {}
   foreach host $ts_config(execd_nodes) {
      lappend queue_list [get_queue_instance "all.q" $host]
   }
   disable_queue $queue_list
   ts_log_fine "disabled $queue_list"

   set pe(slots)             "999"
   set pe(allocation_rule)   "\$round_robin"
   add_pe "round_robin" pe

   set pe(allocation_rule)   "\$fill_up"
   add_pe "fill_up" pe

   set queue_settings(slots) 1000
   set queue_settings(load_thresholds) "np_load_avg=11.75"
   set queue_settings(pe_list)          "round_robin fill_up"
   set qname "res.q"
   add_queue $qname $consumable_resources_test_hosts queue_settings
   ts_log_fine "added queue $qname for hosts $consumable_resources_test_hosts"

   # modify scheduler config
   set my_schedd_config(schedd_job_info)      "true"
   set_schedd_config my_schedd_config
}

proc consumable_resources_cleanup {} {
   global ts_config
   global consumable_resources_test_hosts
   global consumable_resources_saved_slot_count
   global consumable_complex_backup 
   global consumable_host_config_setup

   delete_all_jobs
   wait_for_end_of_all_jobs
   set host_a [lindex $consumable_resources_test_hosts 0]

   set queue_list {}
   foreach host $ts_config(execd_nodes) {
      lappend queue_list [get_queue_instance "all.q" $host]
   }
   enable_queue $queue_list
   ts_log_fine "disabled $queue_list"

   set qname "res.q"
   del_queue $qname $consumable_resources_test_hosts 0 1
   if {[del_pe "round_robin" "" "" 0]} {
      del_pe "round_robin"
   }

   if {[del_pe "fill_up" "" "" 0]} {
      del_pe "fill_up"
   }

   # restore complex
   ts_log_fine "restoring complex settings ..."
   set_complex consumable_complex_backup

   # we changed the schedd config - reset to defaults
   reset_schedd_config

   reset_config_and_propagate consumable_host_config_setup $host_a 
}

# Issue: 1306, Bugster: 6287862 - qhost -l for complexes broken
proc check_qhost_broken {complex count} {
   global ts_config

   # this bug has only be fixed for SGE 6.1
   if {$ts_config(gridengine_version) >= 61} {
      set output [start_sge_bin "qhost" "-l $complex -F | grep arch | wc -l"]
      if {$output != $count} {
         ts_log_severe "qhost -l $complex is broken - see Issue: 1306, returned $output hosts but $count is expected"
      }
   }
}

proc consumable_resources_submit_jobs_and_alter {job_arguments resource resource2 case} {
   global ts_config CHECK_USER

   set job_id [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]

   while {1} {
      trigger_scheduling
      set running_jobs 0
      set error 0

      set job_state [is_job_running $job_id "leeper"]
      if {$job_state == 1} {
         incr running_jobs 1
      }
      if {$job_state == -1} {
         ts_log_warning "case $case: job was not submitted - stop"
         set error 1
         break
      }

      ts_log_fine "running jobs count: $running_jobs"
      if {$running_jobs == 1 || $error != 0} {
         break
      }
   }

   set alter_result [start_sge_bin "qalter" "-l $resource=4 $job_id"]
   if {$prg_exit_state != 1} {
      ts_log_fine "Issue 1761 found!"
      ts_log_fine "qalter -l $resource=4 $job_id"
      ts_log_fine "qalter result: $alter_result - $prg_exit_state"
      set error 1
   }

   set alter_result [start_sge_bin "qalter" "-l $resource=4,$resource2=2 $job_id"]
   if {$prg_exit_state != 1} {
      ts_log_fine "Issue 1761 found!"
      ts_log_fine "qalter -l $resource=4 $job_id"
      ts_log_fine "qalter result: $alter_result - $prg_exit_state"
      set error 1
   }

   set alter_result [start_sge_bin "qalter" "-l $resource2=1 $job_id"]
   if {$prg_exit_state != 1} {
      ts_log_fine "Issue 1761 found!"
      ts_log_fine "qalter -l $resource=4 $job_id"
      ts_log_fine "qalter result: $alter_result - $prg_exit_state"
      set error 1
   }

   set alter_result [start_sge_bin "qalter" "-l $resource=1 $job_id"]
   if {$prg_exit_state != 0} {
      ts_log_fine "Issue 1761 found!"
      ts_log_fine "qalter -l $resource=1 $job_id"
      ts_log_fine "qalter result: $alter_result - $prg_exit_state"
      set error 1
   }

   set alter_result [start_sge_bin "qalter" "-l \"\" $job_id"]
   if {$prg_exit_state != 1} {
      ts_log_fine "Issue 1761 found!"
      ts_log_fine "qalter -l \"\" $job_id"
      ts_log_fine "qalter result: $alter_result - $prg_exit_state"
      set error 1
   }
 
   delete_all_jobs  
   wait_for_end_of_all_jobs
}

proc consumable_resources_submit_pejobs_and_wait {job_arguments job_count run_job_count case pe_name} {
   global ts_config

   set job_id [submit_job "-pe $pe_name 1-$job_count $job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]

   while {1} {
      trigger_scheduling
      set running_jobs 0
      set error 0
      
      set job_state [is_job_running $job_id "leeper"]
      if {$job_state == 1} {
         set job_std_state [get_standard_job_info $job_id 1]
         set running_jobs [llength $job_std_state]
      }

      if {$job_state == -1} {
         ts_log_warning "case $case: job was not submitted - stop"
         set error 1
         break
      }

      ts_log_fine "running jobs count: $running_jobs"
      if {$running_jobs == $run_job_count || $error != 0} {
         break
      }
      if {$running_jobs != 0} {
         ts_log_warning "case $case: job ran with the wrong slot count $running_jobs expected $run_job_count"
         set error 1
         break
      }
   }

   # delete all jobs, and make sure they are no longer referenced
   delete_all_jobs  
   wait_for_end_of_all_jobs
   trigger_scheduling
   after 1000
}

proc consumable_resources_submit_jobs_and_wait {job_arguments job_count run_job_count job_arguments2 case {schedd_info ""} {queue_state ""} {schedd_info_err ""}} {
   global ts_config

   if {$job_arguments2 == ""} {
      for {set i 0} {$i < $job_count} {incr i 1} {
         set job_id($i) [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
      }
   } else {
      for {set i 0} {$i < $job_count} {incr i 1} {
         set job_id($i) [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
         incr i 1
         set job_id($i) [submit_job "$job_arguments2 $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
      }
   }

   while {1} {
      trigger_scheduling
      set running_jobs 0
      set error 0
      for {set i 0} {$i < $job_count} {incr i 1} {
         set job_state [is_job_running $job_id($i) "leeper"]
         set job_id($i,running) $job_state
         if {$job_state == 1} {
            incr running_jobs 1
         }
         if {$job_state == -1} {
            ts_log_warning "case $case: job was not submitted - stop"
            set error 1
            break
         }
      }
      ts_log_fine "running jobs count: $running_jobs"
      if {$running_jobs == $run_job_count || $error != 0} {
         break
      }
   }

   if {$queue_state != ""} {
      wait_for_queue_state [lindex $queue_state 0] [lindex $queue_state 1] 60
   }

   if {$job_count != $run_job_count} {
      if {$schedd_info == ""} {
         ts_log_warning "case $case: got not running job, but no schedule info to search for"
      } else {
         set sched_info_tries 10
         set ok 0
         while {$sched_info_tries > 0} {      
            trigger_scheduling
            for {set i 0} {$i < $job_count} {incr i 1} {
               if {$job_id($i,running) == 0} {
                  ts_log_fine "job $job_id($i) is not running, checking schedd job info message ..."
                  ts_log_fine "looking for \"$schedd_info\" of job $job_id($i)"
                  get_qstat_j_info $job_id($i)
                  if {$schedd_info_err != ""} {
                     if {[string match "*$schedd_info_err*" $qstat_j_info(scheduling info)]} {
                        ts_log_severe "found issue 1894 (scheduling info contains: $schedd_info_err)"
                        set error 1
                        set ok 1
                     }
                     # this bug has been fixed for SGE 6.2u1
                     if {$ts_config(gridengine_version) >= 62} {
                        set result [start_sge_bin "qalter" "-w v $job_id($i)"]
                        if {[string match "*$schedd_info_err*" $result]} {
                           ts_log_severe "found issue 2680 (qalter -w v contains: $result)"
                           set error 1
                           set ok 1
                        }
                     }
                  }
                  if {[string match "*$schedd_info*" $qstat_j_info(scheduling info)]} {
                     ts_log_fine "found matching scheduling info"
                     set ok 1
                  }
               }
            }
            if {$ok == 1} {
               break
            }
            incr sched_info_tries -1
            after 1000
         }
         if {$ok != 1} {
            ts_log_warning "case $case: can't find matching scheduler info:\nexpected: $schedd_info\ngot: $qstat_j_info(scheduling info)"
         }
      }
   }

   # delete all jobs, and make sure they are no longer referenced
   delete_all_jobs  
   wait_for_end_of_all_jobs
   trigger_scheduling
}

proc consumable_resources_test {} {
   global ts_config CHECK_ACT_LEVEL
   global consumable_resources_test_hosts check_description CHECK_USER
   global consumable_resources_test_hosts

   if {$CHECK_ACT_LEVEL == 0} {
      set GLOBALLY [translate_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS "*" "*test1=0*"]
   
      # case a)
      #           all jobs will run
      ts_log_fine "\ncase a)"

      # create test1 complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
   
      # get original global host coniguration
      get_exechost orig_global_host global
   
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global
   
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "fill_up"
  
      # case b) 
      #           5 jobs run, 1 have to wait
      ts_log_fine "\ncase b)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "fill_up"
   
      # case c)
      #           5 jobs run, 1 have to wait
      ts_log_fine "\ncase c)"
      set test1_complex(test1) "t1 INT <= YES YES 1 1000"
      set_complex test1_complex
      
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "c" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" "fill_up"

      # case d)
      #           5 jobs run, 1 have to wait
      ts_log_fine "\ncase d)"
      set job_arguments "-l test1=0 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "d" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" "fill_up"

      # case e)
      #        2 jobs run, 4 have to wait
      set GLOBALLY [translate_macro MSG_SCHEDD_INFO_QUEUEOVERLOADED_SS "*" "*"]

      ts_log_fine "\ncase e)"
      set job_arguments "-o /dev/null -e /dev/null"
      set queue_settings(load_thresholds) "test1=3"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_count 6
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "e" $GLOBALLY

      # this tests issue 1745.
      # if {$ts_config(gridengine_version) >= 62} {
      #   consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "e" "round_robin"
      #   consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "e" "fill_up"
      # }
      
      # clean up
      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global
      
      set test1_complex(test1) ""
      set_complex test1_complex
      ts_log_fine "done"
   }

   if {$CHECK_ACT_LEVEL == 1} {
      set RUNATHOST  [translate_macro MSG_SCHEDD_INFO_CANNOTRUNATHOST_SSS  "*" "*" "*test2=0*"]

      # case a)
      #           all jobs will run
      ts_log_fine "\ncase a)"

      # create test2 complex
      set test2_complex(test2) "t2 INT <= YES YES 0 1000"
      set test2_complex(test3) "t3 int <= YES YES 0 1000"
      set_complex test2_complex

      set host_a [lindex $consumable_resources_test_hosts 0]

      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
   
      # modify complex_values of host_a host
      set host_a_host(complex_values) "test2=5,test3=5"
      set_exechost host_a_host $host_a
      check_qhost_broken "test2=1" 1

      set job_arguments "-l h=$host_a -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "fill_up"

      # case b) 
      #           5 jobs run, 1 have to wait
      ts_log_fine "\ncase b)"
      
      set job_arguments "-l h=$host_a,test2=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "fill_up"
     
      # case ba)
      #   issue : 1761
      #   checks wether qalter can modify a consumable
      ts_log_fine "\ncase ba  - Issue: 1761)"
      set job_arguments "-l h=$host_a,test2=1 -o /dev/null -e /dev/null"
      consumable_resources_submit_jobs_and_alter $job_arguments "test2" "test3" "f"  

      # case c)
      #           5 jobs run, 1 have to wait
      ts_log_fine "\ncase c)"
      set test2_complex(test2) "t2 INT <= YES YES 1 1000"
      set_complex test2_complex
      
      set job_arguments "-l h=$host_a -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "c" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" "fill_up"
   
      # case d)
      #           6 jobs run, 0 have to wait
      ts_log_fine "\ncase d)"
      set job_arguments "-l h=$host_a,test2=0 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "d" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" "fill_up"

      # case e)
      #        2 jobs run, 4 have to wait
      
      set RUNATHOST [translate_macro MSG_SCHEDD_INFO_QUEUEOVERLOADED_SS "*" "*"]

      ts_log_fine "\ncase e)"
      set job_arguments "-o /dev/null -e /dev/null"
      set queue_settings(load_thresholds) "test2=3"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_count 6
      set run_job_count 2

      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "e" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "e" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "e" "fill_up"

      #clean up
      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set test2_complex(test2) ""
      set_complex test2_complex
      ts_log_fine "done"
   }

   if {$CHECK_ACT_LEVEL == 2} {
      set RUNINQUEUE [translate_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS "*" "*" "*test3=0*"]
  
      # case a)
      #           all jobs will run
      ts_log_fine "\ncase a)"

      # create complex
      set test3_complex(test3) "t3 INT <= YES YES 0 1000"
      set_complex test3_complex

      set queue_settings(complex_values) "test3=5"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      check_qhost_broken "test3=1" 0

      # case a
      ts_log_fine "\ncase a)"
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 11
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "fill_up"

      # case b
      set WRONGGLOBAL [translate_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS "*" "*"]
      ts_log_fine "\ncase b)"
      ts_log_fine $WRONGGLOBAL
      set job_arguments "-l test3=1 -o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $RUNINQUEUE "" $WRONGGLOBAL
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "fill_up"

      # case c
      ts_log_fine "\ncase c)"
      set test3_complex(test3) "t3 INT <= YES YES 1 1000"
      set_complex test3_complex

      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "c" $RUNINQUEUE
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "c" "fill_up"

      set RUNINQUEUE [translate_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS "*" "*" "*test3=2*"]
      #case d
      ts_log_fine "\ncase d)"
      set job_arguments "-l test3=3 -o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "d" $RUNINQUEUE
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "d" "fill_up"

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # remove test3 complex 
      set test3_complex(test3) ""
      set_complex test3_complex

      ts_log_fine "done"
   }

   if {$CHECK_ACT_LEVEL == 3} {
      set RUNINQUEUE [translate_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS "*" "*" "*test1=0*"]
      set RUNATHOST  [translate_macro MSG_SCHEDD_INFO_CANNOTRUNATHOST_SSS  "*" "*" "*test1=0*"]
      set GLOBALLY [translate_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS "*" "*test1=0*"]

      # create complex
      set test1_complex(test1) "t2 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=3"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=1"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      check_qhost_broken "test1=1" "[llength $ts_config(execd_nodes)]"


      #case a
      ts_log_fine "\ncase a)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 3
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "a" $RUNINQUEUE
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "a" "fill_up"

      #case aa
      ts_log_fine "\ncase aa)"
      set queue_settings(complex_values) "test1=4"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1,h=$host_a  -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 3
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "aa" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "aa" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "aa" "fill_up"

      #case ab
      ts_log_fine "\ncase ab)"
      set queue_settings(complex_values) "test1=4"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1  -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "ab" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count  "ab" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count  "ab" "fill_up"

      #case b
      ts_log_fine "\ncase b)"
      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_count 4
      set run_job_count 3
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" "b" $RUNATHOST
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments $job_count $run_job_count "b" "fill_up"

      #case c
      ts_log_fine "\ncase c)"
      set job_arguments1 "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_arguments2 "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "c" $GLOBALLY
      consumable_resources_submit_pejobs_and_wait $job_arguments2 $job_count $run_job_count "c" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments2 $job_count $run_job_count "c" "fill_up"

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings
      
      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      ts_log_fine "done"
   }
   
   if {$CHECK_ACT_LEVEL == 4} {
      set FORCED [translate_macro MSG_SCHEDD_INFO_NOTREQFORCEDRES_SS "test1" "*"]

      # create complex
      set test1_complex(test1) "t1 INT <= FORCED YES 0 1000"
      set_complex test1_complex
  
      set queue_settings(complex_values) "test1=1"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # case a
      ts_log_fine "\ncase a)"
      set job_arguments1 "-o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 0
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "a" $FORCED
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "a" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "a" "fill_up"


      # case b
      ts_log_fine "\ncase b)"
      set job_arguments1 "-l test1=1 -o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 1
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "b"
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "b" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "b" "fill_up"

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      ts_log_fine "done"
   }
    

   if {$CHECK_ACT_LEVEL == 5} {
      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
      # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=4"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=3"
      set queue_settings(load_thresholds) "np_load_avg=11.75,test1=2"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # case a
      ts_log_fine "\ncase a)"
      set job_arguments1 "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 1
      set queue_check {}
      lappend queue_check "res.q@$host_a"
      lappend queue_check "a"

      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "" "a" $queue_check
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "a" "round_robin"
      consumable_resources_submit_pejobs_and_wait $job_arguments1 $job_count $run_job_count "a" "fill_up"

      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      ts_log_fine "done"
   }

   if {$CHECK_ACT_LEVEL == 6} {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=4"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=3"
      set queue_settings(load_thresholds) "np_load_avg=11.75,test1=2"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set qstat_F_1 [start_sge_bin "qstat" "-F | grep test"]
      set job_id [submit_job "-l test1=1,h=$host_a -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
      wait_for_jobstart $job_id "leeper" 60

      set qstat_F_2 [start_sge_bin "qstat" "-F | grep test"]

      ts_log_fine "setting hold state of job $job_id"
      hold_job $job_id

      ts_log_fine "reschedule job $job_id"
      set catch_result [start_sge_bin "qmod" "-f -r $job_id"]

      ts_log_fine $catch_result

      wait_for_jobpending $job_id "leeper" 60
      set state [get_queue_state "res.q@$host_a"]
      ts_log_fine "queue state of queue \"res.q@$host_a\": \"$state\""
      if {$state != ""} {
         ts_log_severe "queue did not free alarm state"
      }
      
      set qstat_F_3 [start_sge_bin "qstat" "-F | grep test"]

      ts_log_fine "qstat1 (before job was started)   :\n$qstat_F_1"
      ts_log_fine "qstat2 (when job is running)      :\n$qstat_F_2"
      ts_log_fine "qstat3 (after job was rescheduled):\n$qstat_F_3"

      if {[string compare $qstat_F_1 $qstat_F_3] != 0} {
         ts_log_fine "resource wasn't freed"
         ts_log_severe "resources of rescheduled job wasn't freed"
      }

      delete_all_jobs  
      wait_for_end_of_all_jobs

      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      ts_log_fine "done"
   }
   
   if {$CHECK_ACT_LEVEL == 7} {
      # this is our test host
      set host_a [lindex $consumable_resources_test_hosts 0]

      # reduce the load report time to stabilize and speedup the test
      # prepare cleanup - get original global host coniguration
      get_exechost orig_global_host global
      if {![info exists execd_config_a_host(load_report_time)]} {
         set execd_config_a_host(load_report_time) ""
      }
      if {![info exists execd_config_a_host(load_sensor)]} {
         set execd_config_a_host(load_sensor) ""
      }
      # set load report time
      set new_config_a_host(load_report_time) "00:00:05"
      set_config new_config_a_host $host_a

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # modify complex_values of global host
      set global_host(complex_values) "test1=15"
      set_exechost global_host global

      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=10"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=5"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh
      after 10000 ;# wait at least 10 sec. so that execd knows that the file has changed via stat() command

      set output [start_remote_prog $host_a $CHECK_USER "ln" "-s $ts_config(testsuite_root_dir)/scripts/resource_test1_6_loadsensor.sh $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh"]
      ts_log_fine "created link output: $output"
      wait_for_remote_file $host_a $CHECK_USER "$ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh"

      # now set the load sensor
      set load_sensor_script_path "$ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh"
      if {[info exists execd_config_a_host(load_sensor)]} {
         set new_config_a_host(load_sensor) "$execd_config_a_host(load_sensor),$load_sensor_script_path"
      } else {
         set new_config_a_host(load_sensor) "$load_sensor_script_path"
      }
      set_config new_config_a_host $host_a

      # check for reported load value
      set retries 30
      set ok 0
      while {$retries > 0} {
         set test_grep [start_sge_bin "qstat" "-l h=$host_a -F | grep test1"]
         ts_log_fine "waiting for hc:test1=6 load value (retry count: $retries) ..."
         ts_log_fine $test_grep
         if {[string match "*hc:test1=6*" $test_grep]} {
            ts_log_fine "resource test1 is set to value 6 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if {$ok != 1} {
         ts_log_severe "can't find load value hc:test1=6 by qstat -F on host $host_a"
      }

      set test_grep [start_sge_bin "qconf" "-se $host_a | grep test1"]
      if {[string match "*test1=6*" $test_grep] == 0} {
         ts_log_severe "qconf -se doesn't show test1=6 load value"
      }

      delete_remote_file $host_a $CHECK_USER "$ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh"

      # make sure the new loadsensor has a different timestamp than the old one
      # otherwise execd won't recognize it as a new load sensor
      set output [start_remote_prog $host_a $CHECK_USER "touch" "$ts_config(testsuite_root_dir)/scripts/resource_test1_3_loadsensor.sh"]
      ts_log_fine "touch output: $output"
      set output [start_remote_prog $host_a $CHECK_USER "ln" "-s $ts_config(testsuite_root_dir)/scripts/resource_test1_3_loadsensor.sh $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh"]
      ts_log_fine "created link output: $output"
      wait_for_remote_file $host_a $CHECK_USER "$ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh"
      
      # check for reported load value
      set retries 30
      set ok 0
      while {$retries > 0} {
         set test_grep [start_sge_bin "qstat" "-l h=$host_a -F | grep test1"]
         ts_log_fine "waiting for hc:test1=3 load value (retry count: $retries) ..."
         ts_log_fine $test_grep
         if {[string match "*hc:test1=3*" $test_grep]} {
            ts_log_fine "resource test1 is set to value 3 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if {$ok != 1} {
         ts_log_severe "can't find load value hc:test1=3 by qstat -F on host $host_a"
      }

      set test_grep [start_sge_bin "qconf" "-se $host_a | grep test1"]
      if {[string match "*test1=3*" $test_grep] == 0} {
         ts_log_severe "qconf -se doesn't show test1=3 load value"
      }

      # restore execd config
      set_config execd_config_a_host $host_a

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global

      set test_grep "test1" 
      set retries 45
      set ok 0
      while {$retries > 0} {
         set test_grep [start_sge_bin "qconf" "-se $host_a | grep test1"]
         ts_log_fine "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         ts_log_fine "grep output: $test_grep"
         if {[string match "*test1*" $test_grep] == 0} {
            ts_log_fine "resource test1 disappeared!"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if {$ok != 1} {
         ts_log_severe "load sensor report test1 does not disappear"
      }
      
      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link.sh
      ts_log_fine "done"
   }
   
   if {$CHECK_ACT_LEVEL == 8} {
      # this is our test host
      set host_a [lindex $consumable_resources_test_hosts 0]

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set test1_complex(test2) "t2 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=15,test2=15"
      set_exechost global_host global

      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=10,test2=10"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=5,test2=5"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      # setup load script
      get_config execd_config_a_host $host_a
            
      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link6.sh
      after 10000 ;# wait at least 10 sec. so that execd knows that the file has changed via stat() command
      set output [start_remote_prog $host_a $CHECK_USER "ln" "-s $ts_config(testsuite_root_dir)/scripts/resource_test1_6_loadsensor.sh $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link6.sh"]
      ts_log_fine "ln -s output: $output"
      wait_for_remote_file  $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link6.sh

      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link3.sh
      after 10000 ;# wait at least 10 sec. so that execd knows that the file has changed via stat() command
      set output [start_remote_prog $host_a $CHECK_USER "ln" "-s $ts_config(testsuite_root_dir)/scripts/resource_test2_3_loadsensor.sh $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link3.sh"]
      ts_log_fine "ln -s output: $output"
      wait_for_remote_file  $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link3.sh

      set load_sensor_script_path "$ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link6.sh,$ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link3.sh"
      if {[info exists execd_config_a_host(load_sensor)]} {
         set new_config_a_host(load_sensor) "$execd_config_a_host(load_sensor),$load_sensor_script_path"
      } else {
         set new_config_a_host(load_sensor) "$load_sensor_script_path"
         set execd_config_a_host(load_sensor) ""
      }
      if {[info exists execd_config_a_host(load_report_time)] == 0} {
         set execd_config_a_host(load_report_time) ""
      }

      set new_config_a_host(load_report_time) "00:00:05"
      set_config new_config_a_host $host_a

      # check for reported load value
      set retries 30
      set ok 0
      while {$retries > 0} {
         set test_grep [start_sge_bin "qstat" "-l h=$host_a -F | grep test1"]
         ts_log_fine "waiting for hc:test1=6 load value (retry count: $retries) ..."
         ts_log_fine $test_grep
         if {[string match "*hc:test1=6*" $test_grep]} {
            ts_log_fine "resource test1 is set to value 6 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }
      if {$ok != 1} {
         ts_log_severe "can't find load value hc:test1=6 by qstat -F on host $host_a"
      }

      set test_grep [start_sge_bin "qconf" "-se $host_a | grep test1"]
      if {[string match "*test1=6*" $test_grep] == 0} {
         ts_log_severe "qconf -se doesn't show test1=6 load value"
      }

      # check for reported load value
      set retries 30
      set ok 0
      while {$retries > 0} {
         set test_grep [start_sge_bin "qstat" "-l h=$host_a -F | grep test2"]
         ts_log_fine "waiting for hc:test2=3 load value (retry count: $retries) ..."
         ts_log_fine $test_grep
         if {[string match "*hc:test2=3*" $test_grep]} {
            ts_log_fine "resource test2 is set to value 3 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }
      if {$ok != 1} {
         ts_log_severe "can't find load value hc:test2=3 by qstat -F on host $host_a"
      }

      set test_grep [start_sge_bin "qconf" "-se $host_a | grep test2"]
      if {[string match "*test2=3*" $test_grep] == 0} {
         ts_log_severe "qconf -se doesn't show test2=3 load value"
      }

      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link6.sh
      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link3.sh

      # restore execd config
      set_config execd_config_a_host $host_a

      set queue_settings(complex_values) "NONE"
      set_queue "res.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global

      set test_grep "test1" 
      set retries 45
      while {[string match "*test1*" $test_grep] && $retries > 0} {
         set test_grep [start_sge_bin "qconf" "-se $host_a | grep test1"]
         ts_log_fine "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         ts_log_fine "$test_grep"
         incr retries -1
         after 5000
      }

      if {[string match "*test1*" $test_grep]} {
         ts_log_severe "load sensor report test1 does not disappear"
      }

      set test_grep "test2" 
      set retries 45
      while {[string match "*test2*" $test_grep] && $retries > 0} {
         set test_grep [start_sge_bin "qconf" "-se $host_a | grep test2"]
         ts_log_fine "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         ts_log_fine "$test_grep"
         incr retries -1
         after 5000
      }

      if {[string match "*test2*" $test_grep]} {
         ts_log_severe "load sensor report test2 does not disappear"
      }
      
      # remove test1 and test2 complex 
      set test1_complex(test1) ""
      set test1_complex(test2) ""
      set_complex test1_complex

      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link6.sh
      delete_remote_file $host_a $CHECK_USER $ts_config(testsuite_root_dir)/scripts/resource_loadsensor_link3.sh

      ts_log_fine "done"
   }
}


