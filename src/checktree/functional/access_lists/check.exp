#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "access_lists_init_level"

# define test's name and run level descriptions
set check_name            "access_lists"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   0
set check_description(0)  "Test (x)user_lists access for queue/cluster/pe"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "access_lists_setup"
set check_cleanup_function "access_lists_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "access_lists_global_host"
lappend check_functions "access_lists_exec_host"
lappend check_functions "access_lists_queue"
lappend check_functions "access_lists_cluster_config"
lappend check_functions "access_lists_pe"

proc access_lists_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

global access_lists_queue
global access_lists_host

proc access_lists_setup  {} {
   global ts_config
   global CHECK_GROUP
   global access_lists_queue
   global access_lists_host

   global access_lists_schedd_conf

   global CHECK_OUTPUT CHECK_CORE_MASTER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_PRODUCT_ROOT

   # setup an own queue - we'll change a lot of config params - better not touch all.q
   set access_lists_queue "access"
   set queue_values(load_thresholds)       "np_load_avg=11.00"
   set queue_values(qtype)                 "BATCH INTERACTIVE CHECKPOINTING PARALLEL"
   add_queue $access_lists_queue "@allhosts" queue_values
   # ... and disable all.q
   foreach host $ts_config(execd_nodes) {
      disable_queue [get_queue_instance "all.q" $host]
   }

   # we'll use this execd as test host
   set access_lists_host  [lindex $ts_config(execd_nodes) 0]

   puts $CHECK_OUTPUT "using queue $access_lists_queue"
   puts $CHECK_OUTPUT "using host $access_lists_host"

   #saving original configurations
   get_schedd_config                      access_lists_schedd_conf

   set my_schedd_config(schedule_interval)       "0:0:01"
   if { [ string compare $ts_config(product_type) sgeee] == 0 } {
      if { $ts_config(gridengine_version) == 53 } {
         set my_schedd_config(sgeee_schedule_interval) "0:0:02"
      }
   }
  
   set_schedd_config my_schedd_config

   set group1 [lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0]
   add_access_list "@${group1}"  userA_group
   add_access_list "@${CHECK_SECOND_FOREIGN_SYSTEM_GROUP}" userB_group
   add_access_list "$CHECK_FIRST_FOREIGN_SYSTEM_USER"   userA_name
   add_access_list "$CHECK_SECOND_FOREIGN_SYSTEM_USER"  userB_name

 

   if { [is_scheduler_alive $CHECK_CORE_MASTER [get_qmaster_spool_dir]] != 1 } {
      add_proc_error "access_lists_setup" -1 "scheduler is not alive"
   }

   set jobargs "-o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15"  
   set id [ submit_job $jobargs ]
   wait_for_jobstart $id "leeper" 60 1 1
   wait_for_jobend $id "leeper" 60

   if { [string first "unknown" $CHECK_GROUP] >= 0 } {
      add_proc_error "access_lists_setup" -1 "CHECK_GROUP set to unknown"
   }

   set_error 0 "ok"
}

proc test_job_run { id_string job_id } {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_ARCH

   set had_error 0

   # we need to see the job either pending or already running
   if { [wait_for_jobpending $job_id "leeper" 30 1] != 0 } {
      set had_error 1
   }

   # wait until the job is running, do a qconf -tsm before
   if { [wait_for_jobstart $job_id "leeper" 120 1 1] != 0 } {
      set had_error 1
   }

   if {  $had_error == 1 } {
      catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat" "-f" } catch_result
      puts $CHECK_OUTPUT $catch_result
      add_proc_error "test_job_run" -1 "$id_string, job $job_id should be dispatched:\n$catch_result"
   } 

   delete_job $job_id 1 1
}

proc run_user_denied_jobs { id_string jobargs A_ok B_ok { C_ok "-1" } } {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT access_lists_host CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global access_lists_queue

   puts $CHECK_OUTPUT "======================="
   puts $CHECK_OUTPUT "id_string is $id_string"
   puts $CHECK_OUTPUT "jobargs are: $jobargs"
   puts $CHECK_OUTPUT "======================="


   sleep 2
   set job_id_A [ submit_job $jobargs 0 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER  ]
   if { $A_ok == 1 } {
      test_job_run "$id_string (A)" $job_id_A
   }
   set job_id_B [ submit_job $jobargs 0 30 "" $CHECK_SECOND_FOREIGN_SYSTEM_USER ]
   if { $B_ok == 1 } {
      test_job_run "$id_string (B)" $job_id_B
   }

   if { $C_ok != -1 } {
      set job_id_C [ submit_job $jobargs 0 30 "" $CHECK_USER ]
      if { $C_ok == 1 } {
         test_job_run "$id_string (C)" $job_id_C
      } else {
         if { $job_id_C != -11 } {
            add_proc_error "run_user_denied_jobs" "-1" "$id_string, job $job_id_C (C) should not run"
         } 
      }
   }

   if { $A_ok == 0 } {
      if { $job_id_A != -11 } {
         add_proc_error "run_user_denied_jobs" "-1" "$id_string, job $job_id_A (A) should not run"
      }
   }
 
   if { $B_ok == 0 } {
      if { $job_id_B != -11 } {
         add_proc_error "run_user_denied_jobs" "-1" "$id_string, job $job_id_B (B) should not run"
      }
   }
}

proc check_user_job_info { job_id } {
   global CHECK_OUTPUT CHECK_HOST CHECK_L10N

   set had_error 0

   # was the submit successfull?
   if { [wait_for_jobpending $job_id "leeper" 30 1] != 0 } {
      add_proc_error "check_user_job_info" "-1" "no pending job $job_id"
      set had_error 1
   }

   # the job shall not start - do a qconf -tsm and wait 10 secs
   if { [wait_for_jobstart $job_id "leeper" 10 0 1] == 0 } {
      add_proc_error "check_user_job_info" "-1" "job $job_id shouldn't have started"
      set had_error 1
   }

   if {  $had_error == 0 } {
      # if job is pending as expected, analyze scheduling info
      set scheduling_info_text [get_scheduling_info $job_id]

      if { $CHECK_L10N == 1 } {
         set  HASNOPERMISSION [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_HASNOPERMISSION_SS] "*" "*" ]
         set  NOACCESSTOPE1   [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_NOACCESSTOPE] ]
         set  NOACCESSTOPE2   [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_NOACCESSTOPE_S] "*" ]


         set match1 [string match "*$HASNOPERMISSION*" $scheduling_info_text ]
         set match2 [string match "*$NOACCESSTOPE1*"   $scheduling_info_text ]
         set match3 [string match "*$NOACCESSTOPE2*"   $scheduling_info_text ]

         puts $CHECK_OUTPUT $match1
         puts $CHECK_OUTPUT $match2
         puts $CHECK_OUTPUT $match2

         if { $match1 != 1 && $match2 != 1 && $match3 != 1 } {
            set had_error 1
         }
     } else {
        if { [string first "no permission" $scheduling_info_text ] < 0 && [string first "no access" $scheduling_info_text ] < 0 } {
           set had_error 1
        }
     }
  }

  return $had_error
}

proc run_user_jobs { id_string jobargs A_ok B_ok { C_ok "-1" } } {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT access_lists_host CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global access_lists_queue

   puts $CHECK_OUTPUT "id_string is $id_string"
   puts $CHECK_OUTPUT "jobargs are: $jobargs"
   sleep 2
   set job_id_A [ submit_job $jobargs 1 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER  ]
   if { $A_ok == 1 } {
      test_job_run "$id_string (A)" $job_id_A
   }

   set job_id_B [ submit_job $jobargs 1 30 "" $CHECK_SECOND_FOREIGN_SYSTEM_USER ]
   if { $B_ok == 1 } {
      test_job_run "$id_string (B)" $job_id_B
   }

   if { $C_ok != -1 } {
      set job_id_C [ submit_job $jobargs 1 30 "" $CHECK_USER ]
      if { $C_ok == 1 } {
         test_job_run "$id_string (C)" $job_id_C
      } else {
         if { [check_user_job_info $job_id_C] == 1 } {
            add_proc_error "run_user_jobs" "-1" "$id_string, job $job_id_C (C) should not run"
         }
         wait_for_jobpending $job_id_C "leeper" 30
         delete_job $job_id_C 1 1
      }
   }

   if { $A_ok == 0 } {
      if { [check_user_job_info $job_id_A] == 1 } {
         add_proc_error "run_user_jobs" "-1" "$id_string, job $job_id_A (A) should not run"
      }
      wait_for_jobpending $job_id_A "leeper" 30
      delete_job $job_id_A 1 1
   }
 
   if { $B_ok == 0 } {
      if { [check_user_job_info $job_id_B] == 1 } {
         add_proc_error "run_user_jobs" "-1" "$id_string, job $job_id_B (B) should not run"
      }
      wait_for_jobpending $job_id_B "leeper" 30
      delete_job $job_id_B 1 1
   }

   # wait until jobs are really gone - it might still reference objects, like
   # parallel environments etc.
   set job_ids "$job_id_A $job_id_B"
   if {[info exists job_id_C]} {
      lappend job_ids $job_id_C
   }
   foreach job_id $job_ids {
      while { [get_qstat_j_info $job_id ] != 0 } {
         puts $CHECK_OUTPUT "waiting for job $job_id to leave qmaster"
         after 2000
      }
   }
}

proc access_lists_global_host {} {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT access_lists_host CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_GROUP 
   global access_lists_queue access_lists_host

   set submit_queue [get_queue_instance $access_lists_queue $access_lists_host]
   set jobargs "-o /dev/null -e /dev/null -q $submit_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" 


   # testing user and group
   set access_lists "{userA_name userB_name 0} {userA_group userB_group 1}"
   foreach elem $access_lists {
      set A_USER [lindex $elem 0]
      set B_USER [lindex $elem 1]
      set group_test [lindex $elem 2]
      puts $CHECK_OUTPUT "A_USER = $A_USER"
      puts $CHECK_OUTPUT "B_USER = $B_USER"

      # case 1
      set my_global_host(xuser_lists) "$A_USER"
      set my_global_host(user_lists)  "NONE"
      set_exechost my_global_host "global"
      run_user_jobs "case 1,$A_USER,$B_USER" "$jobargs" 0 1        ;# A = 0 (not running) B = 1 (should run)
   
      # case 2
      set my_global_host(xuser_lists) "NONE"
      set my_global_host(user_lists)  "$A_USER"
      set_exechost my_global_host "global"
      run_user_jobs "case 2,$A_USER,$B_USER" "$jobargs" 1 0
   
      # case 3
      set my_global_host(xuser_lists) "$B_USER"
      set my_global_host(user_lists)  "$A_USER"
      set_exechost my_global_host "global"
      run_user_jobs "case 3,$A_USER,$B_USER" "$jobargs" 1 0 
   
      #case 4
      set my_global_host(xuser_lists) "$A_USER"
      set my_global_host(user_lists)  "$B_USER"
      set_exechost my_global_host "global"
      run_user_jobs "case 4,$A_USER,$B_USER" "$jobargs" 0 1
   
      #case 5
      set my_global_host(xuser_lists) "NONE"
      set my_global_host(user_lists)  "NONE"
      set_exechost my_global_host "global"
      run_user_jobs "case 5,$A_USER,$B_USER" "$jobargs" 1 1
   
      #case 6
      set my_global_host(xuser_lists) "$A_USER $B_USER"
      set my_global_host(user_lists)  "NONE"
      set_exechost my_global_host "global"
      if { $group_test == 1 } {
         puts $CHECK_OUTPUT "group_test=1"
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         puts $CHECK_OUTPUT "check_group = $CHECK_GROUP"
         puts $CHECK_OUTPUT "group1 = $group1"
         puts $CHECK_OUTPUT "group2 = $CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 0
         } else {
            set C_run 1
         }
      } else {
         set C_run 1
      }
      puts $CHECK_OUTPUT "run matrix: 0 0 $C_run"
      run_user_jobs "case 6,$A_USER,$B_USER" "$jobargs" 0 0 $C_run
   
      #case 7
      set my_global_host(xuser_lists) "NONE"
      set my_global_host(user_lists)  "$A_USER $B_USER"
      set_exechost my_global_host "global"
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 1
         } else {
            set C_run 0
         }
      } else {
         set C_run 0
      }
      run_user_jobs "case 7,$A_USER,$B_USER" "$jobargs" 1 1 $C_run

      #restore
      set my_global_host(xuser_lists) "NONE"
      set my_global_host(user_lists)  "NONE"
      set_exechost my_global_host "global"
   }


   # test group/user combinations
   # userA_name userB_name userA_group userB_group
   set my_global_host(xuser_lists) "userA_group"
   set my_global_host(user_lists)  "userA_name"
   set_exechost my_global_host "global"
   run_user_jobs "group/user case 1" "$jobargs" 0 0

   set my_global_host(xuser_lists) "NONE"
   set my_global_host(user_lists)  "userA_name userA_group"
   set_exechost my_global_host "global"
   run_user_jobs "group/user case 2" "$jobargs" 1 0

   set my_global_host(xuser_lists) "userA_name userA_group"
   set my_global_host(user_lists)  "NONE"
   set_exechost my_global_host "global"
   run_user_jobs "group/user case 3" "$jobargs" 0 1

   set my_global_host(xuser_lists) "userA_name"
   set my_global_host(user_lists)  "userA_group"
   set_exechost my_global_host "global"
   run_user_jobs "group/user case 4" "$jobargs" 0 0

   #restore
   set my_global_host(xuser_lists) "NONE"
   set my_global_host(user_lists)  "NONE"
   set_exechost my_global_host "global"


   set_error 0 "ok"
}

proc access_lists_exec_host {} {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT access_lists_host CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_GROUP access_lists_queue access_lists_host

   set submit_queue [get_queue_instance $access_lists_queue $access_lists_host]
   set jobargs "-o /dev/null -e /dev/null -q $submit_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"


   # testing user and group
   set access_lists "{userA_name userB_name 0} {userA_group userB_group 1}"
   foreach elem $access_lists {
      set A_USER [lindex $elem 0]
      set B_USER [lindex $elem 1]
      set group_test [lindex $elem 2]
      puts $CHECK_OUTPUT "A_USER = $A_USER"
      puts $CHECK_OUTPUT "B_USER = $B_USER"

      # case 1
      set my_exec_host(xuser_lists) "$A_USER"
      set my_exec_host(user_lists)  "NONE"
      set_exechost my_exec_host $access_lists_host
      run_user_jobs "case 1,$A_USER,$B_USER" $jobargs 0 1       ;# A = 0 (not running) B = 1 (should run)
   
      # case 2
      set my_exec_host(xuser_lists) "NONE"
      set my_exec_host(user_lists)  "$A_USER"
      set_exechost my_exec_host $access_lists_host
      run_user_jobs "case 2,$A_USER,$B_USER" $jobargs 1 0
   
      # case 3
      set my_exec_host(xuser_lists) "$B_USER"
      set my_exec_host(user_lists)  "$A_USER"
      set_exechost my_exec_host $access_lists_host
      run_user_jobs "case 3,$A_USER,$B_USER" $jobargs 1 0 
   
      #case 4
      set my_exec_host(xuser_lists) "$A_USER"
      set my_exec_host(user_lists)  "$B_USER"
      set_exechost my_exec_host $access_lists_host
      run_user_jobs "case 4,$A_USER,$B_USER" $jobargs 0 1
   
      #case 5
      set my_exec_host(xuser_lists) "NONE"
      set my_exec_host(user_lists)  "NONE"
      set_exechost my_exec_host $access_lists_host
      run_user_jobs "case 5,$A_USER,$B_USER" $jobargs 1 1
   
      #case 6
      set my_exec_host(xuser_lists) "$A_USER $B_USER"
      set my_exec_host(user_lists)  "NONE"
      set_exechost my_exec_host $access_lists_host
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 0
         } else {
            set C_run 1
         }
      } else {
         set C_run 1
      }
      run_user_jobs "case 6,$A_USER,$B_USER" $jobargs 0 0 $C_run
   
      #case 7
      set my_exec_host(xuser_lists) "NONE"
      set my_exec_host(user_lists)  "$A_USER $B_USER"
      set_exechost my_exec_host $access_lists_host
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 1
         } else {
            set C_run 0
         }
      } else {
         set C_run 0
      }
      run_user_jobs "case 7,$A_USER,$B_USER" $jobargs 1 1 $C_run
  
      #restore
      set my_exec_host(xuser_lists) "NONE"
      set my_exec_host(user_lists)  "NONE"
      set_exechost my_exec_host $access_lists_host
   }


   # test group/user combinations
   # userA_name userB_name userA_group userB_group


   set my_exec_host(xuser_lists) "userA_group"
   set my_exec_host(user_lists)  "userA_name"
   set_exechost my_exec_host $access_lists_host
   run_user_jobs "group/user case 1" $jobargs 0 0

   set my_exec_host(xuser_lists) "NONE"
   set my_exec_host(user_lists)  "userA_name userA_group"
   set_exechost my_exec_host $access_lists_host
   run_user_jobs "group/user case 2" $jobargs 1 0

   set my_exec_host(xuser_lists) "userA_name userA_group"
   set my_exec_host(user_lists)  "NONE"
   set_exechost my_exec_host $access_lists_host
   run_user_jobs "group/user case 3" $jobargs 0 1

   set my_exec_host(xuser_lists) "userA_name"
   set my_exec_host(user_lists)  "userA_group"
   set_exechost my_exec_host $access_lists_host
   run_user_jobs "group/user case 4" $jobargs 0 0

   #restore
   set my_exec_host(xuser_lists) "NONE"
   set my_exec_host(user_lists)  "NONE"
   set_exechost my_exec_host $access_lists_host


   set_error 0 "ok"
}

proc access_lists_queue {} {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_GROUP
   global access_lists_queue access_lists_host

   set submit_queue [get_queue_instance $access_lists_queue $access_lists_host]
   set jobargs "-o /dev/null -e /dev/null -q $submit_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

   # testing user and group
   set access_lists "{userA_name userB_name 0} {userA_group userB_group 1}"
   foreach elem $access_lists {
      set A_USER [lindex $elem 0]
      set B_USER [lindex $elem 1]
      set group_test [lindex $elem 2]
      puts $CHECK_OUTPUT "A_USER = $A_USER"
      puts $CHECK_OUTPUT "B_USER = $B_USER"

      # case 1
      set my_queue_conf(xuser_lists) "$A_USER"
      set my_queue_conf(user_lists)  "NONE"
      mod_queue $access_lists_queue $access_lists_host my_queue_conf
      run_user_jobs "case 1,$A_USER,$B_USER" $jobargs 0 1       ;# A = 0 (not running) B = 1 (should run)
   
      # case 2
      set my_queue_conf(xuser_lists) "NONE"
      set my_queue_conf(user_lists)  "$A_USER"
      mod_queue $access_lists_queue $access_lists_host my_queue_conf
      run_user_jobs "case 2,$A_USER,$B_USER" $jobargs 1 0
   
      # case 3
      set my_queue_conf(xuser_lists) "$B_USER"
      set my_queue_conf(user_lists)  "$A_USER"
      mod_queue $access_lists_queue $access_lists_host my_queue_conf
      run_user_jobs "case 3,$A_USER,$B_USER" $jobargs 1 0 
   
      #case 4
      set my_queue_conf(xuser_lists) "$A_USER"
      set my_queue_conf(user_lists)  "$B_USER"
      mod_queue  $access_lists_queue $access_lists_host my_queue_conf
      run_user_jobs "case 4,$A_USER,$B_USER" $jobargs 0 1
   
      #case 5
      set my_queue_conf(xuser_lists) "NONE"
      set my_queue_conf(user_lists)  "NONE"
      mod_queue  $access_lists_queue $access_lists_host my_queue_conf
      run_user_jobs "case 5,$A_USER,$B_USER" $jobargs 1 1
   
      #case 6
      set my_queue_conf(xuser_lists) "$A_USER $B_USER"
      set my_queue_conf(user_lists)  "NONE"
      mod_queue  $access_lists_queue $access_lists_host my_queue_conf
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 0
         } else {
            set C_run 1
         }
      } else {
         set C_run 1
      }
      run_user_jobs "case 6,$A_USER,$B_USER" $jobargs 0 0 $C_run
   
      #case 7
      set my_queue_conf(xuser_lists) "NONE"
      set my_queue_conf(user_lists)  "$A_USER $B_USER"
      mod_queue  $access_lists_queue $access_lists_host my_queue_conf
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 1
         } else {
            set C_run 0
         }
      } else {
         set C_run 0
      }
      run_user_jobs "case 7,$A_USER,$B_USER" $jobargs 1 1 $C_run
  
      #restore
      set my_queue_conf(xuser_lists) "NONE"
      set my_queue_conf(user_lists)  "NONE"
      mod_queue  $access_lists_queue $access_lists_host my_queue_conf
   }


   # test group/user combinations
   # userA_name userB_name userA_group userB_group

   set my_queue_conf(xuser_lists) "userA_group"
   set my_queue_conf(user_lists)  "userA_name"
   mod_queue  $access_lists_queue $access_lists_host my_queue_conf
   run_user_jobs "group/user case 1" $jobargs 0 0

   set my_queue_conf(xuser_lists) "NONE"
   set my_queue_conf(user_lists)  "userA_name userA_group"
   mod_queue  $access_lists_queue $access_lists_host my_queue_conf
   run_user_jobs "group/user case 2" $jobargs 1 0

   set my_queue_conf(xuser_lists) "userA_name userA_group"
   set my_queue_conf(user_lists)  "NONE"
   mod_queue  $access_lists_queue $access_lists_host my_queue_conf
   run_user_jobs "group/user case 3" $jobargs 0 1

   set my_queue_conf(xuser_lists) "userA_name"
   set my_queue_conf(user_lists)  "userA_group"
   mod_queue  $access_lists_queue $access_lists_host my_queue_conf
   run_user_jobs "group/user case 4" $jobargs 0 0

   #restore
   set my_queue_conf(xuser_lists) "NONE"
   set my_queue_conf(user_lists)  "NONE"
   mod_queue  $access_lists_queue $access_lists_host my_queue_conf

   set_error 0 "ok"
}

proc access_lists_cluster_config {} {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT access_lists_queue CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_GROUP access_lists_queue access_lists_host
  
   set submit_queue [get_queue_instance $access_lists_queue $access_lists_host]
   set jobargs "-o /dev/null -e /dev/null -q $submit_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"  
   
   # testing user and group
   set access_lists "{userA_name userB_name 0} {userA_group userB_group 1}"
   foreach elem $access_lists {
      set A_USER [lindex $elem 0]
      set B_USER [lindex $elem 1]
      set group_test [lindex $elem 2]
      puts $CHECK_OUTPUT "A_USER = $A_USER"
      puts $CHECK_OUTPUT "B_USER = $B_USER"

      # case 1
      set my_cluster_conf(xuser_lists) "$A_USER"
      set my_cluster_conf(user_lists)  "NONE"
      set_config my_cluster_conf "global"
      run_user_denied_jobs "case 1,$A_USER,$B_USER" $jobargs 0 1       ;# A = 0 (not running) B = 1 (should run)
   
      # case 2
      set my_cluster_conf(xuser_lists) "NONE"
      set my_cluster_conf(user_lists)  "$A_USER"
      set_config my_cluster_conf "global"
      run_user_denied_jobs "case 2,$A_USER,$B_USER" $jobargs 1 0
   
      # case 3
      set my_cluster_conf(xuser_lists) "$B_USER"
      set my_cluster_conf(user_lists)  "$A_USER"
      set_config my_cluster_conf "global"
      run_user_denied_jobs "case 3,$A_USER,$B_USER" $jobargs 1 0 
   
      #case 4
      set my_cluster_conf(xuser_lists) "$A_USER"
      set my_cluster_conf(user_lists)  "$B_USER"
      set_config my_cluster_conf "global"
      run_user_denied_jobs "case 4,$A_USER,$B_USER" $jobargs 0 1
   
      #case 5
      set my_cluster_conf(xuser_lists) "NONE"
      set my_cluster_conf(user_lists)  "NONE"
      set_config my_cluster_conf "global"
      run_user_denied_jobs "case 5,$A_USER,$B_USER" $jobargs 1 1
   
      #case 6
      set my_cluster_conf(xuser_lists) "$A_USER $B_USER"
      set my_cluster_conf(user_lists)  "NONE"
      set_config my_cluster_conf "global"
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 0
         } else {
            set C_run 1
         }
      } else {
         set C_run 1
      }
      run_user_denied_jobs "case 6,$A_USER,$B_USER" $jobargs 0 0 $C_run
   
      #case 7
      set my_cluster_conf(xuser_lists) "NONE"
      set my_cluster_conf(user_lists)  "$A_USER $B_USER"
      set_config my_cluster_conf "global"
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 1
         } else {
            set C_run 0
         }
      } else {
         set C_run 0
      }
      run_user_denied_jobs "case 7,$A_USER,$B_USER" $jobargs 1 1 $C_run
  
      #restore
      set my_cluster_conf(xuser_lists) "NONE"
      set my_cluster_conf(user_lists)  "NONE"
      set_config my_cluster_conf "global"
   }

    
   # test group/user combinations
   # userA_name userB_name userA_group userB_group

   set my_cluster_conf(xuser_lists) "userA_group"
   set my_cluster_conf(user_lists)  "userA_name"
   set_config  my_cluster_conf "global"
   run_user_denied_jobs "group/user case 1" $jobargs 0 0

   set my_cluster_conf(xuser_lists) "NONE"
   set my_cluster_conf(user_lists)  "userA_name userA_group"
   set_config my_cluster_conf "global"
   run_user_denied_jobs "group/user case 2" $jobargs 1 0

   set my_cluster_conf(xuser_lists) "userA_name userA_group"
   set my_cluster_conf(user_lists)  "NONE"
   set_config my_cluster_conf "global"
   run_user_denied_jobs "group/user case 3" $jobargs 0 1

   set my_cluster_conf(xuser_lists) "userA_name"
   set my_cluster_conf(user_lists)  "userA_group"
   set_config my_cluster_conf "global"
   run_user_denied_jobs "group/user case 4" $jobargs 0 0


   # restore     
   set my_cluster_conf(xuser_lists) "NONE"
   set my_cluster_conf(user_lists)  "NONE"
   set_config  my_cluster_conf "global"
 
   set_error 0 "ok"

}

proc access_lists_pe {} {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER   
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_GROUP
   global access_lists_queue access_lists_host

   set jobargs "-o /dev/null -e /dev/null -pe access_test_pe 2 $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

   set my_pe(pe_name)     "access_test_pe"
   set my_pe(slots)       "8"
   add_pe my_pe
   assign_queues_with_pe_object "$access_lists_queue" "$access_lists_host" "access_test_pe"

   # testing user and group
   set access_lists "{userA_name userB_name 0} {userA_group userB_group 1}"
   foreach elem $access_lists {
      set A_USER [lindex $elem 0]
      set B_USER [lindex $elem 1]
      set group_test [lindex $elem 2]
      puts $CHECK_OUTPUT "A_USER = $A_USER"
      puts $CHECK_OUTPUT "B_USER = $B_USER"

      # case 1
      unset my_pe
      set my_pe(xuser_lists) "$A_USER"
      set my_pe(user_lists)  "NONE"

      puts $CHECK_OUTPUT "setting up pe ..."
      set_pe "access_test_pe" my_pe
      puts $CHECK_OUTPUT "submitting jobs ..."
      run_user_jobs "case 1,$A_USER,$B_USER" $jobargs 0 1       ;# A = 0 (not running) B = 1 (should run)
 
      # case 2
      unset my_pe
      set my_pe(xuser_lists) "NONE"
      set my_pe(user_lists)  "$A_USER"
      set_pe "access_test_pe" my_pe
      run_user_jobs "case 2,$A_USER,$B_USER" $jobargs 1 0

      # case 3
      unset my_pe
      set my_pe(xuser_lists) "$B_USER"
      set my_pe(user_lists)  "$A_USER"
      set_pe "access_test_pe" my_pe
      run_user_jobs "case 3,$A_USER,$B_USER" $jobargs 1 0 

   
      #case 4
      unset my_pe
      set my_pe(xuser_lists) "$A_USER"
      set my_pe(user_lists)  "$B_USER"
      set_pe "access_test_pe" my_pe
      run_user_jobs "case 4,$A_USER,$B_USER" $jobargs 0 1

   
      #case 5
      unset my_pe
      set my_pe(xuser_lists) "NONE"
      set my_pe(user_lists)  "NONE"
      set_pe "access_test_pe" my_pe
      run_user_jobs "case 5,$A_USER,$B_USER" $jobargs 1 1

   
      #case 6
      unset my_pe
      set my_pe(xuser_lists) "$A_USER $B_USER"
      set my_pe(user_lists)  "NONE"
      set_pe "access_test_pe" my_pe
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 0
         } else {
            set C_run 1
         }
      } else {
         set C_run 1
      }
      run_user_jobs "case 6,$A_USER,$B_USER" $jobargs 0 0 $C_run

   
      #case 7
      unset my_pe
      set my_pe(xuser_lists) "NONE"
      set my_pe(user_lists)  "$A_USER $B_USER"
      set_pe "access_test_pe" my_pe
      if { $group_test == 1 } {
         set group1 [ lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0 ]
         if { [string first $CHECK_GROUP $group1] >= 0 ||
              [string first $CHECK_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] >= 0 } {
            set C_run 1
         } else {
            set C_run 0
         }
      } else {
         set C_run 0
      }
      run_user_jobs "case 7,$A_USER,$B_USER" $jobargs 1 1 $C_run
   }
   
   # test group/user combinations
   # userA_name userB_name userA_group userB_group
   unset my_pe
   set my_pe(xuser_lists) "userA_group"
   set my_pe(user_lists)  "userA_name"
   set_pe "access_test_pe" my_pe
   run_user_jobs "group/user case 1" "$jobargs" 0 0 

   unset my_pe
   set my_pe(xuser_lists) "NONE"
   set my_pe(user_lists)  "userA_name userA_group"
   set_pe "access_test_pe" my_pe
   run_user_jobs "group/user case 2" "$jobargs" 1 0

   unset my_pe
   set my_pe(xuser_lists) "userA_name userA_group"
   set my_pe(user_lists)  "NONE"
   set_pe "access_test_pe" my_pe
   run_user_jobs "group/user case 3" "$jobargs" 0 1

   unset my_pe
   set my_pe(xuser_lists) "userA_name"
   set my_pe(user_lists)  "userA_group"
   set_pe "access_test_pe" my_pe
   run_user_jobs "group/user case 4" "$jobargs" 0 0

   del_pe "access_test_pe"

   set_error 0 "ok"
}


proc access_lists_cleanup  {} {
   global ts_config
   global access_lists_schedd_conf access_lists_queue
   global CHECK_OUTPUT

   delete_all_jobs

   set_schedd_config access_lists_schedd_conf

   del_access_list "userA_group"
   del_access_list "userB_group"
   del_access_list "userA_name"
   del_access_list "userB_name"

   # delete the test queue
   del_queue $access_lists_queue "" 0 1
   
   # enable all.q
   foreach host $ts_config(execd_nodes) {
      enable_queue [get_queue_instance "all.q" $host]
   }

   set_error 0 "ok"
}



