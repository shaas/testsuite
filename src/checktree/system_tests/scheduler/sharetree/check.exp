#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# JG: TODO: Create chart: actual resource share over time based on 
#           output of sge_share_mon

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "share_tree_init_level"

# define test's name and run level descriptions
set check_name            "share_tree"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   100
set check_description(0)  "Testing geee share_tree (functional test)"
set check_description(100)  "Testing geee share_tree"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "share_tree_setup"
set check_cleanup_function "share_tree_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "share_tree_test"
lappend check_functions "issue_751"

global share_tree_job_counter 
global share_tree_percentage_variation
global sharetree_stored_configuration

proc share_tree_init_level {} {
   global CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE
   global share_tree_job_counter
   global share_tree_percentage_variation

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      return -1
   }


  switch -- $CHECK_ACT_LEVEL {
     "0" { 
           set share_tree_job_counter       5 
           set share_tree_percentage_variation  10
           return 0    
     } 
     "100" {
           set share_tree_job_counter       100
           set share_tree_percentage_variation  2
           return 0    
     }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

proc wait_for_job_tickes { job_id } {
   global CHECK_OUTPUT

   set my_timeout [timestamp]
   incr my_timeout 300
   
   set last_job_tickets 0
   while { $last_job_tickets == 0 && [timestamp] < $my_timeout } {
      get_extended_job_info $job_id job_info_var
      if {[info exists job_info_var(tckts)]} {
         set last_job_tickets $job_info_var(tckts)
      }
      puts $CHECK_OUTPUT "waiting for job $job_id to get its tickets ..."
      sleep 1
   }
   if { [timestamp] >= $my_timeout } {
      add_proc_error "wait_for_job_tickes" -1 "timeout while waiting for job tickets"
   }
}

proc get_job_tickets { job_list_prj1 job_list_prj2 job_list_prj3 array_name } {
   global CHECK_OUTPUT
 
   upvar $array_name my_tickets   
   
   set job_list ""
   foreach elem $job_list_prj1 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj2 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj3 {
      lappend job_list $elem
   }

   set nr_of_jobs [ llength $job_list ]

   set job_info_var ""
   foreach elem $job_list {
      unset job_info_var
      get_extended_job_info $elem job_info_var
      set my_tickets($elem) $job_info_var(tckts)
      puts -nonewline $CHECK_OUTPUT "\rjob to do: $nr_of_jobs ..."
      flush $CHECK_OUTPUT
      incr nr_of_jobs -1
   }
   puts $CHECK_OUTPUT "                        "
}

proc get_ticket_sum { job_list ticket_array_name } {
   global CHECK_OUTPUT

   upvar $ticket_array_name my_tickets

   set sum 0
   foreach elem $job_list {
      incr sum $my_tickets($elem)
   }
   return $sum
}

proc get_normalized_ticket_order { job_list_prj1 job_list_prj2 job_list_prj3 most_prior_project ticket_array_name return_array } {

   upvar  $ticket_array_name my_tickets  
   upvar  $return_array my_job_ticket_list

   set job_list ""
   foreach elem $job_list_prj1 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj2 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj3 {
      lappend job_list $elem
   }

   set ticket_list ""
   foreach job $job_list {
      lappend ticket_list $my_tickets($job)
   }

   set sorted_tickets [lsort -integer -decreasing $ticket_list]

   set normalized_list ""
   set last_elem ""
   foreach elem $sorted_tickets {
      if { $last_elem == $elem } {
         continue
      }
      lappend normalized_list $elem
      set last_elem $elem
   }
   set lf_nr 0
   set last_prj2_nr -1
   foreach elem $normalized_list {
      foreach job $job_list {
         if { $my_tickets($job) == $elem } {
            set project [get_project_member $job_list_prj1 $job_list_prj2 $job_list_prj3 $job]

            set my_job_ticket_list($lf_nr,project) $project
            set my_job_ticket_list($lf_nr,job_id)  $job
            set my_job_ticket_list($lf_nr,tickets) $elem
            if { $project == $most_prior_project } {
               set last_prj2_nr $lf_nr
            }
            incr lf_nr 1
         }
      } 
   }
   set my_job_ticket_list(job_count) $lf_nr 
   set my_job_ticket_list(last_prior_job_nr) $last_prj2_nr
  
   set jobs1_count 0
   set jobs2_count 0
   set jobs3_count 0
   for {set i 0} { $i <= $my_job_ticket_list(last_prior_job_nr) } {incr i 1} {   
      if { $my_job_ticket_list($i,project) == 1 } {
         incr jobs1_count 1
      }
      if { $my_job_ticket_list($i,project) == 2 } {
         incr jobs2_count 1
      }
      if { $my_job_ticket_list($i,project) == 3 } {
         incr jobs3_count 1
      }
   }
   set my_job_ticket_list(job_count_prj1) $jobs1_count
   set my_job_ticket_list(job_count_prj2) $jobs2_count
   set my_job_ticket_list(job_count_prj3) $jobs3_count


   set all_prj_count [ expr ( $jobs1_count + $jobs2_count + $jobs3_count ) ]
   set my_job_ticket_list(job_sum) $all_prj_count
   
   set all_prj_count_unit [ expr ( $all_prj_count / 100.0 ) ]
   set prj1_percentage [ expr ( $jobs1_count / $all_prj_count_unit ) ]
   set prj2_percentage [ expr ( $jobs2_count / $all_prj_count_unit ) ]
   set prj3_percentage [ expr ( $jobs3_count / $all_prj_count_unit ) ]

   set my_job_ticket_list(job_percent_prj1) $prj1_percentage     
   set my_job_ticket_list(job_percent_prj2) $prj2_percentage  
   set my_job_ticket_list(job_percent_prj3) $prj3_percentage  
 
   return $normalized_list
}



proc set_share_tree {} {
   global CHECK_OUTPUT

   set s_tree ""  
   lappend s_tree "id=0"
   lappend s_tree "name=Root"
   lappend s_tree "type=0"
   lappend s_tree "shares=1"
   lappend s_tree "childnodes=1,4"
   lappend s_tree "id=1"
   lappend s_tree "name=node1"
   lappend s_tree "type=0"
   lappend s_tree "shares=8000"
   lappend s_tree "childnodes=2,3"
   lappend s_tree "id=2"
   lappend s_tree "name=project1"
   lappend s_tree "type=0"
   lappend s_tree "shares=4000"
   lappend s_tree "childnodes=NONE"
   lappend s_tree "id=3"
   lappend s_tree "name=project2"
   lappend s_tree "type=0"
   lappend s_tree "shares=6000"
   lappend s_tree "childnodes=NONE"
   lappend s_tree "id=4"
   lappend s_tree "name=node2"
   lappend s_tree "type=0"
   lappend s_tree "shares=2000"
   lappend s_tree "childnodes=5"
   lappend s_tree "id=5"
   lappend s_tree "name=project3"
   lappend s_tree "type=0"
   lappend s_tree "shares=10000"
   lappend s_tree "childnodes=NONE"
   return $s_tree
}


proc share_tree_setup  {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE
   global CHECK_ARCH
   global CHECK_PRODUCT_ROOT
   global CHECK_HOST 
   global sharetree_stored_configuration test_queue test_host

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      set_error -3 "not available for sge system"
      return 
   }
    
   get_config sharetree_stored_configuration
   set my_execd_params "SHARETREE_RESERVED_USAGE=true"
   if { [string compare -nocase "none" $sharetree_stored_configuration(execd_params)] != 0 } {
      append my_execd_params ",$sharetree_stored_configuration(execd_params)"
   }
   set myconfig(execd_params) "$my_execd_params"
   set_config myconfig


   foreach elem $ts_config(execd_nodes) {
      disable_queue [get_queue_instance "all.q" "$elem"] 
   }  
  
   set test_host [lindex $ts_config(execd_nodes) 0]
   set test_queue [get_queue_instance "test" "$test_host"]
   set change_array(slots) "1"
   set change_array(load_thresholds) "none"
   add_queue "test" $test_host change_array 1

   set prj_setup(name) "project1"
   add_prj prj_setup

   set prj_setup(name) "project2"
   add_prj prj_setup

   set prj_setup(name) "project3"
   add_prj prj_setup

   set s_tree [set_share_tree]

   set vi_commands ""
   foreach elem $s_tree {
      lappend vi_commands "GA${elem}[format "%c" 27]"
   }
   lappend vi_commands "1Gdddddddddd"

   del_sharetree
 
   set CHANGED_SHARETREE [translate $CHECK_HOST 1 0 0 [sge_macro MSG_TREE_CHANGEDSHARETREE]]
   set CAN_T_READ [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QCONF_CANTREADSHARETREEX_S] "*"]

   set result [ handle_vi_edit "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-astree" $vi_commands $CHANGED_SHARETREE $CAN_T_READ ]  
   if { $result != 0 } {
      add_proc_error "share_tree_setup" -1 "could not add sharetree (error: $result)"
   }

   get_schedd_config my_config 
   set my_config(weight_tickets_share) "10000"
   set my_config(job_load_adjustments) "np_load_avg=0.0"
   set my_config(schedule_interval)    "2:0:0"
   set my_config(usage_weight_list)    "cpu=1,mem=0,io=0"
   set my_config(halftime)             "10"
   set_schedd_config my_config

   set_error 0 "ok"
}

proc get_project_member { prj1 prj2 prj3 job_id } {
   
   foreach elem $prj1 {
      if { $elem == $job_id } {
         return 1
      }
   }
   foreach elem $prj2 {
      if { $elem == $job_id } {
         return 2
      }
   }
   foreach elem $prj3 {
      if { $elem == $job_id } {
         return 3
      }
   }
   return 0
}


proc share_tree_test {} {
   global CHECK_PRODUCT_ROOT
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE 
   global CHECK_ARCH CHECK_TESTSUITE_ROOT
   global share_tree_job_counter CHECK_PROTOCOL_DIR
   global CHECK_SCRIPT_FILE_DIR
   global share_tree_percentage_variation
   global prj1_id_list prj2_id_list prj3_id_list
   global test_queue

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      set_error -3 "not available for sge system"
      return 
   }
   
   trigger_scheduling

   disable_queue "$test_queue"

   set prj1_id_list ""
   set prj2_id_list ""
   set prj3_id_list ""
   set counter $share_tree_job_counter
   while { $counter > 0 } {
      lappend prj1_id_list [ submit_job "-e /dev/null -o /dev/null -P project1 $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/sleeper.sh 5 $CHECK_PROTOCOL_DIR"]
      lappend prj2_id_list [ submit_job "-e /dev/null -o /dev/null -P project2 $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/sleeper.sh 5 $CHECK_PROTOCOL_DIR"]
      set last_job [ submit_job "-e /dev/null -o /dev/null -P project3 $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/sleeper.sh 5 $CHECK_PROTOCOL_DIR"]
      lappend prj3_id_list $last_job      
      incr counter -1
   }

   wait_for_jobpending $last_job "leeper" 60

   trigger_scheduling
   
   wait_for_job_tickes $last_job
   
   get_job_tickets $prj1_id_list $prj2_id_list $prj3_id_list tickets
   
   set sorted_tickets [get_normalized_ticket_order  $prj1_id_list $prj2_id_list $prj3_id_list 2 tickets answer ]
   

   if { $answer(job_count) != [ expr ( $share_tree_job_counter * 3 )]  } {
      add_proc_error "share_tree_test" "-1" "not all jobs in list"
   }

   set ticket_count 0
   for {set i 0} { $i < $answer(job_count) } {incr i 1} {
       puts $CHECK_OUTPUT "($i) tickets: $answer($i,tickets) job_id: $answer($i,job_id) project: $answer($i,project)"  
       incr ticket_count $answer($i,tickets) 
   }
   puts $CHECK_OUTPUT "SUM of tickets: $ticket_count"
   puts $CHECK_OUTPUT "last job of project 2: $answer(last_prior_job_nr)"
   puts $CHECK_OUTPUT "job counts:"
   puts $CHECK_OUTPUT "prj1: $answer(job_count_prj1)"
   puts $CHECK_OUTPUT "prj2: $answer(job_count_prj2)"
   puts $CHECK_OUTPUT "prj3: $answer(job_count_prj3)"
   puts $CHECK_OUTPUT "============"
   puts $CHECK_OUTPUT "sum : $answer(job_sum)"
   puts $CHECK_OUTPUT "percentage:"
   puts $CHECK_OUTPUT "prj1: $answer(job_percent_prj1)"
   puts $CHECK_OUTPUT "prj2: $answer(job_percent_prj2)"
   puts $CHECK_OUTPUT "prj3: $answer(job_percent_prj3)"

   set p1_abs [ expr ( int($answer(job_percent_prj1)) )  ]
   set p2_abs [ expr ( int($answer(job_percent_prj2)) )  ]
   set p3_abs [ expr ( int($answer(job_percent_prj3)) )  ]

   set x $share_tree_percentage_variation

   if { $p1_abs < [ expr ( 32 - $x ) ] || $p1_abs > [ expr ( 32 + $x ) ]  } {
      add_proc_error "share_tree_test" -1 "project1 percentage not 32 +/- $x % (value=$answer(job_percent_prj1),$p1_abs)"
   }
   if { $p2_abs < [ expr ( 48 - $x ) ] || $p2_abs > [ expr ( 48 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project2 percentage not 48 +/- $x % (value=$answer(job_percent_prj2),$p2_abs)"
   }
   if { $p3_abs < [ expr ( 20 - $x ) ] || $p3_abs > [ expr ( 20 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project3 percentage not 20 +/- $x % (value=$answer(job_percent_prj3),$p3_abs)"
   }


   foreach job $prj1_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }
   foreach job $prj2_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }
   foreach job $prj3_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }

#   set mod_config(schedule_interval)    "0:0:10"
#   set_schedd_config mod_config
   enable_queue "$test_queue"

   set done 0
   set my_timeout [timestamp]
   incr my_timeout 2500
   set nr_of_jobs 0
   set last_job_count 0
   while { $done == 0 && [timestamp] < $my_timeout} {
      set done 1
      foreach job $prj2_id_list {
         set file_here [file isfile $CHECK_PROTOCOL_DIR/$job]
         if { $file_here == 0 } {
            set done 0
         } 
      }

      if { $done == 1 } {
         continue
      }

      set catch_return [ catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -s r" } result ]
      set rjobout [split $result "\n"]
      set running_jobs [llength $rjobout]
      if { $running_jobs > 0 } {
         incr running_jobs -2 ;# 2 header lines
      }
      if { $running_jobs == 0 } {
         trigger_scheduling
      }
      sleep 2
   }
   disable_queue "$test_queue"
   if { [timestamp] >= $my_timeout } {
      add_proc_error "share_tree_test" -1 "timeout while waiting for start of jobs"
   }
     

 
   set prj3_count 0
   foreach job $prj3_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {   
         incr prj3_count 1
      }
   }

   set prj1_count 0
   foreach job $prj1_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {   
         incr prj1_count 1
      }
   }
   set prj2_count 0
   foreach job $prj2_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {   
         incr prj2_count 1
      }
   }
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "project1 count: $prj1_count"
   puts $CHECK_OUTPUT "project2 count: $prj2_count"
   puts $CHECK_OUTPUT "project3 count: $prj3_count"

   set all_prj_count [ expr ( $prj1_count + $prj2_count + $prj3_count ) ]
   puts $CHECK_OUTPUT "====================="
   puts $CHECK_OUTPUT "sum: $all_prj_count"  
 
   set all_prj_count_unit [ expr ( $all_prj_count / 100.0 ) ]

   set prj1_percentage [ expr ( $prj1_count / $all_prj_count_unit ) ]
   set prj2_percentage [ expr ( $prj2_count / $all_prj_count_unit ) ]
   set prj3_percentage [ expr ( $prj3_count / $all_prj_count_unit ) ]
  

   puts $CHECK_OUTPUT "project1 % $prj1_percentage"
   puts $CHECK_OUTPUT "project2 % $prj2_percentage"
   puts $CHECK_OUTPUT "project3 % $prj3_percentage"

   set x $share_tree_percentage_variation

   if { $prj1_percentage < [ expr ( 32 - $x ) ] || $prj1_percentage > [ expr ( 32 + $x ) ]  } {
      add_proc_error "share_tree_test" -1 "project1 running percentage not 32 +/- $x % (value=$prj1_percentage)"
   }
   if { $prj2_percentage < [ expr ( 48 - $x ) ] || $prj2_percentage > [ expr ( 48 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project2 running percentage not 48 +/- $x % (value=$prj2_percentage)"
   }
   if { $prj3_percentage < [ expr ( 20 - $x ) ] || $prj3_percentage > [ expr ( 20 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project3 running percentage not 20 +/- $x % (value=$prj3_percentage)"
   }

   foreach job [concat $prj1_id_list $prj2_id_list $prj3_id_list] {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }

   set_error 0 "ok" 

}


proc share_tree_cleanup  {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE 
   global CHECK_ARCH 
   global CHECK_PRODUCT_ROOT
   global prj1_id_list prj2_id_list prj3_id_list
   global sharetree_stored_configuration test_host

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   reset_schedd_config

   puts $CHECK_OUTPUT "ensure that no jobs are referenced in qmaster any longer ..."
   foreach job [concat $prj1_id_list $prj2_id_list $prj3_id_list] {
      puts -nonewline $CHECK_OUTPUT "$job " ; flush $CHECK_OUTPUT
      set my_timeout [timestamp]
      incr my_timeout 120
      while { [get_qstat_j_info $job] != 0 } {
          puts -nonewline $CHECK_OUTPUT "." ; flush $CHECK_OUTPUT
          if { [timestamp] > $my_timeout } {
             delete_job $job 1
             break
          }
          sleep 1
      }
      puts $CHECK_OUTPUT " done"
   }

   foreach elem $ts_config(execd_nodes) {
      enable_queue [get_queue_instance "all.q" "$elem"]
   }  

   del_queue test $test_host 0 1

   del_sharetree

  del_prj "project1"
  del_prj "project2"
  del_prj "project3"

  set_config sharetree_stored_configuration

  set_error 0 "ok"
}


proc issue_751 {} {
  global ts_config CHECK_USER CHECK_OUTPUT  
  global prj1_id_list prj2_id_list prj3_id_list

  set prj1_id_list ""
  set prj2_id_list ""
  set prj3_id_list ""

  set host $ts_config(master_host) 

   # the bug has only be fixed in maintrunk for 6.5
   # do only raise a warning for ealier versions
   set error_level -1
   set additional_message ""
   if {$ts_config(gridengine_version) <= 60} {
      set error_level -3
      set additional_message "\nhas been fixed only for 6.5 and higher"
   }

  set output [start_remote_prog $host $CHECK_USER "qconf" "-sstnode /" exit_state 30]
  puts $CHECK_OUTPUT $output
  if { $exit_state != 0 } {
      add_proc_error "issue_751" $error_level "Issue 751: qconf -sstnode / broken$additional_message"
  }

  set output [start_remote_prog $host $CHECK_USER "qconf" "-sstnode Root" exit_state 30]
  puts $CHECK_OUTPUT $output
  if { $exit_state != 0 } {
      add_proc_error "issue_751" $error_level "Issue 751: qconf -sstnode Root broken$additional_message"
  }

  set_error 0 "ok"
}
