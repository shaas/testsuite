#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "job_state_handling_init_level"

# define test's name and run level descriptions
set check_name            "job_state_handling"
set check_category        "COMPATIBILITY SYSTEM L10N"
set check_highest_level   1
set check_description(0)  "Test single job state handling"
set check_description(1)  "Test array job state handling"

# define test's dependencies
set check_needs           "init_core_system" 


# define test's procedure order
set check_functions ""
lappend check_functions "job_state_handling_setup"
lappend check_functions "job_state_handling_hold_pending_running_finished"
lappend check_functions "job_state_handling_error_timehold_jobhold"
lappend check_functions "job_state_handling_max_aj_instances"
lappend check_functions "job_state_handling_max_aj_tasks"
lappend check_functions "job_state_handling_cleanup"


global test_array_jobs 

proc job_state_handling_init_level {} {
   global CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE
   global test_array_jobs 

  switch -- $CHECK_ACT_LEVEL {
     "0" { 
           set test_array_jobs 0
           return 0    
     } 
     "1" {
           set test_array_jobs 1
           return 0
     }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------


proc job_state_handling_setup  {} {
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE
   global CHECK_ARCH
   global CHECK_PRODUCT_ROOT


   set_error 0 "ok"
}

proc job_state_handling_hold_pending_running_finished {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_OUTPUT CHECK_HOST
   global test_array_jobs

   set master_queue [lindex $ts_config(execd_nodes) 0]
# -q ${master_queue}.q
   if { $test_array_jobs == 0 } { 
      set jobargs "-o /dev/null -e /dev/null -h $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   } else {
      set jobargs "-t 1-10 -o /dev/null -e /dev/null -h $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 60"
   }
   set result [submit_job $jobargs]

   set back [ wait_for_jobpending $result "leeper" 100 ]
   if { $back != 0 } { 
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job $result not pending"  
   }

   trigger_scheduling

   set job_state [ get_job_state $result ]
   if { [ string compare $job_state "hqw" ] != 0 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job state not \"hqw\": $job_state"  
   }
 
   trigger_scheduling

   set scheduling_info_result [ get_scheduling_info $result ]
   set correct_info [ translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_JOBHOLD_]]
   if { [ string first  "job dropped because of hold" $scheduling_info_result ] <  0 && 
        [ string first  $correct_info $scheduling_info_result ] <  0 } {
       add_proc_error "job_state_handling_hold_pending_running_finished" -1 "scheduling info not \"job dropped because of hold\"" 
   }
   
   set queue_list ""
   foreach host $ts_config(execd_nodes) {
      append queue_list "$host.q "
   }  
   set queue_list [string trim $queue_list]
   puts $CHECK_OUTPUT "disable queues: \"$queue_list\""
   disable_queue $queue_list

   release_job $result   

   set job_state [ get_job_state $result ]
   puts $CHECK_OUTPUT "job state = \"$job_state\""

   if { [ string compare $job_state "qw" ] != 0 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job state not \"qw\": $job_state"  
   }

   hold_job $result

   enable_queue $queue_list
   
   release_job $result

   set my_timeout [timestamp]
   incr my_timeout 300
   set t_state_ok 0
   while { $my_timeout > [timestamp] } {
      set job_state [ get_job_state $result ]
      puts $CHECK_OUTPUT "job state = \"$job_state\""
      if { [ string compare $job_state "t" ] == 0 } {
         set t_state_ok 1
         break
      }
#     if the time is to short to get the transfering state
#     with qstat -f, we also allow the job running state 
      if { [ string compare $job_state "r" ] == 0 } {
         set t_state_ok 1
         break
      }
      sleep 1
   }   
   if { $t_state_ok != 1 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job state not \"t\": $job_state"  
   }

   wait_for_end_of_transfer $result 300
   set job_state [ get_job_state $result ]
   if { [ string compare $job_state "r" ] != 0 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job state not \"r\": $job_state"  
   }
 
   set back [ wait_for_jobend     $result "leeper" 100 0]
   if { $back != 0 } { 
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job $result not finished"  
   }

   set back [ was_job_running     $result              ]
   if { [ string first $result $back ] < 0 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job $result not in accouting file" 
   }

   set_error 0 "ok"
}



proc job_state_handling_error_timehold_jobhold {} {
   global CHECK_PRODUCT_ROOT
   global test_array_jobs
   global CHECK_OUTPUT 
   global CHECK_ARCH CHECK_HOST

   if { $test_array_jobs == 0 } { 
      set jobargs "-o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" 
   } else {
      set jobargs "-t 1-10 -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15"
   }

   set error_job   [submit_error_job $jobargs]
   set time_job    [submit_time_job  $jobargs]
   set waitjob_job [submit_waitjob_job $jobargs $time_job]

   trigger_scheduling

   wait_for_jobpending $error_job "leeper" 300
   wait_for_jobpending $time_job "leeper" 300
   wait_for_jobpending $waitjob_job "leeper" 300

   sleep 2

   trigger_scheduling

   wait_for_jobpending $error_job "leeper" 300
   wait_for_jobpending $time_job "leeper" 300
   wait_for_jobpending $waitjob_job "leeper" 300

   sleep 2

   set scheduler_info_text [get_scheduling_info $error_job ]
   set correct_text [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_JOBINERROR_]]
   if { [ string first "job is in error state" $scheduler_info_text  ] < 0 &&
        [ string first  $correct_text $scheduler_info_text ] < 0  } {
       add_proc_error "job_state_handling_hold_pending_running_finished" -1 "scheduling info not \"job is in error state\"" 
   }
   if { [get_qstat_j_info $time_job ] } {
      puts $CHECK_OUTPUT "job $time_job submit time:    $qstat_j_info(submission_time)"
      puts $CHECK_OUTPUT "job $time_job execution time: $qstat_j_info(execution_time)"
      set time_job_execution_time $qstat_j_info(execution_time)

      set scheduler_info_text [get_scheduling_info $time_job]
      set correct_text [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_EXECTIME_]]

      if { [ string first "execution time not reached" $scheduler_info_text ] < 0 && 
           [ string first $correct_text $scheduler_info_text ] < 0 } {
          add_proc_error "job_state_handling_hold_pending_running_finished" -1 "scheduling info not \"execution time not reached\"" 
      }
   }
   set scheduler_info_text [ get_scheduling_info $waitjob_job]
   set correct_text [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SCHEDD_INFO_JOBDEPEND_]]
   if { [ string first "job dropped because of job dependencies" $scheduler_info_text ] < 0  && 
        [ string first $correct_text $scheduler_info_text ] < 0  } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "scheduling info not \"job dropped because of job dependencies\"" 
   }

   while { [timestamp] < $time_job_execution_time } {
      set job_state [ get_job_state $time_job ]
      if { [ string compare $job_state "qw" ] != 0 } {
         add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job state not \"qw\": $job_state"
         continue
      }
      puts -nonewline $CHECK_OUTPUT "\rjob $time_job is in state $job_state, continue in [expr ( $time_job_execution_time - [timestamp] ) ] seconds ...   "
      flush $CHECK_OUTPUT
      sleep 1
   } 
   puts $CHECK_OUTPUT ""
   wait_for_jobstart $time_job    "leeper" 100
   
   set job_state [ get_job_state $waitjob_job ]
   if { [ string compare $job_state "hqw" ] != 0 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job $waitjob_job state not \"hqw\": $job_state"
   }

   wait_for_jobstart $waitjob_job "leeper" 200
   wait_for_jobend $waitjob_job "leeper" 100

   set job_state [ get_job_state $error_job ]
   if { [ string compare $job_state "Eqw" ] != 0 } {
      add_proc_error "job_state_handling_hold_pending_running_finished" -1 "job $waitjob_job state not \"Eqw\": $job_state"
   }
   delete_job $error_job

   set_error 0 "ok"
}

proc job_state_handling_max_aj_instances {} {
   global CHECK_PRODUCT_ROOT  
   global CHECK_OUTPUT CHECK_HOST
   global test_array_jobs CHECK_ARCH

   get_config old_config
   set new_config(max_aj_instances) 4

   set_config new_config

   if { $test_array_jobs == 1 } {
      set jobargs "-t 1-10 -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10"
      set result [submit_job $jobargs]
 
      trigger_scheduling

      set array_states 0
      set tasks_done ""
      while {$array_states != -1} {
          set array_states [get_job_state $result 1]
          if { $array_states == -1 } {
             continue
          }
          set running 0
          set waiting 0
          foreach elem $array_states {
             if { [string compare $elem "qw"] == 0 } { incr waiting 1 }
             if { [string compare $elem "r"] == 0  || [string compare $elem "t"] == 0 } { incr running 1 }
          }
          set array_jobs_found [llength $array_states]
          set control_sum [ expr ( $waiting + $running ) ]
          if { $control_sum != $array_jobs_found } {
             add_proc_error "job_state_handling_max_aj_instances" -1 "some array tasks are in unexpected state(s)"
          }
          if { $running > 4 } {
             add_proc_error "job_state_handling_max_aj_instances" -1 "to mutch array tasks are running"
          } 
          if { $running > 0 } {
             for { set i 0 } { $i < $array_jobs_found } { incr i 1 } {
                 if { $task_id($i,task) > 0 && $task_id($i,task) <= 10 } {
                    if { [string first $task_id($i,task) $tasks_done ] < 0 } {
                       lappend tasks_done $task_id($i,task)
                       puts $CHECK_OUTPUT "\ntasks done: $tasks_done"
                       for { set ia 0 } { $ia < $array_jobs_found } { incr ia 1 } {
                           puts $CHECK_OUTPUT "task_id: $task_id($ia,task), state: $task_id($ia,state)"
                       }
                    }
                 }
             }
          }
          if { [llength $tasks_done] < 5 } {

             set scheduling_info_text [get_scheduling_info $result 0 ]
             set correct_text [ translate $CHECK_HOST 1 0 0 [ sge_macro MSG_SCHEDD_INFO_MAX_AJ_INSTANCES_ ]]
#             puts $CHECK_OUTPUT "schedd_info_text: $scheduling_info_text"
#             puts $CHECK_OUTPUT "correct_text    : $correct_text"
             if { [ string first "not all array task may be started due to 'max_aj_instances'" $scheduling_info_text ] < 0 &&
                  [ string first $correct_text $scheduling_info_text ] < 0 } {
                add_proc_error "job_state_handling_hold_pending_running_finished" -1 "scheduling info not \"not all array task may be started due to 'max_aj_instances'\"" 
                break;
             }
          }

          puts -nonewline $CHECK_OUTPUT "."
          flush $CHECK_OUTPUT
      }
   } else {
      set job_array ""
      set jobargs "-o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

      for { set i 0 } { $i < 10 } { incr i 1 } {
         set result [submit_job $jobargs]
         lappend job_array $result
      }

      foreach elem $job_array {
         wait_for_jobstart $elem "leeper" 100
      }

      foreach elem $job_array {
         wait_for_end_of_transfer $elem 100
      }

      foreach elem $job_array {
         set state [get_job_state $elem ]
         if { $state != "r" } {
            add_proc_error "job_state_handling_max_aj_instances" -1 "normal jobs should still be scheduled"
         }
      }
      
      foreach elem $job_array {
         delete_job $elem
      }

   }
   set new_config(max_aj_instances) $old_config(max_aj_instances)
   set_config new_config
   
   set_error 0 "ok"
}

proc job_state_handling_max_aj_tasks {} {
   global CHECK_PRODUCT_ROOT  
   global CHECK_OUTPUT
   global test_array_jobs

   get_config old_config
   set new_config(max_aj_tasks) 5

   set_config new_config

   if { $test_array_jobs == 1 } {
      set jobargs "-t 1-6 -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10"
      set result [submit_job $jobargs 0]
      if { $result != -7 } {
         add_proc_error "job_state_handling_max_aj_tasks" -1 "it should be denied to submit a array with more than 5 tasks"
      }


      set jobargs "-t 1-12:2 -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10"
      set result [submit_job $jobargs 0]
      if { $result != -7 } {
         add_proc_error "job_state_handling_max_aj_tasks" -1 "it should be denied to submit a array with more than 5 tasks"
      }


      set jobargs "-t 1-10:2 -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
      set array1 [submit_job $jobargs 0]
      wait_for_jobstart $array1 "leeper" 100
      wait_for_end_of_transfer $array1 100
      set array_states [get_job_state $array1 0]
      set array_states [get_job_state $array1 1]
      set array_tasks_found [llength $array_states]
      set valid_task_ids "1 3 5 7 9"
      set task_ids ""
      for { set ia 0 } { $ia < $array_tasks_found } { incr ia 1 } {
          puts $CHECK_OUTPUT "task_id: $task_id($ia,task), state: $task_id($ia,state)"
          lappend task_ids $task_id($ia,task) 
      }
      set task_ids [lsort $task_ids]
      puts $CHECK_OUTPUT "task list: $task_ids"
      for { set ia 0 } { $ia < 5 } { incr ia 1 } {
          if { [ lindex $valid_task_ids $ia ] !=  [ lindex $task_ids $ia ] } {
             add_proc_error "job_state_handling_max_aj_tasks" -1 "found wrong task id [ lindex $task_ids $ia ] in array job"
          } 
      } 
      delete_job $array1

      set jobargs "-t 1-5:1 -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
      set array1 [submit_job $jobargs 0]
      wait_for_jobstart $array1 "leeper" 100
      wait_for_end_of_transfer $array1 100
      set array_states [get_job_state $array1 0]
      set array_states [get_job_state $array1 1]
      set array_tasks_found [llength $array_states]
      set valid_task_ids "1 2 3 4 5"
      set task_ids ""
      for { set ia 0 } { $ia < $array_tasks_found } { incr ia 1 } {
          puts $CHECK_OUTPUT "task_id: $task_id($ia,task), state: $task_id($ia,state)"
          lappend task_ids $task_id($ia,task) 
      }
      set task_ids [lsort $task_ids]
      puts $CHECK_OUTPUT "task list: $task_ids"
      for { set ia 0 } { $ia < 5 } { incr ia 1 } {
          if { [ lindex $valid_task_ids $ia ] !=  [ lindex $task_ids $ia ] } {
             add_proc_error "job_state_handling_max_aj_tasks" -1 "found wrong task id [ lindex $task_ids $ia ] in array job"
          } 
      } 
      delete_job $array1
   } else {
      set job_array ""
      set jobargs "-o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

      for { set i 0 } { $i < 10 } { incr i 1 } {
         set result [submit_job $jobargs]
         lappend job_array $result
      }

      foreach elem $job_array {
         wait_for_jobstart $elem "leeper" 100
      }

      foreach elem $job_array {
         wait_for_end_of_transfer $elem 100
      }

      foreach elem $job_array {
         set state [get_job_state $elem ]
         if { $state != "r" } {
            add_proc_error "job_state_handling_max_aj_tasks" -1 "normal jobs should still be scheduled"
         }
      }
      
      foreach elem $job_array {
         delete_job $elem
      }

   }
   set new_config(max_aj_tasks) $old_config(max_aj_tasks)
   set_config new_config
   
   set_error 0 "ok"
}

proc job_state_handling_cleanup  {} {
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE 
   global CHECK_ARCH CHECK_USER
   global CHECK_PRODUCT_ROOT

   puts $CHECK_OUTPUT "do qdel -uall"
   set catch_result [delete_all_jobs]
   puts $CHECK_OUTPUT $catch_result

   set_error 0 "ok"
}



