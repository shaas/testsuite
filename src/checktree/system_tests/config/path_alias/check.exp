#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "path_alias_init_level"


# define test's name and run level descriptions
set check_name            "path_alias"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   1
set check_description(0)  "checking global path alias file"
set check_description(1)  "checking user path alias file"

# define test's dependencies
set check_needs           "init_core_system" 


# setup and cleanup functions
set check_setup_level_function "path_alias_setup"
set check_cleanup_level_function "path_alias_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "path_alias_main"

global PATH_ALIAS_OUTPUT1
global PATH_ALIAS_OUTPUT2
global path_alias_test
set path_alias_test 0

proc path_alias_init_level {} {
  global CHECK_ACT_LEVEL
  global path_alias_test

  switch -- $CHECK_ACT_LEVEL {
     "0" { set path_alias_test 1 ; return 0   } 
     "1" { set path_alias_test 2 ; return 0   }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------



proc path_alias_setup {} {
   global ts_config
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_OUTPUT CHECK_USER
   global PATH_ALIAS_OUTPUT1
   global PATH_ALIAS_OUTPUT2
   global CHECK_PRODUCT_ROOT
   global path_alias_test
   global env CHECK_PROTOCOL_DIR
  
   
   set PATH_ALIAS_OUTPUT1 [ file dirname "$CHECK_JOB_OUTPUT_DIR/adir" ]
   set PATH_ALIAS_OUTPUT2 [ file dirname "$CHECK_JOB_OUTPUT_DIR/adir" ]
   append PATH_ALIAS_OUTPUT1 "/path_alias_output1"
   append PATH_ALIAS_OUTPUT2 "/path_alias_output2"

   puts $CHECK_OUTPUT "creating directory: $PATH_ALIAS_OUTPUT1"
   file mkdir $PATH_ALIAS_OUTPUT1
   if { [ file isdirectory $PATH_ALIAS_OUTPUT1 ] != 1 } {
      add_proc_error "path_alias_setup" -1 "could not create directory $PATH_ALIAS_OUTPUT1" 
   }

   puts $CHECK_OUTPUT "creating directory: $PATH_ALIAS_OUTPUT2"
   file mkdir $PATH_ALIAS_OUTPUT2
   if { [ file isdirectory $PATH_ALIAS_OUTPUT2 ] != 1 } {
      add_proc_error "path_alias_setup" -1 "could not create directory $PATH_ALIAS_OUTPUT2" 
   }

   set do_it 0
   if { $path_alias_test == 1 } {
      set do_it 1
      set file_name "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/sge_aliases"
   }

   if { $path_alias_test == 2 } {
      set do_it 1
      set file_name "$env(HOME)/.sge_aliases"
   }

   if { $do_it == 1 } {
      puts $CHECK_OUTPUT "testing alias file $file_name"
      if { ([ file isfile "${file_name}.sav" ] != 1) && 
           ([ file isfile ${file_name}] == 1) } {
         puts $CHECK_OUTPUT "moving original alias file to ${file_name}.sav"
         file rename ${file_name} ${file_name}.sav
         foreach elem $ts_config(unique_arch_nodes) {
            set counter 60
            while { $counter > 0 } {
               set result [start_remote_prog $elem $CHECK_USER "cat" "${file_name}"]
               incr counter -1
               if {  $prg_exit_state != 0 } {
                  break;
               }
               sleep 1
            }
            if { $counter <= 0 } {
               add_proc_error "path_alias_setup" "-1" "error moving file ${file_name} on host $elem"
            }
         } 

      }
      if { [ file isfile ${file_name}  ] != 1 } {
         set data(src-path,0)     "/tmp_mnt/"
         set data(sub-host,0)     "*"
         set data(exec-host,0)    "*" 
         set data(replacement,0)  "/"
         set data(src-path,1)     "$PATH_ALIAS_OUTPUT1"
         set data(sub-host,1)     "*"
         set data(exec-host,1)    "*" 
         set data(replacement,1)  "$PATH_ALIAS_OUTPUT2"

         create_path_aliasing_file ${file_name} data 2
      }
   }
   set cat_output ""
   set old_cat_output ""
   set cat_hostname ""
   set last_host ""
   foreach elem $ts_config(unique_arch_nodes) {
      set counter 60
      while { $counter > 0 } {
         set result [start_remote_prog $elem $CHECK_USER "cat" "${file_name}"]
         incr counter -1
         if { $prg_exit_state == 0 } {
            break;
         }
         sleep 1
      }
      if {  $prg_exit_state != 0 } {
         add_proc_error "path_alias_setup" "-1" "error reading file ${file_name} on host $elem"
      }
      lappend cat_hostname $elem 
      lappend cat_output $result
      set last_host $elem
   }
   
   set elem_nr 0
   set orig [open "$CHECK_PROTOCOL_DIR/test1.txt" "w" ]
   puts $orig $result
   close $orig
   foreach elem $cat_output {
       set diff [open "$CHECK_PROTOCOL_DIR/test2.txt" "w" ]
       puts $diff $elem 
       close $diff

       set catch_return [ catch { eval exec "diff -w $CHECK_PROTOCOL_DIR/test1.txt $CHECK_PROTOCOL_DIR/test2.txt" } diff_output ]
       if { $catch_return != 0 } {
          add_proc_error "path_alias_setup" "-1" "error compareing output of cat command:\n$diff_output"
       }
   }

   delete_file "$CHECK_PROTOCOL_DIR/test1.txt"
   delete_file "$CHECK_PROTOCOL_DIR/test2.txt"

   set_error 0 "ok"
}

proc path_alias_main {} {
   global ts_config
   global path_alias_test
   global PATH_ALIAS_OUTPUT1
   global PATH_ALIAS_OUTPUT2
   global CHECK_OUTPUT
   global CHECK_PRODUCT_ROOT
   global CHECK_USER   


   set files1_old [get_file_names $PATH_ALIAS_OUTPUT1]
   set files2_old [get_file_names $PATH_ALIAS_OUTPUT2]


   set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10"
   foreach elem $ts_config(unique_arch_nodes) {
      puts $CHECK_OUTPUT "submitting job(s) for host $elem"

      puts $CHECK_OUTPUT "qsub ..."
      set script_name "$PATH_ALIAS_OUTPUT1/global_qsub_alias_$elem.sh"
      set command     "qsub -cwd -l h=${elem}"

      start_remote_prog $elem $CHECK_USER "cd" "$PATH_ALIAS_OUTPUT1 ; $command $job_script" 

      puts $CHECK_OUTPUT "qrsh ..."

      set script_name "$PATH_ALIAS_OUTPUT1/global_qrsh_alias_$elem.sh"
      set command     "qrsh -cwd -l h=${elem} \"pwd\""

      set output [start_remote_prog $elem $CHECK_USER "cd" "$PATH_ALIAS_OUTPUT1 ; $command " ]
      set output [ split $output "\n" ]
      set output [ lindex $output 0 ]
      set output [ split $output "\r" ]
      set output [ lindex $output 0 ]
      if { [ string first "$PATH_ALIAS_OUTPUT2" $output ] < 0 } {
         add_proc_error "path_alias_main" -1 "host: $elem\nqrsh -cwd directory is\n\"$output\"\n instead of \n\"$PATH_ALIAS_OUTPUT2\""
      }

      puts $CHECK_OUTPUT "qsh ..."
      set pwd_script "$PATH_ALIAS_OUTPUT1/global_pwdscript_$elem.sh"
      set command     "> qsh_pwd_output_$elem.txt ; sleep 10"
      create_shell_script $pwd_script $elem "pwd" "$command " "" "/bin/sh" 0 1 1 1

      set command     "qsh -cwd -l h=${elem} -- -e $pwd_script"

      set output [start_remote_prog $elem $CHECK_USER "cd" "$PATH_ALIAS_OUTPUT1 ; $command" ]
      puts $CHECK_OUTPUT $output
   }
 
   wait_for_end_of_all_jobs 100 

   after 10000

   set files1 [get_file_names $PATH_ALIAS_OUTPUT1]
   set files2 [get_file_names $PATH_ALIAS_OUTPUT2]


   set nr_new_files1 [ expr ([llength $files1] - [llength $files1_old]) ]
   set nr_new_files2 [ expr ([llength $files2] - [llength $files2_old]) ]


   puts $CHECK_OUTPUT "files1: $nr_new_files1"
   puts $CHECK_OUTPUT "files2: $nr_new_files2"

   set nr_hosts [ llength $ts_config(unique_arch_nodes)]
   puts $CHECK_OUTPUT "nr_hosts: $nr_hosts"

   if { $nr_new_files1 != $nr_hosts } {
      add_proc_error "path_alias_main" -1 "there are $nr_new_files1 new files in directory $PATH_ALIAS_OUTPUT1, should be $nr_hosts (case 1)"
   }

   set nr_hosts_x2 [ expr ( $nr_hosts * 3 ) ]
   if { $nr_new_files2 != $nr_hosts_x2 } {
      add_proc_error "path_alias_main" -1 "there are $nr_new_files2 new files in directory $PATH_ALIAS_OUTPUT2, should be $nr_hosts_x2 (case 2)"
   } 

   foreach elem $files1 {
      #puts $CHECK_OUTPUT "deleting $elem"
      file delete $PATH_ALIAS_OUTPUT1/$elem
   }
   foreach elem $files2 {
      #puts $CHECK_OUTPUT "deleting $elem"
      file delete $PATH_ALIAS_OUTPUT2/$elem
   }
   
   set_error 0 "ok"
}

proc path_alias_cleanup {} {
   global ts_config
   global path_alias_test
   global PATH_ALIAS_OUTPUT1
   global PATH_ALIAS_OUTPUT2
   global CHECK_OUTPUT
   global CHECK_PRODUCT_ROOT
   global env


   delete_all_jobs
   wait_for_end_of_all_jobs 60

   puts $CHECK_OUTPUT "deleting directory: $PATH_ALIAS_OUTPUT1"
   catch { file delete $PATH_ALIAS_OUTPUT1 }
   if { [ file isdirectory  $PATH_ALIAS_OUTPUT1 ] == 1 } {
      add_proc_error "path_alias_setup" -1 "could delete directory $PATH_ALIAS_OUTPUT1" 
   }
   catch { file delete $PATH_ALIAS_OUTPUT2 }
   puts $CHECK_OUTPUT "deleting directory: $PATH_ALIAS_OUTPUT2"
   if { [ file isdirectory $PATH_ALIAS_OUTPUT2 ] == 1 } {
      add_proc_error "path_alias_setup" -1 "could delete directory $PATH_ALIAS_OUTPUT2" 
   }

   set do_it 0 

   if { $path_alias_test == 1 } {
      set file_name "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/sge_aliases"
      set do_it 1
   } 
   if { $path_alias_test == 2 } {
      set file_name "$env(HOME)/.sge_aliases"
      set do_it 1
   }
   if { $do_it == 1 } {
      file delete $file_name
      puts $CHECK_OUTPUT "deleting $file_name"
      if { [ file isfile "$file_name" ] == 1 } {
         set_error -1 "could not delete file $file_name"
         return 
      }

      if { [ file isfile "$file_name.sav" ] == 1 } {
         puts $CHECK_OUTPUT "removing original alias file to $file_name"
         file rename "$file_name.sav" "$file_name"
      }
   }


   set_error 0 "ok"
}

