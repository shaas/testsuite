#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

#****** checks/reporting *******************************************************
#  NAME
#     reporting -- check reporting functionality
#
#  FUNCTION
#     The purpose of this testsuite check is to test the qmaster repoting file
#     generation.
#
#     It tests the following features:
#        - account_flush_time reporting param
#
#     It should test the following features:
#        - all reporting params
#        - accounting file contents
#        - reporting file contents
#        - reporting of events
#        - reporting of sharelog data
#*******************************************************************************
#
# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "reporting_init_level"

# define test's name and run level descriptions
set check_name            "reporting"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   0
set check_description(0)  "Test reporting parameters and qmaster reporting"

# define test's dependencies
set check_needs           "init_core_system" 


# setup and cleanup functions
set check_setup_function reporting_setup
set check_cleanup_function reporting_cleanup

# define test's procedure order
set check_functions {}
lappend check_functions "reporting_periodic_accounting_test"
lappend check_functions "reporting_immediate_accounting_test"
lappend check_functions "reporting_reporting_accounting_test"
lappend check_functions "reporting_queue_state_test"

global reporting_old_config reporting_acct_file

proc reporting_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------


proc reporting_setup  {} {
   global ts_config CHECK_OUTPUT CHECK_USER
   global reporting_old_config reporting_file reporting_acct_file reporting_test_host

   # delete any jobs that might be in the system
   delete_all_jobs

   # archive old config
   get_config reporting_old_config

   # enable immediate scheduling
   set schedd_conf(flush_submit_sec) 1
   set schedd_conf(flush_finish_sec) 1
   set_schedd_config schedd_conf

   # create 2 queues with one slot each, subordinate mechanism
   set reporting_test_host [host_conf_get_suited_hosts]
   set queue_conf(load_thresholds) NONE
   set queue_conf(slots) 1
   add_queue "reporting" $reporting_test_host queue_conf
   set queue_conf(subordinate_list) "reporting"
   add_queue "reporting_super" $reporting_test_host queue_conf

   # create an additional calendar for queue state test
   set cal(calendar_name) "reporting"
   set cal(year)          "01.01.2000=00:00-01:00=off"
   set cal(week)          "NONE"
   add_calendar "reporting" cal

   # create an additional hostgroup for queue state test
   set hgrp(group_name) "@reporting"
   set hgrp(hostlist)   $reporting_test_host
   add_hostgroup "@reporting" hgrp

   # find accounting file
   set reporting_file "$ts_config(product_root)/$ts_config(cell)/common/reporting"
   set reporting_acct_file "$ts_config(product_root)/$ts_config(cell)/common/accounting"

   # touch reporting file
   start_remote_prog $ts_config(master_host) $CHECK_USER "touch" "$reporting_file"
}

proc reporting_cleanup {} {
   global reporting_old_config reporting_test_host reporting_file

   # restore old config
   set_config reporting_old_config
   reset_schedd_config

   # remove test queues
   del_queue "reporting_super" $reporting_test_host 0 1
   del_queue "reporting" $reporting_test_host 0 1

   # remove calendar and hostgroup of queue state test
   del_calendar "reporting"
   del_hostgroup "@reporting"

   # disable reporting
   set new_config(reporting_params) "accounting=true reporting=false"
   set_config new_config

   # delete the reporting file
   file delete -force $reporting_file
}

proc reporting_do_accounting_test {scenario} {
   global ts_config CHECK_USER
   global CHECK_OUTPUT reporting_acct_file

   # Check accounting file size
   # we might be the first test after installation - in this case no accounting file exists
   if {![file exists $reporting_acct_file]} {
      set f [open $reporting_acct_file w]
      puts $f "# new accounting file"
      close $f
   }
   set mtime [file mtime $reporting_acct_file]

   # Submit job
   # we submit an array job of short running sleepers 
   # to a queue with one slot
   set script "$ts_config(product_root)/examples/jobs/sleeper.sh"
   set job_id [submit_job "-t 1-100 -o /dev/null -j y -q reporting $script 1"]
   if {$job_id <= 0} {
      # error message has been generated by submit_job
      return
   }

   # Watch accounting file for updates.
   # Wait for the first accounting file update
   set done 0
   while {!$done} {
      set new_mtime [file mtime $reporting_acct_file]

      if {$mtime != $new_mtime} {
         set done 1
      }
   }

   set failed 0

   # Watch the accounting file for one flush interval
   # The accounting file should not change between flush intervals
   while {[clock seconds] < [expr $new_mtime + 14]} {
      after 1000

      if {$new_mtime != [file mtime $reporting_acct_file]} {
         add_proc_error $scenario -1 "accounting file was flushed before flush interval"
         set failed 1
         break
      }
   }

   if {$failed != 1} {
      # The accounting file should change at flush intervals
      after 1000

      if {$new_mtime == [file mtime $reporting_acct_file]} {
         add_proc_error $scenario -1 "accounting file was not flushed at flush interval"
      }
   }

   # Delete any jobs that might be in the system
   delete_all_jobs
}

proc reporting_periodic_accounting_test {} {
   # Set accounting_flush_time to 00:00:15
   set new_config(reporting_params) "accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00 accounting_flush_time=00:00:15"
   set_config new_config

   reporting_do_accounting_test reporting_periodic_accounting_test
}

proc reporting_reporting_accounting_test {} {
   # Do not set accounting_flush_time.  Set flush_time to 00:00:15
   set new_config(reporting_params) "accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00"
   set_config new_config

   reporting_do_accounting_test reporting_reporting_accounting_test
}

proc reporting_immediate_accounting_test {} {
   global ts_config CHECK_USER
   global CHECK_OUTPUT reporting_acct_file

   # Set accounting_flush_time to 00:00:00
   set new_config(reporting_params) "accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00 accounting_flush_time=00:00:00"
   set_config new_config

   # Check accounting file size
   set mtime [file mtime $reporting_acct_file]

   # Submit job
   set options "-o /dev/null -j y -sync yes -q reporting"
   set script "$ts_config(product_root)/examples/jobs/sleeper.sh 10"
   set job_id [submit_job "$options $script"]

   if {$job_id <= 0} {
      # error message has been generated in submit_job
      return
   }

   # Check accounting file mtime
   set new_mtime [file mtime $reporting_acct_file]
   if {$mtime == $new_mtime} {
       add_proc_error "reporting_immediate_accounting_test" -1 "accounting file was not flushed before job finish event"
       return
   }

   # Do it again to be sure
   # Submit job
   set job_id [submit_job "$options $script"]

   if {$job_id <= 0} {
      # error message has been generated in submit_job
      return
   }

   # Check accounting file mtime
   if {$new_mtime == [file mtime $reporting_acct_file]} {
       add_proc_error "reporting_immediate_accounting_test" -1 "accounting file was not flushed before job finish event"
       return
   }
}

proc reporting_wait_for_queue_state {state {timeout 10}} {
   global ts_config CHECK_OUTPUT reporting_test_host

   # make sure the queue actually is in the requested state
   set queue_state [get_queue_state [get_queue_instance "reporting" $reporting_test_host]]
   puts $CHECK_OUTPUT "queue is in state \"$queue_state\""
   if {$state != $queue_state} {
      add_proc_error "reporting_wait_for_queue_state" -1 "queue is not in expected state \"$state\", but in state \"$queue_state\""
   }

   # now read from reporting file and check for queue records and the expected state
   puts $CHECK_OUTPUT "waiting for queue state \"$state\" in reporting file"

   set pattern ":queue:reporting:"
   set output [logfile_wait $pattern $timeout 0]
   if {$logfile_wait_error == 0} {
      set queue_state_found 0
      foreach line $output {
         if {[string first $pattern $line] >= 0} {
            set queue_state_found 1
            set split_line [split $line ":"]
            set reported_state [lindex $split_line 5]
            if {$state != $reported_state} {
               add_proc_error "reporting_wait_for_queue_state" -1 "reporting: expected queue state \"$state\" but got \"$reported_state\""
            }
         }
      }

      # There was no queue record at all? That's bad ...
      if {!$queue_state_found} {
         add_proc_error "reporting_wait_for_queue_state" -1 "there were no queue records in the reporting file, got only\n$output"
      }
   }
}

proc reporting_queue_state_test {} {
   global ts_config CHECK_OUTPUT
   global reporting_file reporting_test_host

   # activate reporting and set short reporting flush time
   set new_config(reporting_params) "reporting=true flush_time=00:00:1"
   set_config new_config

   # tail -f reporting file
   init_logfile_wait $ts_config(master_host) $reporting_file
   ########################
   # test queue alarm state
   ########################
# queue alarms are not delivered by qmaster
# would require architectural changes
if {0} {
   replace_attr "queue" "load_thresholds" "np_load_avg=-1" "reporting"
   reporting_wait_for_queue_state "a"
   replace_attr "queue" "load_thresholds" "NONE" "reporting"

   ################################
   # test queue suspend alarm state
   ################################
   replace_attr "queue" "suspend_thresholds" "np_load_avg=-1" "reporting"
   reporting_wait_for_queue_state "A"
   replace_attr "queue" "suspend_thresholds" "NONE" "reporting"
}
   ###########################
   # test queue disabled state
   ###########################
   disable_queue "reporting"
   reporting_wait_for_queue_state "d"
   enable_queue "reporting"
   reporting_wait_for_queue_state ""

   ############################
   # test queue suspended state
   ############################
   suspend_queue "reporting"
   reporting_wait_for_queue_state "s"
   unsuspend_queue "reporting"
   reporting_wait_for_queue_state ""

   ##########################
   # test queue unknown state
   ##########################
   start_sge_bin "qconf" "-ke $reporting_test_host"
   reporting_wait_for_queue_state "u"
   startup_execd $reporting_test_host
   wait_for_load_from_all_queues 60
   reporting_wait_for_queue_state ""

   ########################
   # test queue error state
   ########################
   replace_attr "queue" "prolog" "non_existing_prolog" "reporting"
   set job_id [submit_job "-o /dev/null -j y -q reporting -b y echo test"]
   trigger_scheduling
   wait_for_queue_state [get_queue_instance "reporting" $reporting_test_host] "E" 60
   reporting_wait_for_queue_state "E"
   delete_job $job_id
   replace_attr "queue" "prolog" "NONE" "reporting"
   start_sge_bin "qmod" "-c reporting"
   reporting_wait_for_queue_state ""

   ###########################################
   # test queue suspended on subordinate state
   ###########################################
   set job_id [submit_job "-o /dev/null -j y -q reporting_super -b y sleep 60"]
   trigger_scheduling
   wait_for_queue_state [get_queue_instance "reporting" $reporting_test_host] "S" 60
   reporting_wait_for_queue_state "S"
   delete_job $job_id 1
   reporting_wait_for_queue_state ""

   ####################################
   # test queue calender disabled state 
   ####################################
   #
   # after adding the calendar "always disabled"
   replace_attr "queue" "calendar" "always_disabled" "reporting"
   reporting_wait_for_queue_state "D"
   # test queue default state (after adding the calendar disabling in one minute)
   set time1 [expr [timestamp] + 120]
   set time2 [expr $time1 + 600];# test will probably fail when running over midnight
   set cal(calendar_name) "reporting"
   set cal(year) "[clock format $time1 -format "%d.%m.%Y"]"
   append cal(year) "=[clock format $time1 -format "%H:%M"]"
   append cal(year) "-[clock format $time2 -format "%H:%M"]"
   append cal(year) "=off"
   mod_calendar "reporting" cal
   replace_attr "queue" "calendar" "reporting" "reporting"
   reporting_wait_for_queue_state ""
   # test queue calender disabled state (when calendar time reached)
   wait_for_queue_state [get_queue_instance "reporting" $reporting_test_host] "D" 180
   reporting_wait_for_queue_state "D"
   # test queue default state (after removing the calendar)
   replace_attr "queue" "calendar" "NONE" "reporting"
   reporting_wait_for_queue_state ""

   #####################################
   # test queue calender suspended state
   #####################################
   #
   # after adding the calendar "always suspended"
   replace_attr "queue" "calendar" "always_suspend" "reporting"
   reporting_wait_for_queue_state "C"
   # test queue default state (after adding the calendar suspending in one minute)
   set time1 [expr [timestamp] + 120]
   set time2 [expr $time1 + 600];# test will probably fail when running over midnight
   set cal(calendar_name) "reporting"
   set cal(year) "[clock format $time1 -format "%d.%m.%Y"]"
   append cal(year) "=[clock format $time1 -format "%H:%M"]"
   append cal(year) "-[clock format $time2 -format "%H:%M"]"
   append cal(year) "=suspended"
   mod_calendar "reporting" cal
   replace_attr "queue" "calendar" "reporting" "reporting"
   reporting_wait_for_queue_state ""
   # test queue calender suspended state (when calendar time reached)
   wait_for_queue_state [get_queue_instance "reporting" $reporting_test_host] "C" 180
   reporting_wait_for_queue_state "C"
   # test queue default state (after removing the calendar)
   replace_attr "queue" "calendar" "NONE" "reporting"
   reporting_wait_for_queue_state ""

   ###########################
   # test queue ambigous state
   ###########################
   replace_attr "queue" "load_thresholds" "NONE,\[@allhosts=load_avg=10\],\[@reporting=load_avg=20\]" "reporting"
   wait_for_queue_state [get_queue_instance "reporting" $reporting_test_host] "c" 60
   reporting_wait_for_queue_state "c"
   purge_queue "reporting@@reporting" "load_thresholds"
   reporting_wait_for_queue_state ""

   ###########################
   # test queue orphaned state
   ###########################
   set job_id [submit_job "-o /dev/null -j y -q reporting -b y sleep 60"]
   trigger_scheduling
   wait_for_jobstart $job_id "" 60
   replace_attr "queue" "hostlist" "NONE" "reporting"
   reporting_wait_for_queue_state "o"
   delete_job $job_id 1
   replace_attr "queue" "hostlist" "$reporting_test_host" "reporting"
   #reporting_wait_for_queue_state ""

   # shutdown tail -f
   close_logfile_wait
}
