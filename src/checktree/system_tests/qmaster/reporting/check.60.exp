#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

#****** checks/reporting *******************************************************
#  NAME
#     reporting -- check reporting functionality
#
#  FUNCTION
#     The purpose of this testsuite check is to test the qmaster repoting file
#     generation.
#
#     It tests the following features:
#        - account_flush_time reporting param
#
#     It should test the following features:
#        - all reporting params
#        - accounting file contents
#        - reporting file contents
#        - reporting of events
#        - reporting of sharelog data
#*******************************************************************************
#
# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "no"

# define a level initialization procedure:
set check_init_level_procedure "reporting_init_level"

# define test's name and run level descriptions
set check_name            "reporting"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   0
set check_description(0)  "Test reporting parameters and qmaster reporting"

# define test's dependencies
set check_needs           "init_core_system" 


# setup and cleanup functions
set check_setup_function reporting_setup
set check_cleanup_function reporting_cleanup

# define test's procedure order
set check_functions {}
lappend check_functions "reporting_periodic_accounting_test"
lappend check_functions "reporting_immediate_accounting_test"
lappend check_functions "reporting_reporting_accounting_test"

global reporting_old_config reporting_acct_file

proc reporting_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------


proc reporting_setup  {} {
   global ts_config CHECK_OUTPUT
   global reporting_old_config reporting_acct_file reporting_test_host

   # Delete any jobs that might be in the system
   delete_all_jobs

   # Archive old config
   get_config reporting_old_config

   # Enable immediate scheduling
   set schedd_conf(flush_submit_sec) 1
   set schedd_conf(flush_finish_sec) 1
   set_schedd_config schedd_conf

   # Create a queue with one slot
   set reporting_test_host [host_conf_get_suited_hosts 1]
   set queue_conf(slots) 1
   add_queue "reporting" $reporting_test_host queue_conf

   # Find accounting file
   set reporting_acct_file "$ts_config(product_root)/$ts_config(cell)/common/accounting"
}

proc reporting_cleanup {} {
   global reporting_old_config reporting_test_host

   # Restore old config
   set_config reporting_old_config
   reset_schedd_config

   # remove test host
   del_queue "reporting" $reporting_test_host 0 1

}

proc reporting_do_accounting_test {scenario} {
   global ts_config CHECK_ARCH CHECK_PRODUCT_ROOT CHECK_USER CHECK_HOST
   global CHECK_OUTPUT reporting_acct_file

   # Check accounting file size
   # we might be the first test after installation - in this case no accounting file exists
   if {![file exists $reporting_acct_file]} {
      set f [open $reporting_acct_file w]
      puts $f "# new accounting file"
      close $f
   }
   set mtime [file mtime $reporting_acct_file]

   # Submit job
   # we submit an array job of short running sleepers 
   # to a queue with one slot
   set script "$ts_config(product_root)/examples/jobs/sleeper.sh"
   set job_id [submit_job "-t 1-100 -o /dev/null -j y -q reporting $script 1"]
   if {$job_id <= 0} {
      # error message has been generated by submit_job
      return
   }

   # Watch accounting file for updates.
   # Wait for the first accounting file update
   set done 0
   while {!$done} {
      set new_mtime [file mtime $reporting_acct_file]

      if {$mtime != $new_mtime} {
         set done 1
      }
   }

   set failed 0

   # Watch the accounting file for one flush interval
   # The accounting file should not change between flush intervals
   while {[clock seconds] < [expr $new_mtime + 14]} {
      after 1000

      if {$new_mtime != [file mtime $reporting_acct_file]} {
         add_proc_error $scenario -1 "accounting file was flushed before flush interval"
         set failed 1
         break
      }
   }

   if {$failed != 1} {
      # The accounting file should change at flush intervals
      after 1000

      if {$new_mtime == [file mtime $reporting_acct_file]} {
         add_proc_error $scenario -1 "accounting file was not flushed at flush interval"
      }
   }

   # Delete any jobs that might be in the system
   delete_all_jobs
}

proc reporting_periodic_accounting_test {} {
   # Set accounting_flush_time to 00:00:15
   set new_config(reporting_params) "accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00 accounting_flush_time=00:00:15"
   set_config new_config

   reporting_do_accounting_test reporting_periodic_accounting_test
}

proc reporting_reporting_accounting_test {} {
   # Do not set accounting_flush_time.  Set flush_time to 00:00:15
   set new_config(reporting_params) "accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00"
   set_config new_config

   reporting_do_accounting_test reporting_reporting_accounting_test
}

proc reporting_immediate_accounting_test {} {
   global ts_config CHECK_ARCH CHECK_PRODUCT_ROOT CHECK_USER CHECK_HOST
   global CHECK_OUTPUT reporting_acct_file

   # Set accounting_flush_time to 00:00:00
   set new_config(reporting_params) "accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00 accounting_flush_time=00:00:00"
   set_config new_config

   # Check accounting file size
   set mtime [file mtime $reporting_acct_file]

   # Submit job
   set options "-o /dev/null -j y -sync yes -q reporting"
   set script "$ts_config(product_root)/examples/jobs/sleeper.sh 10"
   set job_id [submit_job "$options $script"]

   if {$job_id <= 0} {
      # error message has been generated in submit_job
      return
   }

   # Check accounting file mtime
   set new_mtime [file mtime $reporting_acct_file]
   if {$mtime == $new_mtime} {
       add_proc_error "reporting_immediate_accounting_test" -1 "accounting file was not flushed before job finish event"
       return
   }

   # Do it again to be sure
   # Submit job
   set job_id [submit_job "$options $script"]

   if {$job_id <= 0} {
      # error message has been generated in submit_job
      return
   }

   # Check accounting file mtime
   if {$new_mtime == [file mtime $reporting_acct_file]} {
       add_proc_error "reporting_immediate_accounting_test" -1 "accounting file was not flushed before job finish event"
       return
   }
}
