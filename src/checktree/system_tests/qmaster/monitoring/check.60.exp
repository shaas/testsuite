#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

#####################
#
# Test description:
#------------------
#
# - Tests the monitoring output for the messages file and qping
# - it tests:
#  - enabling monitoring
#  - disabling monitoring
#  - disabling monitoring by removing the monitoring param
#  - disabling monitoring for the message file
#  - enabling monitoring for the message file
#  - test if monitoring is started on a qmaster start
#

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qmaster_monitoring_init_level"

# define test's name and run level descriptions
set check_name            "qmaster_monitoring"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "check qmaster monitoring"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function qmaster_monitoring_setup
set check_cleanup_function qmaster_monitoring_cleanup

# define test's procedure order
set check_functions ""
lappend check_functions "qmaster_monitoring_dynamic"
lappend check_functions "qmaster_monitoring_restart"
lappend check_functions "qmaster_monitoring_dynamic_qping"
lappend check_functions "qmaster_monitoring_restart_qping"

proc qmaster_monitoring_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" { 
         return 0
      } 
   } 

   return -1  ;# no other level 
}

# -------- local test procedures: initialization------------------------------
proc parse_monitor_tet { line } {
   set split_line [split $line ": ()|,"]

   set index 0

   foreach elem $split_line {
      puts "<$index>:$elem"
      incr index 1
   }
}


proc qmaster_monitoring_setup  {} {
   global CHECK_OUTPUT ts_config
   global global_config

   # backup global config - we'll change it
   puts $CHECK_OUTPUT "backup global config"
   get_config global_config

   set_error 0 "ok"
}

proc qmaster_monitoring_cleanup  {} {
   global CHECK_OUTPUT ts_config
   global global_config

   puts $CHECK_OUTPUT "reset global config"
   set_config global_config

   set_error 0 "ok"
}



proc qmaster_monitoring_monitor {id expected_prof qping {tail_timeout 20}} {
   global CHECK_OUTPUT

   # some information output
   switch -exact $expected_prof {
      NONE {
         puts $CHECK_OUTPUT "expecting that no monitoring message shows up the next $tail_timeout s"
      }
      CONSUME {
         puts $CHECK_OUTPUT "consuming messages for $tail_timeout s"
      }
      default {
         puts $CHECK_OUTPUT "expecting monitoring messages showing up within the next $tail_timeout s"
      }
   }

   # initialize counters for monitoring messages
   set prof(SIGT) 0
   set prof(MT) 0
   set prof(EDT) 0
   set prof(TET) 0

   # this is the spawn id of our tail to qmaster messages file
   set sp_id [lindex $id 1]

   # the time period we wait for messages
   set now [clock seconds]
   set end [expr $now + $tail_timeout]

   # wait until timeout
   while {$now < $end} {
      set timeout 1
      expect_user {
         -i $sp_id timeout {
            # output how long we'll still wait
            puts $CHECK_OUTPUT "[expr $end -$now]\r"
         }
         -i $sp_id full_buffer {
            add_proc_error qmaster_monitoring_monitor -1 "buffer overflow, please increase CHECK_EXPECT_MATCH_MAX_BUFFER"
         }
         -i $sp_id eof {
            add_proc_error qmaster_monitoring_monitor -1 "unexpected eof"
         }
         -i $sp_id "?*\n" {
            # parse new lines in messages file
            #puts $CHECK_OUTPUT "received new line in messages file"
            if { $qping == 1 } {
               foreach line [ string trim [split $expect_out(0,string) "\n"]] {
                  set line [string trim $line]
                  if {[string length $line] > 0} {
                     #puts $CHECK_OUTPUT "processing line: $line"
                     set split_line [split $line "|"]
                     set message [lindex $split_line 1]
                        switch -glob -- $message {
                           "*SIGT: runs*" {
                              incr prof(SIGT)
                           }
                           "*MT(*): runs*" {
                              incr prof(MT)
                              #parse_monitor_tet $message
                           }
                           "*EDT: runs*" {
                              incr prof(EDT)
                              set tmp [lindex $split_line 2]
                              set message "$message $tmp"
                              #parse_monitor_tet $message
                           }
                           "*TET: runs*" {
                              incr prof(TET)
                              #parse_monitor_tet $message
                           }
                           default {
#     puts $CHECK_OUTPUT "unknown monitoring message $message"
                           }
                        }
                     } ;# if
                  } ;# foreach
               
            } else {
               foreach line [ string trim [split $expect_out(0,string) "\n"]] {
                  set line [string trim $line]
                  if {[string length $line] > 0} {
                     #puts $CHECK_OUTPUT "processing line: $line"
                     set split_line [split $line "|"]
                     set monitoring [lindex $split_line 3]   
                     set message [lindex $split_line 4]
                     switch -glob -- $monitoring {
                        "P" {
                           switch -glob -- $message {
                              "SIGT*" {
                                 incr prof(SIGT)
                              }
                              "MT(*)*" {
                                 incr prof(MT)
                                 #parse_monitor_tet $message
                              }
                              "EDT*" {
                                 incr prof(EDT)
                                 set tmp [lindex $split_line 5]
                                 set message "$message $tmp"
                                 #parse_monitor_tet $message
                              }
                              "TET*" {
                                 incr prof(TET)
                                 #parse_monitor_tet $message
                              }
                              default {
                            #     puts $CHECK_OUTPUT "unknown monitoring message $message"
                              }
                           }
                        }
                        default {
                        #   puts $CHECK_OUTPUT "ignoring: [string range $line 0 50] ..."
                        }
                     } ;# switch
                  } ;# valid line
               } ;# foreach line  
            } ;
         } ;# data
      } ;# switch

      set now [clock seconds]
   } ;# while

   # some informational output
   puts $CHECK_OUTPUT "SIGT: $prof(SIGT)"
   puts $CHECK_OUTPUT "MT:   $prof(MT)"
   puts $CHECK_OUTPUT "EDT:  $prof(EDT)"
   puts $CHECK_OUTPUT "TET:  $prof(TET)"

   # now check for the expected result
   puts $CHECK_OUTPUT "verifying results"
   switch -exact $expected_prof {
      NONE {
         # here we may not have received any monitoring messages
         set error 0
         set message "expected no monitoring message to show up, but got"
         foreach thread "SIGT MT EDT TET" {
            if {$prof($thread) > 0} {
               set error 1
               append message "\n$prof($thread) $thread monitoring messages"
            }
         }

         if {$error} {
            add_proc_error qmaster_monitoring_monitor -1 $message
         }
      }
      CONSUME {
         # no check here
      }
      default {
         # here we shall have expected n messages for the requested thread, 
         # 0 messages for the other ones
         set error 0
         set message "expected $expected_prof monitoring messages to show up, but got"
         foreach thread "MT EDT TET" {
            if {$prof($thread) == 0} {
               set error 1
               append message "\n$prof($thread) $thread monitoring messages"
            }
         }

         if {$error} {
            add_proc_error qmaster_monitoring_monitor -1 $message
         }
      }
   }   
}


proc qmaster_monitoring_dynamic_qping {} {
   global CHECK_OUTPUT ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   set ps_interval 4
   set qping_host $ts_config(master_host)
   set qping_arch [resolve_arch $qping_host]
   puts $CHECK_OUTPUT "starting qping monitor on host $qping_host"
   set id [ open_remote_spawn_process $qping_host $CHECK_FIRST_FOREIGN_SYSTEM_USER "$ts_config(product_root)/bin/$qping_arch/qping" "-i $ps_interval -f $ts_config(master_host) $ts_config(commd_port) qmaster 1"]      
   
   # wait for monitoring messages - no such messages may show up
   qmaster_monitoring_monitor $id NONE 1

   set prof "MONITOR_TIME"
   
   puts $CHECK_OUTPUT "testing monitoring $prof"

# 1)
# check, wether the monitoring works
#

   # switch on monitoring
   set global_conf(qmaster_params) "$prof=0:0:1"
   set_config global_conf

   # wait for monitoring messages for this thread
   qmaster_monitoring_monitor $id $prof 1

# 3)
# check, wether the log monitoring messages has no effect on qping output
#

   set global_conf(qmaster_params) "$prof=0:0:1,LOG_MONITOR_MESSAGE=false"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id $prof 1

   set global_conf(qmaster_params) "$prof=0:0:1,LOG_MONITOR_MESSAGE=true"
   set_config global_conf

   # wait for monitoring messages for this thread
   qmaster_monitoring_monitor $id $prof 1
   
# 4)
# check, wether the set to 0 turns the monitoring off
#
   
   # switch off monitoring
   set global_conf(qmaster_params) "$prof=0:0:0"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME  1 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 1

# 5)
# check, wether the NONE switch turns the monitoring off
#

   # switch on monitoring
   set global_conf(qmaster_params) "$prof=0:0:1"
   set_config global_conf

   # wait for monitoring messages for this thread
   qmaster_monitoring_monitor $id $prof 1

   set global_conf(qmaster_params) "NONE"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME 1 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 1


   
   # stop the tail -f
   close_spawn_process $id

   set_error 0 "ok"
}

proc qmaster_monitoring_dynamic {} {
   global CHECK_OUTPUT ts_config

   # tail -f to qmaster messages file
   puts $CHECK_OUTPUT "tail -f to qmaster messages file"
   set spooldir [get_qmaster_spool_dir]
   set id [init_logfile_wait $ts_config(master_host) "$spooldir/messages"]

   
   # wait for monitoring messages - no such messages may show up
   qmaster_monitoring_monitor $id NONE 0

   set prof "MONITOR_TIME"
   
   puts $CHECK_OUTPUT "testing monitoring $prof"

# 1)
# check, wether the monitoring works
#
   # switch on monitoring
   set global_conf(qmaster_params) "$prof=0:0:1"
   set_config global_conf

   # wait for monitoring messages for this thread
   qmaster_monitoring_monitor $id $prof 0

# 2)
# check, wether the log monitoring message to false turns the messages off
#

   set global_conf(qmaster_params) "$prof=0:0:1,LOG_MONITOR_MESSAGE=false"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME  0 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 0

# 3)
# check, wether the log monitoring messages to true turns the messages on
#

   set global_conf(qmaster_params) "$prof=0:0:1,LOG_MONITOR_MESSAGE=true"
   set_config global_conf

   # wait for monitoring messages for this thread
   qmaster_monitoring_monitor $id $prof 0

# 4)
# check, wether the set to 0 turns the monitoring off
#

   # switch off monitoring
   set global_conf(qmaster_params) "$prof=0:0:0"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME  0 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 0

# 5)
# check, wether the NONE switch turns the monitoring off
#

   # switch on monitoring
   set global_conf(qmaster_params) "$prof=0:0:1"
   set_config global_conf

   # wait for monitoring messages for this thread
   qmaster_monitoring_monitor $id $prof 0

   set global_conf(qmaster_params) "NONE"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME  0 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 0
   
# done, shutdown test

   # stop the tail -f
   close_spawn_process $id

   set_error 0 "ok"
}



proc qmaster_monitoring_restart {} {
   global CHECK_OUTPUT ts_config

   # tail -f to qmaster messages file
   puts $CHECK_OUTPUT "tail -f to qmaster messages file"
   set spooldir [get_qmaster_spool_dir]
   set id [init_logfile_wait $ts_config(master_host) "$spooldir/messages"]

   # enable some monitoring level
   set global_conf(qmaster_params) "MONITOR_TIME=0:0:1"
   set_config global_conf

   # wait for monitoring messages to show up
   qmaster_monitoring_monitor $id MT 0

   # shutdown qmaster
   shutdown_qmaster $ts_config(master_host) $spooldir

   # restart qmaster
   startup_qmaster 0

   # wait for monitoring messages
   qmaster_monitoring_monitor $id MT 0
   
   # switch off monitoring
   set global_conf(qmaster_params) "MONITOR_TIME=0:0:0"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME 0 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 0


   
   # stop the tail -f
   close_spawn_process $id

   set_error 0 "ok"
}

proc qmaster_monitoring_restart_qping {} {
   global CHECK_OUTPUT ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   set spooldir [get_qmaster_spool_dir]

   set ps_interval 4
   set qping_host $ts_config(master_host)
   set qping_arch [resolve_arch $qping_host]
   puts $CHECK_OUTPUT "starting qping monitor on host $qping_host"
   set id [ open_remote_spawn_process $qping_host $CHECK_FIRST_FOREIGN_SYSTEM_USER "$ts_config(product_root)/bin/$qping_arch/qping" "-i $ps_interval -f $ts_config(master_host) $ts_config(commd_port) qmaster 1"]  
      
   # enable some monitoring level
   set global_conf(qmaster_params) "MONITOR_TIME=0:0:1"
   set_config global_conf

   # wait for monitoring messages to show up
   qmaster_monitoring_monitor $id MT 1

   # shutdown qmaster
   shutdown_qmaster $ts_config(master_host) $spooldir

   # restart qmaster
   startup_qmaster 0

   # wait for monitoring messages
   qmaster_monitoring_monitor $id MT 1

   # switch off monitoring
   set global_conf(qmaster_params) "MONITOR_TIME=0:0:0"
   set_config global_conf
   # consume monitoring messages that may have shown up while we switched monitoring off
   qmaster_monitoring_monitor $id CONSUME 1 10

   # no further message may appear
   qmaster_monitoring_monitor $id NONE 1

   # stop the tail -f
   close_spawn_process $id

   set_error 0 "ok"
}

