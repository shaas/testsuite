#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "submit_del_init_level"

# define test's name and run level descriptions
set check_name            "submit_del"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "delete immediate submitted job (signaling test)"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "submit_del_setup"
set check_cleanup_function "submit_del_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "submit_del_test"

proc submit_del_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

global submit_del_qconfig
global submit_del_check_queue

proc submit_del_setup  {} {
   global ts_config
   global CHECK_OUTPUT CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_MAIN_RESULTS_DIR CHECK_USER
   global submit_del_qconfig CHECK_PRODUCT_ROOT
   global submit_del_check_queue

   if { $ts_config(gridengine_version) == 53 } {
      get_config submit_del_qconfig
      set my_config(schedd_params) "FLUSH_SUBMIT_SEC=0"
      set_config my_config
   } else {
      set my_schedd_conf(flush_submit_sec) "1"
      set_schedd_config my_schedd_conf
   }   

   set_error 0 "ok"
}

proc submit_del_test { } {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global submit_del_qconfig submit_del_check_queue CHECK_USER
   global CHECK_HOST CHECK_PRODUCT_ROOT CHECK_DEBUG_LEVEL
   global CHECK_L10N ts_config

   set arch [resolve_arch $CHECK_HOST]
   set qsub_program "$CHECK_PRODUCT_ROOT/bin/$arch/qsub"
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"
   set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

   set job_list ""
   foreach host $ts_config(execd_nodes) {
      set arguments "-o /dev/null -e /dev/null -l h=$host $job_script"
      lappend job_list [submit_job $arguments ]
   }

   foreach job $job_list {
      wait_for_jobstart $job "Sleeper" 60 1 1
   }

   set catch_result [delete_all_jobs]

   wait_for_end_of_all_jobs 180

   if { $CHECK_L10N == 1 } {
         if { $ts_config(gridengine_version) == 53 } {
            set JOB_SUBMITTED       [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "*" "*" "*"]
            set JOB_SUBMITTED_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "__JOB_ID__" "__JOB_NAME__" "__JOB_ARG__"]
         } else {
            set JOB_SUBMITTED       [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "*" "*"]
            set JOB_SUBMITTED_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "__JOB_ID__" "__JOB_NAME__"]
         }
         set job_id_pos [ string first "__JOB_ID__" $JOB_SUBMITTED_DUMMY ]
         set job_name_pos [ string first "__JOB_NAME__" $JOB_SUBMITTED_DUMMY ]
         if { $job_id_pos > $job_name_pos  } {
            add_proc_error "submit_del_test" "-1" "locale switches parameter for qsub string! This is not supported yet"
         }
         incr job_id_pos -1
         set job_id_prefix [ string range $JOB_SUBMITTED_DUMMY 0 $job_id_pos ]
         set job_id_prefix_length [ string length $job_id_prefix]
         puts $CHECK_OUTPUT "job id prefix is: \"$job_id_prefix\""
   }

   set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

   set runs [ expr ( [llength $ts_config(execd_nodes) ] * 5 ) ]
   while { $runs > 0 } { 
      foreach host $ts_config(execd_nodes) {
         set arguments "-o /dev/null -e /dev/null -l h=$host"
         set catch_return [ catch { eval exec "$qsub_program $arguments $job_script" } result ]
         puts $CHECK_OUTPUT $result
         if { $CHECK_L10N == 0 } {   
            set job_id [lindex $result 2]    
         } else {
            set id_pos [string first $job_id_prefix $result]
            incr id_pos $job_id_prefix_length
            set job_id [string range $result $id_pos end]
            set space_pos [ string first " " $job_id ]
            set job_id [string range $job_id 0 $space_pos ]
            set job_id [string trim $job_id]
         }
         puts $CHECK_OUTPUT "job id is: $job_id"
         wait_for_jobstart $job_id "leeper" 60
         puts $CHECK_OUTPUT "job $job_id started, deleting it"
         set catch_return [ catch { eval exec "$qdel_program $job_id" } result ]
         puts $CHECK_OUTPUT $result
         incr runs -1
      }
   }
   set runs [ expr ( [llength $ts_config(execd_nodes) ] * 5 ) ]

   wait_for_end_of_all_jobs 180
   puts $CHECK_OUTPUT "pass 1 completed"
   
   incr job_id 1  ;# prepare job_id for next job !!!
   while { $runs > 0 } { 
      foreach host $ts_config(execd_nodes) {
         set arguments "-o /dev/null -e /dev/null -l h=$host"

         set result [start_remote_prog $CHECK_HOST $CHECK_USER "qsub" "$arguments $job_script \nqdel $job_id"]
         puts $CHECK_OUTPUT $result 
         incr job_id 1
         incr runs -1
      }
   }
   
   wait_for_end_of_all_jobs 180

   puts $CHECK_OUTPUT "pass 2 completed"
   set_error 0 "ok"
}


proc submit_del_cleanup  {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global submit_del_qconfig submit_del_check_queue


   if {$ts_config(gridengine_version) == 53} {
      set_config submit_del_qconfig
   } else {
      reset_schedd_config
   }

   delete_all_jobs
   wait_for_end_of_all_jobs 100

   puts $CHECK_OUTPUT "do qmod -c for all queues"
   foreach hostname $ts_config(execd_nodes) {
      set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c [get_queue_instance all.q $hostname]" } output ]
      puts $CHECK_OUTPUT $output
   }

   set_error 0 "ok"
}

