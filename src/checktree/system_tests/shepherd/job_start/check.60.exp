#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__



#****** system_tests/shepherd/job_start *************************************************
#  NAME
#     job_start
#
#  FUNCTION
#     Run level short: check only one execd host
#     Run level medium: check all execd hosts with differenct architectures
#     
#     This check will change the spooling directories of each execd to
#     cell, NFS-ROOT2NOBODY, NFS-ROOT2ROOT and local and sumbit various job
#     types (qsub, qsh, qrsh, qrlogin, qlogin and tight_integrated). After
#     The job(s) were running the content of the sheperd trace files are
#     parsed and compared with expected values.
#
#
#*******************************************************************************


# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "job_start_init_level"

# define test's name and run level descriptions
set check_name            "job_start"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   102
set check_description(0)   "test shepherd trace file write on admin  user system"
set check_description(1)   "test shepherd trace file write on root   user system"
set check_description(2)   "test shepherd trace file write on normal user system"
set check_description(100) "test shepherd trace file write on admin  user system (on all architectures in cluster)"
set check_description(101) "test shepherd trace file write on root   user system (on all architectures in cluster)"
set check_description(102) "test shepherd trace file write on normal user system (on all architectures in cluster)"







# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function job_start_setup
set check_cleanup_function job_start_cleanup



# define test's procedure order
set check_functions ""
lappend check_functions "job_start_test"


global job_start_stored_configuration  

proc job_start_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" { 
         return 0
      } 
      "1" {
         return 0
      }
      "2" {
         return 0
      }
      "100" {
         return 0
      }
      "101" {
         return 0
      }
      "102" {
         return 0
      }
   } 

   return -1  ;# no other level 
}




# -------- local test procedures: initialization------------------------------


proc job_start_setup  {} {
   global CHECK_OUTPUT ts_config  job_start_stored_configuration 
   puts $CHECK_OUTPUT "\n--- Setup ---"

   puts $CHECK_OUTPUT "saving actual configuration ..."   
   get_config job_start_stored_configuration
   set my_job_start_schedd_config(schedule_interval) "0:0:01"
   set_schedd_config my_job_start_schedd_config 

   # create parallel environment
   set pe(pe_name)            tight_job_start
   set pe(slots)              1000
   set pe(user_lists)         none
   set pe(xuser_lists)        none
   set pe(start_proc_args)    none
   set pe(stop_proc_args)     none
   set pe(allocation_rule)    "\$round_robin"
   set pe(control_slaves)     TRUE
   set pe(job_is_first_task)  FALSE
   add_pe pe
   assign_queues_with_pe_object all.q "" tight_job_start

   set_error 0 "ok"
}

proc job_start_cleanup  {} {
   global CHECK_OUTPUT ts_config job_start_stored_configuration

   puts $CHECK_OUTPUT "--- Cleanup ---"
   delete_all_jobs
   wait_for_end_of_all_jobs 60

   puts $CHECK_OUTPUT "restoring original configuration ..."
   reset_schedd_config
   set_config job_start_stored_configuration
   

   del_pe tight_job_start


   switch_to_admin_user_system


   set_error 0 "ok"
}


proc job_start_test {} {
   global job_start_test_hosts check_description CHECK_ARCH CHECK_USER ts_user_config
   global CHECK_OUTPUT ts_config CHECK_CORE_MASTER CHECK_ACT_LEVEL CHECK_SCRIPT_FILE_DIR
   global CHECK_DISPLAY_OUTPUT
   puts $CHECK_OUTPUT $check_description($CHECK_ACT_LEVEL)

   set root_id 0


   # First select user system for the runlevel
   if { $CHECK_ACT_LEVEL == 0 || $CHECK_ACT_LEVEL == 100 } {
      if { [switch_to_admin_user_system] != 0 } {
         set_error -3 "can't run test shepherd/job_start for admin user system"
         return
      }
   }

   if { $CHECK_ACT_LEVEL == 1 || $CHECK_ACT_LEVEL == 101 } {    
      if { [switch_to_root_user_system ] != 0 } {
         set_error -3 "can't run test shepherd/job_start for root user system"
         return
      }
   }

   if { $CHECK_ACT_LEVEL == 2 || $CHECK_ACT_LEVEL == 102 } {
      if { [switch_to_normal_user_system ] != 0 } {
         set_error -3 "can't run test shepherd/job_start for normal user system"
         return
      }
   }

   get_config act_configuration

   # Setting execd_params to KEEP_ACTIVE=true
   set my_execd_params "KEEP_ACTIVE=true"
   if { [string compare "none" $act_configuration(execd_params)] != 0 } {
      append my_execd_params ",$act_configuration(execd_params)"
   }
   set myconfig(execd_params) "$my_execd_params"
   set myconfig(load_report_time) "00:00:02"
   puts $CHECK_OUTPUT "setting execd_param to \"$my_execd_params\" ..."
   set_config myconfig
 

   set type_list {}
   lappend type_list "cell"
   lappend type_list "NFS-ROOT2NOBODY"
   lappend type_list "NFS-ROOT2ROOT"
   lappend type_list "local"   ;# this has to be the last one (original testsuite spool directory) 


   set hosts_to_check {}
   foreach host $ts_config(unique_arch_nodes) {
      lappend hosts_to_check $host
      if { $CHECK_ACT_LEVEL < 100 } {
         break   ;# only one host for this runlevel(s)
      }
   }

   foreach spool_type $type_list {
      # set correct spool type for all execd hosts
      puts $CHECK_OUTPUT "using \"$spool_type\" spool directory for:"
      foreach host $hosts_to_check {
         set spool_dir [get_execd_spooldir $host $spool_type]
         if { $spool_dir == "" } {
            add_proc_error "job_start_test" -1 "can't get spool dir type \"$spool_type\" for host $host"
            set_error 0 "ok" ;# only for testsuite (add_proc_error already added error
            return
         }
         puts $CHECK_OUTPUT "   $host: setting spool dir $spool_dir ..."
         if { [switch_execd_spool_dir $host $spool_type 1] != 0 } {
            add_proc_error "job_start_test" -1 "can't set execd spool dir type \"$spool_type\" for host $host"
            set_error 0 "ok" ;# only for testsuite (add_proc_error already added error
            return
         }
      }

      # test all job types for each execd host
      set job_type {}
      lappend job_type "qsub"
      lappend job_type "qsh"
      lappend job_type "qrsh"
      lappend job_type "qrlogin"
      lappend job_type "qlogin"
      lappend job_type "tight_integrated"
      
      foreach host $hosts_to_check {
         get_config execd_host_config $host
         get_queue all.q all_queue_config


         foreach jobt $job_type {
            set job_id [submit_wait_type_job $jobt $host $ts_user_config(second_foreign_user) qacct_info]

            set current_run_text    "\n"
            append current_run_text "Running $jobt job as user $ts_user_config(second_foreign_user)\n"
            append current_run_text "on host $host with spooling type \"$spool_type\"\n\n"
            append current_run_text "XWindow display set to $CHECK_DISPLAY_OUTPUT\n\n"
            if { $jobt == "qsh" && $job_id <= 0 } {
               append current_run_text "YOU HAVE TO SET the XWindow display correctly for qsh jobs.\n"
               append current_run_text "Also check if you have enabled the host to use your display (check with xhost command).\n"
               append current_run_text "You can set your display by modifying the testsuite user configuration file!\n\n"
            }
            append current_run_text "$jobt Error:\n\n"
   
            if { $job_id <= 0 } {
               add_proc_error "job_start_test" -1 "$current_run_text Skipping further job result test! Continue with next job ..."
               continue
            }



            switch -exact $jobt {
               "qlogin" {
                  set expected_trace_status      9   ;# killed by qdel (signal 9)
                  set expected_trace_WIFSIGNALED 1   ;# yes a signaled exit
                  set expected_trace_WIFEXITED   0   ;# no normal exit 
                  set expected_qacct_exit_state  137 ;# 128 + 9
               }
               "qsh" {
                  set expected_trace_status      9   ;# killed by qdel (signal 9)
                  set expected_trace_WIFSIGNALED 1   ;# yes a signaled exit
                  set expected_trace_WIFEXITED   0   ;# no normal exit 
                  set expected_qacct_exit_state  137 ;# 128 + 9
               }
               "tight_integrated" {
                  set expected_trace_status      0
                  set expected_trace_WIFSIGNALED 0
                  set expected_trace_WIFEXITED   1
                  set expected_qacct_exit_state  0  
                  set expected_job_run_time      30
               }

               default {
                  set expected_trace_status      0
                  set expected_trace_WIFSIGNALED 0
                  set expected_trace_WIFEXITED   1
                  set expected_qacct_exit_state  0  
                  set expected_job_run_time      5
               }
            }

            puts $CHECK_OUTPUT "job $job_id run successful"
#           foreach name [array names qacct_info] {
#              puts $CHECK_OUTPUT "=> qacct_info($name) = $qacct_info($name)"
#           }
            switch -exact $jobt {
               "tight_integrated" {
                  puts $CHECK_OUTPUT "exit state of master task is [lindex $qacct_info(exit_status) 0]"
                  puts $CHECK_OUTPUT "exit state of slave  task is [lindex $qacct_info(exit_status) 1]"
               }
               default {
                  puts $CHECK_OUTPUT "exit state is $qacct_info(exit_status)"
               }
            }
            
            # get trace file
            set spool_dir [get_execd_spooldir $host $spool_type]
            set jobs_dir $spool_dir/$host/active_jobs/$job_id.1
            set trace_file        $jobs_dir/trace
            set exit_status_file  $jobs_dir/exit_status
            set error_file        $jobs_dir/error
            set usage_file        $jobs_dir/usage

            puts $CHECK_OUTPUT "trace file:       $trace_file"
            puts $CHECK_OUTPUT "exit_status file: $exit_status_file"
            puts $CHECK_OUTPUT "error file:       $error_file"


            wait_for_remote_file $host $ts_user_config(second_foreign_user) $trace_file 
            wait_for_remote_file $host $ts_user_config(second_foreign_user) $exit_status_file 
            wait_for_remote_file $host $ts_user_config(second_foreign_user) $error_file 
            wait_for_remote_file $host $ts_user_config(second_foreign_user) $usage_file 


            puts $CHECK_OUTPUT "reading $trace_file ..."
            set trace_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $trace_file prg_exit_state 10]
#            puts $CHECK_OUTPUT "---\n$trace_output\n---"
            puts $CHECK_OUTPUT "reading $error_file ..."
            set error_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $error_file prg_exit_state 10]
#            puts $CHECK_OUTPUT "---\n$error_output\n---"
            puts $CHECK_OUTPUT "doing ls -n $jobs_dir ..."
            set file_perms_output [start_remote_prog $host $ts_user_config(second_foreign_user) ls "-n $jobs_dir" prg_exit_state 10] 
#            puts $CHECK_OUTPUT "---\n$file_perms_output\n---"

            if { $jobt == "qrsh" || $jobt == "qrlogin" } {
               puts $CHECK_OUTPUT "reading $usage_file ..."
               set usage_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $usage_file prg_exit_state 10]
   #            puts $CHECK_OUTPUT "---\n$usage_output\n---"
               set usage_output [split $usage_output "\r\n"]
               foreach line_a $usage_output {
                  set line [string trim $line_a]
                  if { $line != "" } {
                     if { [string match "*exit_status*" $line ] } {
                        set exit_status_output [get_string_value_between "exit_status=" -1 $line ]
                        puts $CHECK_OUTPUT "exit_status:  $exit_status_output"
                     }
                  }
               }
            } else {
               puts $CHECK_OUTPUT "reading $exit_status_file ..."
               set exit_status_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $exit_status_file prg_exit_state 10]
   #           puts $CHECK_OUTPUT "---\n$exit_status_output\n---"
            }

            puts $CHECK_OUTPUT "checking all information ..."
            if { [lindex $qacct_info(exit_status) 0] != $expected_qacct_exit_state } {
               add_proc_error "job_start_test" -1 "$current_run_text qacct exit_status doesn't match expected exit state $expected_qacct_exit_state"
            }         

            if { [lindex $qacct_info(exit_status) 0] != $exit_status_output && $expected_trace_WIFEXITED == 1 } {
               add_proc_error "job_start_test" -1 "$current_run_text exit_status_file doesn't match qacct exit_status"
            }

            if { [string trim $error_output] != "" } {
               add_proc_error "job_start_test" -1 "$current_run_text error_file is not empty: \"$error_output\""
            }

            
            if { $jobt == "tight_integrated" } {
               set tight_jobs_dir "$jobs_dir/1.$host"
               set tight_trace_file        $tight_jobs_dir/trace
               set tight_exit_status_file  $tight_jobs_dir/exit_status
               set tight_error_file        $tight_jobs_dir/error
               puts $CHECK_OUTPUT "tight trace file:       $tight_trace_file"
               puts $CHECK_OUTPUT "tight exit_status file: $tight_exit_status_file"
               puts $CHECK_OUTPUT "tight error file:       $tight_error_file"

               wait_for_remote_file $host $ts_user_config(second_foreign_user) $tight_trace_file 
               wait_for_remote_file $host $ts_user_config(second_foreign_user) $tight_exit_status_file 
               wait_for_remote_file $host $ts_user_config(second_foreign_user) $tight_error_file 

               set tight_trace_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $tight_trace_file prg_exit_state 60]
#               puts $CHECK_OUTPUT "---\n$tight_trace_output\n---"

               set tight_exit_status_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $tight_exit_status_file prg_exit_state 60]
#               puts $CHECK_OUTPUT "---\n$tight_exit_status_output\n---"

               set tight_error_output [start_remote_prog $host $ts_user_config(second_foreign_user) cat $tight_error_file prg_exit_state 60]
#               puts $CHECK_OUTPUT "---\n$tight_error_output\n---"

               set tight_file_perms_output [start_remote_prog $host $ts_user_config(second_foreign_user) ls "-n $tight_jobs_dir" prg_exit_state 60] 
#               puts $CHECK_OUTPUT "---\n$tight_file_perms_output\n---"

               if { [lindex $qacct_info(exit_status) 0] != $expected_qacct_exit_state } {
                  add_proc_error "job_start_test" -1 "$current_run_text qacct exit_status of master task doesn't match expected exit state $expected_qacct_exit_state: [lindex $qacct_info(exit_status) 0] != $expected_qacct_exit_state"
               }         

               set slave_qacct_info [lindex $qacct_info(exit_status) 1];
               if { $slave_qacct_info != $tight_exit_status_output && $expected_trace_WIFEXITED == 1 } {
                  add_proc_error "job_start_test" -1 "$current_run_text exit_status_file doesn't match qacct slave task exit_status:  $slave_qacct_info != $tight_exit_status_output && $expected_trace_WIFEXITED == 1"
               }

               if { [string trim $tight_error_output] != "" } {
                  add_proc_error "job_start_test" -1 "$current_run_text error_file is not empty for slave task: \"$tight_error_output\""
               }
            }


            # check files for correct file owner permissions
            set admin_uid [get_uid $CHECK_USER $host]
            puts $CHECK_OUTPUT "my admin_uid is \"$admin_uid\""

            set uid [get_uid $ts_user_config(second_foreign_user) $host]
            puts $CHECK_OUTPUT "my uid is \"$uid\""
            
            set gid [get_gid $ts_user_config(second_foreign_user) $host]
            puts $CHECK_OUTPUT "my gid is \"$gid\""

            set test_files {}
            lappend test_files $trace_file
            lappend test_files $exit_status_file
            lappend test_files $error_file

            if { $jobt == "tight_integrated" } {
               lappend test_files $tight_trace_file
               lappend test_files $tight_exit_status_file
               lappend test_files $tight_error_file
            }

            foreach file $test_files {
               set file_uid [get_file_uid $ts_user_config(second_foreign_user) $host $file]
               set file_gid [get_file_gid $ts_user_config(second_foreign_user) $host $file]
               set file_perm [get_file_perm $ts_user_config(second_foreign_user) $host $file]

               puts $CHECK_OUTPUT "uid of file $file: $file_uid"
               puts $CHECK_OUTPUT "gid of file $file: $file_gid"
               #RD NFS-ROOT2NOBODY has other file permissions
               if { $spool_type == "NFS-ROOT2NOBODY" } {
                  if { $file_uid != $admin_uid } {
                     add_proc_error "job_start_test" -1 "$current_run_text uid($file_uid) of file \"$file\" doesn't match job uid($admin_uid)"
                  }
                  if { $file_perm != "-rw-rw-rw-" } {
                     add_proc_error "job_start_test" -1 "$current_run_text permission $file_uid of file \"$file\" doesn't match expected perm -rw-rw-rw-"
                  }
                  
               } else {
                  if { $file_uid != $uid } {
                     add_proc_error "job_start_test" -1 "$current_run_text uid($file_uid) of file \"$file\" doesn't match job uid($uid)"
                  }
                  if { $file_gid != $gid } {
                     add_proc_error "job_start_test" -1 "$current_run_text gid($file_gid) of file \"$file\" doesn't match job gid($gid)"
                  }
                  if { $file_perm != "-rw-r--r--" } {
                     add_proc_error "job_start_test" -1 "$current_run_text permission $file_uid of file \"$file\" doesn't match expected perm -rw-r--r--"
                  }
               }
            }


            # parse trace file of (master task) job

            # delete old parsing matches
            set found_array(1) 0
            if { [info exists found_array] } {
               unset found_array
            }

            set trace_output [split $trace_output "\r\n"]
            foreach line_a $trace_output {
               set line [string trim $line_a]
               if { $line != "" } {
#                  puts $CHECK_OUTPUT $line
                  if { [string match "*shepherd called with*" $line ] } {
                     set found_array(1) 1
                     set trace_pid_1 [get_string_value_between "\[" "\]" $line ] 
                     set trace_pid_1 [get_string_value_between ":" -1 $trace_pid_1 ] 

                     set trace_uid   [get_string_value_between "with uid = " ", euid = " $line ] 
                     set trace_euid  [get_string_value_between "euid = " -1 $line ] 

                     puts $CHECK_OUTPUT "pid 1: $trace_pid_1"
                     puts $CHECK_OUTPUT "uid:   $trace_uid"
                     puts $CHECK_OUTPUT "euid:  $trace_euid"

                     # check euid to be uid of admin user
                     if { $trace_euid != $admin_uid } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file euid(=$trace_euid) is not uid(=$admin_uid)"
                     }
                     # check uid of sheperd (root)
                     if { $trace_uid != $root_id } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file euid(=$trace_uid) is not uid(=$root_id)"
                     }
                  }

                  if { [string match "*setting limits*" $line ] } {
                     set found_array(2) 1
                     set trace_pid_2 [get_string_value_between "\[" "\]" $line ] 
                     set trace_pid_2 [get_string_value_between ":" -1 $trace_pid_2 ] 
                     puts $CHECK_OUTPUT "pid 2: $trace_pid_2"
                     
                     if { [info exists trace_pid_1] != 1 } {
                        add_proc_error "job_start_test" -1 "$current_run_text sheperd trace file doesn't contain \"shepherd called with\" string"
                        set trace_pid_1 "unknown"
                     }

                     if { $trace_pid_2 == $trace_pid_1 } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file doesn't have different pids: pid 1($trace_pid_1), pid2($trace_pid_2)"
                     }
                  }

                  if { [string match "*switching to intermediate/target user*" $line ] } {
                     set found_array(3) 1
                  }

                  if { [string match "*now running with uid*euid**" $line ] } {
                     set found_array(4) 1
                     set trace_running_uid  [get_string_value_between "uid=" ", euid" $line ] 
                     set trace_running_euid [get_string_value_between "euid=" -1 $line ] 
                     puts $CHECK_OUTPUT "trace_running_uid: $trace_running_uid"
                     puts $CHECK_OUTPUT "trace_running_euid: $trace_running_euid"

                     if { $trace_running_uid != $trace_running_euid } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file of job uid($trace_running_uid) != euid($trace_running_euid)"
                     }
                     if { $jobt == "qrsh" || $jobt == "qrlogin" || $jobt == "qlogin" } {
                        # RD: qsh deamons must run as root because they open /dev/*
                        if { $trace_running_uid != $root_id } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file doesn't start $jobt job with uid$root_id trace_running_uid = $trace_running_uid"
                        }
                     } else {
                        if { $trace_running_uid != $uid } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file doesn't start $jobt job with uid($uid) trace_running_uid = $trace_running_uid"
                        }
                     }
                  }

                  if { [string match "*execvp*" $line ] } {
                     set found_array(5) 1
                     set line_split [split $line " "]
                     foreach line_part $line_split {
                        puts $CHECK_OUTPUT $line_part
                     }

                     switch -exact $jobt {
                        "qsh" {
                           set trace_binary    [get_string_value_between "execvp(" "," [lindex $line_split 3 ] ]
                           set trace_argument1 [get_string_value_between "\"" "\"" [lindex $line_split 4 ] ]
                           set trace_argument2 [get_string_value_between "\"" "\"" [lindex $line_split 5 ] ]
                           set trace_argument3 [get_string_value_between "\"" "\"" [lindex $line_split 6 ] ]
                           set trace_argument4 [get_string_value_between "\"" "\"" [lindex $line_split 7 ] ]
                           set trace_argument5 [get_string_value_between "\"-n\" \"" "\" \"-e\"" $line ]
                           set trace_argument6 [get_string_value_between "\"" "\"" [lindex $line_split 17 ] ]
                           set trace_argument7 [get_string_value_between "\"" "\"" [lindex $line_split 18 ] ]

                           puts $CHECK_OUTPUT "trace_binary:    \"$trace_binary\""
                           puts $CHECK_OUTPUT "trace_argument1: \"$trace_argument1\""
                           puts $CHECK_OUTPUT "trace_argument2: \"$trace_argument2\""
                           puts $CHECK_OUTPUT "trace_argument3: \"$trace_argument3\""
                           puts $CHECK_OUTPUT "trace_argument4: \"$trace_argument4\""
                           puts $CHECK_OUTPUT "trace_argument5: \"$trace_argument5\""
                           puts $CHECK_OUTPUT "trace_argument6: \"$trace_argument6\""
                           puts $CHECK_OUTPUT "trace_argument7: \"$trace_argument7\""

                           if { $trace_binary != $execd_host_config(xterm) } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output binary doesn't match \"$execd_host_config(xterm)\": $trace_binary"
                           }
                           if { $trace_argument1 != $execd_host_config(xterm)  } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 1 doesn't match \"$execd_host_config(xterm)\": $trace_argument1"
                           }
                           if { $trace_argument2 != "-display" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 2 doesn't match \"-display\": $trace_argument2"
                           }
                           if { $trace_argument3 != "$CHECK_DISPLAY_OUTPUT" } {
                              # make this an "unsupported" warning - it depends on testsuite user config
                              # and user shell setup
                              add_proc_error "job_start_test" -3 "$current_run_text shepherd trace file execvp output arg 3 doesn't match \"$CHECK_DISPLAY_OUTPUT\": $trace_argument3"
                           }
                           if { $trace_argument4 != "-n" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 4 doesn't match \"-n\": $trace_argument4"
                           }
                           # we ignore argument 5 (xterm window text)

                           if { $trace_argument6 != "-e" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 6 doesn't match \"-e\": $trace_argument6"
                           }

                           puts $CHECK_OUTPUT "xterm shell: $all_queue_config(shell)"
                           if { $trace_argument7 != $all_queue_config(shell) } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 7 doesn't match \"$all_queue_config(shell)\" from queue config: $trace_argument7"
                           }
                        }
                        default {
                           set trace_binary    [get_string_value_between "execvp(" "," [lindex $line_split 3 ] ]
                           set trace_argument1 [get_string_value_between "\"" "\"" [lindex $line_split 4 ] ]
                           set trace_argument2 [get_string_value_between "\"" "\"" [lindex $line_split 5 ] ]
                           set trace_argument3 [get_string_value_between "\"" "\"" [lindex $line_split 6 ] ]

                           puts $CHECK_OUTPUT "trace_binary:    \"$trace_binary\""
                           puts $CHECK_OUTPUT "trace_argument1: \"$trace_argument1\""
                           puts $CHECK_OUTPUT "trace_argument2: \"$trace_argument2\""
                           puts $CHECK_OUTPUT "trace_argument3: \"$trace_argument3\""


                           if { $trace_binary != "/bin/sh" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output binary doesn't match \"/bin/sh\": $trace_binary"
                           }
                           if { $trace_argument1 != "-sh" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 1 doesn't match \"-sh\": $trace_argument1"
                           }
                           if { $trace_argument2 != "$spool_dir/$host/job_scripts/$job_id" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 2 doesn't match \"$spool_dir/$host/job_scripts/$job_id\": $trace_argument2"
                           }
                           if { $trace_argument3 != $expected_job_run_time } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 3 doesn't match \"$expected_job_run_time\": $trace_argument3"
                           }
                        }
                     }
                  }

                  if { [string match "*calling qlogin_starter*" $line ] } {
                     set found_array(5) 1
                     puts $CHECK_OUTPUT $line

                     set line [get_string_value_between "qlogin_starter(" ");" $line]
                     puts $CHECK_OUTPUT $line
                     set line_split [split $line ","]
                     foreach line_part $line_split {
                        puts $CHECK_OUTPUT $line_part
                     }
                     set trace_job_dir   [string trim [lindex $line_split 0 ]]
                     set trace_daemon    [string trim [lindex $line_split 1 ]]

                     puts $CHECK_OUTPUT "trace_job_dir: \"$trace_job_dir\""
                     puts $CHECK_OUTPUT "trace_daemon:  \"$trace_daemon\""

                     if { $trace_job_dir != $jobs_dir } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job dir \"$jobs_dir\": $trace_job_dir"
                     }
                     switch -exact $jobt {
                        "qrlogin" {
                           if { $trace_daemon != $execd_host_config(rlogin_daemon) } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job daemon \"$execd_host_config(rlogin_daemon)\": $trace_daemon"
                           }
                        }
                        "qlogin" {
                           if { $trace_daemon != $execd_host_config(qlogin_daemon) } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job daemon \"$execd_host_config(qlogin_daemon)\": $trace_daemon"
                           }
                        }
                        default {
                           # using rshd from gridengine source 
                           set host_arch [resolve_arch $host]
                           set expected_trace_daemon "$ts_config(product_root)/utilbin/$host_arch/rshd"
                           set trace_daemon_split [split $trace_daemon " "]
                           set trace_daemon [lindex $trace_daemon_split 0]
                           set trace_daemon_arg [lindex $trace_daemon_split 1]
                           puts $CHECK_OUTPUT "trace_rshd:     \"$trace_daemon\""
                           puts $CHECK_OUTPUT "trace_rshd_arg: \"$trace_daemon_arg\""
                           
                           if { $trace_daemon != $expected_trace_daemon } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job daemon \"$expected_trace_daemon\": $trace_daemon"
                           }
                           if { $trace_daemon_arg != "-l" } {
                              add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job daemon \"-l\": $trace_daemon_arg"
                           }
                        }
                     }
                  }
                  


#08/25/2005 11:45:28 [115091:13995]: wait3 returned 13996 (status: 0; WIFSIGNALED: 0,  WIFEXITED: 1, WEXITSTATUS: 0)

                  if { [string match "*wait3 returned*(status*" $line ] } {
                     set found_array(6) 1

                     set trace_wait_return [get_string_value_between "wait3 returned" "(status" $line ]
                     set trace_status      [get_string_value_between "(status:" "; WIFSIGNALED:" $line ]
                     set trace_WIFSIGNALED [get_string_value_between "WIFSIGNALED:" ",  WIFEXITED:" $line ]
                     set trace_WIFEXITED   [get_string_value_between "WIFEXITED:" ", WEXITSTATUS:" $line ]
                     set trace_WEXITSTATUS [get_string_value_between "WEXITSTATUS:" ")" $line ]

                     puts $CHECK_OUTPUT "trace_wait_return: \"$trace_wait_return\""
                     puts $CHECK_OUTPUT "trace_status:      \"$trace_status\""
                     puts $CHECK_OUTPUT "trace_WIFSIGNALED: \"$trace_WIFSIGNALED\""
                     puts $CHECK_OUTPUT "trace_WIFEXITED:   \"$trace_WIFEXITED\""
                     puts $CHECK_OUTPUT "trace_WEXITSTATUS: \"$trace_WEXITSTATUS\""

                     if { $trace_wait_return != $trace_pid_2 } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match child pid($trace_pid_2): $trace_wait_return"
                     }


                     if { $trace_status != $expected_trace_status } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match status($expected_trace_status): got $trace_status"
                     }

                     if { $trace_WIFSIGNALED != $expected_trace_WIFSIGNALED } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match WIFSIGNALED($expected_trace_WIFSIGNALED): got $trace_WIFSIGNALED"
                     }

                     if { $trace_WIFEXITED != $expected_trace_WIFEXITED } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match WIFEXITED($expected_trace_WIFEXITED): got $trace_WIFEXITED"
                     }

                     if { $trace_WEXITSTATUS != $exit_status_output } {
                        add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match WEXITSTATUS($exit_status_output): got $trace_WEXITSTATUS"
                     }
                  }

                  if { [string match "*job exited with exit status*" $line ] } {
                     set found_array(7) 1

                     set trace_job_exit_status [get_string_value_between "exit status" -1 $line ]
                     puts $CHECK_OUTPUT "trace_job_exit_status: \"$trace_job_exit_status\""

                     if { $trace_WIFSIGNALED != 0 } {
                       set job_signal_id [lindex $qacct_info(exit_status) 0]
                       incr job_signal_id -128
                       if { $job_signal_id != $trace_status } {
                          add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file job exit status value doesn't match 128 + $job_signal_id : $trace_job_exit_status"
                       }
                     } else {
                       if { $trace_job_exit_status != [lindex $qacct_info(exit_status) 0] } {
                          add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file job exit status value doesn't match qacct exit status([lindex $qacct_info(exit_status) 0]): $trace_job_exit_status"
                       }
                     }
                  }


               }
            }

            for { set index 1 } { $index <= 7 } { incr index 1 } {
               if { [info exists found_array($index)] } {
                  puts $CHECK_OUTPUT "found index $index"
               } else {
                  add_proc_error "job_start_test" -1 "$current_run_text can't find index $index in shepherd trace file"
               }
            }



            # only for tight_integrated
            if { $jobt == "tight_integrated" } {

               # delete old parsing matches
               set found_array(1) 0
               if { [info exists found_array] } {
                  unset found_array
               }
              
               set trace_output [split $tight_trace_output "\r\n"]
               foreach line_a $trace_output {
                  set line [string trim $line_a]
                  if { $line != "" } {
                     if { [string match "*shepherd called with*" $line ] } {
                        set found_array(1) 1
                        set trace_pid_1 [get_string_value_between "\[" "\]" $line ] 
                        set trace_pid_1 [get_string_value_between ":" -1 $trace_pid_1 ] 

                        set trace_uid   [get_string_value_between "with uid = " ", euid = " $line ] 
                        set trace_euid  [get_string_value_between "euid = " -1 $line ] 

                        puts $CHECK_OUTPUT "pid 1: $trace_pid_1"
                        puts $CHECK_OUTPUT "uid:   $trace_uid"
                        puts $CHECK_OUTPUT "euid:  $trace_euid"

                        # check euid to be uid of admin user
                        if { $trace_euid != $admin_uid } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file euid(=$trace_euid) is not uid(=$admin_uid)"
                        }
                        # check uid of sheperd (root)
                        if { $trace_uid != $root_id } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file euid(=$trace_uid) is not uid($root_id)"
                        }
                     }

                     if { [string match "*setting limits*" $line ] } {
                        set found_array(2) 1
                        set trace_pid_2 [get_string_value_between "\[" "\]" $line ] 
                        set trace_pid_2 [get_string_value_between ":" -1 $trace_pid_2 ] 
                        puts $CHECK_OUTPUT "pid 2: $trace_pid_2"
                        
                        if { $trace_pid_2 == $trace_pid_1 } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file doesn't have different pids: pid 1($trace_pid_1), pid2($trace_pid_2)"
                        }
                     }

                     if { [string match "*switching to intermediate/target user*" $line ] } {
                        set found_array(3) 1
                     }

                     if { [string match "*now running with uid*euid**" $line ] } {
                        set found_array(4) 1
                        set trace_running_uid  [get_string_value_between "uid=" ", euid" $line ] 
                        set trace_running_euid [get_string_value_between "euid=" -1 $line ] 
                        puts $CHECK_OUTPUT "trace_running_uid: $trace_running_uid"
                        puts $CHECK_OUTPUT "trace_running_euid: $trace_running_euid"

                        if { $trace_running_uid != $trace_running_euid } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file of job uid($trace_running_uid) != euid($trace_running_euid)"
                        }
                        # RD: qsh deamons must run as root because they open /dev/*
                        if { $trace_running_uid != $root_id } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file doesn't start $jobt job with uid($root_id) trace_running_uid = $trace_running_uid"
                        }
                     }

                     if { [string match "*execvp*" $line ] } {
                        set found_array(5) 1
                        set line_split [split $line " "]
                        foreach line_part $line_split {
                           puts $CHECK_OUTPUT $line_part
                        }

                        set trace_binary    [get_string_value_between "execvp(" "," [lindex $line_split 3 ] ]
                        set trace_argument1 [get_string_value_between "\"" "\"" [lindex $line_split 4 ] ]
                        set trace_argument2 [get_string_value_between "\"" "\"" [lindex $line_split 5 ] ]
                        set trace_argument3 [get_string_value_between "\"" "\"" [lindex $line_split 6 ] ]

                        puts $CHECK_OUTPUT "trace_binary:    \"$trace_binary\""
                        puts $CHECK_OUTPUT "trace_argument1: \"$trace_argument1\""
                        puts $CHECK_OUTPUT "trace_argument2: \"$trace_argument2\""
                        puts $CHECK_OUTPUT "trace_argument3: \"$trace_argument3\""


                        if { $trace_binary != "/bin/sh" } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output binary doesn't match \"/bin/sh\": $trace_binary"
                        }
                        if { $trace_argument1 != "-sh" } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 1 doesn't match \"-sh\": $trace_argument1"
                        }
                        if { $trace_argument2 != "$spool_dir/$host/job_scripts/$job_id" } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 2 doesn't match \"$spool_dir/$host/job_scripts/$job_id\": $trace_argument2"
                        }
                        if { $trace_argument3 != $expected_job_run_time } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file execvp output arg 3 doesn't match \"$expected_job_run_time\": $trace_argument3"
                        }
                     }

                     if { [string match "*calling qlogin_starter*" $line ] } {
                        set found_array(5) 1
                        puts $CHECK_OUTPUT $line

                        set line [get_string_value_between "qlogin_starter(" ");" $line]
                        puts $CHECK_OUTPUT $line
                        set line_split [split $line ","]
                        foreach line_part $line_split {
                           puts $CHECK_OUTPUT $line_part
                        }
                        set trace_job_dir   [string trim [lindex $line_split 0 ]]
                        set trace_daemon    [string trim [lindex $line_split 1 ]]

                        puts $CHECK_OUTPUT "trace_job_dir: \"$trace_job_dir\""
                        puts $CHECK_OUTPUT "trace_daemon:  \"$trace_daemon\""

                        if { $trace_job_dir != $tight_jobs_dir } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job dir \"$tight_jobs_dir\": $trace_job_dir"
                        }
                        # using rshd from gridengine source 
                        set host_arch [resolve_arch $host]
                        set expected_trace_daemon "$ts_config(product_root)/utilbin/$host_arch/rshd"
                        set trace_daemon_split [split $trace_daemon " "]
                        set trace_daemon [lindex $trace_daemon_split 0]
                        set trace_daemon_arg [lindex $trace_daemon_split 1]
                        puts $CHECK_OUTPUT "trace_rshd:     \"$trace_daemon\""
                        puts $CHECK_OUTPUT "trace_rshd_arg: \"$trace_daemon_arg\""
                        
                        if { $trace_daemon != $expected_trace_daemon } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job daemon \"$expected_trace_daemon\": $trace_daemon"
                        }
                        if { $trace_daemon_arg != "-l" } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file qlogin_starter output job daemon \"-l\": $trace_daemon_arg"
                        }
                     }
                     

                     if { [string match "*wait3 returned*(status*" $line ] } {
                        set found_array(6) 1

                        set trace_wait_return [get_string_value_between "wait3 returned" "(status" $line ]
                        set trace_status      [get_string_value_between "(status:" "; WIFSIGNALED:" $line ]
                        set trace_WIFSIGNALED [get_string_value_between "WIFSIGNALED:" ",  WIFEXITED:" $line ]
                        set trace_WIFEXITED   [get_string_value_between "WIFEXITED:" ", WEXITSTATUS:" $line ]
                        set trace_WEXITSTATUS [get_string_value_between "WEXITSTATUS:" ")" $line ]

                        puts $CHECK_OUTPUT "trace_wait_return: \"$trace_wait_return\""
                        puts $CHECK_OUTPUT "trace_status:      \"$trace_status\""
                        puts $CHECK_OUTPUT "trace_WIFSIGNALED: \"$trace_WIFSIGNALED\""
                        puts $CHECK_OUTPUT "trace_WIFEXITED:   \"$trace_WIFEXITED\""
                        puts $CHECK_OUTPUT "trace_WEXITSTATUS: \"$trace_WEXITSTATUS\""

                        if { $trace_wait_return != $trace_pid_2 } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match child pid($trace_pid_2): $trace_wait_return"
                        }


                        if { $trace_status != $expected_trace_status } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match status($expected_trace_status): got $trace_status"
                        }

                        if { $trace_WIFSIGNALED != $expected_trace_WIFSIGNALED } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match WIFSIGNALED($expected_trace_WIFSIGNALED): got $trace_WIFSIGNALED"
                        }

                        if { $trace_WIFEXITED != $expected_trace_WIFEXITED } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match WIFEXITED($expected_trace_WIFEXITED): got $trace_WIFEXITED"
                        }

                        if { $trace_WEXITSTATUS != $exit_status_output } {
                           add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file wait3 return value doesn't match WEXITSTATUS($exit_status_output): got $trace_WEXITSTATUS"
                        }
                     }

                     if { [string match "*job exited with exit status*" $line ] } {
                        set found_array(7) 1

                        set trace_job_exit_status [get_string_value_between "exit status" -1 $line ]
                        puts $CHECK_OUTPUT "trace_job_exit_status: \"$trace_job_exit_status\""

                        if { $trace_WIFSIGNALED != 0 } {
                          set job_signal_id [lindex $qacct_info(exit_status) 0]
                          incr job_signal_id -128
                          if { $job_signal_id != $trace_status } {
                             add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file job exit status value doesn't match 128 + $job_signal_id : $trace_job_exit_status"
                          }
                        } else {
                          if { $trace_job_exit_status != [lindex $qacct_info(exit_status) 0] } {
                             add_proc_error "job_start_test" -1 "$current_run_text shepherd trace file job exit status value doesn't match qacct exit status([lindex $qacct_info(exit_status) 0]): $trace_job_exit_status"
                          }
                        }
                     }


                  }
               }

               for { set index 1 } { $index <= 7 } { incr index 1 } {
                  if { [info exists found_array($index)] } {
                     puts $CHECK_OUTPUT "found index $index for slave job"
                  } else {
                     add_proc_error "job_start_test" -1 "$current_run_text can't find index $index in shepherd trace file for $jobt slave task job"
                  }
               }
            }
            

         }  ;# jobt
      }
   }

   set_error 0 "ok"
}


