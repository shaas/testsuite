#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name
global check_category
global check_description
global check_needs
global check_functions
global check_highest_level
global check_init_level_procedure
global check_root_access_needs

# define a level initialization procedure:
set check_init_level_procedure "qrsh_init_level"

# define test's name and run level descriptions
set check_name            "qrsh"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   200
set check_description(0)    "checking qrsh to one exec host (master)"
set check_description(200)  "checking qrsh to all exec hosts"

# define test's dependencies
set check_needs           "init_core_system"
set check_root_access_needs  "yes"

# setup and cleanup functions
set check_setup_level_function "qrsh_setup"
set check_cleanup_level_function "qrsh_cleanup"

# define test's procedure order
set check_functions {}
lappend check_functions "qrsh_function"              ;# is a job executed?
lappend check_functions "qrsh_h"                     ;# test -h option
lappend check_functions "qrsh_hold_jid"              ;# test -hold_jid option
lappend check_functions "qrsh_alltoall"              ;# qrsh from all hosts to all hosts
lappend check_functions "qrsh_starter_method"        ;# does the starter method work for qrsh?
lappend check_functions "qrsh_accounting"            ;# accounting and online usage (sgeee)
lappend check_functions "qrsh_suspend"               ;# suspend
lappend check_functions "qrsh_delete"                ;# delete
lappend check_functions "qrsh_terminate"             ;# test terminate method
lappend check_functions "qrsh_qsub_gid"              ;# qsub gid set correctly?
lappend check_functions "qrsh_batch"                 ;# run qrsh in batch mode
lappend check_functions "qrsh_limits"                ;# limits (e.g. cpu) passed correctly
lappend check_functions "qrsh_env"                   ;# test the -v VAR=val and -v VAR options
lappend check_functions "qrsh_reservation"           ;# test the -R y option
lappend check_functions "qrsh_sigterm_running_job"   ;# test CTRL-C for running job
lappend check_functions "qrsh_sigterm_pending_job"   ;# test CTRL-C for pending job
lappend check_functions "qrsh_notify"                ;# check signal handling

proc qrsh_init_level {} {
   global CHECK_ACT_LEVEL

   switch -exact $CHECK_ACT_LEVEL {
      0 -
      200 {
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------
proc qrsh_setup {} {
   global ts_config CHECK_ACT_LEVEL
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global qrsh_hostlist qrsh_submithost
   global QSUB_GID_USER QSUB_GID_GROUPS

   # setup hosts
   set qrsh_submithost $ts_config(master_host)
   switch -exact $CHECK_ACT_LEVEL {
      0 {
         set qrsh_hostlist [host_conf_get_suited_hosts]
      }
      200 {
         set qrsh_hostlist $ts_config(unique_arch_nodes)
      }
   }

   ts_log_fine "using submit host  $qrsh_submithost"
   ts_log_fine "using exec host(s) $qrsh_hostlist"

   # setup some user info
   set QSUB_GID_USER   $CHECK_FIRST_FOREIGN_SYSTEM_USER
   set QSUB_GID_GROUPS $CHECK_FIRST_FOREIGN_SYSTEM_GROUP
}

proc qrsh_cleanup {} {
   global qrsh_hostlist qrsh_submithost
   global QSUB_GID_USER QSUB_GID_GROUPS

   foreach var "qrsh_hostlist qrsh_submithost QSUB_GID_USER QSUB_GID_GROUPS" {
      if {[info exists $var]} {
         unset $var
      }
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

# -------- check functions -----------------------------------------------------

#                                                             max. column:     |
#****** qrsh/qrsh_function() ******
# 
#  NAME
#     qrsh_function -- ??? 
#
#  SYNOPSIS
#     qrsh_function { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_function {} {
   global ts_config CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "qrsh functional test"
   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host echo qrsh sucessfully started"]
      set sp_id [lindex $qrsh_id 1]
  
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "qrsh sucessfully started" {
            ts_log_fine "qrsh to host $host ok"
            exp_continue
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
         -i $sp_id default {
            ts_log_severe "qrsh to host $host failed"
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_notify() ******
# 
#  NAME
#     qrsh_notify -- Checks if started with -notify the signal forwarding is 
#                    is correct. 
#
#  SYNOPSIS
#     qrsh_notify { } 
#
#  FUNCTION
#     Starts a shell scripts which are waiting for SIGUSR(1|2) signal. 
#     Sends a SIGKILL and SIGSTOP signal to the scripts. Because of 
#     the -notify option these signals can be caught as SIGUSR1 and  
#     SIGUSR2 signals. 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_notify {} {
   global CHECK_ACTUAL_TEST_PATH
   global ts_config CHECK_USER
   global qrsh_submithost 

   set arch [resolve_arch $qrsh_submithost]

   # first test: signal forwarding
   # send SIGKILL -> qrsh job will get an SIGUSR2 before SIGKILL
   ts_log_fine "starting $ts_config(product_root)/bin/$arch/qrsh -notify $CHECK_ACTUAL_TEST_PATH/signalhandler.sh USR2"

   # start qrsh with bash script which is waiting for a SIGSTOP signal
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER \
        $ts_config(product_root)/bin/$arch/qrsh \
        "-notify -nostdin $CHECK_ACTUAL_TEST_PATH/signalhandler.sh USR2"]

   # figure out the job id  
   set sp_channel [lindex $qrsh_id 1]
   set output [start_remote_prog $qrsh_submithost $CHECK_USER \
        $ts_config(product_root)/bin/$arch/qstat "-u $CHECK_USER | grep \'signal\' "]
   set output [string trim $output]
   
   scan $output "%d " job_id
   ts_log_fine "Job id is: $job_id "

   # wait for first output of the remote script
   set timeout 20 
   expect {
      -i $sp_channel "running"  {
         ts_log_fine "job started "
      }      
      -i $sp_channel timeout {
         ts_log_severe "Got no output from job! Job seems not to be in running state" 
      }
   } 
 
   # send signal SIGKILL
   delete_job $job_id
   ts_log_fine "Job $job_id will be deleted!"

   set timeout 30 
   expect {
      -i $sp_channel full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_channel "Signal" {
         ts_log_fine "Successful transfer of the signal SIGKILL -> SIGUSR2."
      }
      -i $sp_channel timeout {
         ts_log_severe "Job did't cought signal!"
      }
   }

   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs

   # second test: signal forwarding
   # send SIGSTOP -> qrsh job will get an SIGUSR1 before SIGSTOP
   ts_log_fine "starting $ts_config(product_root)/bin/$arch/qrsh -notify $CHECK_ACTUAL_TEST_PATH/signalhandler.sh USR1"

   # start qrsh with bash script which is waiting for a SIGSTOP signal
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER \
        $ts_config(product_root)/bin/$arch/qrsh \
        "-notify -nostdin $CHECK_ACTUAL_TEST_PATH/signalhandler.sh USR1"]

   # figure out the job id  
   set sp_channel [lindex $qrsh_id 1]
   set output [start_remote_prog $qrsh_submithost $CHECK_USER \
        $ts_config(product_root)/bin/$arch/qstat "-u $CHECK_USER | grep \'signal\' "]
   set output [string trim $output]
   scan $output "%d " job_id
   
   ts_log_fine "Job id is: $job_id "   
   sleep 1
   # wait for first output of the remote script
   set timeout 10
   expect {
      -i $sp_channel "running"  {
         ts_log_fine "job started "
      }
      -i $sp_channel timeout {
         ts_log_severe "Got no output from job! Job seems not to be in running state" 
      }
   } 
   # send signal SIGSTOP
   suspend_job $job_id

   set timeout 30 
   expect {
      -i $sp_channel full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_channel "Signal" {
         ts_log_fine "Successful transfer of the signal SIGSTOP -> SIGUSR1."
      }
      -i $sp_channel timeout {
         ts_log_severe "Job did't cought signal!"
      }
   }

   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs
}


proc qrsh_h {} {
   global ts_config CHECK_USER
   global qrsh_submithost

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set job_id [submit_job $arguments]
   delete_job $job_id  ;# now we know the last job id

   incr job_id 1       ;# job id of next job !
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-h echo qrsh sucessfully started"]
   set sp_id [lindex $qrsh_id 1]

   trigger_scheduling
   wait_for_jobpending $job_id "echo" 60

   trigger_scheduling
   set run_result [get_standard_job_info $job_id]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [lindex $line 4]
      ts_log_fine "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if {$tmp_job_state != "hqw"} {
      ts_log_severe "qrsh -h job is not in pending state"
   }

   trigger_scheduling

   set timeout 15
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh sucessfully started" {
         ts_log_severe "qrsh -h failed"
      }
      -i $sp_id default {
         ts_log_fine "qrsh -h timeout for hold state ok, now releasing job $job_id"
      }
   }

   release_job $job_id
   trigger_scheduling

   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh sucessfully started" {
         ts_log_fine "qrsh -h ok"
      }
      -i $sp_id default {
         ts_log_severe "qrsh -h failed for job $job_id"
      }
   }

   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "_exit_status_:(*)*\n" {
         ts_log_fine "got exit status from script:\n$expect_out(buffer)"
      }
      -i $sp_id default {
         ts_log_severe "got timeout for job $job_id"
      }
   }

   close_spawn_process $qrsh_id

   wait_for_end_of_all_jobs
}

proc qrsh_hold_jid {} {
   global ts_config CHECK_USER
   global qrsh_submithost

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $ts_config(product_root)/examples/jobs/sleeper.sh 6000"
   set hold_job_id [submit_job $arguments]
   set job_id [expr $hold_job_id + 1]
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-hold_jid $hold_job_id echo qrsh sucessfully started"]
   set sp_id [lindex $qrsh_id 1]
  
   trigger_scheduling
   wait_for_jobpending $job_id "echo" 60

   trigger_scheduling
   set run_result [get_standard_job_info $job_id]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [ lindex $line 4 ]
      ts_log_fine "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if {$tmp_job_state != "hqw"} {
      ts_log_severe "qrsh -hold_jid job is not in pending state"
   }

   trigger_scheduling

   set timeout 15
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh sucessfully started" {
         ts_log_severe "qrsh -hold_jid failed"
      }
      -i $sp_id default {
         ts_log_fine "qrsh -hold_jid timeout for hold state ok, now deleting job $hold_job_id"
      }
   }

   delete_job $hold_job_id 1
   trigger_scheduling

   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh sucessfully started" {
         ts_log_fine "qrsh -hold_jid ok"
      }
      -i $sp_id default {
         ts_log_severe "qrsh -hold_jid failed for job $job_id"
      }
   }

   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "_exit_status_:(*)*\n" {
         ts_log_fine "got exit status from script:\n$expect_out(buffer)"
      }
      -i $sp_id default {
         ts_log_severe "qrsh -hold_jid failed for job $job_id"
      }
   }

   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_alltoall() ******
# 
#  NAME
#     qrsh_alltoall -- ??? 
#
#  SYNOPSIS
#     qrsh_alltoall { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_alltoall {} {
   global ts_config
   global CHECK_USER
   global qrsh_hostlist

   foreach source $qrsh_hostlist {
      set source_arch [resolve_arch $source]
      foreach dest $qrsh_hostlist {
         set qrsh_id [open_remote_spawn_process "$source" $CHECK_USER "$ts_config(product_root)/bin/$source_arch/qrsh" "-l hostname=$dest echo qrsh sucessfully started"]
         set sp_id [lindex $qrsh_id 1]
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id eof {
               ts_log_severe "open_remote_spawn_process closed connection (eof)"
            }
            -i $sp_id "qrsh sucessfully started" {
               ts_log_fine "qrsh from host $source to host $dest ok"
               exp_continue
            }
            -i $sp_id "_exit_status_:(*)*\n" {
               ts_log_fine "got exit status from script:\n$expect_out(buffer)"
            }
            -i $sp_id default {
               ts_log_severe "qrsh from host $source to host $dest failed"
            }
         }

         close_spawn_process $qrsh_id
      }
   }

   wait_for_end_of_all_jobs
}

proc qrsh_starter_method {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   mod_queue all.q "" change_array

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host echo qrsh sucessfully started"]
      set sp_id [lindex $qrsh_id 1] 
  
      set timeout 60
      set starter_method 0
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "starter method started" {
            set starter_method 1
            exp_continue
         }
         -i $sp_id "qrsh sucessfully started" {
            if {$starter_method == 0} {
               ts_log_severe "qrsh job started without starter_method on host $host"
            } else {
               ts_log_fine "qrsh to host $host ok"
            }
            exp_continue
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
         -i $sp_id default {
            ts_log_severe "qrsh to host $host failed"
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs

   # unset starter method
   set change_array(starter_method) "none"
   mod_queue "all.q" "" change_array
}

#                                                             max. column:     |
#****** qrsh/qrsh_accounting() ******
# 
#  NAME
#     qrsh_accounting -- ??? 
#
#  SYNOPSIS
#     qrsh_accounting { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_accounting {} {
   global ts_config CHECK_PRODUCT_TYPE
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   if {$ts_config(gridengine_version) == 53} {
      set INTERACTIVE_JOB [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_D "*"]
      set INTERACTIVE_JOB_DUMMY [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_D "__JOBID__"]
   } else {
      set INTERACTIVE_JOB [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S "*"]
      set INTERACTIVE_JOB_DUMMY [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S "__JOBID__"]
   }
   set job_id_start [string first "__JOBID__" $INTERACTIVE_JOB_DUMMY]

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-verbose -nostdin -l hostname=$host $ts_config(product_root)/examples/jobs/worker.sh 120"]
      
      set state startup
      set job_id ""
      set sp_id [lindex $qrsh_id 1] 

      while {[string compare $state exit] != 0} {
         set timeout 80
         expect {
            -i $sp_id full_buffer {
               ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set state exit
            }
            -i $sp_id eof {
               ts_log_severe "open_remote_spawn_process closed connection (eof)"
               set state exit
            }
            -i $sp_id timeout {
               # now (after 80s) the job should be running
               if {[string compare $state running]} {
                  ts_log_severe "qrsh to host $host failed"
                  set state exit
               } else {
                  # in sgeee mode, we can check the online usage
                  if {$CHECK_PRODUCT_TYPE == "sgeee"} {
                     if {$job_id == ""} {
                        ts_log_severe "unknown job_id for qrsh job on host $host"
                     } else {
                        if {[info exists job_info]} {
                           unset job_info
                        }
                        if {[get_extended_job_info $job_id] == 1} {
                           if {$job_info(cpu) < 10} {
                              ts_log_config "online usage probably does not work on $host"
                           }
                        } else {
                           ts_log_severe "get_extended_jobinfo failed for job $job_id on host $host"
                        }
                     }
                  }
               }
            }
            -i $sp_id $INTERACTIVE_JOB {
               ts_log_finer "jobstart: \"$expect_out(0,string)\""
               set job_id [string range $expect_out(0,string) $job_id_start end]
               set space_start [string first " " $job_id]
               set job_id [string range $job_id 0 $space_start]
               set job_id [string trim $job_id]
               ts_log_fine "job id is: \"$job_id\""
               set state scheduled
            }
            -i $sp_id "Forking" { ;# "Forking" printout is from worker job (utilbin/work.c)
               set state running
            }
            -i $sp_id "_exit_status_" {   ;# _exit_status_ is from open_remote_spawn_process - generated script
               if {[string compare $state running]} {
                  ts_log_severe "qrsh to host $host failed"
               }
               set state exit
            }
         }
      }

      close_spawn_process $qrsh_id

      # wait for accounting file to be flushed (esp. for 6.0) and NFS
      sleep 15

      if {$job_id != ""} {
         if {[get_qacct $job_id] == 0} {
            set cpu [expr $qacct_info(ru_utime) + $qacct_info(ru_stime)]
            if {$cpu < 30} {
               ts_log_severe "cpu entry \"$cpu\" in accounting seems to be wrong for job $job_id on host $host"
            }

            if {$CHECK_PRODUCT_TYPE == "sgeee"} {
               # compute absolute diffence between cpu and ru_utime + ru_stime
               set difference [expr $cpu - $qacct_info(cpu)]
               set difference [expr $difference * $difference]
               if {$difference > 2} {
                  ts_log_severe "accounting: cpu($qacct_info(cpu)) is not the sum of ru_utime and ru_stime ($cpu) for job $job_id on host $host"
               }
            }
         }
      }
   }

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_suspend() ******
# 
#  NAME
#     qrsh_suspend -- ??? 
#
#  SYNOPSIS
#     qrsh_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_suspend {} {
   global ts_config
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set running_states [host_get_running_states $host]
      set suspended_states [host_get_suspended_states $host]

      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host $ts_config(testsuite_root_dir)/scripts/work_pid.sh 60"]
      
      # evaluate pid and JOB_ID
      set sp_id [ lindex $qrsh_id 1 ] 

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "my pid is *\n" {
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
            ts_log_fine "job has pid $job_pid and job id $job_id"
         }
         -i $sp_id timeout {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id "_exit_status_" {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id eof {
            close_spawn_process $qrsh_id
            ts_log_severe "open_remote_spawn_process closed connection (eof)"
         }
      }

      # continue only, if job is running correctly
      if {[info exists job_pid] && [info exists job_id]} {
         # check process status (should be sleeping or running)
         get_ps_info $job_pid $host 
         
         if {$ps_info($job_pid,error) != 0} {
            close_spawn_process $qrsh_id
            ts_log_severe "cannot get info about process $job_pid on host $host"
            continue
         }
         ts_log_fine "job should be running"
         ts_log_fine $ps_info($job_pid,index_names) 
         ts_log_fine $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_states] == -1} {
            close_spawn_process $qrsh_id
            ts_log_severe "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)\nps output:\n$ps_info($job_pid,index_names)\n$ps_info($job_pid,string)"
            continue
         }

         # suspend job
         suspend_job $job_id
         sleep 10
         # process status should be suspended
         get_ps_info $job_pid $host
         if {$ps_info($job_pid,error) != 0} {
            ts_log_severe "cannot get info about process $job_pid on host $host"
            close_spawn_process $qrsh_id
            continue
         }
         ts_log_fine "job should be suspended"
         ts_log_fine $ps_info($job_pid,index_names) 
         ts_log_fine $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $suspended_states] == -1} {
            ts_log_severe "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
            close_spawn_process $qrsh_id
            continue
         }

         # unsuspend job
         unsuspend_job $job_id
         sleep 10
         # process status should be sleeping or running
         get_ps_info $job_pid $host
         if {$ps_info($job_pid,error) != 0} {
            ts_log_severe "cannot get info about process $job_pid on host $host"
            close_spawn_process $qrsh_id
            continue
         }
         ts_log_fine "job should be running"
         ts_log_fine $ps_info($job_pid,index_names) 
         ts_log_fine $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_states] == -1} {
            ts_log_severe "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
            close_spawn_process $qrsh_id
            continue
         }
      }

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh to host $host to finish"
         }
         -i $sp_id eof {
            ts_log_severe "open_remote_spawn_process closed connection (eof)"
         }
         -i $sp_id "_exit_status_" {
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_delete() ******
# 
#  NAME
#     qrsh_delete -- ??? 
#
#  SYNOPSIS
#     qrsh_delete { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_delete {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      set sp_id [ lindex $qrsh_id 1 ] 
 
      # evaluate pid and JOB_ID
      set timeout 60
      set error 0
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id "my pid is*" {
            ts_log_fine "got pid of job!"
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
         }
         -i $sp_id timeout {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed - timeout"
            set error 1
         }
         -i $sp_id eof {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed - eof"
            set error 1
         }
         
      }

      if {$error == 0} {
         if {[info exists job_pid] && [info exists job_id]} {
            # qdel 
            ts_log_fine "now deleting job $job_id ..."
            delete_job $job_id 1

            # check if shell script is still running
            get_ps_info $job_pid $host
            if {$ps_info($job_pid,error) == 0} {
               ts_log_severe "process of deleted job $job_pid on host $host is still running"
            } else {
               ts_log_fine "job is gone - ok !"
            }
         }
      }

      close_spawn_process $qrsh_id 1

      set q_state [get_queue_state "all.q@${host}"]
      if {[string first "E" $q_state] >= 0} {
         ts_log_severe "queue all.q@${host} goes to state \"$q_state\" after job deletion"
         delete_all_jobs ;# this will remove the E state
      }
   }
 
   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_terminate() ******
# 
#  NAME
#     qrsh_terminate -- ??? 
#
#  SYNOPSIS
#     qrsh_terminate { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_terminate {} {
   global ts_config CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist qrsh_submithost

   set terminate_out_file [get_tmp_file_name]

   # set terminate method
   set change_array(terminate_method) "$CHECK_ACTUAL_TEST_PATH/terminate.sh \$job_id \$job_pid $terminate_out_file"
   mod_queue "all.q" "" change_array

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      
      # evaluate pid and JOB_ID
      set sp_id [lindex $qrsh_id 1] 
      set error 0
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id timeout {
            ts_log_severe "qrsh to host $host failed - timeout"
            set error 1
         }
         -i $sp_id eof {
            ts_log_severe "qrsh to host $host failed - eof"
            set error 1
         }
         -i $sp_id "my pid is*" {
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
         }
      }

      if {$error == 1} {
         close_spawn_process $qrsh_id
         continue
      }

      if {[info exists job_pid] && [info exists job_id]} {
         get_ps_info $job_pid $host
         # qdel 
         delete_job $job_id

         for {set i 0} {$i < 60} {incr i} {
            after 1000
            start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
            if {$exit_code == 0} {
               ts_log_fine "terminate method has been started"
               break
            } else {
               ts_log_fine "waiting for terminate method"
            }
         }   

         # wait for terminate method to finish
         sleep 2
         # check contents of terminate.out
         set line [start_remote_prog $host $CHECK_USER cat $terminate_out_file exit_code]
         if {$exit_code != 0} {
            ts_log_severe "error reading from terminate method output file on host $host"
         } else {
            if {[scan $line "job_id=%d job_pid=%d" t_job_id t_job_pid] != 2} {
               ts_log_severe "error reading from terminate method output file on host $host"
            } else {
               # t_job_pid should be ppid of job_pid
               if {![info exists ps_info($job_pid,ppid)]} {
                  ts_log_severe "info about ppid of pid $job_pid not available on host $host"
               } else {
                  if {$ps_info($job_pid,ppid) != $t_job_pid} {
                     ts_log_severe "wrong job_pid passed to terminate method for job $job_id on host $host, should be $ps_info($job_pid,ppid) but is $t_job_pid"
                  }
               }
            }
         }
         # check if shell script is still running
         get_ps_info $job_pid $host
         if {$ps_info($job_pid,error) == 0} {
            ts_log_severe "process of deleted job $job_pid on host $host is still running"
         }
      }

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh to host $host to finish"
         }
         -i $sp_id eof {
            ts_log_severe "open_remote_spawn_process closed connection (eof)"
         }
         -i $sp_id "_exit_status_" {
         }
      }

      close_spawn_process $qrsh_id
   }

   # reset terminate method
   set change_array(terminate_method) "NONE"
   mod_queue "all.q" "" change_array

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/check_qsub_gid_output() ******
# 
#  NAME
#     check_qsub_gid_output -- ??? 
#
#  SYNOPSIS
#     check_qsub_gid_output { output check_group } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     output      - ??? 
#     check_group - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_qsub_gid_output {output check_group} {
   set substring [string range $output [string first "gid=" $output] end]
   set group [string trim [string range $substring [string first "(" $substring] [string first ")" $substring]] "()"]

   ts_log_fine "process was executed under user group $group"

   if {[string compare $group $check_group] == 0} {
      return 1
   } else {
      return 0
   }
}

proc qrsh_qsub_gid {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_PROTOCOL_DIR
   global QSUB_GID_USER QSUB_GID_GROUPS
   global qrsh_hostlist qrsh_submithost

   if {![host_has_newgrp $qrsh_submithost 0]} {
      ts_log_config "cannot run this test:\nqrsh submithost $qrsh_submithost doesn't have the newgrp command"
      return
   }

   if {$ts_config(gridengine_version) == 53 } {
      set USING_FOR     [translate_macro MSG_GDI_USING_SS "*USE_QSUB_GID=true*" "*"]
      set FINISHED_JOBS [translate_macro MSG_GDI_USING_SS "*finished_jobs*" "*"]
   } else {
      set USING_FOR     [translate_macro MSG_CONF_USING_SS "*USE_QSUB_GID=true*" "*"]
      set FINISHED_JOBS [translate_macro MSG_CONF_USING_SS "*finished_jobs*" "*"]
   }

   set submit_host_arch [resolve_arch $qrsh_submithost]

   foreach host $qrsh_hostlist {
      ts_log_fine "using host $host"
      # dump commandfile to file
      set f [open $CHECK_PROTOCOL_DIR/qrsh.sh w]
      set id_command [host_get_id_a_command $host]
      puts $f "$ts_config(product_root)/bin/$submit_host_arch/qrsh -l hostname=$host $id_command"
      close $f

      file attributes "$CHECK_PROTOCOL_DIR/qrsh.sh" -permissions 00755
      wait_for_remote_file $host $QSUB_GID_USER $CHECK_PROTOCOL_DIR/qrsh.sh

      # call qsub_gid.sh, gid must be primary gid
      set output [start_remote_prog $qrsh_submithost $QSUB_GID_USER "$CHECK_ACTUAL_TEST_PATH/qsub_gid.sh" "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 0]
      if {[check_qsub_gid_output $output $group] == 0} {
         ts_log_severe "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # set parameter USE_QSUB_GID
      get_config config $host
      if {[info exists config(execd_params)]} {
         set execd_params $config(execd_params)
      } else {
         set execd_params ""
      }

      if {$execd_params == ""} {
         set config(execd_params) "USE_QSUB_GID=true"
      } else {
         set config(execd_params) "$execd_params,USE_QSUB_GID=true"
      }
      set_config_and_propagate config $host
      
      # call qsub_gid.sh, gid must be secondary gid
      set output [start_remote_prog $qrsh_submithost $QSUB_GID_USER "$CHECK_ACTUAL_TEST_PATH/qsub_gid.sh" "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 1]
      if {[check_qsub_gid_output $output $group] == 0} {
         ts_log_severe "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # unset USE_QSUB_GID 
      unset config
      set config(execd_params) $execd_params
      set_config_and_propagate config $host
   }

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_batch() ******
# 
#  NAME
#     qrsh_batch -- ??? 
#
#  SYNOPSIS
#     qrsh_batch { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_batch {} {
   global ts_config
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "check qrsh in immediate and batch mode (-now yes / no)"
   set COULD_NOT_BE_SCHEDULED [translate_macro MSG_QSH_REQUESTCANTBESCHEDULEDTRYLATER_S "*" ]
   if { $ts_config(gridengine_version) == 53 } {
      set HAS_BEEN_SUBMITTED  [translate_macro MSG_JOB_SUBMITJOB_USS "*" "*" "*" ]
   } else {
      set HAS_BEEN_SUBMITTED  [translate_macro MSG_JOB_SUBMITJOB_US "*" "*"]
   }
   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set queue [get_queue_instance "all.q" $host]
      # disable queue
      disable_queue $queue
      ts_log_fine "queue should be disabled now ..."
      # start qrsh - must be rejected
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-q $queue -N immediate echo blahblah"]
      set sp_id [lindex $qrsh_id 1]

      # evaluate pid and JOB_ID
      set timeout 60
      set error 1
      log_user 1
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            ts_log_severe "qrsh -now yes ran despite no resources free on host $host"
         }
         -i $sp_id $COULD_NOT_BE_SCHEDULED {
            ts_log_fine "qrsh aborted correctly"
            set error 0
         } 
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh -now yes on host $host to fail due to lack of resources"
         }
         -i $sp_id eof {
            ts_log_severe "qrsh -now yes failed without error message on host $host"
         }
      }
      close_spawn_process $qrsh_id
 
      if {$error} {
         ts_log_severe "skipping test on host $host"
         enable_queue [get_queue_instance "all.q" $host]
         continue
      }

      # start qrsh -now no
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-verbose -q $queue -now no -N batch echo blahblah"]
      # must be in pending jobs
      set sp_id [lindex $qrsh_id 1] 

      set timeout 60
      log_user 1
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id eof {
            ts_log_severe "eof waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id $HAS_BEEN_SUBMITTED {
            set job_id [lindex $expect_out(0,string) 2]
            ts_log_fine "qrsh job $job_id correctly submitted"
            set error 0
         }
      }
      if {$error} {
         ts_log_severe "skipping test on host $host"
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      if {[get_extended_job_info $job_id] == 0} {
         ts_log_severe "no job info for job $job_id - skipping test on host $host"
         delete_job $job_id 1
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      if {$job_info(state) != "qw"} {
         ts_log_severe "state of job is $job_info(state), should be qw, skipping test on host $host"
         delete_job $job_id 1
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      # enable queue, trigger scheduling
      ts_log_fine "now enable the queue ..."
      enable_queue $queue
      trigger_scheduling

      # job must be scheduled
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            ts_log_fine "got qrsh job output as expected (blahblah)!"
         }
         -i $sp_id $COULD_NOT_BE_SCHEDULED { 
            ts_log_severe "message \"could not be scheduled\" should not occur with batch jobs"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh to be scheduled to host $host"
         }
         -i $sp_id eof {
            ts_log_severe "qrsh exited without executing command on host $host"
         }
      }

      # now wait for shell termination
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for exit_status on host $host"
         }
         -i $sp_id eof {
            ts_log_severe "got eof on host $host"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- ??? 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_limits {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "check if limits are propagated to qrsh jobs"
   set limit_in 10
   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host -l h_cpu=$limit_in $CHECK_ACTUAL_TEST_PATH/ulimit.sh"]
      set sp_id [lindex $qrsh_id 1]

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id eof {
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id "CPU limit is *\n" {
            set limit_out [lindex $expect_out(0,string) 3]
            ts_log_fine "qrsh to host $host ok, CPU limit is $limit_out s"

            if {$limit_out != $limit_in} {
               ts_log_severe "limit on host $host not correctly set"
            }
         }
      }

      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout error while waiting for exit_status on host $host"
         }
         -i $sp_id eof {
            ts_log_severe "got eof on host $host"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs 30 
}

proc qrsh_reservation {} {
   global ts_config
   global qrsh_submithost

   set output [start_sge_bin "qrsh" "-R y echo blahblah" $qrsh_submithost]
   if {$prg_exit_state != 0 || [string trim $output] != "blahblah"} {
      ts_log_severe "qrsh -R y failed - see Issue: 1306:\n$output"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

proc qrsh_env {} {
   global ts_config CHECK_USER
   global qrsh_submithost

   ts_log_fine "check if environment variables are set correctly"

   # Set a dummy env var
   set inherited_value "ThIsIsAtEsT"
   set explicit_value "tHiSiSoNlYaTeSt"
   set my_env(QRSH_ENV_TEST_DUMMY) $inherited_value

   # Test
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_bin "$ts_config(product_root)/bin/$arch/qrsh"
   set output [start_remote_prog $qrsh_submithost $CHECK_USER $qrsh_bin "-v QRSH_ENV_TEST_DUMMY 'echo \$QRSH_ENV_TEST_DUMMY'" prg_exit_state 60 0 "" my_env]
   if {[string compare [string trim $output] $inherited_value] != 0} {
      set error_text "qrsh did not inherit test environment variable: $inherited_value != $output\n"
      append error_text "Bug 1255: qrsh does not properly pass along environment variables"
      ts_log_severe $error_text
   }

   set output [start_remote_prog $qrsh_submithost $CHECK_USER $qrsh_bin "-v QRSH_ENV_TEST_DUMMY=$explicit_value 'echo \$QRSH_ENV_TEST_DUMMY'" prg_exit_state 60 0 "" my_env]
   if {[string compare [string trim $output] $explicit_value] != 0} {
      set error_text "qrsh did not inherit test environment variable: $explicit_value != $output\n"
      append error_text "Bug 1255: qrsh does not properly pass along environment variables"
      ts_log_severe $error_text
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- send CTRL-C to running job 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     Test if Issue 1639 exists
#
#  SEE ALSO
#     qrsh_sigterm_pending_job  
#*******************************

proc qrsh_sigterm_running_job {} {
   global ts_config
   global CHECK_USER
   global qrsh_submithost

   # start qrsh 
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER "$ts_config(product_root)/bin/$arch/qrsh" "\"echo started; sleep 3600\""]
   set sp_id [lindex $qrsh_id 1]

   # job must be scheduled
   set timeout 30
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id -- "started" {
         ts_log_fine "qrsh job started as expected!"
      }
      -i $sp_id timeout {
         ts_log_severe "timeout waiting for qrsh to be scheduled"
      }
   }

   # now terminate the connection - this will send a CTRL-C to the qrsh
   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs 60

   set output [start_sge_bin qstat "-s pr"]
   if {$prg_exit_state == 0} {
      if {$output == ""} {
         ts_log_fine "no further jobs in system"
      } else {
         ts_log_severe "CTRL-C for running qrsh job does not delete job - issue 1639:\n$output"
      }
   } else {
      ts_log_severe "error executing qstat -s pr:\n$output"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- send CTRL-C to pending job 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     Test if Issue 1639 exists
#
#  SEE ALSO
#     qrsh_sigterm_running_job  
#*******************************
proc qrsh_sigterm_pending_job {} {
   global ts_config
   global CHECK_USER
   global qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   # start qrsh 
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER "$ts_config(product_root)/bin/$arch/qrsh" "-now n -l arch=bla sleep 3600"]
   set sp_id [lindex $qrsh_id 1]

   set timer 10
   while {[get_job_info -1] == 0} {
      if {$timer == 0} {
         ts_log_severe "error submitting qrsh job"
         break
      }
      sleep 1
      incr timer -1
   }
  
   # now terminate the connection - this will send a CTRL-C to the qrsh
   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs 15

   set output [start_sge_bin qstat "-s pr"]
   if {$prg_exit_state == 0} {
      if {$output == ""} {
         ts_log_fine "no further jobs in system"
      } else {
         ts_log_severe "CTRL-C for pending qrsh job does not delete job - issue 1639:\n$output"
      }
   } else {
      ts_log_severe "error executing qstat -s pr:\n$output"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

