#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# define a level initialization procedure:
set check_init_level_procedure "qrsh_init_level"

# define test's name and run level descriptions
set check_name            "qrsh"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   200
set check_description(0)    "checking qrsh to one exec host (master)"
set check_description(200)  "checking qrsh to all exec hosts"

# define test's dependencies
set check_needs           "init_core_system" 
set check_root_access_needs  "yes"

# setup and cleanup functions
set check_cleanup_function "qrsh_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "qrsh_function"              ;# is a job executed?
lappend check_functions "qrsh_h"                     ;# test -h option
lappend check_functions "qrsh_hold_jid"              ;# test -hold_jid option
lappend check_functions "qrsh_alltoall"              ;# qrsh from all hosts to all hosts
lappend check_functions "qrsh_starter_method"        ;# does the starter method work for qrsh?
lappend check_functions "qrsh_accounting"            ;# accounting and online usage (sgeee)
lappend check_functions "qrsh_suspend"               ;# suspend
lappend check_functions "qrsh_delete"                ;# delete
lappend check_functions "qrsh_terminate"             ;# test terminate method
lappend check_functions "qrsh_qsub_gid"              ;# qsub gid set correctly?
lappend check_functions "qrsh_batch"                 ;# run qrsh in batch mode
lappend check_functions "qrsh_limits"                ;# limits (e.g. cpu) passed correctly
lappend check_functions "qrsh_env"                   ;# test the -v VAR=val and -v VAR options
lappend check_functions "qrsh_reservation"           ;# test the -R y option
lappend check_functions "qrsh_sigterm_running_job"   ;# test CTRL-C for running job
lappend check_functions "qrsh_sigterm_pending_job"   ;# test CTRL-C for pending job

# test specific global variables
global qrsh_hostlist
global QSUB_GID_USER
global QSUB_GID_GROUPS
global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
set QSUB_GID_USER   "$CHECK_FIRST_FOREIGN_SYSTEM_USER"
set QSUB_GID_GROUPS "$CHECK_FIRST_FOREIGN_SYSTEM_GROUP"


proc qrsh_init_level {} {
   global ts_config
   global CHECK_ACT_LEVEL CHECK_OUTPUT
   global qrsh_hostlist qrsh_submithost

   set qrsh_submithost $ts_config(master_host)

   switch -exact $CHECK_ACT_LEVEL {
      0 {
         set qrsh_hostlist [lindex $ts_config(unique_arch_nodes) 0]
         return 0
      }
      200 {
         set qrsh_hostlist $ts_config(unique_arch_nodes)
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

# -------- check functions -----------------------------------------------------

#                                                             max. column:     |
#****** qrsh/qrsh_function() ******
# 
#  NAME
#     qrsh_function -- ??? 
#
#  SYNOPSIS
#     qrsh_function { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_function {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh functional test"
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                                      "-l hostname=$host echo qrsh sucessfully started"]
      set sp_id [ lindex $qrsh_id 1 ] 
  
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_function" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }

         -i $sp_id default {
            add_proc_error "qrsh_function" -1 "qrsh to host $host failed"
         }
         -i $sp_id "qrsh sucessfully started" {
            puts $CHECK_OUTPUT "qrsh to host $host ok"
         }
      }

      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_function" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }

         -i $sp_id default {
            add_proc_error "qrsh_function" -1 "qrsh to host $host failed"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }
   
   wait_for_end_of_all_jobs 30 

   set_error 0 "ok"
}


proc qrsh_h {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_USER
   global qrsh_submithost


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh -h functional test"

   wait_for_end_of_all_jobs 30

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30"
   set job_id [submit_job $arguments]
   delete_job $job_id  ;# now we know the last job id

   incr job_id 1       ;# job id of next job !

   set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                "-h echo qrsh sucessfully started"]
   set sp_id [ lindex $qrsh_id 1 ] 
  
   trigger_scheduling

   wait_for_jobpending $job_id "echo" 60 

   trigger_scheduling

   set run_result [get_standard_job_info $job_id ]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [ lindex $line 4 ]
      puts $CHECK_OUTPUT "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if { $tmp_job_state != "hqw" } {
      add_proc_error "qrsh_h" -1 "qrsh -h job is not in pending state"
   }

   trigger_scheduling

   set timeout 15
   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_h" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }

      -i $sp_id default {
         puts $CHECK_OUTPUT "qrsh -h timeout for hold state ok, now releasing job $job_id"
      }

      -i $sp_id "qrsh sucessfully started" {
         add_proc_error "qrsh_h" -1 "qrsh -h failed" 
      }
   }

   release_job $job_id

   trigger_scheduling

   set timeout 60
   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_h" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }

      -i $sp_id default {
         add_proc_error "qrsh_h" -1 "qrsh -h failed for job $job_id"
      }
      -i $sp_id "qrsh sucessfully started" {
         puts $CHECK_OUTPUT "qrsh -h ok"
      }
   }

   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_h" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }

      -i $sp_id default {
         add_proc_error "qrsh_h" -1 "got timeout for job $job_id"
      }
      -i $sp_id "_exit_status_:(*)*\n" {
            puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
      }
   }

   close_spawn_process $qrsh_id

   wait_for_end_of_all_jobs 30 

   set_error 0 "ok"
}


proc qrsh_hold_jid {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_USER
   global qrsh_submithost


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh -hold_jid functional test"

   wait_for_end_of_all_jobs 30

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 6000"
   set hold_job_id [submit_job $arguments] 
   set job_id [ expr ( $hold_job_id + 1 )]

   set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                "-hold_jid $hold_job_id echo qrsh sucessfully started"]
   set sp_id [ lindex $qrsh_id 1 ] 
  
   trigger_scheduling

   wait_for_jobpending $job_id "echo" 60 

   trigger_scheduling

   set run_result [get_standard_job_info $job_id ]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [ lindex $line 4 ]
      puts $CHECK_OUTPUT "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if { $tmp_job_state != "hqw" } {
      add_proc_error "qrsh_hold_jid" -1 "qrsh -hold_jid job is not in pending state"
   }

   trigger_scheduling

   set timeout 15
   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_hold_jid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id default {
         puts $CHECK_OUTPUT "qrsh -hold_jid timeout for hold state ok, now deleting job $hold_job_id"
      }
      -i $sp_id "qrsh sucessfully started" {
         add_proc_error "qrsh_hold_jid" -1 "qrsh -hold_jid failed" 
      }
   }

   delete_job $hold_job_id 1

   trigger_scheduling

   set timeout 60
   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_hold_jid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }

      -i $sp_id default {
         add_proc_error "qrsh_hold_jid" -1 "qrsh -hold_jid failed for job $job_id"
      }
      -i $sp_id "qrsh sucessfully started" {
         puts $CHECK_OUTPUT "qrsh -hold_jid ok"
      }
   }

   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_hold_jid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }

      -i $sp_id default {
         add_proc_error "qrsh_hold_jid" -1 "qrsh -hold_jid failed for job $job_id"
      }
      -i $sp_id "_exit_status_:(*)*\n" {
         puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
      }
   }

   close_spawn_process $qrsh_id

   wait_for_end_of_all_jobs 30 


   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_alltoall() ******
# 
#  NAME
#     qrsh_alltoall -- ??? 
#
#  SYNOPSIS
#     qrsh_alltoall { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_alltoall {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh from each host to all hosts"


   foreach source $qrsh_hostlist {
      set source_arch [resolve_arch $source]
      foreach dest $qrsh_hostlist {
         set qrsh_id [open_remote_spawn_process "$source" "ts_def_con" "$CHECK_PRODUCT_ROOT/bin/$source_arch/qrsh" "-l hostname=$dest echo qrsh sucessfully started"]
         set sp_id [ lindex $qrsh_id 1 ]                              
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_alltoall" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id eof {
               add_proc_error "qrsh_alltoall"  -1 "open_remote_spawn_process closed connection (eof)"
            }
            -i $sp_id "qrsh sucessfully started" {
               puts $CHECK_OUTPUT "qrsh from host $source to host $dest ok"
            }   
            -i $sp_id default {
               add_proc_error "qrsh_alltoall" -1 "qrsh from host $source to host $dest failed"
            }
         }
          
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_alltoall"  -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id eof {
               add_proc_error "qrsh_alltoall"  -1 "open_remote_spawn_process closed connection (eof)"
            }
            -i $sp_id "_exit_status_:(*)*\n" {
               puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
            }
            -i $sp_id default {
               add_proc_error "qrsh_alltoall" -1 "qrsh from host $source to host $dest failed"
            }
         }
         close_spawn_process $qrsh_id
      }
   }

   wait_for_end_of_all_jobs 30 


   set_error 0 "ok"
}


proc qrsh_starter_method {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist qrsh_submithost

   puts $CHECK_OUTPUT "qrsh testing starter_method"

   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   mod_queue all.q "" change_array

   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                                      "-l hostname=$host echo qrsh sucessfully started"]
      set sp_id [ lindex $qrsh_id 1 ] 
  
      set done 0
      set starter_method 0
 
      while {$done == 0} {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_starter_method" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               return
            }

            -i $sp_id "starter method started" {
               set starter_method 1
            }

            -i $sp_id "qrsh sucessfully started" {
               if {$starter_method == 0} {
                  add_proc_error "qrsh_starter_method" -1 "qrsh job started without starter_method on host $host"
               } else {
                  puts $CHECK_OUTPUT "qrsh to host $host ok"
               }
            }

            -i $sp_id "_exit_status_:(*)*\n" {
               set done 1
               puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
            }

            -i $sp_id default {
               set done 1
               add_proc_error "qrsh_starter_method" -1 "qrsh to host $host failed"
            }
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs 30 


   # unset starter method
   set change_array(starter_method) "none"
   mod_queue "all.q" "" change_array

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_accounting() ******
# 
#  NAME
#     qrsh_accounting -- ??? 
#
#  SYNOPSIS
#     qrsh_accounting { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_accounting {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_PRODUCT_TYPE
   global CHECK_HOST CHECK_USER
   global qrsh_hostlist qrsh_submithost


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   puts $CHECK_OUTPUT "qrsh accounting test"
   if { $ts_config(gridengine_version) == 53 } {
      set INTERACTIVE_JOB [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_D] "*"]
      set INTERACTIVE_JOB_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_D] "__JOBID__"]
   } else {
      set INTERACTIVE_JOB [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S] "*"]
      set INTERACTIVE_JOB_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S] "__JOBID__"]
   }
   set job_id_start [ string first "__JOBID__" $INTERACTIVE_JOB_DUMMY ]

   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-verbose -nostdin -l hostname=$host $CHECK_PRODUCT_ROOT/examples/jobs/worker.sh 120"]
      
      set state startup
      set job_id ""
      set sp_id [ lindex $qrsh_id 1 ] 

      while { [string compare $state exit] != 0 } {
         set timeout  80
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_accounting" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set state exit
            }

            -i $sp_id eof {
               add_proc_error "qrsh_accounting"  -1 "open_remote_spawn_process closed connection (eof)"
               set state exit
            }

            -i $sp_id timeout {
               if { [string compare $state running] } {
                  add_proc_error "qrsh_accounting"  -1 "qrsh to host $host failed"
                  set state exit
               } else {
                  if {$CHECK_PRODUCT_TYPE == "sgeee"} {
                     if { $job_id == "" } {
                        add_proc_error "qrsh_accounting"  -1 "unknown job_id for qrsh job on host $host"
                     } else {
                        if {[info exists job_info]} {
                           unset job_info
                        }
                        if {[get_extended_job_info $job_id] } {
                           if { $job_info(cpu) < 10 } {
                              add_proc_error "qrsh_accounting"  -3 "online usage probably does not work on $host"
                           }
                        } else {
                           add_proc_error "qrsh_accounting"  -1 "get_extended_jobinfo failed for job $job_id on host $host"
                        }
                     }
                  }
               }
            }

            -i $sp_id $INTERACTIVE_JOB {
               puts "jobstart: \"$expect_out(0,string)\""
               set job_id [ string range $expect_out(0,string) $job_id_start end]
               set space_start [ string first " " $job_id ]
               set job_id [ string range $job_id 0 $space_start ]
               set job_id [ string trim $job_id ]
               puts $CHECK_OUTPUT "job id is: \"$job_id\""
               set state scheduled
            }

            -i $sp_id "Your interactive job *\n" {
               set job_id [lindex $expect_out(0,string) 3]
               puts $CHECK_OUTPUT "job id is: \"$job_id\""
               set state scheduled
            }

            -i $sp_id "Forking" { ;# "Forking" printout is from worker job (utilbin/work.c)
               set state running
            }

            -i $sp_id "_exit_status_" {   ;# _exit_status_ is from open_remote_spawn_process - generated script
               if { [string compare $state running] } {
                  add_proc_error "qrsh_accounting"  -1 "qrsh to host $host failed"
               }
               set state exit
            }
         }
      }

      close_spawn_process $qrsh_id

      # wait for accounting file to be flushed (esp. for 6.0) and NFS
      sleep 30

      if { $job_id != "" } {
         if {[info exists qacct_info]} {
            unset qacct_info
         }

         if {[get_qacct $job_id] == 0} {
            set cpu [expr $qacct_info(ru_utime) + $qacct_info(ru_stime)]
            if { $cpu < 30 } {
               add_proc_error "qrsh_accounting"  -1 "cpu entry \"$cpu\" in accounting seems to be wrong for job $job_id on host $host"
            }

            if { $CHECK_PRODUCT_TYPE == "sgeee" } {
               # compute absolute diffence between cpu and ru_utime + ru_stime
               set difference [expr $cpu - $qacct_info(cpu)]
               set difference [expr $difference * $difference]
               if { $difference > 2 } {
                  add_proc_error "qrsh_accounting"  -1 "accounting: cpu($qacct_info(cpu)) is not the sum of ru_utime and ru_stime ($cpu) for job $job_id on host $host"
               }
            }
         }
      }
   }

   wait_for_end_of_all_jobs 30 

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_suspend() ******
# 
#  NAME
#     qrsh_suspend -- ??? 
#
#  SYNOPSIS
#     qrsh_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_suspend {} {
   global ts_config
   global CHECK_OUTPUT CHECK_ARCH
   global qrsh_hostlist qrsh_submithost

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   puts $CHECK_OUTPUT "check if a process started by qrsh can be (un)suspended using qmod"

   foreach host $qrsh_hostlist {
      set running_states [host_get_running_states $host]
      set suspended_states [host_get_suspended_states $host]

      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $ts_config(product_root)/bin/$CHECK_ARCH/qrsh "-l hostname=$host $ts_config(testsuite_root_dir)/scripts/work_pid.sh 60"]
      
      # evaluate pid and JOB_ID
      set done 0
      set sp_id [ lindex $qrsh_id 1 ] 

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            add_proc_error "qrsh_suspend" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "my pid is *\n" {
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
            puts $CHECK_OUTPUT "job has pid $job_pid and job id $job_id"
         }
         -i $sp_id timeout {
            close_spawn_process $qrsh_id
            add_proc_error "qrsh_suspend" -1 "qrsh to host $host failed"
         }
         -i $sp_id "_exit_status_" {
            close_spawn_process $qrsh_id
            add_proc_error "qrsh_suspend" -1 "qrsh to host $host failed"
         }
         -i $sp_id eof {
            close_spawn_process $qrsh_id
            add_proc_error "qrsh_suspend" -1 "open_remote_spawn_process closed connection (eof)"
         }
      }

      # continue only, if job is running correctly
      if { [info exists job_pid] && [info exists job_id] } {
         # check process status (should be sleeping or running)
         get_ps_info $job_pid $host 
         
         if { $ps_info($job_pid,error) != 0 } {
            close_spawn_process $qrsh_id
            add_proc_error "qrsh_suspend" -1 "cannot get info about process $job_pid on host $host"
            continue
         }
         puts $CHECK_OUTPUT "job should be running"
         puts $CHECK_OUTPUT $ps_info($job_pid,index_names) 
         puts $CHECK_OUTPUT $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_states] == -1} {
            close_spawn_process $qrsh_id
            add_proc_error "qrsh_suspend" -1 "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)\nps output:\n$ps_info($job_pid,index_names)\n$ps_info($job_pid,string)\n"
            continue
         }

         # suspend job
         suspend_job $job_id
         sleep 10
         # process status should be suspended
         get_ps_info $job_pid $host
         if { $ps_info($job_pid,error) != 0 } {
            add_proc_error "qrsh_suspend" -1 "cannot get info about process $job_pid on host $host"
            close_spawn_process $qrsh_id
            continue
         }
         puts $CHECK_OUTPUT "job should be suspended"
         puts $CHECK_OUTPUT $ps_info($job_pid,index_names) 
         puts $CHECK_OUTPUT $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $suspended_states] == -1} {
            add_proc_error "qrsh_suspend" -1 "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
            close_spawn_process $qrsh_id
            continue
         }

         # unsuspend job
         unsuspend_job $job_id
         sleep 10
         # process status should be sleeping or running
         get_ps_info $job_pid $host
         if { $ps_info($job_pid,error) != 0 } {
            add_proc_error "qrsh_suspend" -1 "cannot get info about process $job_pid on host $host"
            close_spawn_process $qrsh_id
            continue
         }
         puts $CHECK_OUTPUT "job should be running"
         puts $CHECK_OUTPUT $ps_info($job_pid,index_names) 
         puts $CHECK_OUTPUT $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_states] == -1} {
            add_proc_error "qrsh_suspend" -1 "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
            close_spawn_process $qrsh_id
            continue
         }
      }

      set done 0
      while { $done == 0 } {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_suspend" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
            }

            -i $sp_id timeout {
               add_proc_error "qrsh_suspend" -1 "timeout waiting for qrsh to host $host to finish"
               set done 1
            }

            -i $sp_id eof {
               add_proc_error "qrsh_suspend" -1 "open_remote_spawn_process closed connection (eof)"
               set done 1
            }

            -i $sp_id "_exit_status_" {
               set done 1
            }
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs 30 


   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_delete() ******
# 
#  NAME
#     qrsh_delete -- ??? 
#
#  SYNOPSIS
#     qrsh_delete { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_delete {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER
   global qrsh_hostlist qrsh_submithost

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if all processes of a qrsh job are finished after qdel"

   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      set sp_id [ lindex $qrsh_id 1 ] 
 
      # evaluate pid and JOB_ID
      set timeout 60
      set done 0
      set error 0
      while { $done == 0 } {
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_delete" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
               set error 1
            }
            -i $sp_id "my pid is*" {
               puts $CHECK_OUTPUT "got pid of job!"
               set job_pid [lindex $expect_out(0,string) 3]
               set job_id [lindex $expect_out(0,string) 7]
               set done 1
            }
            -i $sp_id timeout {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_delete" -1 "qrsh to host $host failed - timeout"
               set done 1
               set error 1
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_delete" -1 "qrsh to host $host failed - eof"
               set done 1
               set error 1
            }
            
         }
      }

      if { $error == 0 } {
         if { [info exists job_pid] && [info exists job_id] } {
            # qdel 
            puts $CHECK_OUTPUT "now deleting job $job_id ..."
            delete_job $job_id 1

            puts $CHECK_OUTPUT "continue now ..."
            # check if shell script is still running
            get_ps_info $job_pid $host
            if { $ps_info($job_pid,error) == 0 } {
               add_proc_error "qrsh_delete" -1 "process of deleted job $job_pid on host $host is still running"
            } else {
               puts $CHECK_OUTPUT "job is gone - ok !"
            }
         }
      }

      close_spawn_process $qrsh_id 1

      set q_state [get_queue_state "all.q@${host}"]
      if { [string first "E" $q_state] >= 0 } {
         add_proc_error "qrsh_delete" -1 "queue all.q@${host} goes to state \"$q_state\" after job deletion"
         delete_all_jobs ;# this will remove the E state
      }
   }
 
   wait_for_end_of_all_jobs 30 

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_terminate() ******
# 
#  NAME
#     qrsh_terminate -- ??? 
#
#  SYNOPSIS
#     qrsh_terminate { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_terminate {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_COMMD_PORT
   global qrsh_hostlist qrsh_submithost

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if terminate method for a qrsh job gets right job_pid"


   set terminate_out_file [get_tmp_file_name "" "qrsh" $CHECK_COMMD_PORT]

   # set terminate method
   set change_array(terminate_method) "$CHECK_ACTUAL_TEST_PATH/terminate.sh \$job_id \$job_pid $terminate_out_file"
   mod_queue "all.q" "" change_array



   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      
      # evaluate pid and JOB_ID
      set timeout 60
      set done 0
      set error 0
      set sp_id [ lindex $qrsh_id 1 ] 

      while { $done == 0 } {
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_terminate" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
               set error 1
            }

            -i $sp_id timeout {
               add_proc_error "qrsh_terminate" -1 "qrsh to host $host failed - timeout"
               set done 1
               set error 1
            }

            -i $sp_id eof {
               add_proc_error "qrsh_terminate" -1 "qrsh to host $host failed - eof"
               set done 1
               set error 1
            }

            -i $sp_id "my pid is*" {
               set job_pid [lindex $expect_out(0,string) 3]
               set job_id [lindex $expect_out(0,string) 7]
               set done 1
            }
         }
      }

      if { $error == 1 } {
         close_spawn_process $qrsh_id
         continue
      }

      if { [info exists job_pid] && [info exists job_id] } {
         get_ps_info $job_pid $host
         # qdel 
         delete_job $job_id

         for {set i 0} {$i < 60} {incr i} {
            after 1000
            start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
            if {$exit_code == 0} {
               puts $CHECK_OUTPUT "terminate method has been started"
               break
            } else {
               puts $CHECK_OUTPUT "waiting for terminate method"
            }
         }   
        
         # wait for terminate method to finish
         sleep 2
         # check contents of terminate.out
         set line [start_remote_prog $host $CHECK_USER cat $terminate_out_file exit_code]
         if {$exit_code != 0} {
            add_proc_error "qrsh_terminate" -1 "error reading from terminate method output file on host $host"
         } else {
            if {[scan $line "job_id=%d job_pid=%d" t_job_id t_job_pid] != 2} {
               add_proc_error "qrsh_terminate" -1 "error reading from terminate method output file on host $host"
            } else {
               # t_job_pid should be ppid of job_pid
               if { ! [info exists ps_info($job_pid,ppid)] } {
                  add_proc_error "qrsh_terminate" -1 "info about ppid of pid $job_pid not available on host $host"
               } else {   
                  if { $ps_info($job_pid,ppid) != $t_job_pid} {
                     add_proc_error "qrsh_terminate" -1 "wrong job_pid passed to terminate method for job $job_id on host $host, should be $ps_info($job_pid,ppid) but is $t_job_pid"
                  }
               }
            }
         }
         # check if shell script is still running
         get_ps_info $job_pid $host
         if { $ps_info($job_pid,error) == 0 } {
            add_proc_error "qrsh_terminate" -1 "process of deleted job $job_pid on host $host is still running"
         }
      }
      
      set done 0
      while { $done == 0 } {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_terminate" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
            }
            -i $sp_id timeout {
               add_proc_error "qrsh_terminate" -1 "timeout waiting for qrsh to host $host to finish"
               set done 1
            }
            -i $sp_id eof {
               add_proc_error "qrsh_terminate" -1 "open_remote_spawn_process closed connection (eof)"
               set done 1
            }
            -i $sp_id "_exit_status_" {
               set done 1
            }
         }
      }

      close_spawn_process $qrsh_id

      start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
   }

   # reset terminate method
   set change_array(terminate_method) "NONE"
   mod_queue "all.q" "" change_array

   wait_for_end_of_all_jobs 30 


   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/check_qsub_gid_output() ******
# 
#  NAME
#     check_qsub_gid_output -- ??? 
#
#  SYNOPSIS
#     check_qsub_gid_output { output check_group } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     output      - ??? 
#     check_group - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_qsub_gid_output {output check_group} {
   global CHECK_OUTPUT

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   set substring [string range $output [string first "gid=" $output] end]
   set group [string trim [string range $substring [string first "(" $substring] [string first ")" $substring]] "()"]

   puts $CHECK_OUTPUT "process was executed under user group $group"

   if {[string compare $group $check_group] == 0} {
      return 1
   } else {
      return 0
   }
}

#                                                             max. column:     |
#****** qrsh/qrsh_qsub_gid() ******
# 
#  NAME
#     qrsh_qsub_gid -- ??? 
#
#  SYNOPSIS
#     qrsh_qsub_gid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_qsub_gid {} {
   global ts_config
   global CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_PROTOCOL_DIR
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST
   global QSUB_GID_USER QSUB_GID_GROUPS CHECK_SECOND_FOREIGN_SYSTEM_USER
   global qrsh_hostlist qrsh_submithost

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   if { $ts_config(gridengine_version) == 53 } {
      set USING_FOR     [translate $CHECK_HOST 1 0 0 [sge_macro MSG_GDI_USING_SS] "*USE_QSUB_GID=true*" "*"]
      set FINISHED_JOBS [translate $CHECK_HOST 1 0 0 [sge_macro MSG_GDI_USING_SS] "*finished_jobs*" "*"]
   } else {
      set USING_FOR     [translate $CHECK_HOST 1 0 0 [sge_macro MSG_CONF_USING_SS] "*USE_QSUB_GID=true*" "*"]
      set FINISHED_JOBS [translate $CHECK_HOST 1 0 0 [sge_macro MSG_CONF_USING_SS] "*finished_jobs*" "*"]
   }

   puts $CHECK_OUTPUT "check if qsub gid is propagated to qrsh job"

   foreach host $qrsh_hostlist {
      if {[resolve_arch $host] == "win32-x86"} {
         add_proc_error "qrsh_qsub_gid" -3 "qrsh_qsub_gid test not supported on windows execution host $host"
         continue
      }

      puts $CHECK_OUTPUT "using host $host"
      # dump commandfile to file
      set f [open $CHECK_PROTOCOL_DIR/qrsh.sh w]
      switch -exact [resolve_arch $host] {
         "aix42" -
         "aix43" -
         "darwin" -
         "darwin-ppc" -
         "darwin-x86" -
         "osf4" -
         "tru64" -
         "win32-x86" {
            puts $f "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -l hostname=$host /usr/bin/id"
         }
         default {
            puts $f "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -l hostname=$host /usr/bin/id -a"
         }   
      }   
      close $f

      file attributes "$CHECK_PROTOCOL_DIR/qrsh.sh" -permissions 00755
      wait_for_remote_file $host $QSUB_GID_USER $CHECK_PROTOCOL_DIR/qrsh.sh


      # call qsub_gid.sh, gid must be primary gid
      set output [start_remote_prog "$qrsh_submithost" $QSUB_GID_USER $CHECK_ACTUAL_TEST_PATH/qsub_gid.sh "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 0]
      if {[check_qsub_gid_output $output $group] == 0} {
         add_proc_error "qrsh_qsub_gid" -1 "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # get path of hosts messages file
      get_config config $host
      if {![info exists config(execd_spool_dir)]} {
         get_config config
      }
      set messages_name "$config(execd_spool_dir)/$host/messages"
      
      # spawn a tail -f to messages file and skip first (old) lines
      # we use the second configured test user to avoid having two open_remote_spawn
      # processes with same userid and same host
      set tail_id [open_remote_spawn_process $host "ts_def_con" /usr/bin/tail "-f $messages_name"]
      set skipping 1
      set sp_id [ lindex $tail_id 1 ] 

      while {$skipping == 1} {
         set timeout 5
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value" 
            }
            -i $sp_id timeout {
               set skipping 0
            }
            -i $sp_id "*\n" {
            }
         }
      }

      # set parameter USE_QSUB_GID
      unset config
      get_config config $host
      if {[info exists config(execd_params)]} {
         set execd_params $config(execd_params)
      } else {
         set execd_params ""
      }

      unset config
      if {$execd_params == ""} {
         set config(execd_params) "USE_QSUB_GID=true"
      } else {
         set config(execd_params) "$execd_params,USE_QSUB_GID=true"
      }
      set_config config $host
      
      # wait until USE_QSUB_GID is changed on host
      puts $CHECK_OUTPUT "waiting for configuration change to take effect"
      set timeout 120
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $tail_id
            add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            continue
         }
         -i $sp_id default {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
            add_proc_error "qrsh_qsub_gid" -1 "setting execd_params to USE_QSUB_GID=true failed on host $host"
            continue
         }
         -i $sp_id $USING_FOR {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
         }
         -i $sp_id "using*USE_QSUB_GID=true*\n" {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
         }
      }

      # call qsub_gid.sh, gid must be secondary gid
      set output [start_remote_prog "$qrsh_submithost" $QSUB_GID_USER $CHECK_ACTUAL_TEST_PATH/qsub_gid.sh "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 1]
      if {[check_qsub_gid_output $output $group] == 0} {
         add_proc_error "qrsh_qsub_gid" -1 "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # spawn a tail -f to messages file and skip first (old) lines
      set tail_id [open_remote_spawn_process $host "ts_def_con" /usr/bin/tail "-f $messages_name"]
      set sp_id [ lindex $tail_id 1 ] 
      set skipping 1
      while {$skipping == 1} {
         set timeout 5
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id timeout {
               set skipping 0
            }
            -i $sp_id "*\n" {
            }
         }
      }

      # unset USE_QSUB_GID 
      unset config
      set config(execd_params) $execd_params
      set_config config $host

      # wait until USE_QSUB_GID is changed on host
      puts $CHECK_OUTPUT "waiting for configuration change to take effect"
      set timeout 120
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            close_spawn_process $tail_id
            continue
         }
         -i $sp_id timeout {
            send -i $sp_id "\003"
            add_proc_error "qrsh_qsub_gid" -1 "clearing execd_params from USE_QSUB_GID=true failed on host $host"
            close_spawn_process $tail_id
            continue
         }
         -i $sp_id $FINISHED_JOBS {
            send -i $sp_id "\003"
         }
         -i $sp_id "using*finished_jobs*" {
            send -i $sp_id "\003"
         }
      }

      close_spawn_process $tail_id
   }

   wait_for_end_of_all_jobs 30 
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_batch() ******
# 
#  NAME
#     qrsh_batch -- ??? 
#
#  SYNOPSIS
#     qrsh_batch { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_batch {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST CHECK_USER
   global qrsh_hostlist qrsh_submithost

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   puts $CHECK_OUTPUT "check qrsh in immediate and batch mode (-now yes / no)"
   set COULD_NOT_BE_SCHEDULED [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_REQUESTCANTBESCHEDULEDTRYLATER_S] "*" ]
   if { $ts_config(gridengine_version) == 53 } {
      set HAS_BEEN_SUBMITTED  [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "*" "*" "*" ]
   } else {
      set HAS_BEEN_SUBMITTED  [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "*" "*" "*"]
   }

   foreach host $qrsh_hostlist {
      set queue [get_queue_instance "all.q" $host]
      # disable queue
      disable_queue $queue
      puts $CHECK_OUTPUT "queue should be disabled now ..."
      # start qrsh - must be rejected
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-q $queue -N immediate echo blahblah"]
      set sp_id [ lindex $qrsh_id 1 ] 

      # evaluate pid and JOB_ID
      set timeout 60
      set error 1
      log_user 1
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            add_proc_error "qrsh_batch" -1 "qrsh -now yes ran dispite no resources free on host $host"
         }
         -i $sp_id $COULD_NOT_BE_SCHEDULED {
            puts $CHECK_OUTPUT "qrsh aborted correctly (1)"
            set error 0
         } 
         -i $sp_id "could not be scheduled*\n" {
            puts $CHECK_OUTPUT "qrsh aborted correctly (2)"
            set error 0
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for qrsh -now yes on host $host to fail due to lack of resources"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "qrsh -now yes failed without error message on host $host"
         }
      }
      close_spawn_process $qrsh_id
 
      if { $error } {
         add_proc_error "qrsh_batch" -1 "skipping test on host $host"
         enable_queue [get_queue_instance "all.q" $host]
         continue
      }
 
      # start qrsh -now no
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-verbose -q $queue -now no -N batch echo blahblah"]
      # must be in pending jobs
      set sp_id [ lindex $qrsh_id 1 ] 

      set timeout 60
      log_user 1
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "eof waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id $HAS_BEEN_SUBMITTED {
            set job_id [lindex $expect_out(0,string) 2]
            puts $CHECK_OUTPUT "qrsh job $job_id correctly submitted (1)"
            set error 0
         }
         -i $sp_id "your job * has been submitted" {
            set job_id [lindex $expect_out(0,string) 2]
            puts $CHECK_OUTPUT "qrsh job $job_id correctly submitted (2)"
            set error 0
         }
      }
      if { $error } {
         add_proc_error "qrsh_batch" -1 "skipping test on host $host"
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      if {[info exists job_info]} {
         unset job_info
      }

      if { [get_extended_job_info $job_id] == 0} {
         add_proc_error "qrsh_batch" -1 "no job info for job $job_id - skipping test on host $host"
         delete_job $job_id 1
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      if { $job_info(state) != "qw" } {
         add_proc_error "qrsh_batch" -1 "state of job is $job_info(state), should be qw, skipping test on host $host"
         delete_job $job_id 1
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }
      
      puts $CHECK_OUTPUT "now enable the queue ..."

      # enable queue, trigger scheduling
      enable_queue $queue

      trigger_scheduling
      
      # job must be scheduled
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            puts $CHECK_OUTPUT "got qrsh job output as expected (blahblah)!"
         }
         -i $sp_id $COULD_NOT_BE_SCHEDULED { 
            add_proc_error "qrsh_batch" -1 "message \"could not be scheduled\" should not occur with batch jobs"
         }
         -i $sp_id "*could not be scheduled*" {
            add_proc_error "qrsh_batch" -1 "message \"could not be scheduled\" should not occur with batch jobs"
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for qrsh to be scheduled to host $host"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "qrsh exited without executing command on host $host"
         }
      }

      # now wait for shell termination
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for exit_status on host $host"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "got eof on host $host"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs 30 

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- ??? 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_limits {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if limits are propagated to qrsh jobs"
   set limit_in 10

   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host -l h_cpu=$limit_in $CHECK_ACTUAL_TEST_PATH/ulimit.sh"]
      set sp_id [ lindex $qrsh_id 1 ] 

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_limits" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_limits" -1 "qrsh to host $host failed"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_limits" -1 "qrsh to host $host failed"
         }
         -i $sp_id "CPU limit is *\n" {
            set limit_out [lindex $expect_out(0,string) 3]
            puts $CHECK_OUTPUT "qrsh to host $host ok, CPU limit is $limit_out s"

            if { $limit_out != $limit_in } {
               add_proc_error "qrsh_limits" -1 "limit on host $host not correctly set"
            }
         }
      }

      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_limits" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_limits" -1 "timeout error while waiting for exit_status on host $host"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_limits" -1 "got eof on host $host"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            puts $CHECK_OUTPUT "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs 30 
   set_error 0 "ok"
}

proc qrsh_reservation {} {
   global ts_config CHECK_OUTPUT CHECK_ARCH CHECK_HOST CHECK_USER

   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qrsh" "-R y echo bla"]
   puts $CHECK_OUTPUT $output
   if { [string match "error: Unknown option*" $output] == 1 } {
      add_proc_error "qrsh_reservation" -1 "qrsh -R y failed - see Issue: 1306"
   }
   wait_for_end_of_all_jobs 30 
   set_error 0 "ok"
}

proc qrsh_env {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH env

   puts $CHECK_OUTPUT "check if environment variables are set correctly"

   # Set a dummy env var
   set inherited_value "ThIsIsAtEsT"
   set explicit_value "tHiSiSoNlYaTeSt"
   set env(QRSH_ENV_TEST_DUMMY) $inherited_value

   # Test
   catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -v QRSH_ENV_TEST_DUMMY echo \\\$QRSH_ENV_TEST_DUMMY" "2>/dev/null"} result1
   
   if { [ string compare $result1 "$inherited_value" ] != 0 } {
      set error_text "qrsh did not inherit test environment variable: $inherited_value != $result1\n"
      append  error_text "Bug 1255: qrsh does not properly pass along environment variables"
      add_proc_error "qrsh_env" -1 $error_text
   }

   catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -v QRSH_ENV_TEST_DUMMY=$explicit_value echo \\\$QRSH_ENV_TEST_DUMMY" "2>/dev/null" } result2
   
   if { [ string compare $result2 "$explicit_value" ] != 0 } {
      set error_text "qrsh did not inherit test environment variable: $explicit_value != $result2\n"
      append error_text "Bug 1255: qrsh does not properly pass along environment variables"
      add_proc_error "qrsh_env" -1 $error_text
   }

   wait_for_end_of_all_jobs 30 
   set_error 0 "ok"
}

#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- send CTRL-C to running job 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     Test if Issue 1639 exists
#
#  SEE ALSO
#     qrsh_sigterm_pending_job  
#*******************************

proc qrsh_sigterm_running_job {} {

   global ts_config CHECK_OUTPUT CHECK_ARCH CHECK_HOST

   # start qrsh 
   set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $ts_config(product_root)/bin/$CHECK_ARCH/qrsh "\"echo started; sleep 3600\""]
   set sp_id [lindex $qrsh_id 1]

     
   # job must be scheduled
   set timeout 30
   expect {
      -i $sp_id full_buffer {
         add_proc_error "qrsh_qrsh_sigterm_running_job" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id -- "*started*" {
         puts $CHECK_OUTPUT "qrsh job started as expected!"
      }
     -i $sp_id timeout {
         add_proc_error "qrsh_sigterm_running_job" -1 "timeout waiting for qrsh to be scheduled"
      }
   }

   # now terminate the connection
   send -i $sp_id "\003"
   send -i $sp_id "\003"
   sleep 10
   close_spawn_process $qrsh_id

   wait_for_end_of_all_jobs 60

   set result [start_sge_bin qstat "-s pr" "" "" catch_return ]
   if { $catch_return == 0 } {
      if { [ string compare $result "" ] == 0 } {
         puts $CHECK_OUTPUT "no further jobs in system"
      } else {
         add_proc_error "qrsh_sigterm_running_job" -1 "CTRL-C for running qrsh job does not delete job - issue 1639"
      }
   } else {
      add_proc_error "qrsh_sigterm_running_job" -1 "error executing qstat -s pr"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set_error 0 "ok"
}

#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- send CTRL-C to pending job 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     Test if Issue 1639 exists
#
#  SEE ALSO
#     qrsh_sigterm_running_job  
#*******************************
proc qrsh_sigterm_pending_job {} {

   global ts_config CHECK_OUTPUT CHECK_ARCH CHECK_HOST

   # start qrsh 
   set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $ts_config(product_root)/bin/$CHECK_ARCH/qrsh "-now n -l arch=bla sleep 3600"]
   set sp_id [ lindex $qrsh_id 1 ]

   set timer 10

   while { [ get_job_info -1 ] == 0 } {
      if { $timer == 0 } {
         add_proc_error "qrsh_sigterm_pending_job" -1 "error submitting qrsh job"
         break;
      }
      sleep 1
      incr timer -1
   }
  
   # now terminate the connection
   send -i $sp_id "\003"
   send -i $sp_id "\003"
   close_spawn_process $qrsh_id

   wait_for_end_of_all_jobs 15

   set result [start_sge_bin qstat "-s pr" "" "" catch_return ]
   if { $catch_return == 0 } {
      if { [ string compare $result "" ] == 0 } {
         puts $CHECK_OUTPUT "no further jobs in system"
      } else {
         add_proc_error "qrsh_sigterm_pending_job" -1 "CTRL-C for pending qrsh job does not delete job - issue 1639"
      }
   } else {
      add_proc_error "qrsh_sigterm_pending_job" -1 "error executing qstat -s pr"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set_error 0 "ok"
}


proc qrsh_cleanup {} {
   delete_all_jobs
   wait_for_end_of_all_jobs 60
}
