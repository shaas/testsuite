#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#
global CHECK_CHECKTREE_ROOT              ;# path where checktree lies
global CHECK_ACT_PATH          ;# actual checkpath
global CHECK_PRODUCT_ROOT  ;# path to sgeee/sge system
global CHECK_PRODUCT_TYPE       ;# "sgeee" or "sge"         
global CHECK_COMMD_PORT        ;# commd port
global CHECK_USER              ;# user who start test
global CHECK_ARCH              ;# architecture of this system (e.g. irix6)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr 
global check_category
global check_root_access_needs
set check_root_access_needs "yes"

set check_name         "qalter"
set check_category     "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_description(0)  "check every option"
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)

# define a level initialization procedure:
set check_init_level_procedure "qalter_init_level"

# setup and cleanup functions
set check_cleanup_function "qalter_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "run_dummy_jobs"   ;# functions to call (in order)
lappend check_functions "start_testjob"
lappend check_functions "qalter_ac"
lappend check_functions "qalter_A"
lappend check_functions "qalter_c"
lappend check_functions "qalter_ckpt"
lappend check_functions "qalter_cwd"
lappend check_functions "qalter_dc"
lappend check_functions "qalter_e"
lappend check_functions "qalter_hard"
lappend check_functions "qalter_hold"
lappend check_functions "qalter_j"
lappend check_functions "qalter_l"
lappend check_functions "qalter_m"
lappend check_functions "qalter_notify"
lappend check_functions "qalter_M"
lappend check_functions "qalter_N"
lappend check_functions "qalter_o"
lappend check_functions "qalter_P"
lappend check_functions "qalter_p"
lappend check_functions "qalter_pe"
lappend check_functions "qalter_q"
lappend check_functions "qalter_ry"
lappend check_functions "qalter_rn"
lappend check_functions "qalter_sc"
lappend check_functions "qalter_soft"
lappend check_functions "qalter_S"
lappend check_functions "qalter_v"
lappend check_functions "qalter_verify"
lappend check_functions "qalter_V"
lappend check_functions "qalter_w"
lappend check_functions "qalter_a"
lappend check_functions "qalter_t"

set check_errno       "-1"                         ;# 0 -> OK , != 0 means error 
set check_errstr      "was never running"        ;# string for error description
global submitresult
global normal_job_id
global hold_job_A
global hold_job_B
global hold_job_C
global hold_job_D
global hold_job_T
global hold_job_U
global nonadmin_hold_job
global nonadmin_user
global job_output_dir

proc qalter_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

proc qalter_cleanup {} {
   delete_all_jobs
   wait_for_end_of_all_jobs 60
}

#                                                             max. column:     |
#****** qalter/run_dummy_jobs() ******
# 
#  NAME
#     run_dummy_jobs -- ??? 
#
#  SYNOPSIS
#     run_dummy_jobs { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_dummy_jobs {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global CHECK_OUTPUT check_errno hold_job_D hold_job_U
   global check_errstr normal_job_id hold_job_A hold_job_B hold_job_C hold_job_T
   global ts_user_config nonadmin_user nonadmin_hold_job

   set queue [get_queue_instance all.q [lindex $ts_config(execd_nodes) 0]]

   # This jobs has to be long enough to survive the starting of the next jobs
   set submitresult [ submit_job "-o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 90" ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }

   # wait for job to run
   if { [wait_for_jobstart $submitresult "leeper" 200] != 0 } {
      set_error -1 "job $submitresult does not start"
      delete_all_jobs
      return 
   }

   set normal_job_id $submitresult 

   set submitresult [ submit_job "-h -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }
   set hold_job_A $submitresult

   set submitresult [ submit_job "-h -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }
   set hold_job_B $submitresult
    
   set submitresult [ submit_job "-h -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15 " ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }
   set hold_job_C $submitresult
    
   set submitresult [ submit_job "-h -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15 " ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }
   set hold_job_D $submitresult

   set submitresult [ submit_job "-h -t 1-4 -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15 " ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }

   set hold_job_T $submitresult

   set submitresult [ submit_job "-h -t 1-4 -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15 " ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }
   
   set hold_job_U $submitresult
   
   #  Submit a job as not admin user
   set nonadmin_user $ts_user_config(first_foreign_user)
   
   set submitresult [ submit_job "-h -t 1-4 -o /dev/null -e /dev/null -q $queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15 " \
                      1  60 "" $nonadmin_user  ]
   if {$submitresult < 0 } {
     set_error -1 "failure"
     return
   }
   
   # wait for job to get in pending state
   if { [wait_for_jobpending $submitresult "leeper" 200 ] != 0 } {
      set_error -1 "job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }

   set nonadmin_hold_job $submitresult

   # Restore submitresult for legacy tests
   set submitresult $normal_job_id

   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qalter/start_testjob() ******
# 
#  NAME
#     start_testjob -- ??? 
#
#  SYNOPSIS
#     start_testjob { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc start_testjob {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno job_output_dir CHECK_JOB_OUTPUT_DIR
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   set queue [get_queue_instance "all.q" [lindex $ts_config(execd_nodes) 0]]

   set job_output_dir "$CHECK_JOB_OUTPUT_DIR" 
   set submitresult [ submit_job "-h -q $queue -e $job_output_dir -o $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" ]
   if {$submitresult < 0 } {
     set_error -1 "start_testjob - failure"
     return
   }
   # wait for job to get in pending state 
   if { [wait_for_jobpending $submitresult "leeper" 200] != 0 } {
      set_error -1 "start_testjob - job $submitresult is not in pending state"
      delete_all_jobs
      return 
   }
   set_error 0 "start_testjob - no errors"
}

#                                                             max. column:     |
#****** qalter/qalter_ac() ******
# 
#  NAME
#     qalter_ac -- ??? 
#
#  SYNOPSIS
#     qalter_ac { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_ac {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH normal_job_id

   set option "-ac myvar=test -ac myvar2='test2a,test2b' -ac myvar3=\"test3a,test3b\""
   set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $normal_job_id" } qalteroutput ]

   if {$qalterresult == 1} {
      set_error -1 "qalter $option - $qalteroutput"
      return
   }

   set qstatresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -j $normal_job_id" } qstatoutput ]

   if {$qstatresult == 1} {
      set_error -1 "qalter $option - qstat error: $qstatoutput"
      return
   }

   if {[regexp {context:[ \t]+([^ \t\r\n]+)\n} $qstatoutput context vars] != 1} {
      set_error -1 "qalter $option - qalter error: context variables were not set"
      return
   }

   if {$vars != "myvar=test,myvar2='test2a,test2b',myvar3=\"test3a,test3b\""} {
      set_error -1 "qalter $option - qalter error: context variables incorrect: $vars"
      return
   }

   set_error 0 "qalter $option - no errors"
   return
}

#                                                             max. column:     |
#****** qalter/qalter_A() ******
# 
#  NAME
#     qalter_A -- ??? 
#
#  SYNOPSIS
#     qalter_A { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_A {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-A blahblah"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_c() ******
# 
#  NAME
#     qalter_c -- ??? 
#
#  SYNOPSIS
#     qalter_c { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_c {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-c n -ckpt testcheckpointobject"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_ckpt() ******
# 
#  NAME
#     qalter_ckpt -- ??? 
#
#  SYNOPSIS
#     qalter_ckpt { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_ckpt {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-ckpt testcheckpointobject"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_clear() ******
# 
#  NAME
#     qalter_clear -- ??? 
#
#  SYNOPSIS
#     qalter_clear { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_clear {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-clear"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_cwd() ******
# 
#  NAME
#     qalter_cwd -- ??? 
#
#  SYNOPSIS
#     qalter_cwd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_cwd {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-cwd"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}
   
#                                                             max. column:     |
#****** qalter/qalter_dc() ******
# 
#  NAME
#     qalter_dc -- ??? 
#
#  SYNOPSIS
#     qalter_dc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_dc {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH normal_job_id
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   # Test delete with double-quoted list
   set option "-dc myvar3"
   set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $normal_job_id" } qalteroutput ]

   if {$qalterresult == 1} {
      set_error -1 "qalter $option - $qalteroutput"
      return
   }

   set qstatresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -j $normal_job_id" } qstatoutput ]

   if {$qstatresult == 1} {
      set_error -1 "qalter $option - qstat error: $qstatoutput"
      return
   }

   if {[regexp {context:[ \t]+([^ \t\r\n]+)\n} $qstatoutput context vars] != 1} {
      set_error -1 "qalter $option - qalter error: context variables were not set"
      return
   }

   if {$vars != "myvar=test,myvar2='test2a,test2b'"} {
      set_error -1 "qalter $option - qalter error: context variables incorrect: $vars"
      return
   }

   # Test delete with single-quoted list
   set option "-dc myvar2"
   set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $normal_job_id" } qalteroutput ]

   if {$qalterresult == 1} {
      set_error -1 "qalter $option - $qalteroutput"
      return
   }

   set qstatresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -j $normal_job_id" } qstatoutput ]

   if {$qstatresult == 1} {
      set_error -1 "qalter $option - qstat error: $qstatoutput"
      return
   }

   if {[regexp {context:[ \t]+([^ \t\r\n]+)\n} $qstatoutput context vars] != 1} {
      set_error -1 "qalter $option - qalter error: context variables were not set"
      return
   }

   if {$vars != "myvar=test"} {
      set_error -1 "qalter $option - qalter error: context variables incorrect: $vars"
      return
   }

   # Test delete without quotes
   set option "-dc myvar"
   set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $normal_job_id" } qalteroutput ]

   if {$qalterresult == 1} {
      set_error -1 "qalter $option - $qalteroutput"
      return
   }

   set qstatresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -j $normal_job_id" } qstatoutput ]

   if {$qstatresult == 1} {
      set_error -1 "qalter $option - qstat error: $qstatoutput"
      return
   }

   if {[regexp {context:[ \t]+([^ \t\r\n]+)\n} $qstatoutput context vars] == 1} {
      set_error -1 "qalter $option - qalter error: context variables were not deleted"
      return
   }

   set_error 0 "qalter $option - no errors"
   return
}

#                                                             max. column:     |
#****** qalter/qalter_e() ******
# 
#  NAME
#     qalter_e -- ??? 
#
#  SYNOPSIS
#     qalter_e { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_e {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno job_output_dir
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-e $job_output_dir"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_hard() ******
# 
#  NAME
#     qalter_hard -- ??? 
#
#  SYNOPSIS
#     qalter_hard { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_hard {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno CHECK_OUTPUT
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   set queue [get_queue_instance "all.q" [lindex $ts_config(execd_nodes) 0]]
  set option "-hard -q $queue"
  puts $CHECK_OUTPUT "calling: qalter $option $submitresult"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_hold() ******
# 
#  NAME
#     qalter_hold -- ??? 
#
#  SYNOPSIS
#     qalter_hold { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_hold {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
  global submitresult normal_job_id hold_job_A hold_job_B hold_job_C 
 
  
  set option "-hold_jid $normal_job_id,$hold_job_B,$hold_job_C,[expr ($hold_job_C + 1000 ) ]"
  puts $CHECK_OUTPUT "calling: qalter $option $hold_job_A"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $hold_job_A" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }

  if { [ release_job $hold_job_A ] != 0 } {
     set_error -1 "could not release job $hold_job_A"
     return
  }

  # wait for job to run
  if { [wait_for_jobstart $hold_job_A "leeper" 200 0] != -1 } {
     set_error -1 "job $hold_job_A should not start yet"
      delete_all_jobs
     return 
  }

  # release job B 
  if { [ release_job $hold_job_B ] != 0 } {
     set_error -1 "could not release job $hold_job_B"
     return
  }

  # release job C
  if { [ release_job $hold_job_C ] != 0 } {
     set_error -1 "could not release job $hold_job_C"
     return
  }

  # wait for job A to run 
  if { [wait_for_jobstart $hold_job_A "leeper" 200] != 0 } {
     set_error -1 "job $hold_job_A does not run"
      delete_all_jobs
     return 
  }


  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_j() ******
# 
#  NAME
#     qalter_j -- ??? 
#
#  SYNOPSIS
#     qalter_j { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_j {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-j y"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_l() ******
# 
#  NAME
#     qalter_l -- ??? 
#
#  SYNOPSIS
#     qalter_l { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_l {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-l h=[lindex $ts_config(execd_nodes) 0]"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_m() ******
# 
#  NAME
#     qalter_m -- ??? 
#
#  SYNOPSIS
#     qalter_m { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_m {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-m beas"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_notify() ******
# 
#  NAME
#     qalter_notify -- ??? 
#
#  SYNOPSIS
#     qalter_notify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_notify {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-notify"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_M() ******
# 
#  NAME
#     qalter_M -- ??? 
#
#  SYNOPSIS
#     qalter_M { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_M {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno CHECK_REPORT_EMAIL_TO
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

  if { [ string compare $CHECK_REPORT_EMAIL_TO "none" ] == 0 } {
      add_proc_error "qalter_M" -1 "no email address specified"  
      return
  }

  set option "-M $CHECK_REPORT_EMAIL_TO"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_N() ******
# 
#  NAME
#     qalter_N -- ??? 
#
#  SYNOPSIS
#     qalter_N { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_N {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-N Sleeper_job"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_o() ******
# 
#  NAME
#     qalter_o -- ??? 
#
#  SYNOPSIS
#     qalter_o { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_o {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno job_output_dir
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-o $job_output_dir"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_P() ******
# 
#  NAME
#     qalter_P -- ??? 
#
#  SYNOPSIS
#     qalter_P { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_P {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
  global check_errno CHECK_PRODUCT_TYPE
  global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-P mytestproject"
  if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0} {
    set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
    if {$qalterresult == 1} {
      set_error -1 "qalter $option - $qalteroutput"
      return
    }
    set_error 0 "qalter $option - no errors"
    return
  } else {
    # not possible for sge systems!
    set_error 0 "qalter $option - Not possible for Codine-System"
    return
  }
}

#                                                             max. column:     |
#****** qalter/qalter_p() ******
# 
#  NAME
#     qalter_p -- ??? 
#
#  SYNOPSIS
#     qalter_p { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_p {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-p 1024"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_pe() ******
# 
#  NAME
#     qalter_pe -- ??? 
#
#  SYNOPSIS
#     qalter_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_pe {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-pe mytestpe 1-3"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_q() ******
# 
#  NAME
#     qalter_q -- ??? 
#
#  SYNOPSIS
#     qalter_q { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_q {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

  set option "-q [get_queue_instance all.q [lindex $ts_config(execd_nodes) 0]]"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_ry() ******
# 
#  NAME
#     qalter_ry -- ??? 
#
#  SYNOPSIS
#     qalter_ry { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_ry {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-r y"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_rn() ******
# 
#  NAME
#     qalter_rn -- ??? 
#
#  SYNOPSIS
#     qalter_rn { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_rn {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-r n"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_sc() ******
# 
#  NAME
#     qalter_sc -- ??? 
#
#  SYNOPSIS
#     qalter_sc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_sc {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH hold_job_D
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   set option "-ac myvar=test4 -sc myvar=test,myvar2='test2a,test2b',myvar3=\"test3a,test3b\""
   # At this point, hold_job_D is the only single job still hanging around
   set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $hold_job_D" } qalteroutput ]

   if {$qalterresult == 1} {
      set_error -1 "qalter $option - $qalteroutput"
      return
   }

   set qstatresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -j $hold_job_D" } qstatoutput ]

   if {$qstatresult == 1} {
      set_error -1 "qalter $option - qstat error: $qstatoutput"
      return
   }

   if {[regexp {context:[ \t]+([^ \t\r\n]+)\n} $qstatoutput context vars] != 1} {
      set_error -1 "qalter $option - qalter error: context variables were not set"
      return
   }

   if {$vars != "myvar=test,myvar2='test2a,test2b',myvar3=\"test3a,test3b\""} {
      set_error -1 "qalter $option - qalter error: context variables incorrect: $vars"
      return
   }

   set_error 0 "qalter $option - no errors"
   return
}

#                                                             max. column:     |
#****** qalter/qalter_soft() ******
# 
#  NAME
#     qalter_soft -- ??? 
#
#  SYNOPSIS
#     qalter_soft { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_soft {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   set queue [get_queue_instance "all.q" [lindex $ts_config(execd_nodes) 0]]
  set option "-soft -q $queue"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_S() ******
# 
#  NAME
#     qalter_S -- ??? 
#
#  SYNOPSIS
#     qalter_S { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_S {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-S /bin/sh"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_v() ******
# 
#  NAME
#     qalter_v -- ??? 
#
#  SYNOPSIS
#     qalter_v { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_v {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-v DISPLAY"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_verify() ******
# 
#  NAME
#     qalter_verify -- ??? 
#
#  SYNOPSIS
#     qalter_verify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_verify {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-verify"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_V() ******
# 
#  NAME
#     qalter_V -- ??? 
#
#  SYNOPSIS
#     qalter_V { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_V {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER
  set option "-V"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_w() ******
# 
#  NAME
#     qalter_w -- ??? 
#
#  SYNOPSIS
#     qalter_w { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_w {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno 
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   set queue [get_queue_instance "all.q" [lindex $ts_config(execd_nodes) 0]]
  set option "-w e -q $queue"
  set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $submitresult" } qalteroutput ]
  if {$qalterresult == 1} {
    set_error -1 "qalter $option - $qalteroutput"
    return
  }
  set_error 0 "qalter $option - no errors"
  return
}

#                                                             max. column:     |
#****** qalter/qalter_a() ******
# 
#  NAME
#     qalter_a -- ??? 
#
#  SYNOPSIS
#     qalter_a { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_a {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult ts_config
   global check_errno job_output_dir CHECK_OUTPUT
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   set queue [get_queue_instance "all.q" [lindex $ts_config(execd_nodes) 0]]
   set job_id [ submit_job "-h -q $queue -e $job_output_dir -o $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" ]

   if {$job_id < 0 } {
     del_job_files $job_id $job_output_dir 2
     set_error -1 "failure"
     return
   }

   set hour [exec date "+%H"]
   set minute [exec date "+%M"]

   if { [string first "0" $hour] == 0 } {
      set hour [string index $hour 1 ]
   }  
   if { [string first "0" $minute] == 0 } {
      set minute [string index $minute 1 ]
   }  

   if {$minute < 58 } {
     set minute [expr ($minute + 2) ]
   } else {
     set minute [expr ($minute + 2 - 60) ]
 
     if {$hour < 23 } {
        set hour [expr ($hour + 1) ]
     } else {
        set hour "00"
     }
   }

   set rhour $hour
   set rminute $minute

   if {$hour < 10} {
     set rhour "0$hour"
   }
   if {$minute < 10} {
     set rminute "0$minute"
   }
   
   set start "[exec date +\%Y\%m\%d]$rhour$rminute"

   set option "-a $start"
 

   set time [timestamp]
   set seconds [exec date "+%S"]
   if { [string first "0" $seconds] == 0 } {
      set seconds [string index $seconds 1 ]
   }     

   puts $CHECK_OUTPUT "$option $job_id"
#   set result [eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat -j $job_id"]

   set qalterresult [eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $job_id"]
   if {$qalterresult == 1} {
     set_error -1 "qalter $option - couldn't change starttime"
     return
   }
   
   puts $CHECK_OUTPUT "will qrls $job_id now ..."


   #Release job
   set qrlsresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrls $job_id" } qrlsoutput ]

   puts $CHECK_OUTPUT "qrls result is $qrlsresult"
   puts $CHECK_OUTPUT "qrls output is $qrlsoutput"

   # calulate time until job should run
   set pend_time [expr ( [timestamp] - $time )]
   set wait_time [expr ( 120 - $pend_time - $seconds - 10 ) ] ;# 10 seconds are ok  
   puts $CHECK_OUTPUT "qalter $option - job should not start the next $wait_time seconds"
   set time [timestamp]
   if { [wait_for_jobstart $job_id "leeper" $wait_time 0] != -1 } {
      puts $CHECK_OUTPUT "qalter $option - time left: [expr ($wait_time - [expr ( [timestamp] - $time)] ) ]"
      set_error -1 "qalter $option - job should not run until yet"
      delete_all_jobs
      return 
   } 

   # wait for job to start
   puts $CHECK_OUTPUT "qalter $option - ok now the job should start"
   if { [wait_for_jobstart $job_id "leeper" 300] == -1 } {
      set_error -1 "qalter $option - job doesn't start"
      del_job_files $job_id $job_output_dir 2
      return 
   } 
 
   # wait for end of job
   if { [wait_for_jobend $job_id "leeper" 300] == -1 } {
      set_error -1 "qalter $option - job doesn't stop"
      del_job_files $job_id $job_output_dir 2
      return 
   } 
  
   set back [del_job_files $job_id $job_output_dir 2 ]  
   if { $back != 2 } {
        set_error -1 "qalter $option - can't delete Jobfile $job_id"
   } else {
        set_error 0 "qalter $option - no errors"
   }
}

#                                                             max. column:     |
#****** qalter/qalter_t() ******
# 
#  NAME
#     qalter_w -- test -t option for altering array jobs
#
#  SYNOPSIS
#     qalter_w { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qalter_t {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH submitresult
   global check_errno hold_job_T
   global check_errstr  CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_USER

   if { $ts_config(gridengine_version) == 53 } {
      set_error 0 "qalter -t not available for SGE(EE) 5.3"
   } else {
      set option "-h n"
      set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $hold_job_T -t 1-4" } qalteroutput ]
      if {$qalterresult == 1} {
         set_error -1 "qalter $option - $qalteroutput"
         return
      }

      # Test invalid uses
      set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option $hold_job_T -t 1-4 -t 1-4" } qalteroutput ]
      if {$qalterresult == 0} {
         set_error -1 "qalter $option - allowed invalid -t switch"
         return
      }

      set qalterresult [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qalter $option -t 1-4 $hold_job_T -t 1-4" } qalteroutput ]
      if {$qalterresult == 0} {
         set_error -1 "qalter $option - allowed invalid -t switch"
         return
      }
      set_error 0 "qalter $option - no errors"
   }
}

