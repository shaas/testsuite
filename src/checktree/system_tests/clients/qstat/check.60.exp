#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions
global check_category check_root_access_needs check_highest_level
global prj_exists

set check_root_access_needs  "yes"

set check_name           "qstat"
set check_category       "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level  0
set check_description(0) "checking qstat functionality (with and without -xml)"
set check_needs          "init_core_system "      ;# dependencies of this check (name of other check)

# define a level initialization procedure:
set check_init_level_procedure "qstat_init_level"

# setup and cleanup functions
set check_setup_function "qstat_setup"
set check_cleanup_function "qstat_cleanup"

set check_functions      {}
lappend check_functions  "check_core_queues"     ;# functions to call (in order)
lappend check_functions  "qstat_option_l"
lappend check_functions  "qstat_option_q"
lappend check_functions  "qstat_option_pe"
lappend check_functions  "qstat_option_U"
lappend check_functions  "qstat_option_s"
lappend check_functions  "qstat_issue1800"

lappend check_functions  "qstat_plain_xml_comparison"  ;# Compare the two qstatcommands
lappend check_functions  "qstat_ne_plain_xml_comparison"  ;# Compare the two qstat -ne commands
#lappend check_functions  "qstat_r_plain_xml_comparison"  ;# Compare the two qstat -r commands
#lappend check_functions  "qstat_j_ERROR_plain_xml_comparison"  ;# Compare the two qstat -j ERROR commands
#lappend check_functions  "qstat_j_plain_xml_comparison"  ;# Compare the two qstat -j  commands
lappend check_functions  "qstat_urg_plain_xml_comparison"  ;# Compare the two qstat -urg commands
#lappend check_functions  "qstat_f_urg_plain_xml_comparison"  ;# Compare the two qstat -f -urg commands
lappend check_functions  "qstat_pri_plain_xml_comparison"  ;# Compare the two qstat -pri commands
lappend check_functions  "qstat_f_qs_plain_xml_comparison"  ;# Compare the two qstat -f -qs E commands
#lappend check_functions  "qstat_l_q_plain_xml_comparison"  ;# Compare the two qstat -l q=all.q commands
#lappend check_functions  "qstat_f_plain_xml_comparison"  ;# Compare the two qstat -f commands
#lappend check_functions  "qstat_explain_plain_xml_comparison"  ;# Compare the two qstat -explain E commands
#lappend check_functions  "qstat_f_q_plain_xml_comparison"  ;# Compare the two qstat -f -q all.q commands
#lappend check_functions  "qstat_f_ne_plain_xml_comparison"  ;# Compare the two qstat -f -ne commands
#lappend check_functions  "qstat_ext_plain_xml_comparison"  ;# Compare the two qstat -ext commands
#lappend check_functions  "qstat_f_r_plain_xml_comparison"  ;# Compare the two qstat -f -r commands
#lappend check_functions  "qstat_f_ext_plain_xml_comparison"  ;# Compare the two qstat -f -ext commands
#lappend check_functions  "qstat_F_plain_xml_comparison"  ;# Compare the two qstat -F commands
#lappend check_functions  "qstat_F_rerun_h_vmem_plain_xml_comparison"  ;# Compare the two qstat -F rerun,h_vmem commands
#lappend check_functions "qstat_g_c_plain_xml_comparison" ;# Compare the two qstat -g c commands
#lappend check_functions "qstat_g_d_plain_xml_comparison" ;# Compare the two qstat -g d commands
#lappend check_functions "qstat_g_t_plain_xml_comparison" ;# Compare the two qstat -g t commands
#lappend check_functions "qstat_s_a_plain_xml_comparison" ;# Compare the two qstat -s a commands
lappend check_functions "qstat_s_p_plain_xml_comparison" ;# Compare the two qstat -s p commands
lappend check_functions "qstat_s_r_plain_xml_comparison" ;# Compare the two qstat -s r commands
lappend check_functions "qstat_s_s_plain_xml_comparison" ;# Compare the two qstat -s s commands
lappend check_functions "qstat_s_z_plain_xml_comparison" ;# Compare the two qstat -s z commands
lappend check_functions "qstat_s_hs_plain_xml_comparison" ;# Compare the two qstat -s hs commands
lappend check_functions "qstat_s_hu_plain_xml_comparison" ;# Compare the two qstat -s hu commands
lappend check_functions "qstat_u_valid_plain_xml_comparison" ;# Compare the two qstat -u $CHECK_USER commands
lappend check_functions "qstat_u_invalid_plain_xml_comparison" ;# Compare the two qstat -u wrong_user commands
lappend check_functions "qstat_U_valid_plain_xml_comparison" ;# Compare the two qstat -U $CHECK_USER commands
lappend check_functions "test_issue123"

proc qstat_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      0 {
         return 0
      }
   }

   return -1
}


# TODO: (CR) 1) This test should not simply wait 10 seconds for the job to start (after 10000)
#            2) Why is the test useing its own submitter script (we can not work with job ids here)
#            3) Why is the qsub of -N QERROR job disabled in the job start script?


proc qstat_setup {} {
   global ts_config CHECK_HAVE_TDOM
   global first_host last_host prj_exists

   # First add queues "error" with one host (last).
   # Set prolog to non-existent path, and np_load_avg to 10
   if {[llength $ts_config(execd_nodes)] < 2} {
      ts_log_config "we need a minumum of 2 hosts to run the qstat test"
      return -1
   }

   # verify if we can perform the qstat -xml tests
   if {$CHECK_HAVE_TDOM == 0} {
      ts_log_config "The tDOM TCL package is not installed!\nWe cannot run the qstat -xml tests!"
   }

   # our test hosts
   set hosts [host_conf_get_suited_hosts 2]
   set first_host [lindex $hosts 0]
   set last_host  [lindex $hosts 1]

   # some test queues
   set wrong_queue "wrong.q"
   set new_wrong_queue(prolog)  "/non/existent/path"
   set new_wrong_queue(load_thresholds)  "np_load_avg=10"
   add_queue $wrong_queue $last_host new_wrong_queue

   set empty_queue "empty.q"
   set new_empty_queue(pe_list)  "NONE"
   set new_empty_queue(load_thresholds)  "np_load_avg=10"
   add_queue $empty_queue $first_host new_empty_queue

   set prj "qstat_j_project"
   set result0 [get_project_list]
   set prj_exists "false"
   foreach elem $result0 {
      if {[string compare $elem $prj] == 0} {
         set prj_exists "true"
      }
   }
   if {$prj_exists == "false"} {
      set result [add_project $prj]
   }
}

proc qstat_cleanup {} {
   global ts_config prj_exists

   delete_all_jobs
   wait_for_end_of_all_jobs

   del_queue "wrong.q" "" 1 1
   del_queue "empty.q" "" 1 1

   # remove files / queues from qstat_profile test
   set home [glob "~/"]
   #
   # Delete regardless....
   #
   file delete "$ts_config(product_root)/$ts_config(cell)/common/sge_qstat"
   file delete "$home/.sge_qstat"
   #
   # Clean up test.q if it's still around.
   #
   get_queue_list queue_list
   foreach queue $queue_list {
      if {$queue != "all.q"} {
         del_queue $queue "" 1 1
      }
   }

   set prj "qstat_j_project"
   if {$prj_exists == "false"} {
      set result [del_project $prj]
   }
}

#****** check/qstat_count_jobs() ***********************************************
#  NAME
#     qstat_count_jobs() -- count the jobs of the qstat output with the
#                           given options 
#
#  SYNOPSIS
#     qstat_count_jobs { func_name qstat_options expected_jobs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     func_name     - name of the calling function. needed for ts_log_severe
#     qstat_options - options for qstat 
#     expected_jobs - the nr of the expected job count
#
#*******************************************************************************
proc qstat_count_jobs {func_name qstat_options expected_jobs} {
   global ts_config 
   
   ts_log_fine "\nrunning qstat $qstat_options"
   set output [start_sge_bin "qstat" $qstat_options]
   ts_log_fine $output

   if {$prg_exit_state == 0} {
      if {[info exists jobinfo]} {
         unset jobinfo
      }  
      parse_qstat output jobinfo
      set shown_jobs $jobinfo(index)
      set nr_jobs [llength $shown_jobs]

      ts_log_fine "number of jobs: $nr_jobs"
      if {$nr_jobs != $expected_jobs} {
         ts_log_severe "$func_name: qstat $qstat_options broken, got $nr_jobs but expected $expected_jobs"
      }
   } else {
      ts_log_severe "$func_name: qstat $qstat_options exit status not 0 ($prg_exit_state), output:\n$output"
   }
}

# here starts the test
#                                                             max. column:     |
#****** qstat/check_core_queues() ******
# 
#  NAME
#     check_core_queues -- ??? 
#
#  SYNOPSIS
#     check_core_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_core_queues {} {
  global ts_config CHECK_USER

  set check_host [host_conf_get_suited_hosts]

  set result [start_sge_bin "qstat" "-f -q all.q"]
#
#Original output of qstat -f looks like this for 6.0 and 6.1:
#>qstat -f
#queuename            qtype used/tot. load_avg arch    states
#----------------------------------------------------------------------------
#all.q@balrog             BI    0/2       1.42     solaris64 
#----------------------------------------------------------------------------
#all.q@dwain              BI    1/1       2.00     irix6     a
#     2     0 Sleeper    crei         r     05/15/2000 13:09:48 MASTER           
#
############################################################################
# - PENDING JOBS - PENDING JOBS - PENDING JOBS - PENDING JOBS - PENDING JOBS
############################################################################
#     3     0 Sleeper    crei         qw    05/15/2000 13:09:49          
#
#And since 6.2
#>qstat -f
#queuename            qtype resv/used/tot. load_avg arch    states
#----------------------------------------------------------------------------
#all.q@balrog             BI    0/0/2       1.42     solaris64 
#----------------------------------------------------------------------------
#all.q@dwain              BI    0/1/1       2.00     irix6     a
#     2     0 Sleeper    crei         r     05/15/2000 13:09:48 MASTER           
#
############################################################################
# - PENDING JOBS - PENDING JOBS - PENDING JOBS - PENDING JOBS - PENDING JOBS
############################################################################
#     3     0 Sleeper    crei         qw    05/15/2000 13:09:49          

  # split each line as listelement
  set help [split $result "\n"]
 
  #remove first line
  set help [lreplace $help 0 0]
  set data ""

  #get every line after "----..." line 
  set len [llength $help]
  for {set ind 0} {$ind < $len } {incr ind 1} {
     if {[lsearch [lindex $help $ind] "------*"] >= 0 } {
        lappend data [lindex $help [expr $ind + 1]]
     }
  }

  set qcount [llength $data]
  set qnames ""
  set slots ""
  set load ""

  # get line data information for queuename used/tot and load_avg
  foreach elem $data {
     set linedata $elem
     lappend qnames [lindex $linedata 0]
     set used_tot [lindex $linedata 2]
     set pos1 [expr [string last "/" $used_tot] + 1]
     set pos2 [expr [string length $used_tot]   - 1]

     lappend slots [string range $used_tot $pos1 $pos2 ]
     lappend load [lindex $linedata 3]
  }

  # check if number of queues matches core system queue count
  if {[llength $ts_config(execd_nodes)] != $qcount} {
     ts_log_severe "queue count doesn't match (number of queues should be [llength $ts_config(execd_nodes)])"
     return
  }

  # check if slots for host $check_host are correct (needs successfully tested "loadcheck" check)
  set numofproc [node_get_processors $check_host]
  ts_log_fine "got $numofproc slots"

  set queue_name [get_queue_instance "all.q" [resolve_host $check_host 1]]
  set reported_slots [lindex $slots [lsearch $qnames $queue_name]]

  # Testsuite sets up 10 slots per CPU, but not more than 100 slots per queue instance,
  # so we don't expect more.
  set expected_slots [min [expr $numofproc * 10] 100]
  if {$reported_slots != $expected_slots} {
     ts_log_severe "queue $queue_name should have $expected_slots slots (min(cpu count * 10, 100))\nqstat reported $reported_slots"
     return
  }

  # check if load of an host is set > 99 (no execd report)
  set ind 0
  foreach elem $load {
    if {$elem >= 99} {
       ts_log_severe "queue [lindex $qnames $ind] has load > 99"
       return
    }
    incr ind 1
  }

  ts_log_fine "check_core_queues\n- number of queues: $qcount\n- qnames: $qnames\n- slots: $slots\n- load: $load"
}

proc qstat_option_l {} {
  global ts_config

   set check_host [host_conf_get_suited_hosts]
   set my_arch [resolve_arch $check_host]

   ts_log_fine "submitting job requesting arch=$my_arch ..."   
   set arguments "-o /dev/null -e /dev/null -h -l arch=$my_arch"
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"

   ts_log_fine "submitting job requesting arch=undefined_arch ..."  
   set arguments "-o /dev/null -e /dev/null -h -l arch=undefined_arch"
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"

   qstat_count_jobs "qstat_option_l" "-l arch=$my_arch" 3 
   qstat_count_jobs "qstat_option_l" "-l arch=undefined_arch" 0 

   delete_all_jobs
   wait_for_end_of_all_jobs
}

proc qstat_option_q {} {
  global ts_config

  ts_log_fine "submitting jobs requesting each queue ..."   
  foreach host $ts_config(execd_nodes) {
     set qname [get_queue_instance "all.q" $host]
     set arguments "-o /dev/null -e /dev/null -h -q $qname"
     submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"
  }

  foreach host $ts_config(execd_nodes) {
     set qname [get_queue_instance "all.q" $host]
     qstat_count_jobs "qstat_option_q" "-q $qname" 1 
  }

  delete_all_jobs
  wait_for_end_of_all_jobs
}


proc qstat_option_pe {} {
   global ts_config

   set hostname [host_conf_get_suited_hosts]

   set testq(load_thresholds) "np_load_avg=7.00"
   set testq(slots) 10
   add_queue "test1.q" $hostname testq
   add_queue "test2.q" $hostname testq

   set mype1(slots) 6 
   set mype1(allocation_rule) "\$pe_slots"
   add_pe "mype1" mype1
   assign_queues_with_pe_object "test1.q" $hostname mype1

   set mype2(slots) 2
   set mype2(allocation_rule) "\$pe_slots"
   add_pe "mype2" mype2
   assign_queues_with_pe_object "test2.q" $hostname mype2

   set job_id_list ""
   ts_log_fine "submitting job requesting pe mype1 ..."   
   set arguments "-o /dev/null -e /dev/null -pe mype1 2"
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
   lappend job_id_list $job_id
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
   lappend job_id_list $job_id
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
   lappend job_id_list $job_id

   ts_log_fine "submitting job requesting pe mype2 ..."  
   set arguments "-o /dev/null -e /dev/null -pe mype2 2"
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
   lappend job_id_list $job_id

   foreach jobid $job_id_list {
      wait_for_jobstart $jobid "Sleeper" 60
   }
  
   qstat_count_jobs "qstat_option_pe" "-pe mype1" 3
   qstat_count_jobs "qstat_option_pe" "-pe mype2" 1 
   
   delete_all_jobs
   wait_for_end_of_all_jobs
   
   del_pe "mype1"
   del_pe "mype2"

   del_queue "test1.q" $hostname 0 1
   del_queue "test2.q" $hostname 0 1
}

proc qstat_option_U {} {
   global ts_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

   set hostname [host_conf_get_suited_hosts]
   set testq(load_thresholds) "np_load_avg=7.00"
   set testq(slots) 10
   set testq(user_lists) deadlineusers 
   add_queue "test.q" $hostname testq
   set qname [get_queue_instance "test.q" $hostname]

   ts_log_fine "submitting jobs as user $CHECK_USER ..."   
   set arguments "-o /dev/null -e /dev/null  -q $qname"
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_USER
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_USER
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_USER

   ts_log_fine "submitting job as user $CHECK_FIRST_FOREIGN_SYSTEM_USER ..."
   set arguments "-o /dev/null -e /dev/null -h -q $qname"
   submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER

   qstat_count_jobs "qstat_option_U" "-u '*' -U $CHECK_USER" 4

   if {$ts_config(gridengine_version) >= 61} {
      qstat_count_jobs "qstat_option_U" "-U $CHECK_USER" 3
   } else {
      qstat_count_jobs "qstat_option_U" "-U $CHECK_USER" 4
   }

   qstat_count_jobs "qstat_option_U" "-u '*' -U $CHECK_FIRST_FOREIGN_SYSTEM_USER" 0
   qstat_count_jobs "qstat_option_U" "-U $CHECK_FIRST_FOREIGN_SYSTEM_USER" 0

   delete_all_jobs
   wait_for_end_of_all_jobs
   del_queue "test.q" 1 1
}

proc qstat_option_s {} {
  global ts_config

  ts_log_fine "submitting a long running batch job ..."   
  set arguments "-o /dev/null -e /dev/null"
  set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100000"]
  wait_for_jobstart $job_id "Sleeper" 60

  ts_log_fine "submitting & suspending a batch job ..."   
  set arguments "-o /dev/null -e /dev/null"
  set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100000"]
  wait_for_jobstart $job_id "Sleeper" 60
  set result [start_sge_bin "qmod" "-s $job_id"]

  ts_log_fine "submitting an user hold batch job ..."   
  set arguments "-h -o /dev/null -e /dev/null"
  submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"

  ts_log_fine "submitting an system hold batch job ..."   
  set arguments "-h -o /dev/null -e /dev/null"
  set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
  set result [start_sge_bin "qalter" "-h s $job_id"]
  set result [start_sge_bin "qalter" "-h U $job_id"]

  ts_log_fine "submitting an operator hold batch job ..."   
  set arguments "-h -o /dev/null -e /dev/null"
  set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
  set result [start_sge_bin "qalter" "-h o $job_id"]
  set result [start_sge_bin "qalter" "-h U $job_id"]

  ts_log_fine "submitting an dependency hold batch job ..."   
  set arguments "-hold_jid \"Sleeper\" -o /dev/null -e /dev/null"
  submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"

  #-s a
  qstat_count_jobs "qstat_option_s" "-s a" 6

  #-s h
  qstat_count_jobs "qstat_option_s" "-s h" 4 

  #-s hu
  qstat_count_jobs "qstat_option_s" "-s hu" 1 

  #-s hs
  qstat_count_jobs "qstat_option_s" "-s hs" 1 

  #-s ho
  qstat_count_jobs "qstat_option_s" "-s ho" 1 

  #-s hj
  qstat_count_jobs "qstat_option_s" "-s hj" 1 

  #-s p
  qstat_count_jobs "qstat_option_s" "-s p" 4 

  #-s r
  qstat_count_jobs "qstat_option_s" "-s r" 1 

  #-s s 
  qstat_count_jobs "qstat_option_s" "-s s" 1 

  # some combinations
  qstat_count_jobs "qstat_option_s" "-s hss" 2
  qstat_count_jobs "qstat_option_s" "-s hr"  5
  qstat_count_jobs "qstat_option_s" "-s hhs" 4
  qstat_count_jobs "qstat_option_s" "-s hsh" 4
  qstat_count_jobs "qstat_option_s" "-s huhshohj" 4


  #-s ha
  ts_log_fine "submitting an date hold batch job ..."   
  #
  # Set duetime well in the future. No hard coded values, please.
  # 
  set duetime [clock format [clock scan "next week"] -format "%m%d%H%M"]
  set arguments "-a $duetime -o /dev/null -e /dev/null"
  submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"
  qstat_count_jobs "qstat_option_s" "-s ha" 1 

  # TODO test critical states & combinations

  delete_all_jobs
  wait_for_end_of_all_jobs
}

proc qstat_issue1800 {} {
  global ts_config CHECK_USER 
  global first_host

  ts_log_fine "submitting an array job ..."   
  set arguments "-l h=$first_host -o /dev/null -e /dev/null -t 1-1000"
  set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
  wait_for_jobstart $job_id "Sleeper" 60

  qstat_count_jobs "qstat_issue1800" "-s p" 1 

  qstat_count_jobs "qstat_issue1800" "-s hu" 0 
  start_sge_bin "qalter" "-h u $job_id"
  qstat_count_jobs "qstat_issue1800" "-s hu" 1 

  qstat_count_jobs "qstat_issue1800" "-s hs" 0 
  start_sge_bin "qalter" "-h s $job_id"
  qstat_count_jobs "qstat_issue1800" "-s hs" 1 
   
  qstat_count_jobs "qstat_issue1800" "-s ho" 0 
  start_sge_bin "qalter" "-h o $job_id"
  qstat_count_jobs "qstat_issue1800" "-s ho" 1 

  delete_job $job_id 1
}

#
#****** qstat/qstat_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_plain_xml_comparison() -- Compare plain and XML ouptout of qstat
#     command.
#
#  SYNOPSIS
#     qstat_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_plain_output contains the plain qstat output in an assoc. array
   # qstat_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_plain_output]

   ts_log_fine "plain qstat array .... \n"
   parray qstat_plain_output

   # qstat_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_xml_output]

   ts_log_fine "xml qstat array .... \n"
   parray qstat_xml_output

   # Now let's compare them by jobid.
   set jobid_list  $qstat_plain_output(index)

   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if {$column == "state" || $column == "queue" || $column == "master"} {
            set qstat_xml_output($jobid,$column) [string trim $qstat_xml_output($jobid,$column)]
         }

         if {$qstat_plain_output($jobid,$column) != $qstat_xml_output($jobid,$column)} {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_plain_output was $qstat_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_xml_output was $qstat_xml_output($jobid,$column)... \n"
            incr error_flag 1
         }
      }
   }

   if {$error_flag != 0} {
      ts_log_severe "error in plain, XML qstat"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

  

#
#****** qstat/qstat_ne_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_ne)plain_xml_comparison() -- Compare plain and XML ouptout of qstat -ne
#     command.
#
#  SYNOPSIS
#     qstat_ne_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -ne command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_ne_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_ne_plain_output contains the plain qstat output in an assoc. array
   # qstat_ne)plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_ne_plain_output "-ne"]
   
   ts_log_fine "plain qstat -ne array .... \n"
   parray qstat_ne_plain_output
   
   # qstat_ne_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_ne_xml_output "-ne"]
   
   ts_log_fine "xml qstat -ne array .... \n"
   parray qstat_ne_xml_output

   # Now let's compare them by jobid. 
   set jobid_list   $qstat_ne_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_ne_xml_output($jobid,$column) [string trim $qstat_ne_xml_output($jobid,$column)]
         }
         
         if { $qstat_ne_plain_output($jobid,$column) != $qstat_ne_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_ne_plain_output was $qstat_ne_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_ne_xml_output was $qstat_ne_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -ne"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#****** qstat/qstat_j_ERROR_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_j_ERROR_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -j ERROR"  command.
#
#  SYNOPSIS
#     qstat_j_ERROR_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -j ERROR" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_j_ERROR_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH  CHECK_USER
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_j_ERROR_plain_output contains the plain qstat output in an assoc. array
   # qstat_j_ERROR_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_j_ERROR_plain_parse qstat_j_ERROR_plain_output]
   
   ts_log_fine "plain qstat -j ERROR array .... \n"
   parray qstat_j_ERROR_plain_output

   # qstat_j_ERROR_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_j_JOB_NAME_xml_parse qstat_j_ERROR_xml_output "ERROR"]
   
   ts_log_fine "xml qstat -j ERROR array .... \n"
   parray qstat_j_ERROR_xml_output

   set jobid_list  $qstat_j_ERROR_plain_output(jobid_list)
   
   # We skip some comparisons also due to a bug in qstat -j JOB_NAME:
   # See IZ 2067 for details.
   set column_vars "exec_file account owner uid group gid submission_time  \
                    sge_o_home notify job_name  jobshare env_list  script_file  \ 
                    sge_o_log_name sge_o_path sge_o_shell sge_o_workdir sge_o_host"
                    # scheduling hard_queue_list  \
                    # merge reason mail_list stdout_path_list \
                    # shell_list job_args
   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {      
         # Skip comparison for "notify, since plain and XML outputs are different letter
         # cases! Upper vs. lower.
         # See IZ 2069 for details.
         if { ($column == "notify") && ($qstat_j_ERROR_plain_output($jobid,$column) == "FALSE") && \
               ($qstat_j_ERROR_xml_output($jobid,$column) == "false") || \
               ($qstat_j_ERROR_plain_output($jobid,$column) == "TRUE") && \
               ($qstat_j_ERROR_xml_output($jobid,$column) == "true") } {
             continue
         }
         
         if { $qstat_j_ERROR_plain_output($jobid,$column) != $qstat_j_ERROR_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_j_ERROR_plain_output was $qstat_j_ERROR_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_j_ERROR_xml_output was $qstat_j_ERROR_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -j ERROR"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#****** qstat/qstat_j_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_j_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -j "  command.
#
#  SYNOPSIS
#     qstat_j_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -j " command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_j_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH  CHECK_USER
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }
    
#     ts_log_fine "skipping this test, as qstat -j is broken. See IZ 2076, 2077, 2079"
#     return
   
   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_j_plain_output contains the plain qstat output in an assoc. array
   # qstat_j_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_j_plain_parse qstat_j_plain_output]
   
   ts_log_fine "plain qstat -j  array .... \n"
   parray qstat_j_plain_output
   
   # qstat_j_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_j_xml_parse qstat_j_xml_output]
   
   ts_log_fine "xml qstat -j array .... \n"
   parray qstat_j_xml_output

   set jobid_list  $qstat_j_plain_output(jobid_list)
   
   # We skip some comparisons also due to a bug in qstat -j JOB_NAME:
   # See IZ 2067 for details.
   set column_vars "jobid jobid_msg"
   
   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {      
         if { $qstat_j_plain_output($jobid,$column) != $qstat_j_xml_output($jobid,$column) } {
            
            # Put this if due to mismatch in plain, XML messages output. See IZ 2076, 2077  for details.
            if { ($qstat_j_plain_output($jobid,$column) == "Jobs dropped because of error state") && \
                 ($qstat_j_xml_output($jobid,$column) == "job is in error state") || \
                 ($qstat_j_plain_output($jobid,$column) ==  "Jobs dropped because of hold state") && \
                 ($qstat_j_xml_output($jobid,$column) == "job dropped because of hold") } {
               continue
            }
            
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_j_plain_output was $qstat_j_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_j_xml_output was $qstat_j_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -j "
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#
#****** qstat/qstat_r_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_r_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -r
#     command.
#
#  SYNOPSIS
#     qstat_r_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************
proc qstat_r_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
   
   # Clear error states, if any
   set result01 [start_sge_bin "qmod" "-c all.q"]
   set result02 [start_sge_bin "qmod" "-c wrong.q"]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_r_plain_output contains the plain qstat output in an assoc. array
   # qstat_r_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_r_plain_parse qstat_r_plain_output]
   
   ts_log_fine "plain qstat -r array .... \n"
   parray qstat_r_plain_output
   
   # qstat_r_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_r_xml_output "-r"]
   
   ts_log_fine "xml qstat -r array .... \n"
   parray qstat_r_xml_output

   # Now let's compare them by jobid.  
   set jobid_list  $qstat_r_plain_output(jobid_list) 
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   
   # We also skip the master_queue, full_jobname comparisons due to bug in
   # qstat -x -xml
   # See IZ 2065 for details
   set column_vars "prior name user state time queue task_id   \
   hard_resource soft_resource hard_req_queue  req_pe_value  granted_pe_value"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or these values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "task_id") || \
            ($column == "full_jobname") || ($column == "master_queue") || ($column == "hard_resource") || \
            ($column == "soft_resource") || ($column == "hard_req_queue") || ($column == "req_pe") || \
            ($column == "req_pe_value") || ($column == "granted_pe") || ($column == "granted_pe_value") } {
            append qstat_r_plain_output($jobid,$column) ""
            append qstat_r_xml_output($jobid,$column) ""
            set qstat_r_plain_output($jobid,$column) [string trim $qstat_r_plain_output($jobid,$column)]
            set qstat_r_xml_output($jobid,$column) [string trim $qstat_r_xml_output($jobid,$column)]
         }
         
         if { $qstat_r_plain_output($jobid,$column) != $qstat_r_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_r_plain_output was $qstat_r_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_r_xml_output was $qstat_r_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -r"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}
 
#
#****** qstat/qstat_f_r_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_r_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -f -r
#     command.
#
#  SYNOPSIS
#     qstat_f_r_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -f -r command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_r_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
      
   # Clear error states, if any
   set result01 [start_sge_bin "qmod" "-c all.q"]
   set result02 [start_sge_bin "qmod" "-c wrong.q"]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_f_r_plain_output contains the plain qstat output in an assoc. array
   # qstat_f_r_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_f_r_plain_parse qstat_f_r_plain_output]
      
   ts_log_fine "plain qstat -f -r array .... \n"
   parray qstat_f_r_plain_output
      
   # qstat_f_r_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_f_r_xml_output "-r"]
      
   ts_log_fine "xml qstat -f -r array .... \n"
   parray qstat_f_r_xml_output

   # Now let's compare them by jobid. 
   set jobid_list  $qstat_f_r_plain_output(jobid_list)  
      
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
      
   # We also skip the master_queue, full_jobname comparisons due to bug in
   # qstat -x -xml
   # See IZ 2065 for details
   set column_vars "prior name user state time queue task_id   \
   hard_resource soft_resource hard_req_queue  req_pe_value  granted_pe_value"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # Need to put $jobid$column since $jobid contains a "," already!
         # For columns state, queue and master, trim the trailing blanks
         
         # For queue or these values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "task_id") || \
            ($column == "full_jobname") || ($column == "master_queue") || ($column == "hard_resource") || \
            ($column == "soft_resource") || ($column == "hard_req_queue") || ($column == "req_pe") || \
            ($column == "req_pe_value") || ($column == "granted_pe") || ($column == "granted_pe_value") } {
            append qstat_f_r_plain_output($jobid,$column) ""
            append qstat_f_r_xml_output($jobid,$column) ""
            set qstat_f_r_plain_output($jobid,$column) [string trim $qstat_f_r_plain_output($jobid,$column)]
            set qstat_f_r_xml_output($jobid,$column) [string trim $qstat_f_r_xml_output($jobid,$column)]
         }
            
         if { $qstat_f_r_plain_output($jobid,$column) != $qstat_f_r_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_r_plain_output was $qstat_f_r_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_f_r_xml_output was $qstat_f_r_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }
      
   # Now compare the queue information output   
   set queue_list $qstat_f_r_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_f_r_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_f_r_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if {$plain_queue_length != $xml_queue_length} {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_f_r_plain_output($queue,$column) != $qstat_f_r_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_r_plain_output was $qstat_f_r_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_f_r_xml_output was $qstat_f_r_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
      
   if {$error_flag != 0} {  
      ts_log_severe "error in plain, XML qstat -f -r"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}
 

#
#
#****** qstat/qstat_urg_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_urg_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -urg
#     command.
#
#  SYNOPSIS
#     qstat_urg_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -urg command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_urg_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global  CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # qstat_urg_plain_output contains the plain qstat output in an assoc. array
   # qstat_urg_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_urg_plain_parse qstat_urg_plain_output ]
   
   ts_log_fine "plain qstat -urg array .... \n"
   parray qstat_urg_plain_output
   
   # qstat_urg_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_urg_xml_output "-urg"]
   
   ts_log_fine "xml qstat -urg array .... \n"
   parray qstat_urg_xml_output

   # Now let's compare them by jobid.
   set jobid_list  $qstat_urg_plain_output(jobid_list)  
   set column_vars "prior nurg urg rrcontr wtcontr dlcontr name user time queue slots task_id"  

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         if { ($column == "slots") || ($column == "queue") || ($column == "task_id") } {
            append qstat_urg_xml_output($jobid,$column) " "
            set qstat_urg_xml_output($jobid,$column) [string trim $qstat_urg_xml_output($jobid,$column)]
            set qstat_urg_plain_output($jobid,$column) [string trim $qstat_urg_plain_output($jobid,$column)]

         }
         
         if { $qstat_urg_plain_output($jobid,$column) != $qstat_urg_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_urg_plain_output was $qstat_urg_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_urg_xml_output was $qstat_urg_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -urg"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#
#****** qstat/qstat_f_urg_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_urg_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -f -urg
#     command.
#
#  SYNOPSIS
#     qstat_f_urg_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -urg command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_urg_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global  CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
   
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # qstat_f_urg_plain_output contains the plain qstat  output in an assoc. array
   # qstat_f_urg_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_f_urg_plain_parse qstat_f_urg_plain_output "-f"]]
   
   ts_log_fine "plain qstat -f -urg array .... \n"
   parray qstat_f_urg_plain_output
   
   # qstat_f_urg_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_f_urg_xml_output "-urg"]
   
   ts_log_fine "xml qstat -f -urg array .... \n"
   parray qstat_f_urg_xml_output

   # Now let's compare them by jobid.
   set jobid_list  $qstat_f_urg_plain_output(jobid_list) 
   
   # No "queue" var. See IZ 2072.
   set column_vars "prior nurg urg rrcontr wtcontr dlcontr name user time  slots task_id"  

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         if { ($column == "slots") || ($column == "queue") || ($column == "task_id") } {
            append qstat_f_urg_xml_output($jobid,$column) " "
            set qstat_f_urg_xml_output($jobid,$column) [string trim $qstat_f_urg_xml_output($jobid,$column)]
            # Get rid of extra white spaces
            set single_white_space_string [qstat_special_parse $qstat_f_urg_xml_output($jobid,$column) ]
            set qstat_f_urg_xml_output($jobid,$column)  $single_white_space_string
            set qstat_f_urg_plain_output($jobid,$column) [string trim $qstat_f_urg_plain_output($jobid,$column)]
         }
         
         if { $qstat_f_urg_plain_output($jobid,$column) != $qstat_f_urg_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_urg_plain_output was $qstat_f_urg_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_f_urg_xml_output was $qstat_f_urg_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }
      
   # Now compare the queue information output   
   set queue_list $qstat_f_urg_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_f_urg_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_f_urg_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if {$plain_queue_length != $xml_queue_length} {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_f_urg_plain_output($queue,$column) != $qstat_f_urg_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_urg_plain_output was $qstat_f_urg_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_f_urg_xml_output was $qstat_f_urg_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
         
   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -f -urg"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#****** qstat/qstat_pri_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_pri_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -urg
#     command.
#
#  SYNOPSIS
#     qstat_pri_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -urg command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_pri_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # qstat_pri_plain_output contains the plain qstat output in an assoc. array
   # qstat_pri_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_pri_plain_parse qstat_pri_plain_output ]
   
   ts_log_fine "plain qstat -pri array .... \n"
   parray qstat_pri_plain_output
   
   # qstat_pri_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_pri_xml_output "-pri"]
   
   ts_log_fine "xml qstat -pri array .... \n"
   parray qstat_pri_xml_output

   # Now let's compare them by jobid. 
   set jobid_list  $qstat_pri_plain_output(jobid_list)  
   
   # Skip nurg and ntckts colums since XML output does not report those
   # See IZ 2060 for details.
   set column_vars "prior npprior ppri name  user state time queue slots task_id "  
         
   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         if { ($column == "slots") || ($column == "queue") || ($column == "task_id") } {
            append qstat_pri_xml_output($jobid,$column) " "
            
            set special_plain [qstat_special_parse $qstat_pri_plain_output($jobid,$column)]
            set qstat_pri_plain_output($jobid,$column) $special_plain
            set special_xml [qstat_special_parse $qstat_pri_xml_output($jobid,$column)]
            set qstat_pri_xml_output($jobid,$column) $special_xml
            
            set qstat_pri_plain_output($jobid,$column) [string trim $qstat_pri_plain_output($jobid,$column)]               
            set qstat_pri_xml_output($jobid,$column) [string trim $qstat_pri_xml_output($jobid,$column)]
         }
         
         if { $qstat_pri_plain_output($jobid,$column) != $qstat_pri_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_pri_plain_output was $qstat_pri_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_pri_xml_output was $qstat_pri_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -pri"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}



#****** qstat/qstat_l_q_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_l_q_plain_xml_comparison() -- Compare plain and XML ouptout of "qstat -l q=all.q"
#     command.
#
#  SYNOPSIS
#     qstat_l_q_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_l_q_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_l_q_plain_output contains the plain qstat output in an assoc. array
   # qstat_l_q_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_l_q_plain_output "-l q=all.q"]
   
   ts_log_fine "plain qstat -l q=all.q array .... \n"
   parray qstat_l_q_plain_output
   
   # qstat_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_l_q_xml_output "-l q=all.q"]
   
   ts_log_fine "xml qstat -l q=all.q array .... \n"
   parray qstat_l_q_xml_output

   # Now let's compare them by jobid. 
   set jobid_list  $qstat_l_q_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   
   set plain_jobid_length [llength $qstat_l_q_plain_output(index) ]
   set xml_jobid_length [llength $qstat_l_q_xml_output(jobid_list) ]
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if {$plain_jobid_length != $xml_jobid_length} {
      ts_log_severe "length of job list differs between plain and xml:\n$qstat_l_q_plain_output(index)\n$qstat_l_q_xml_output(jobid_list)"
      incr error_flag 1
   }
   
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_l_q_xml_output($jobid,$column) [string trim $qstat_l_q_xml_output($jobid,$column)]
         }
         
         
         if { $qstat_l_q_plain_output($jobid,$column) != $qstat_l_q_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_l_q_plain_output was $qstat_l_q_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_l_q_xml_output was $qstat_l_q_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -l q=all.q"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_ext_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_ext_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -ext" command.
#
#  SYNOPSIS
#     qstat_ext_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -ext" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_ext_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_ext_plain_output contains the plain qstat output in an assoc. array
   # qstat_ext_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_ext_plain_parse qstat_ext_plain_output]
   
   ts_log_fine "plain qstat -ext array .... \n"
   parray qstat_ext_plain_output
   
   append qstat_ext_xml_output(jobid_list) ""
   # qstat_ext_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_ext_xml_parse qstat_ext_xml_output]
   
   ts_log_fine "xml qstat -ext array .... \n"
   parray qstat_ext_xml_output

   # Now let's compare them by jobid. For now we skip the last entry
   # due to bug in parse_qstat. See IZ 2024.
   # For this case, let's skip the FIRST entry! New bug in parse_multiline_list
   set jobid_list [lrange $qstat_ext_plain_output(jobid_list) 1 end]
   
   set column_vars "prior ntckts name user project department state cpu mem io  \
                    tckts ovrts otckt ftckt stckt share queue slots task_id" ; # slots task_id"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and slots, trim the trailing blanks
         # For queue or slots values, need to trim XML output to match
         # the plain output.
         if { ($column == "cpu") || ($column == "mem") || ($column == "io") || ($column == "state") || \
              ($column == "queue") || ($column == "slots") || ($column == "task_id") } {
            append qstat_ext_xml_output($jobid,$column) " "
            append qstat_ext_plain_output($jobid,$column) " " 
            set qstat_ext_xml_output($jobid,$column) [string trim $qstat_ext_xml_output($jobid,$column)]
            set qstat_ext_plain_output($jobid,$column) [string trim $qstat_ext_plain_output($jobid,$column)]
            
         }
         # Add this to fix mismatch between plain, XML output for empty project name
         # See IZ 
         if {$qstat_ext_plain_output($jobid,$column) == "NA"} {
            continue
         }
         
         # Trim trailing blanks in plain output.
         set qstat_ext_plain_output($jobid,$column) [string trim $qstat_ext_plain_output($jobid,$column)]
         if { $qstat_ext_plain_output($jobid,$column) != $qstat_ext_xml_output($jobid,$column) } {
            if { ($column == "department") && ([string first $qstat_ext_plain_output($jobid,$column) \
                  $qstat_ext_xml_output($jobid,$column)] >=0) } {
               continue ; # plain parsing is incomplete for column "department"
            }
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_ext_plain_output was $qstat_ext_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_ext_xml_output was $qstat_ext_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -ext"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

 
#****** qstat_f_ext_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_ext_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -f -ext" command.
#
#  SYNOPSIS
#     qstat_f_ext_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -f -ext" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_ext_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub3.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_f_ext_plain_output contains the plain qstat output in an assoc. array
   # qstat_f_ext_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_ext_plain_parse qstat_f_ext_plain_output "-f"]
   
   ts_log_fine "plain qstat -f -ext array .... \n"
   parray qstat_f_ext_plain_output
   
   # qstat_f_ext_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_f_ext_xml_output "-ext"]
   
   ts_log_fine "xml qstat -f -ext array .... \n"
   parray qstat_f_ext_xml_output

   # Now let's compare them by jobid. For now we skip the last entry
   # due to bug in parse_qstat. See IZ 2024.
   # For this case, let's skip the FIRST entry! New bug in parse_multiline_list
   set jobid_list [lrange $qstat_f_ext_plain_output(jobid_list) 1 end]

   set column_vars "prior ntckts name user project department state cpu mem io \
                    tckts ovrts otckt queue task_id " ; #ftckt stckt share queue slots task_id

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and slots, trim the trailing blanks
         # For queue or slots values, need to trim XML output to match
         # the plain output.
         if { ($column == "cpu") || ($column == "mem") || ($column == "io") || ($column == "state") || \
              ($column == "queue") || ($column == "slots") || ($column == "task_id") } {
            append qstat_f_ext_xml_output($jobid,$column) " "
            append qstat_f_ext_plain_output($jobid,$column) " " 
            set qstat_f_ext_xml_output($jobid,$column) [string trim $qstat_f_ext_xml_output($jobid,$column)]
            set qstat_f_ext_plain_output($jobid,$column) [string trim $qstat_f_ext_plain_output($jobid,$column)]

         }
         # Add this to fix mismatch between plain, XML output for NA values name
         # See IZ 
         if { ($qstat_f_ext_plain_output($jobid,$column) == "NA") } {
            continue
         }
         
         # Trim trailing blanks in plain output.
         set qstat_f_ext_plain_output($jobid,$column) [string trim $qstat_f_ext_plain_output($jobid,$column)]
         if { $qstat_f_ext_plain_output($jobid,$column) != $qstat_f_ext_xml_output($jobid,$column) } {
            if { ($column == "department") && ([string first $qstat_f_ext_plain_output($jobid,$column) \
                  $qstat_f_ext_xml_output($jobid,$column)] >=0) } {
               continue ; # plain parsing is incomplete for column "department"
            }
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_ext_plain_output was $qstat_f_ext_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_f_ext_xml_output was $qstat_f_ext_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }
      
   # Now compare the queue information output   
   set queue_list   $qstat_f_ext_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_f_ext_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_f_ext_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_f_ext_plain_output($queue,$column) != $qstat_f_ext_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_ext_plain_output was $qstat_f_ext_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_f_ext_xml_output was $qstat_f_ext_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -f -ext"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#
#
#****** qstat/qstat_f_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -f
#     command.
#
#  SYNOPSIS
#     qstat_f_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER  
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # Clear error states, if any
   set result1 [start_sge_bin "qmod" "-c all.q"]

   # qstat_f_plain_output contains the plain qstat -f output in an assoc. array
   # qstat_f_plain_output(jobid) contains a list of jobids.

   set result1 [qstat_f_plain_parse qstat_f_plain_output]

   ts_log_fine "plain qstat -f array .... \n"
   parray qstat_f_plain_output

   # qstat_f_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_f_xml_output]

   ts_log_fine "xml qstat -f array .... \n"
   parray qstat_f_xml_output

   # Now let's compare them by jobid
   set jobid_list  $qstat_f_plain_output(jobid_list)  
   
   set plain_jobid_length [llength $qstat_f_plain_output(jobid_list) ]
   set xml_jobid_length [llength $qstat_f_xml_output(jobid_list) ]

   set column_vars "prior name user state time slots task_id" ;  # queue" ; # slots task_id"

   set error_flag 0
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if { ($plain_jobid_length != $xml_jobid_length) } {
       incr error_flag 1
   }
         
   foreach jobid $jobid_list {
      foreach column $column_vars {
         append qstat_f_xml_output($jobid,task_id) ""
         set qstat_f_xml_output($jobid,task_id) [string trim $qstat_f_xml_output($jobid,task_id)]
         set qstat_f_plain_output($jobid,task_id) [string trim $qstat_f_plain_output($jobid,task_id)]

         if { $qstat_f_plain_output($jobid,$column) != $qstat_f_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_plain_output was $qstat_f_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_f_xml_output was $qstat_f_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
      
   # Now compare the queue information output   
   set queue_list  $qstat_f_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_f_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_f_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if {$plain_queue_length != $xml_queue_length} {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_f_plain_output($queue,$column) != $qstat_f_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_plain_output was $qstat_f_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_f_xml_output was $qstat_f_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if {$error_flag != 0} {
      ts_log_severe "error in plain, XML qstat -f"
   }

   # Delete all jobs
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#
#****** qstat/qstat_exlain_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_explain_plain_xml_comparison() -- Compare plain and XML ouptout of
#     qstat -explain E command.
#
#  SYNOPSIS
#     qstat_explain_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_explain_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER  
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # Clear error states, if any
   set result1 [start_sge_bin "qmod" "-c all.q"]

   # qstat_explain_plain_output contains the plain "qstat -explain E" output in an assoc. array
   # qstat_explain_plain_output(jobid) contains a list of jobids.

   set result1 [qstat_f_plain_parse qstat_explain_plain_output "-explain E"]

   ts_log_fine "plain qstat -explain E array .... \n"
   parray qstat_explain_plain_output

   # qstat_explain_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_explain_xml_output "-explain E"]

   ts_log_fine "xml qstat -explain E array .... \n"
   parray qstat_explain_xml_output

   #Now let's compare them by jobid

   set jobid_list $qstat_explain_plain_output(jobid_list)
   
   set plain_jobid_length [llength $qstat_explain_plain_output(jobid_list) ]
   set xml_jobid_length [llength $qstat_explain_xml_output(jobid_list) ]

   set column_vars "prior name user state time slots task_id" ;  # queue slots task_id"

   set error_flag 0
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if { ($plain_jobid_length != $xml_jobid_length) } {
       incr error_flag 1
   }
         
   foreach jobid $jobid_list {
      foreach column $column_vars {
         append qstat_explain_xml_output($jobid,task_id) ""
         set qstat_explain_xml_output($jobid,task_id) [string trim $qstat_explain_xml_output($jobid,task_id)]
         set qstat_explain_plain_output($jobid,task_id) [string trim $qstat_explain_plain_output($jobid,task_id)]

         if { $qstat_explain_plain_output($jobid,$column) != $qstat_explain_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_explain_plain_output was $qstat_explain_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_explain_xml_output was $qstat_explain_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
      
   # Now compare the queue information output   
   set queue_list $qstat_explain_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_explain_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_explain_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_explain_plain_output($queue,$column) != $qstat_explain_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_explain_plain_output was $qstat_explain_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_explain_xml_output was $qstat_explain_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if {$error_flag != 0} {
      ts_log_severe "error in plain, XML qstat -explain E"
   }

   # Delete all jobs
   delete_all_jobs
   wait_for_end_of_all_jobs
}




#
#****** qstat/qstat_f_q_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_q_plain_xml_comparison() -- Compare plain, XML output of qstat -f -q all.q
#     command.
#
#  SYNOPSIS
#     qstat_f_q_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_q_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER 
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # Clear error states, if any
   set result1 [start_sge_bin "qmod" "-c all.q"]

   # qstat_f_q_plain_output contains the plain qstat -f output in an assoc. array
   # qstat_f_q_plain_output(jobid) contains a list of jobids.

   set result1 [qstat_f_plain_parse qstat_f_q_plain_output "-q all.q"]

   ts_log_fine "plain qstat -f -q all.q array .... \n"
   parray qstat_f_q_plain_output

   # qstat_f_q_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_f_q_xml_output "-q all.q"]

   ts_log_fine "xml qstat -f qs all.q array .... \n"
   parray qstat_f_q_xml_output

   #Now let's compare them by jobid

   set jobid_list $qstat_f_q_plain_output(jobid_list) 
   
   set plain_jobid_length [llength $qstat_f_q_plain_output(jobid_list) ]
   set xml_jobid_length [llength $qstat_f_q_xml_output(jobid_list) ]

   set column_vars "prior name user state time slots task_id" ;  # queue" ; # slots task_id"

   set error_flag 0
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if { ($plain_jobid_length != $xml_jobid_length) } {
       incr error_flag 1
   }
         
   foreach jobid $jobid_list {
      foreach column $column_vars {
         append qstat_f_q_xml_output($jobid,task_id) ""
         set qstat_f_q_xml_output($jobid,task_id) [string trim $qstat_f_q_xml_output($jobid,task_id)]
         set qstat_f_q_plain_output($jobid,task_id) [string trim $qstat_f_q_plain_output($jobid,task_id)]

         if { $qstat_f_q_plain_output($jobid,$column) != $qstat_f_q_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_q_plain_output was $qstat_f_q_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_f_q_xml_output was $qstat_f_q_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
      
   # Now compare the queue information output   
   set queue_list  $qstat_f_q_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_f_q_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_f_q_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if {$plain_queue_length != $xml_queue_length} {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_f_q_plain_output($queue,$column) != $qstat_f_q_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_f_q_plain_output was $qstat_f_q_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_f_q_xml_output was $qstat_f_q_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag != 0 } {
      ts_log_severe "error in plain, XML qstat -f -q all.q"
   }

   # Delete all jobs
   delete_all_jobs
   wait_for_end_of_all_jobs
}



#
#****** qstat/qstat_f_qs_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_qs_plain_xml_comparison() -- Compare plain, XML output of qstat -f -qs  
#     command.
#
#  SYNOPSIS
#     qstat_f_qs_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_qs_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER 
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   ts_log_fine "skipping this test, as qstat -f -qs E is broken. See IZ 2073 ...\n" 
}


#****** qstat/qstat_f_ne_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_ne_plain_xml_comparison() -- Compare plain and XML ouptout of "qstat -f -ne"
#     command.
#
#  SYNOPSIS
#     qstat_f_ne_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_ne_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER  
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # Clear error states, if any
   set result1 [start_sge_bin "qmod" "-c all.q"]

   # qstat_f_ne_plain_output contains the plain "qstat -f -ne" output in an assoc. array
   # qstat_f_ne_plain_output(jobid) contains a list of jobids.

   set result1 [qstat_f_plain_parse qstat_f_ne_plain_output "-ne"]

   ts_log_fine "plain qstat -f -ne array .... \n"
   parray qstat_f_ne_plain_output

   # qstat_f_ne_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_f_xml_parse qstat_f_ne_xml_output "-ne"]

   ts_log_fine "xml qstat -f -ne array .... \n"
   parray qstat_f_ne_xml_output

   #Now let's compare them by jobid

   set jobid_list $qstat_f_ne_plain_output(jobid_list)  
   
   set plain_jobid_length [llength $qstat_f_ne_plain_output(jobid_list) ]
   set xml_jobid_length [llength $qstat_f_ne_xml_output(jobid_list) ]

   set column_vars "prior name user state time slots task_id" ;   

   set error_flag 0
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if {$plain_jobid_length != $xml_jobid_length} {
       incr error_flag 1
   }
         
   foreach jobid $jobid_list {
      foreach column $column_vars {
         append qstat_f_ne_xml_output($jobid,task_id) ""
         set qstat_f_ne_xml_output($jobid,task_id) [string trim $qstat_f_ne_xml_output($jobid,task_id)]
         set qstat_f_ne_plain_output($jobid,task_id) [string trim $qstat_f_ne_plain_output($jobid,task_id)]

         if { $qstat_f_ne_plain_output($jobid,$column) != $qstat_f_ne_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_plain_output was $qstat_f_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_xml_output was $qstat_f_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
      
      
   if { $error_flag != 0 } {
      ts_log_severe "error in plain, XML qstat -f -ne"
   }

   # Delete all jobs
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#****** qstat/qstat_F_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_F_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -F
#     command.
#
#  SYNOPSIS
#     qstat_F_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#     We also accumulate the compexes by queue and compare them.
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_F_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER  
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # Clear error states, if any
   set result1 [start_sge_bin "qmod" "-c all.q"]

   # qstat_F_plain_output contains the plain qstat -F output in an assoc. array
   # qstat_F_plain_output(jobid_list) contains a list of jobids.

   set result1 [qstat_F_plain_parse qstat_F_plain_output ""]

   ts_log_fine "plain qstat -F array .... \n"
   parray qstat_F_plain_output

   # qstat_F_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_F_xml_parse qstat_F_xml_output ""]

   ts_log_fine "xml qstat -F array .... \n"
   parray qstat_F_xml_output

   #ts_log_fine "plain jobid's are these: $qstat_F_plain_output(jobid_list) ...\n"
   #ts_log_fine "xml jobid's are these: $qstat_F_xml_output(jobid_list) ...\n"

   #Now let's compare them by jobid

   set jobid_list   $qstat_F_plain_output(jobid_list)  
   
   set plain_jobid_length [llength $qstat_F_plain_output(jobid_list)]
   set xml_jobid_length [llength $qstat_F_xml_output(jobid_list)]

   set column_vars "prior name user state time slots task_id" ; 

   set error_flag 0
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if { ($plain_jobid_length != $xml_jobid_length) } {
       incr error_flag 1
   }
         
   foreach jobid $jobid_list {
      foreach column $column_vars {
         append qstat_F_xml_output($jobid,task_id) ""
         set qstat_F_xml_output($jobid,task_id) [string trim $qstat_F_xml_output($jobid,task_id)]
         set qstat_F_plain_output($jobid,task_id) [string trim $qstat_F_plain_output($jobid,task_id)]

         if { $qstat_F_plain_output($jobid,$column) != $qstat_F_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_plain_output was $qstat_F_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_xml_output was $qstat_F_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
      
      
   # Now compare the queue information output   
   set queue_list   $qstat_F_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_F_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_F_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   # Comment out state, which is not seen in XML output!
   #set column_vars "qname qtype total_slots used_slots load_avg arch state"
   set column_vars "qname qtype total_slots used_slots load_avg arch \
                    qf:qname qf:hostname qc:slots qf:tmpdir qf:seq_no qf:rerun qf:calendar \
                    qf:s_rt qf:h_rt qf:s_cpu qf:h_cpu qf:s_fsize qf:h_fsize qf:s_data \
                    qf:h_data qf:s_stack qf:h_stack qf:s_core qf:h_core qf:s_rss \
                    qf:h_rss qf:s_vmem qf:h_vmem qf:min_cpu_interval"
   
   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_F_plain_output($queue,$column) != $qstat_F_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_plain_output was $qstat_F_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_xml_output was $qstat_F_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag != 0 } {
      ts_log_severe "error in plain, XML qstat -F"
   }

   # Delete all jobs
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#****** qstat/qstat_F_rerun_h_vmem_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_F_rerun_h_vmem_plain_xml_comparison() -- Compare plain and XML ouptout of "qstat -F
#     rerun,h_vmem" command.
#
#  SYNOPSIS
#     qstat_F_rerun_h_vmem_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#     We also accumulate the compexes by queue and compare them.
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_F_rerun_h_vmem_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER  
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000
   
   # Clear error states, if any
   set result1 [start_sge_bin "qmod" "-c all.q"]

   # qstat_F_rerun_h_vmem_plain_output contains the plain "qstat -F rerun,h_vmem" output in an assoc. array
   # qstat_F_rerun_h_vmem_plain_output(jobid_list) contains a list of jobids.

   # Pass "rerun h_vmem" to qstat_F_plain_parse to get this output
   set result1 [qstat_F_plain_parse qstat_F_rerun_h_vmem_plain_output "rerun h_vmem"]

   ts_log_fine "plain qstat -F rerun,h_vmem array .... \n"
   parray qstat_F_rerun_h_vmem_plain_output

   # qstat_F_rerun_h_vmem_xml_output contains the XML qstat output in an assoc. array
   #set result2 [qstat_F_rerun_h_vmem_xml_parse qstat_F_rerun_h_vmem_xml_output]
   set result2 [qstat_F_xml_parse qstat_F_rerun_h_vmem_xml_output "rerun h_vmem"]

   ts_log_fine "xml qstat -F rerun,h_vmem array .... \n"
   parray qstat_F_rerun_h_vmem_xml_output

   #Now let's compare them by jobid

   set jobid_list   $qstat_F_rerun_h_vmem_plain_output(jobid_list)  
   
   set plain_jobid_length [llength $qstat_F_rerun_h_vmem_plain_output(jobid_list)]
   set xml_jobid_length [llength $qstat_F_rerun_h_vmem_xml_output(jobid_list)]

   set column_vars "prior name user state time slots task_id "

   set error_flag 0
   
   # Check that we have same number of jobs in plain listing as in XML listing
   if { ($plain_jobid_length != $xml_jobid_length ) } {
       incr error_flag 1
   }
         
   foreach jobid $jobid_list {
      foreach column $column_vars {
         append qstat_F_rerun_h_vmem_xml_output($jobid,task_id) ""
         set qstat_F_rerun_h_vmem_xml_output($jobid,task_id) \
         [string trim $qstat_F_rerun_h_vmem_xml_output($jobid,task_id)]
         set qstat_F_rerun_h_vmem_plain_output($jobid,task_id) \
         [string trim $qstat_F_rerun_h_vmem_plain_output($jobid,task_id)]

         if { $qstat_F_rerun_h_vmem_plain_output($jobid,$column) != \
            $qstat_F_rerun_h_vmem_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_F_rerun_h_vmem_plain_output was \
            $qstat_F_rerun_h_vmem_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_F_rerun_h_vmem_xml_output was \
            $qstat_F_rerun_h_vmem_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }   
   }

   # Now compare the queue information output   
   set queue_list  $qstat_F_rerun_h_vmem_plain_output(queue_list)  
   
   set plain_queue_length [llength $qstat_F_rerun_h_vmem_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_F_rerun_h_vmem_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   # Comment out state, which is not seen in XML output!
   #set column_vars "qname qtype total_slots used_slots load_avg arch state"
   set column_vars "qname qtype total_slots used_slots load_avg arch \
                    qf:rerun qf:h_vmem"
                       
   foreach queue $queue_list {
      foreach column $column_vars {
         if { $qstat_F_rerun_h_vmem_plain_output($queue,$column) \
           != $qstat_F_rerun_h_vmem_xml_output($queue,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for queue $queue ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_F_rerun_h_vmem_plain_output was $qstat_F_rerun_h_vmem_plain_output($queue,$column)... \n"
            ts_log_fine "while qstat_F_rerun_h_vmem_xml_output was $qstat_F_rerun_h_vmem_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag != 0 } {
      ts_log_severe "error in plain, XML qstat -F rerun,h_vmem"
   }

   # Delete all jobs
   delete_all_jobs
   wait_for_end_of_all_jobs
}



#****** qstat/qstat_g_c_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -g c" command.
#
#  SYNOPSIS
#     qstat_g_c_plain_xml_comparison { }. The assoc. array has entries for
#     cluster, queue, cluster queue load, used, available, total,  aoACDS  cdsuE
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -g c" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_g_c_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }


# somehow the xml parsing switches the values:
# TODO: This test is failing
#plain qstat -g c array ....
#qstat_g_c_plain_output(all.q,aoACDS)         = 0
#qstat_g_c_plain_output(all.q,avail)          = 128
#qstat_g_c_plain_output(all.q,cdsuE)          = 40
#qstat_g_c_plain_output(all.q,clusterqueue)   = all.q
#qstat_g_c_plain_output(all.q,cqload)         = 0.19
#qstat_g_c_plain_output(all.q,resv)           = 0
#qstat_g_c_plain_output(all.q,total)          = 180
#qstat_g_c_plain_output(all.q,used)           = 17
#qstat_g_c_plain_output(empty.q,aoACDS)       = 0
#qstat_g_c_plain_output(empty.q,avail)        = 10
#qstat_g_c_plain_output(empty.q,cdsuE)        = 0
#qstat_g_c_plain_output(empty.q,clusterqueue) = empty.q
#qstat_g_c_plain_output(empty.q,cqload)       = 0.29
#qstat_g_c_plain_output(empty.q,resv)         = 0
#qstat_g_c_plain_output(empty.q,total)        = 10
#qstat_g_c_plain_output(empty.q,used)         = 0
#qstat_g_c_plain_output(queue_list)           = all.q empty.q wrong.q
#qstat_g_c_plain_output(wrong.q,aoACDS)       = 0
#qstat_g_c_plain_output(wrong.q,avail)        = 0
#qstat_g_c_plain_output(wrong.q,cdsuE)        = 10
#qstat_g_c_plain_output(wrong.q,clusterqueue) = wrong.q
#qstat_g_c_plain_output(wrong.q,cqload)       = 0.03
#qstat_g_c_plain_output(wrong.q,resv)         = 0
#qstat_g_c_plain_output(wrong.q,total)        = 10
#qstat_g_c_plain_output(wrong.q,used)         = 0
#xml qstat -g c array ....
#qstat_g_c_xml_output(all.q,aoACDS)         = 180
#qstat_g_c_xml_output(all.q,avail)          = 0
#qstat_g_c_xml_output(all.q,cdsuE)          = 0
#qstat_g_c_xml_output(all.q,clusterqueue)   = all.q
#qstat_g_c_xml_output(all.q,cqload)         = 0.19
#qstat_g_c_xml_output(all.q,total)          = 128
#qstat_g_c_xml_output(all.q,used)           = 17
#qstat_g_c_xml_output(empty.q,aoACDS)       = 10
#qstat_g_c_xml_output(empty.q,avail)        = 0
#qstat_g_c_xml_output(empty.q,cdsuE)        = 0
#qstat_g_c_xml_output(empty.q,clusterqueue) = empty.q
#qstat_g_c_xml_output(empty.q,cqload)       = 0.29
#qstat_g_c_xml_output(empty.q,total)        = 10
#qstat_g_c_xml_output(empty.q,used)         = 0
#qstat_g_c_xml_output(queue_list)           = all.q empty.q wrong.q
#qstat_g_c_xml_output(wrong.q,aoACDS)       = 10
#qstat_g_c_xml_output(wrong.q,avail)        = 0
#qstat_g_c_xml_output(wrong.q,cdsuE)        = 0
#qstat_g_c_xml_output(wrong.q,clusterqueue) = wrong.q
#qstat_g_c_xml_output(wrong.q,cqload)       = 0.03
#qstat_g_c_xml_output(wrong.q,total)        = 0
#qstat_g_c_xml_output(wrong.q,used)         = 0
#> qstat -g c -xml
#<?xml version='1.0'?>
#<job_info  xmlns:xsd="http://www.w3.org/2001/XMLSchema">
#  <cluster_queue_summary>
#    <name>all.q</name>
#    <load>0.16543</load>
#    <used>17</used>
#    <resv>0</resv>
#    <available>128</available>
#    <total>180</total>
#    <temp_disabled>0</temp_disabled>
#    <manual_intervention>40</manual_intervention>
#  </cluster_queue_summary>
#  <cluster_queue_summary>
#    <name>empty.q</name>
#    <load>0.27930</load>
#    <used>0</used>
#    <resv>0</resv>
#    <available>10</available>
#    <total>10</total>
#    <temp_disabled>0</temp_disabled>
#    <manual_intervention>0</manual_intervention>
#  </cluster_queue_summary>
#  <cluster_queue_summary>
#    <name>wrong.q</name>
#    <load>0.02000</load>
#    <used>0</used>
#    <resv>0</resv>
#    <available>0</available>
#    <total>10</total>
#    <temp_disabled>0</temp_disabled>
#    <manual_intervention>10</manual_intervention>
#  </cluster_queue_summary>


   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_g_c_plain_output contains the plain qstat output in an assoc. array
   set result1 [qstat_g_c_plain_parse qstat_g_c_plain_output]
   
   ts_log_fine "plain qstat -g c array .... \n"
   parray qstat_g_c_plain_output
   
   # qstat_g_c_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_g_c_xml_parse qstat_g_c_xml_output]
   
   ts_log_fine "xml qstat -g c array .... \n"
   parray qstat_g_c_xml_output

   # Now let's compare them by queues. For now we skip the last entry
   
   set queue_list $qstat_g_c_plain_output(queue_list)
   
   set column_vars "clusterqueue cqload used avail total aoACDS cdsuE"

   set error_text ""
   
   set plain_queue_length [llength $qstat_g_c_plain_output(queue_list) ]
   set xml_queue_length [llength $qstat_g_c_xml_output(queue_list) ]

   
   # Check that we have same number of queues in plain listing as in XML listing
   if {($plain_queue_length != $xml_queue_length)} {
       append error_text "\"$plain_queue_length\" != \"$xml_queue_length\" (plain_queue_length != xml_queue_length)\n"
   }
   
   foreach queue $queue_list {
      foreach column $column_vars {
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { $qstat_g_c_plain_output($queue,$column) != $qstat_g_c_xml_output($queue,$column) } {
            append error_text "    qstat_g_c_plain_output for $queue $column was \"$qstat_g_c_plain_output($queue,$column)\"... \n"
            append error_text "while qstat_g_c_xml_output for $queue $column was \"$qstat_g_c_xml_output($queue,$column)\"... \n"
         }
         
      }
   }

   if {$error_text != ""} {  
      ts_log_severe "error in plain, XML qstat -g c:\n$error_text"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_g_d_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_g_d_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -g d" command.
#
#  SYNOPSIS
#     qstat_g_d_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -g d" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_g_d_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_g_d_plain_output contains the plain qstat output in an assoc. array
   # qstat_g_d_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_g_d_plain_output "-g d"]
   
   ts_log_fine "plain qstat -g d array .... \n"
   parray qstat_g_d_plain_output
   
   # qstat_g_d_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_g_d_xml_output "-g d"]
   
   ts_log_fine "xml qstat -g d array .... \n"
   parray qstat_g_d_xml_output

   # Now let's compare them by jobid.  We skip the last item
   # See IZ 2024 for details.

   set jobid_list  $qstat_g_d_plain_output(index)
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"
   
   set error_flag 0
   
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_g_d_xml_output($jobid,$column) [string trim $qstat_g_d_xml_output($jobid,$column)]
            set qstat_g_d_plain_output($jobid,$column) [string trim $qstat_g_d_plain_output($jobid,$column)]
            
         }
         
         if { ($qstat_g_d_plain_output($jobid,$column) == "{} {} {} {} {}") && ($qstat_g_d_xml_output($jobid,$column) == "") } {
            continue 
         }

         if { $qstat_g_d_plain_output($jobid,$column) != $qstat_g_d_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_g_d_plain_output was $qstat_g_d_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_g_d_xml_output was $qstat_g_d_xml_output($jobid,$column)... \n"
            incr error_flag 1
         }
         
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -g d"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_g_t_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_g_t_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -g t" command.
#
#  SYNOPSIS
#     qstat_g_t_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -g d" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_g_t_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs
   # Took out the PARQALELL qsub jobs, since parse_qstat seems to have some
   # problems with those types of jobs sometimes....
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub1.sh" ""]
   
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_g_t_plain_output contains the plain qstat output in an assoc. array
   # qstat_g_t_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_g_t_plain_output "-g t"]
   
   ts_log_fine "plain qstat -g t array .... \n"
   parray qstat_g_t_plain_output
   
   # qstat_g_d_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_g_t_xml_output "-g t"]
   
   ts_log_fine "xml qstat -g t array .... \n"
   parray qstat_g_t_xml_output

   # Now let's compare them by jobid.   
   set jobid_list  $qstat_g_t_plain_output(index)
    
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   # We also skip master comparison due to another parse_qstat bug
   # 
   set column_vars "prior name user state time queue "; # task_id queue master
   
   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_g_t_xml_output($jobid,$column) [string trim $qstat_g_t_xml_output($jobid,$column)]
            set qstat_g_t_plain_output($jobid,$column) [string trim $qstat_g_t_plain_output($jobid,$column)]
         }
         
         if { ($column == "task_id") } { ; # assign jatask entry to task_id
            # Take out the "," from the $jobid so I can add the entry properly
            regsub "," $jobid "" id ; 
            append qstat_g_t_plain_output($id,$column) $qstat_g_t_plain_output($id,jatask)
            append qstat_g_t_xml_output($id,$column) ""
            set qstat_g_t_xml_output($id,$column) [string trim $qstat_g_t_xml_output($id,$column)]
            set qstat_g_t_plain_output($id,$column) [string trim $qstat_g_t_plain_output($id,$column)]
         }
         if { $qstat_g_t_plain_output($jobid,$column) != $qstat_g_t_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_g_t_plain_output was $qstat_g_t_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_g_t_xml_output was $qstat_g_t_xml_output($jobid,$column)... \n"
            incr error_flag 1
         }
         
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -g t"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_s_a_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_a_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -s a"  command.
#
#  SYNOPSIS
#     qstat_s_a_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_s_a_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_a_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_a_plain_output "-s a"]
   
   ts_log_fine "plain qstat -s a array .... \n"
   parray qstat_s_a_plain_output
   
   # qstat_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_a_xml_output "-s a"]
   
   ts_log_fine "xml qstat -s a array .... \n"
   parray qstat_s_a_xml_output

   # Now let's compare them by jobid. 
   set jobid_list $qstat_s_a_plain_output(index)
         
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master" ; #task_id

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_a_xml_output($jobid,$column) [string trim $qstat_s_a_xml_output($jobid,$column)]
         }
         
         if { $qstat_s_a_plain_output($jobid,$column) != $qstat_s_a_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_a_plain_output was $qstat_s_a_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_a_xml_output was $qstat_s_a_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -s a"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#****** qstat/qstat_s_p_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_p_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -s p"  command.
#
#  SYNOPSIS
#     qstat_s_p_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************
proc qstat_s_p_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_p_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_p_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_p_plain_output "-s p"]
   
   ts_log_fine "plain qstat -s p array .... \n"
   parray qstat_s_p_plain_output
   
   # qstat_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_p_xml_output "-s p"]
   
   ts_log_fine "xml qstat -s p array .... \n"
   parray qstat_s_p_xml_output

   # Now let's compare them by jobid. 
   
   set jobid_list  $qstat_s_p_plain_output(index) 
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_p_xml_output($jobid,$column) [string trim $qstat_s_p_xml_output($jobid,$column)]
         }
         
         
         if { $qstat_s_p_plain_output($jobid,$column) != $qstat_s_p_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_p_plain_output was $qstat_s_p_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_p_xml_output was $qstat_s_p_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -s p"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}



#
#****** qstat/qstat_s_r_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_r_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -s r
#     command.
#
#  SYNOPSIS
#     qstat_s_r_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_s_r_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER     
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_r_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_r_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_r_plain_output "-s r"]
   
   ts_log_fine "plain qstat -s r array .... \n"
   parray qstat_s_r_plain_output
   
   # qstat_s_r_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_r_xml_output "-s r"]
   
   ts_log_fine "xml qstat array -s r .... \n"
   parray qstat_s_r_xml_output

   # Now let's compare them by jobid.
   set jobid_list   $qstat_s_r_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_r_xml_output($jobid,$column) [string trim $qstat_s_r_xml_output($jobid,$column)]
         }
         
         if { $qstat_s_r_plain_output($jobid,$column) != $qstat_s_r_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_r_plain_output was $qstat_s_r_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_r_xml_output was $qstat_s_r_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {
      ts_log_severe "error in plain, XML qstat -s r"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#****** qstat/qstat_s_s_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_s_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -s s
#     command.
#
#  SYNOPSIS
#     qstat_s_s_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -s s command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_s_s_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER     
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_s_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_s_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_s_plain_output "-s s"]
   
   ts_log_fine "plain qstat -s s array .... \n"
   parray qstat_s_s_plain_output
   
   # Initialize it to blank
   set qstat_s_s_xml_output(index) ""
   # qstat_s_s_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_s_xml_output "-s s"]
   
   ts_log_fine "xml qstat array -s s .... \n"
   parray qstat_s_s_xml_output

   # Now let's compare them by jobid.
   
   set jobid_list  $qstat_s_s_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_s_xml_output($jobid,$column) [string trim $qstat_s_s_xml_output($jobid,$column)]
         }
         
         if { $qstat_s_s_plain_output($jobid,$column) != $qstat_s_s_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_s_plain_output was $qstat_s_s_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_s_xml_output was $qstat_s_s_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -s s"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#****** qstat/qstat_s_z_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_z_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -s z
#     command.
#
#  SYNOPSIS
#     qstat_s_z_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_s_z_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER     
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_z_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_z_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_z_plain_output "-s z"]
   
   ts_log_fine "plain qstat -s z array .... \n"
   parray qstat_s_z_plain_output
   
   # Initialize it to blank
   set qstat_s_z_xml_output(index) ""
   # qstat_s_z_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_z_xml_output "-s z"]
   
   ts_log_fine "xml qstat array -s z .... \n"
   parray qstat_s_z_xml_output

   # Now let's compare them by jobid. 
   set jobid_list   $qstat_s_z_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_z_xml_output($jobid,$column) [string trim $qstat_s_z_xml_output($jobid,$column)]
         }
         
         if { $qstat_s_z_plain_output($jobid,$column) != $qstat_s_z_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_z_plain_output was $qstat_s_z_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_z_xml_output was $qstat_s_z_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -s z"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#****** qstat/qstat_s_hs_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_hs_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -s hs
#     command.
#
#  SYNOPSIS
#     qstat_s_hs_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -s hs command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_s_hs_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER     
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_hs_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_hs_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_hs_plain_output "-s hs"]
   
   ts_log_fine "plain qstat -s hs array .... \n"
   parray qstat_s_hs_plain_output
   
   # Initialize it to blank
   set qstat_s_hs_xml_output(index) ""
   # qstat_s_hs_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_hs_xml_output "-s hs"]
   
   ts_log_fine "xml qstat array -s hs .... \n"
   parray qstat_s_hs_xml_output

   # Now let's compare them by jobid.
   
   set jobid_list  $qstat_s_hs_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_hs_xml_output($jobid,$column) [string trim $qstat_s_hs_xml_output($jobid,$column)]
         }
         
         if { $qstat_s_hs_plain_output($jobid,$column) != $qstat_s_hs_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_hs_plain_output was $qstat_s_hs_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_hs_xml_output was $qstat_s_hs_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -s hs"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}


#
#****** qstat/qstat_s_hu_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_s_hu_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -s hu
#     command.
#
#  SYNOPSIS
#     qstat_s_hu_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -s hu command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_s_hu_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER     
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_s_hu_plain_output contains the plain qstat output in an assoc. array
   # qstat_s_hu_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_s_hu_plain_output "-s hu"]
   
   ts_log_fine "plain qstat -s hu array .... \n"
   parray qstat_s_hu_plain_output
   
   # qstat_s_hu_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_s_hu_xml_output "-s hu"]
   
   ts_log_fine "xml qstat array -s hu .... \n"
   parray qstat_s_hu_xml_output

   # Now let's compare them by jobid.
   
   set jobid_list  $qstat_s_hu_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_s_hu_xml_output($jobid,$column) [string trim $qstat_s_hu_xml_output($jobid,$column)]
         }
         
         if { $qstat_s_hu_plain_output($jobid,$column) != $qstat_s_hu_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_s_hu_plain_output was $qstat_s_hu_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_s_hu_xml_output was $qstat_s_hu_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -s hu"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_u_valid_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_u_valid_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -u $CHECK_USER"  command.
#
#  SYNOPSIS
#     qstat_s_p_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_u_valid_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER   
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
  
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_u_valid_plain_output contains the plain qstat output in an assoc. array
   # qstat_u_valid_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_u_valid_plain_output "-u $CHECK_USER"]
   
   ts_log_fine "plain qstat -u $CHECK_USER array .... \n"
   parray qstat_u_valid_plain_output
   
   # qstat_u_valid_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_u_valid_xml_output "-u $CHECK_USER"]
   
   ts_log_fine "xml qstat -u $CHECK_USER array .... \n"
   parray qstat_u_valid_xml_output

   # Now let's compare them by jobid. 
   
   set jobid_list  $qstat_u_valid_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_u_valid_xml_output($jobid,$column) [string trim $qstat_u_valid_xml_output($jobid,$column)]
         }
         
         if { $qstat_u_valid_plain_output($jobid,$column) != $qstat_u_valid_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_u_valid_plain_output was $qstat_u_valid_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_u_valid_xml_output was $qstat_u_valid_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -u $CHECK_USER"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_u_invalid_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_u_invalid_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -u $CHECK_USER"  command.
#
#  SYNOPSIS
#     qstat_u_invalid_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -u wrong_user command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_u_invalid_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER 
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_u_invalid_plain_output contains the plain qstat output in an assoc. array_
   # qstat_u_invalid_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_u_invalid_plain_output "-u wrong_user"]
   
   ts_log_fine "plain qstat -u wrong_user array .... \n"
   parray qstat_u_invalid_plain_output
   
   # Initialize to blank
   set qstat_u_invalid_xml_output(index) ""
   # qstat_u_invalid_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_u_invalid_xml_output "-u wrong_user"]
   
   ts_log_fine "xml qstat -u wrong_user array .... \n"
   parray qstat_u_invalid_xml_output

   # Now let's compare them by jobid. 
   
   set jobid_list  $qstat_u_invalid_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_u_invalid_xml_output($jobid,$column) [string trim $qstat_u_invalid_xml_output($jobid,$column)]
         }
         
         if { $qstat_u_invalid_plain_output($jobid,$column) != $qstat_u_invalid_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_u_invalid_plain_output was $qstat_u_invalid_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_u_invalid_xml_output was $qstat_u_valid_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -u wrong_user"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qstat/qstat_U_valid_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_U_valid_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -U $CHECK_USER"  command.
#
#  SYNOPSIS
#     qstat_U_valid_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat -U $CHECK_USER command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_U_valid_plain_xml_comparison {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER 
   global CHECK_HAVE_TDOM

   if {!$CHECK_HAVE_TDOM} {
      ts_log_fine "skipping qstat -xml cases ... \n"
      return 
   }

   # Run some jobs      
   set result_local_return [start_remote_prog $ts_config(master_host) $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
   
   # Wait a little for jobs to be scheduled.
   trigger_scheduling
   after 10000

   # qstat_U_valid_plain_output contains the plain qstat output in an assoc. array
   # qstat_U_valid_plain_output(jobid) contains a list of jobids.
   set result1 [qstat_plain_parse qstat_U_valid_plain_output "-U $CHECK_USER"]
   
   ts_log_fine "plain qstat -U $CHECK_USER array .... \n"
   parray qstat_U_valid_plain_output
   
   # qstat_U_valid_xml_output contains the XML qstat output in an assoc. array
   set result2 [qstat_xml_parse qstat_U_valid_xml_output "-U $CHECK_USER"]
   
   ts_log_fine "xml qstat -U $CHECK_USER array .... \n"
   parray qstat_U_valid_xml_output

   # Now let's compare them by jobid. 
   
   set jobid_list  $qstat_U_valid_plain_output(index)  
   
   # We skip the task_id comparison also due to a bug in parse_qstat,
   # See IZ 2052 for details.
   set column_vars "prior name user state time queue master"

   set error_flag 0
   foreach jobid $jobid_list {
      foreach column $column_vars {
         # For columns state, queue and master, trim the trailing blanks
         # For queue or master values, need to trim XML output to match
         # the plain output.
         if { ($column == "state") || ($column == "queue") || ($column == "master") } {
            set qstat_U_valid_xml_output($jobid,$column) [string trim $qstat_U_valid_xml_output($jobid,$column)]
         }
         
         if { $qstat_U_valid_plain_output($jobid,$column) != $qstat_U_valid_xml_output($jobid,$column) } {
            ts_log_fine "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
            ts_log_fine "and column $column... \n"
            ts_log_fine "qstat_U_valid_plain_output was $qstat_U_valid_plain_output($jobid,$column)... \n"
            ts_log_fine "while qstat_U_valid_xml_output was $qstat_U_valid_xml_output($jobid,$column)... \n"
            incr error_flag 1
         } 
      }
   }

   if { $error_flag != 0 } {  
      ts_log_severe "error in plain, XML qstat -U $CHECK_USER"
   }
   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

proc test_issue123 {} {
   global ts_config CHECK_USER CHECK_HAVE_TDOM
   
   # verify if we can perform the qstat -xml tests
   if {$CHECK_HAVE_TDOM == 0} {
      return
   }
   delete_all_jobs
   wait_for_end_of_all_jobs

   # submit job qsub -t 1-5 sleeper.sh
   set arguments "-t 1-5"
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 50"]
   
   wait_for_jobstart $job_id "Sleeper" 60 1 1
   
   set result1 [qstat_gdr_xml_parse xml] 
   
   set result1 [plain_gdr_parse plain]
   
   set var_array {jobNumber prio name owner state queue slots tasks fullName}

   # for each job test that the xml and plain outputs are the same
   for {set ind 0} {$ind < 5} {incr ind 1} {
      foreach elem $var_array {
         if {[string compare [string trim $xml(job$ind,$elem)] [string trim $plain(job$ind,$elem)]] != 0} {
            if {[info exists xml($elem)]} {
               set xml_output [string trim $xml($elem)]
            } else {
               set xml_output "XML tag \"$elem\" not found!"
            }
            ts_log_severe "outputs do not match from plain and xml for $elem.\nxml output: $xml_output\nplain output: [string trim $plain($elem)]"
            return
         }
      }           
   }  
   delete_all_jobs
   wait_for_end_of_all_jobs

   # Test xml for hard and soft resources

   # submit job
   set host [host_conf_get_suited_hosts]
   set arch [resolve_arch $host]
   set arguments "-l a=$arch -soft -l h=$host"
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh"]
   wait_for_jobstart $job_id "Sleeper" 60 1 1   
   
   #capture xml output
   set res1 [qstat_r_xml_parse xml]
   # capture plain output
   set res1 [plain_r_parse plain]

   set var_array1 { jobNumber prio name owner state queue slots hard soft }
   # compare xml and plain arrays to ensure  all attributes match
   foreach elem $var_array1 {
      if {[ string compare [string trim $xml($elem)] \
         [string trim $plain($elem)]] != 0} {
         ts_log_fine "xml = [string trim $xml($elem)] , plain = [string trim $plain($elem)]"
         ts_log_severe "outputs do not match from plain and xml for $elem.\nxml output: [string trim $xml($elem)]\nplain output: [string trim $plain($elem)]"
         return
      }
   }   
   delete_all_jobs
   wait_for_end_of_all_jobs
}

