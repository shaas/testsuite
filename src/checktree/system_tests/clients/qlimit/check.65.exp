#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "no"

# define a level initialization procedure:
set check_init_level_procedure "qlimit_init_level"

# define test's name and run level descriptions
set check_name            "qlimit"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "test qlimit functionality"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function qlimit_setup
set check_cleanup_function qlimit_cleanup


# define test's procedure order
set check_functions ""
lappend check_functions "qlimit_help"                   ;# print this help
lappend check_functions "qlimit_option_u"
lappend check_functions "qlimit_option_l"

proc qlimit_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level 
}

proc qlimit_setup {} {
   global CHECK_OUTPUT ts_config complex_global_host_backup

   set lirs_name1 "qlimit_test1"
   set lirs_name2 "qlimit_test2"

   # create new complex attributes
   #           name            short  type    op.   requ.  cons. default  urgency
   set complex(test_time)     "tt     TIME      <=    YES    NO    0:0:0    0"
   set complex(test_memory)   "tm     MEMORY    <=    YES    NO    0        0"
   set_complex complex

   # backup global and specific host
   get_exechost complex_global_host_backup "global"

   append config(complex_values) "tt=1:0:0"
   append config(complex_values) ",tm=1000M"
   set_exechost config "global"

   # Set per user limitation rule sets 
   set rules ""
   lappend rules "users `*` to slots=10"
   set lirs_charray($lirs_name1,limit) "$rules"
   set lirs_charray($lirs_name1,enabled) "true"

   # Set for all user limitation rule sets 
   unset rules
   set rules ""
   lappend rules "users * to slots=10"
   set lirs_charray($lirs_name2,limit) "$rules"
   set lirs_charray($lirs_name2,enabled) "true"

   # Add both limitation rule sets
   set result [add_lirs lirs_charray]

   set_error 0 "ok"
}

proc qlimit_cleanup {} {
   global CHECK_OUTPUT ts_config complex_global_host_backup

   delete_all_jobs
   wait_for_end_of_all_jobs 20

   # reset global and specific host setup
   set_exechost complex_global_host_backup "global"

   # delete our test complex attributes
   set complex(test_time)     ""
   set complex(test_memory)   ""
   set_complex complex

   if {[get_lirs_list lirs_names "" "" 0] == 0} {
      foreach elem $lirs_names {
         puts $CHECK_OUTPUT "Removing limitation rule sets $elem ...\n"
         del_lirs $elem
      }
   }

   set_error 0 "ok"
}

proc qlimit_help {} {
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_PRODUCT_VERSION_NUMBER

   set qlimit_help_lines 10

   set output [start_sge_bin "qlimit" "-help"]

   puts $CHECK_OUTPUT "qlimit output    : \n---"
   puts $CHECK_OUTPUT "$output"
   puts $CHECK_OUTPUT "---\n"
   puts $CHECK_OUTPUT "qlimit exit state: $prg_exit_state"

   if {$prg_exit_state != 0} {
      set_error -1 "exit state is not 0"
   }

   set output [string trim $output]

   if {[string first $CHECK_PRODUCT_VERSION_NUMBER $output] < 0} {
      set_error -1 "version string ($CHECK_PRODUCT_VERSION_NUMBER) not found"
   } 
 
   set lines [split $output "\n"]
   set nr_of_lines [llength $lines] 

   puts $CHECK_OUTPUT "Output has $nr_of_lines lines"

   if {$nr_of_lines != $qlimit_help_lines} {
      add_proc_error "qlimit_help" -1 "help output has $nr_of_lines, but expected are $qlimit_help_lines lines:\n$output"
   }

   set_error 0 "ok"
}

proc qlimit_option_u {} {
   global ts_config CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

   puts $CHECK_OUTPUT "checking qlimit -u option ..."

   set job_options "-o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 10000"

   # Submit 2 jobs for CHECK_USER
   set job_id1 [submit_job "$job_options"]
   set job_id2 [submit_job "$job_options"]
   trigger_scheduling
   wait_for_jobstart $job_id1 "leeper" 20
   wait_for_jobstart $job_id2 "leeper" 20

   # Count qlimit rules for * and CHECK_USER (should be two)
   qlimit_count_entries "qlimit_option_u" "-u $CHECK_USER" 2
   qlimit_count_entries "qlimit_option_u" "-u '*'" 2
   qlimit_count_entries "qlimit_option_u" "" 2

   # Submit 2 more jobs for CHECK_FIRST_FOREIGN_SYSTEM_USER
   set job_id1 [submit_job "$job_options" 1 60 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   set job_id2 [submit_job "$job_options" 1 60 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   trigger_scheduling
   wait_for_jobstart $job_id1 "leeper" 20
   wait_for_jobstart $job_id2 "leeper" 20

   # Count qlimit rules for * (should be 3) and CHECK_USER (should be two)
   # and CHECK_FIRST_FOREIGN_SYSTEM_USER (should be 2)
   qlimit_count_entries "qlimit_option_u" "-u '*'" 3
   qlimit_count_entries "qlimit_option_u" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER" 3
   qlimit_count_entries "qlimit_option_u" "-u $CHECK_USER" 2
   qlimit_count_entries "qlimit_option_u" "" 2
   qlimit_count_entries "qlimit_option_u" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER" 2

   delete_all_jobs
   wait_for_end_of_all_jobs 20

   set_error 0 "ok"
}

proc qlimit_count_entries { func_name qlimit_options expected_entries } {
   global ts_config CHECK_OUTPUT

   puts $CHECK_OUTPUT "\nrunning qlimit $qlimit_options"
   set result [start_sge_bin "qlimit" "$qlimit_options" "" "" exit_code]
   puts $CHECK_OUTPUT $result
   if {$exit_code == 0} {
      set tmp [split $result "\n"]
      set nr_entries [llength $tmp]

      # Remove \n from the end
      incr nr_entries -1

      # Two lines are the header header
      if {$tmp > 0} {
         incr nr_entries -2
      }

      puts $CHECK_OUTPUT "number of entries: $nr_entries"
      if {$nr_entries != $expected_entries} {
         add_proc_error "$func_name" -1 "qlimit $qlimit_options broken, got $nr_entries but expected $expected_entries"
      }
   } else {
      add_proc_error "$func_name" -1 "qlimit $qlimit_options exit status not 0"
   }
}

proc qlimit_option_l {} {
   global ts_config CHECK_OUTPUT

   puts $CHECK_OUTPUT "checking qlimit -l option ..."

   set job_options "-o /dev/null -j y -l tm=900M,tt=0:50:0 $ts_config(product_root)/examples/jobs/sleeper.sh 10000"

   # Set per user limitation rule sets 
   set lirs_name "option_l"
   set rules ""
   lappend rules "users rd141302 hosts `*` to tm=1000M,tt=1:0:0"
   set lirs_charray($lirs_name,limit) "$rules"
   set lirs_charray($lirs_name,enabled) "true"
   add_lirs lirs_charray
   
   set job_id [submit_job "$job_options"]
   trigger_scheduling
   wait_for_jobstart $job_id "leeper" 20

   # two rules from default rule sets and two from test specific rule set
   qlimit_count_entries "qlimit_option_l" "" 4

   qlimit_count_entries "qlimit_option_l" "-l tm" 1
   qlimit_count_entries "qlimit_option_l" "-l tt" 1
   qlimit_count_entries "qlimit_option_l" "-l tm,tt" 2
   qlimit_count_entries "qlimit_option_l" "-l tm,tt,slots" 4

   #Cleanup
   del_lirs $lirs_name
   
   delete_all_jobs
   wait_for_end_of_all_jobs 20

   set_error 0 "ok"
}
