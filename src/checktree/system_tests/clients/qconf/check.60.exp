#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_functions 

#### define test's procedure order
append_check_and_exclude_in_jgdi "qconf_de_check" "Does not use start_sge_bin, so it never uses JGDI"
append_check_and_exclude_in_jgdi "qconf_backslash_default_space_check" "Options a/rattr not implemented" ;# functions to call (in order)
append_check_and_exclude_in_jgdi "qconf_backslash_default_comma_check" "Options a/rattr not implemented"
append_check_and_exclude_in_jgdi "qconf_backslash_custom_space_check" "Options a/rattr not implemented"
append_check_and_exclude_in_jgdi "qconf_backslash_custom_comma_check" "Options a/rattr not implemented" 
append_check_and_exclude_in_jgdi "qconf_backslash_space_output_check" "Options a/rattr not implemented"
append_check_and_exclude_in_jgdi "qconf_backslash_comma_output_check" "Options a/rattr not implemented"

append_check_and_exclude_in_jgdi "qconf_issue1767"
append_check_and_exclude_in_jgdi "qconf_shgrp_tree_check"	;# List tree like structure of hosts
append_check_and_exclude_in_jgdi "qconf_shgrp_resolved_check"	;# List  hosts in a group
append_check_and_exclude_in_jgdi "qconf_modify_hostgroup"

append_check_and_exclude_in_jgdi "qconf_purge_queue" "BROKEN -purge succeeds with invalid arg"

#                                                             max. column:     |
#****** qconf/qconf_backslash_default_space_check() ******
# 
#  NAME
#     qconf_backslash_default_space_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_default_space_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_setup_hostgroup* will be added as hostgroups
#     via "qconf -Ahgrp".  All files named backslash_space_hostgroup* will be
#     added as hostgroups via "qconf -Ahgrp" and checked that the hostlist field
#     contains all of the hostgroups added from the backslash_setup_hostgroup*
#     files.  All files named backslash_space_fail_hostgroup* will be added
#     via "qconf -Ahgrp" and checked to be sure the operation failed.  Finally,
#     all added hostgroups will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_default_space_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_PRODUCT_TYPE 
   global CHECK_USER ts_config

   puts $CHECK_OUTPUT "testing qconf default backslash parsing with spaces ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Setup
   set setup_groups ""
   catch { set setup_groups [glob "$CHECK_ACTUAL_TEST_PATH/backslash_setup_hostgroup*"] }
   set required_groups ""
   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "host group"]

   foreach group $setup_groups {
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Ahgrp $group"]
      set output [string trim $output]
      puts $CHECK_OUTPUT $output
      if { [regexp $ADDED $output match groupname] == 0 } {
         add_proc_error "qconf_backslash_default_space_check" -1 "error parsing file \"$group\" in qconf_backslash_default_space_check ($output)"
         return
      }
      lappend required_groups $groupname
      puts $CHECK_OUTPUT "added host group \"$groupname\""
   }

   set required_groups [lsort $required_groups]

   # Check backslash parsing with spaces
   set space_groups ""
   catch { set space_groups [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_hostgroup*"] }
   set added_groups ""

   foreach group $space_groups {
      puts $CHECK_OUTPUT "parsing host group file: $group"
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Ahgrp $group" ]

      if { [regexp $ADDED $output match groupname] == 0 } {
         add_proc_error "qconf_backslash_default_space_check" -1 "error parsing file \"$group\" in qconf_backslash_default_space_check"
         continue
      }

      puts $CHECK_OUTPUT "added host group $groupname"
      lappend added_groups $groupname

      # Check that the hostgroup was added correctly
      set output [start_sge_bin "qconf" "-shgrp $groupname" ]

      if { [regexp {hostlist[ \t]+([^\n]+)} $output match hostlist] == 0 } {
         add_proc_error "qconf_backslash_default_space_check" -1 "error parsing file \"$group\" in qconf_backslash_default_space_check"
         continue
      }

      set hostlist [lsort $hostlist]

      if { $hostlist != $required_groups } {
         add_proc_error "qconf_backslash_default_space_check" -1 "error parsing file \"$group\" in qconf_backslash_default_space_check"
         continue
      }
   }

   # Check backslash parsing failures
   set space_groups ""
   catch { set space_groups [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_fail_hostgroup*"] }

   foreach group $space_groups {
      puts $CHECK_OUTPUT "parsing host group file: $group"
      catch { start_remote_prog $master_host $CHECK_USER "qconf" "-Ahgrp $group" }

      if { $prg_exit_state == 0 } {
         add_proc_error "qconf_backslash_default_space_check" -1 "allowed bad file \"$group\" in qconf_backslash_default_space_check"
         continue
      }
   }

   # Remove groups
   foreach group "$added_groups $required_groups" {
      start_sge_bin "qconf" "-dhgrp $group"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_default_comma_check() ******
# 
#  NAME
#     qconf_backslash_default_comma_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_default_comma_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_comma_userlist* will be added as user lists
#     via "qconf -Au" and checked that the entries field contains root, bin, and
#     sys.  All files named backslash_comma_fail_userlist* will be added via
#     "qconf -Au" and checked to be sure the operation failed.  Finally, all
#     added user lists will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_default_comma_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_PRODUCT_TYPE
   global CHECK_USER ts_config

   puts $CHECK_OUTPUT "testing qconf default backslash parsing with commas ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Check backslash parsing with commas
   set comma_userlists ""
   catch { set comma_userlists [glob "$CHECK_ACTUAL_TEST_PATH/backslash_comma_userlist*"] }
   set required_userlists [lsort "root bin sys"]

   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "userset"]
   puts $CHECK_OUTPUT "added is \"$ADDED\""
   foreach userlist $comma_userlists {
      puts $CHECK_OUTPUT "parsing userlist file: $userlist"
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Au $userlist" ]
      puts $CHECK_OUTPUT "output is \"$output\""
      if { [regexp $ADDED $output match userlistname] == 0 } {
         add_proc_error "qconf_backslash_default_comma_check" -1 "error parsing file \"$userlist\" in qconf_backslash_comma_check\n(output: $output)"
         return
      }
      puts $CHECK_OUTPUT "added userlist $userlistname"
      # Check that the userlist was added correctly
      set output [start_sge_bin "qconf" "-su $userlistname"]
      start_sge_bin "qconf" "-dul $userlistname"

      if { [regexp {entries[ \t]+([^\n]+)} $output match users] == 0 } {
         add_proc_error "qconf_backslash_default_comma_check" -1 "error parsing file \"$userlist\" in qconf_backslash_comma_check"
         continue
      }

      set users [lsort [join [split $users ", "]]]

      if { $required_userlists != $users } {
         add_proc_error "qconf_backslash_default_comma_check" -1 "error parsing file \"$userlist\" in qconf_backslash_comma_check -- unknown users: $user1, $user2"
      }
   }

   # Check backslash parsing failures with commas
   set comma_userlists ""
   catch { set comma_userlists [glob "$CHECK_ACTUAL_TEST_PATH/backslash_comma_fail_userlist*"] }

   foreach userlist $comma_userlists {
      puts $CHECK_OUTPUT "parsing userlist file: $userlist"
      catch { start_remote_prog $master_host $CHECK_USER "qconf" "-Au $userlist" }

      if { $prg_exit_state == 0 } {
         add_proc_error "qconf_backslash_default_comma_check" -1 "error parsing file \"$userlist\" in qconf_backslash_comma_check"
         continue
      }
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_custom_space_check() ******
# 
#  NAME
#     qconf_backslash_custom_space_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_custom_space_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_setup_userlist* will be added as user lists
#     via "qconf -Au".  All files named backslash_space_queue* will be
#     added as queues via "qconf -Aq" and checked that the user_lists field
#     contains all of the user lists added from the backslash_setup_userlist*
#     files.  All files named backslash_space_fail_queue* will be added
#     via "qconf -Aq" and checked to be sure the operation failed.  Finally,
#     all added user lists and queues will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_custom_space_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_PRODUCT_TYPE
   global CHECK_USER ts_config

   puts $CHECK_OUTPUT "testing qconf custom backslash parsing with spaces ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Setup
   set setup_users ""
   catch { set setup_users [glob "$CHECK_ACTUAL_TEST_PATH/backslash_setup_userlist*"] }
   set required_users ""

   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "userset"]


   foreach user $setup_users {
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Au $user"]

      if { [regexp $ADDED $output match username] == 0 } {
         add_proc_error "qconf_backslash_custom_space_check" -1 "error parsing file \"$user\" in qconf_backslash_custom_space_check"
         return
      }

      lappend required_users $username
      puts $CHECK_OUTPUT "added userlist $username"
   }

   set required_users [lsort $required_users]

   # Check backslash parsing with spaces
   set space_queues ""
   catch { set space_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_queue*"] }
  
   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "cluster queue"]
 

   foreach queue $space_queues {
      puts $CHECK_OUTPUT "parsing queue file: $queue"
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Aq $queue" ]

      if { [regexp $ADDED $output match queuename] == 0 } {
         add_proc_error "qconf_backslash_custom_space_check" -1 "error parsing file \"$queue\" in qconf_backslash_custom_space_check"
         continue
      }

      puts $CHECK_OUTPUT "added queue $queuename"

      # Check that the hostgroup was added correctly
      set output [start_sge_bin "qconf" "-sq $queuename"]
      start_sge_bin "qconf" "-dq $queuename"

      if { [regexp {user_lists[ \t]+([^\n]+)} $output match userlist] == 0 } {
         add_proc_error "qconf_backslash_custom_space_check" -1 "error parsing file \"$queue\" in qconf_backslash_custom_space_check"
         continue
      }

      set userlist [lsort $userlist]

      if { $userlist != $required_users } {
         add_proc_error "qconf_backslash_custom_space_check" -1 "error parsing file \"$queue\" in qconf_backslash_custom_space_check"
      }
   }

   # Check backslash parsing failures
   set space_queues ""
   catch { set space_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_fail_queue*"] }

   foreach queue $space_queues {
      puts $CHECK_OUTPUT "parsing queue file: $queue"
      catch { start_remote_prog $master_host $CHECK_USER "qconf" "-Aq $queue" }

      if { $prg_exit_state == 0 } {
         add_proc_error "qconf_backslash_custom_space_check" -1 "allowed bad file \"$queue\" in qconf_backslash_custom_space_check"
         continue
      }
   }

   # Remove userlists
   foreach user $required_users {
      start_sge_bin "qconf" "-dul $user"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_custom_comma_check() ******
# 
#  NAME
#     qconf_backslash_custom_comma_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_custom_comma_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_setup_userlist* will be added as user lists
#     via "qconf -Au".  All files named backslash_space_queue* will be
#     added as queues via "qconf -Aq" and checked that the user_lists field
#     contains all of the user lists added from the backslash_setup_userlist*
#     files.  All files named backslash_space_fail_queue* will be added
#     via "qconf -Aq" and checked to be sure the operation failed.  Finally,
#     all added user lists and queues will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_custom_comma_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT CHECK_PRODUCT_TYPE
   global CHECK_USER ts_config

   puts $CHECK_OUTPUT "testing qconf custom backslash parsing with commas ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Setup
   set setup_users ""
   catch { set setup_users [glob "$CHECK_ACTUAL_TEST_PATH/backslash_setup_userlist*"] }
   set required_users ""

   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "userset"]

   foreach user $setup_users {
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Au $user"]

      if { [regexp $ADDED $output match username] == 0 } {
         add_proc_error "qconf_backslash_custom_comma_check" -1 "error parsing file \"$user\" in qconf_backslash_custom_space_check"
         return
      }

      lappend required_users $username
      puts $CHECK_OUTPUT "added userlist $username"
   }

   set required_users [lsort $required_users]

   # Check backslash parsing with spaces
   set comma_queues ""
   catch { set comma_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_comma_queue*"] }
   set added_queues ""
   
   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "cluster queue"]

   foreach queue $comma_queues {
      puts $CHECK_OUTPUT "parsing queue file: $queue"
      set output [start_remote_prog $master_host $CHECK_USER "qconf" "-Aq $queue" ]

      if { [regexp $ADDED $output match queuename] == 0 } {
         add_proc_error "qconf_backslash_custom_comma_check" -1 "error parsing file \"$queue\" in qconf_backslash_custom_comma_check"
         continue
      }

      puts $CHECK_OUTPUT "added queue $queuename"
      lappend added_queues $queuename

      # Check that the hostgroup was added correctly
      set output [start_sge_bin "qconf" "-sq $queuename"]
      start_sge_bin "qconf" "-dq $queuename"

      if { [regexp {user_lists[ \t]+([^\n]+)} $output match userlist] == 0 } {
         add_proc_error "qconf_backslash_custom_comma_check" -1 "error parsing file \"$queue\" in qconf_backslash_custom_comma_check"
         continue
      }

      set userlist [lsort [join [split $userlist ", "]]]

      if { $userlist != $required_users } {
         add_proc_error "qconf_backslash_custom_comma_check" -1 "error parsing file \"$queue\" in qconf_backslash_custom_comma_check"
      }
   }

   # Check backslash parsing failures
   set comma_queues ""
   catch { set comma_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_fail_queue*"] }

   foreach queue $comma_queues {
      puts $CHECK_OUTPUT "parsing queue file: $queue"
      catch { start_remote_prog $master_host $CHECK_USER "qconf" "-Aq $queue" }

      if { $prg_exit_state == 0 } {
         add_proc_error "qconf_backslash_custom_comma_check" -1 "allowed bad file \"$queue\" in qconf_backslash_custom_comma_check"
         continue
      }
   }

   # Remove userlists
   foreach user $required_users {
      start_sge_bin "qconf" "-dul $user"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_space_output_check() ******
# 
#  NAME
#     qconf_backslash_space_output_check -- tests backslash line continuation in
#                                     output
#
#  SYNOPSIS
#     qconf_backslash_space_output_check { } 
#
#  FUNCTION
#     This function tests the outputing of backslash continued lines by qconf.
#     It uses three hostgroup name classes: short, medium, and long.  The short
#     names are just that: short.  The medium name is shorter than a line, but
#     long enough to cause a line wrap in combination with two short names.
#     The long name is longer than a line.  In order to test border cases, the
#     sizes of the names are calulated to produce lines of length 78, 79, 80,
#     and 81 when taken in various combinations.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_space_output_check {} {
   global ts_config CHECK_OUTPUT CHECK_USER env

   puts $CHECK_OUTPUT "testing qconf backslash line continuation in output"
   set master_host [resolve_host $ts_config(master_host)]

   # Set up failure report
   set failures ""

   set names ""
   # Length > 80
   lappend names "@reallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallylongname1"
   # Length = 47
   lappend names "@thisisareallyreallyreallyreallyreallylongname0"
   # Length = 21
   lappend names "@thisisaveryshortname"
   # Length = 23
   lappend names "@thisisareallyshortname"
   # Length = 24
   lappend names "@thisisareallyshortname2"
   # 0 + offset = 127
   # 1 + 2 + offset + spaces = 78
   # 2 + 3 + 4 + offset + spaces = 79
   # 1 + 3 + offset + spaces = 80
   # 1 + 4 + offset + spaces = 81

   puts $CHECK_OUTPUT "adding host groups"

   # Add each of the names as a host group
   foreach name $names {
      puts $CHECK_OUTPUT "adding host group: $name"
      # localize messages
      set short_name [string range $name 0 99]
      set ADDED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER "$master_host*" $short_name "host group"]
      # add by handling vi
      set master_arch [resolve_arch $ts_config(master_host)]
      handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-ahgrp $name" "" $ADDED
   }

   puts $CHECK_OUTPUT "done adding host groups"

   # Store the long names
   set lname [lindex $names 0]
   set mname [lindex $names 1]

   # Remove the long names from the list
   set names [lreplace $names 0 1]

   # Max line size is taken from sge_flatfile.h
   set max_line 80
   # Offset is "hostlist "
   set offset 9
   # Set failure flag
   set failed 0

   # For each relevant permutation of the names list
   for {set mindex 0} {$mindex < 4} {incr mindex} {
      for {set lindex 0} {$lindex < 5} {incr lindex} {
         puts $CHECK_OUTPUT "testing permutation $mindex-$lindex"

         set permutation [linsert $names $mindex $mname]
         set permutation [linsert $permutation $lindex $lname]
         # Create a host group with the names list as the host list
         set vi_commands ""
         lappend vi_commands "/hostlist\nwC$permutation[format "%c" 27]"
         set groupname "@qconfbackslash$mindex$lindex"
         # localize messages
         set ADDED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER "$master_host*" $groupname "host group"]
         # add by handling vi
         set master_arch [resolve_arch $ts_config(master_host)]
         handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-ahgrp $groupname" $vi_commands $ADDED
         
         # Check the output
         # The test suite sets the SGE_SINGLE_LINE variable before every action,
         # so in order to test backslash line continuation, we first have to
         # unset the env var.
         set output [start_remote_prog $master_host $CHECK_USER "qconf" "-shgrp $groupname" prg_exit_state 60 0 "" "" 1 1 0 1 0 0 1]
         # I love TCL.  The next line does the following:
         # 1. Break the output up by lines
         # 2. Remove the first line, the group name
         # 3. Reassemble the output
         # 4. Break the output up by whitespace
         # 5. Remove the first word, "hostlist"
         # What's left is a list containing the names of the host groups and
         # the backslashes as separate list entries.
         set tokens [lrange [split [join [lrange [split [string map {"\r\n" "\n" } $output] "\n"] 1 end]]] 1 end]

         # Calculate the line breaks
         set length 0
         set index 0

         foreach token $tokens {
            # Skip empty tokens
            if {[string length $token] == 0} {
               continue
            }

            set reserve 2

            if {$index >= [llength $permutation]} {
               puts $CHECK_OUTPUT "too many tokens: $tokens"
               lappend failures "permutation $mindex-$lindex"
               set failed 1
               break
            } else {
               if {$index == [llength $permutation] - 1} {
                  # If this is the last token, don't reserve space for a line
                  # break
                  set reserve 0
               }
            }

            set name [lindex $permutation $index]
            set strlen [string length $name]

            if {
                (($length + $strlen) >= ($max_line - $offset - $reserve)) &&
                ($length > 0)
            } then {
               if {$token != "\\"} {
                  puts $CHECK_OUTPUT "expected backslash: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               puts $CHECK_OUTPUT "matched backslash"

               set length 0
            } else {
               if {$name != $token} {
                  puts $CHECK_OUTPUT "expected $name: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               puts $CHECK_OUTPUT "matched token with $strlen characters"

               # Count the space
               if {$length > 0} {
                  incr length
               }

               incr length $strlen
               incr index
            }
         }

         if {($failed != 1) && ([llength $permutation] > $index)} {
            puts $CHECK_OUTPUT "expected $name -- too few tokens: $tokens"
            lappend failures "permutation $mindex-$lindex"
            set failed 1
         }

         # Remove the host group
         start_sge_bin "qconf" "-dhgrp $groupname"
      }
   }

   # Remove all host groups
   start_sge_bin "qconf" "-dhgrp $mname"
   start_sge_bin "qconf" "-dhgrp $lname"

   foreach name $names {
      start_sge_bin "qconf" "-dhgrp $name"
   }

   if {$failed} {
      add_proc_error "qconf_backslash_space_output_check" "-1" "error printing hostgroup in qconf_backslash_space_output_check -- failed for $failures"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_space_output_check() ******
# 
#  NAME
#     qconf_backslash_comma_output_check -- tests backslash line continuation in
#                                     output
#
#  SYNOPSIS
#     qconf_backslash_comma_output_check { } 
#
#  FUNCTION
#     This function tests the outputing of backslash continued lines by qconf.
#     It uses three complex variable name classes: short, medium, and long.  The
#     short names are just that: short.  The medium name is shorter than a line,
#     but long enough to cause a line wrap in combination with two short names.
#     The long name is longer than a line.  In order to test border cases, the
#     sizes of the names are calulated to produce lines of length 78, 79, 80,
#     and 81 when taken in various combinations.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_comma_output_check {} {
   global ts_config CHECK_OUTPUT CHECK_USER env

   set master_host [resolve_host $ts_config(master_host)]

   puts $CHECK_OUTPUT "testing qconf backslash line continuation in output"

   # Set up failure report
   set failures ""

   set names ""

   puts $CHECK_OUTPUT "adding complex variables"

   # Add each of the names as a complex variable
   for {set count 1} {$count <= 5} {incr count} {
      set name "complexvar$count"
      puts $CHECK_OUTPUT "adding complex variable: $name"
      # localize messages
      set ADDED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER "$master_host*" $name "complex entry"]
      # add by handling vi
      set vi_commands ""
      lappend vi_commands "O$name cv$count RESTRING == YES NO NONE 0[format "%c" 27]"
      set master_arch [resolve_arch $ts_config(master_host)]
      handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-mc" $vi_commands $ADDED
      lappend names $name
   }

   puts $CHECK_OUTPUT "done adding complex variables"

   # Setup desired line lengths
   # 100 + comma + offset = 123
   # 17 + 18 + 20 + commas + offset = 80
   # 37 + 17 + commas + offset = 78
   # 37 + 18 + commas + offset = 79
   # 37 + 20 + commas + offset = 81
   set lines ""
   lappend lines 17
   lappend lines 18
   lappend lines 20
   lappend lines 37
   lappend lines 100

   # Max line size is taken from sge_flatfile.h
   set max_line 80
   # Offset is "complex_values        "
   set offset 22
   # Set failure flag
   set failed 0

   set snames ""
   set count 0

   foreach length $lines {
      set name [lrange $names $count $count]
      set name "${name}="

      set strlen [string length $name]
      set extend [expr $length - $strlen]

      for {set counter 0} {$counter < $extend} {incr counter} {
         set name "${name}0"
      }

      lappend snames $name
      incr count
   }

   # Store the long names
   set mname [lindex $snames 3]
   set lname [lindex $snames 4]

   # Remove the long names from the list
   set snames [lreplace $snames 3 end]

   # localize messages
   if { $ts_config(gridengine_version) == 62 } {
      set ADDED [translate_macro MSG_SGETEXT_MODIFIEDINLIST_SSSS "*" "*" "*" "*" ]
   } else {
      set ADDED [translate_macro MSG_EXEC_HOSTENTRYOFXCHANGEDINEXECLIST_S "global"]
   }

   # For each relevant permutation of the names list
   for {set mindex 0} {$mindex < 4} {incr mindex} {
      for {set lindex 0} {$lindex < 5} {incr lindex} {
         puts $CHECK_OUTPUT "testing permutation $mindex-$lindex"

         set permutation [linsert $snames $mindex $mname]
         set permutation [linsert $permutation $lindex $lname]
         set permuted_names ""

         # Build a comma-separated list
         foreach name $permutation {
            if {$permuted_names == ""} {
               set permuted_names "$name"
            } else {
               set permuted_names "${permuted_names},$name"
            }
         }

         # Added the complex vars to the global host
         start_sge_bin "qconf" "-rattr exechost complex_values \"$permuted_names\" global"

         # Check the output
         # The test suite sets the SGE_SINGLE_LINE variable before every action,
         # so in order to test backslash line continuation, we first have to
         # unset the env var.
         set output [start_remote_prog $master_host $CHECK_USER "qconf" "-se global" prg_exit_state 60 0 "" "" 1 1 0 1 0 0 1]

         # I love TCL.  The next line does the following:
         # 1. Replace \r\n with \n
         # 2. Break the output up by lines
         # 3. Remove everything except the complex_values lines
         # 4. Reassemble the output
         # 5. Break the output up by whitespace and commas
         # 6. Remove the first word, "complex_values"
         # What's left is a list containing the complex variables and
         # the backslashes as separate list entries.
         set tokens [lrange [split [join [lrange [split [string map {"\r\n" "\n"} $output] "\n"] 2 end-9]] " ,"] 1 end]

         # Calculate the line breaks
         set length 0
         set index 0

         foreach token $tokens {
            # Skip empty tokens
            if {[string length $token] == 0} {
               continue
            }

            # Reserve space for two commas and a line break
            set reserve 4

            if {$index >= [llength $permutation]} {
               puts $CHECK_OUTPUT "too many tokens: $tokens"
               lappend failures "permutation $mindex-$lindex"
               set failed 1
               break
            } else {
               if {$index == [llength $permutation] - 1} {
                  # If this is the last token, don't reserve space for a line
                  # break or the last comma.  If this is the only token on the
                  # line, don't reserve space for the first comma either.
                  if {$length == 0} {
                     set reserve 0
                  } else {
                     set reserve 1
                  }
               }
            }

            set name [lindex $permutation $index]
            set strlen [string length $name]

            if {
                (($length + $strlen) > ($max_line - $offset - $reserve)) &&
                ($length > 0)
            } then {
               if {"$token" != "\\"} {
                  puts $CHECK_OUTPUT "expected backslash: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               puts $CHECK_OUTPUT "matched backslash"

               set length 0
            } else {
               if {$name != "$token"} {
                  puts $CHECK_OUTPUT "expected $name: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               puts $CHECK_OUTPUT "matched token with $strlen characters"

               # Count the comma
               if {$length > 0} {
                  incr length
               }

               incr length $strlen
               incr index
            }
         }

         if {($failed != 1) && ([llength $permutation] > $index)} {
            puts $CHECK_OUTPUT "expected $name -- too few tokens: $tokens"
            lappend failures "permutation $mindex-$lindex"
            set failed 1
         }
      }
   }

   # Restore global host
   start_sge_bin "qconf" "-rattr exechost complex_values NONE global"

   # Remove all complex variables
   # localize messages
   set REMOVED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_REMOVEDFROMLIST_SSSS] $CHECK_USER "$master_host*" [lrange $names end end] "complex"]
   set vi_commands ""
   lappend vi_commands "/complexvar\n5dd"
   set master_arch [resolve_arch $ts_config(master_host)]
   handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-mc" $vi_commands $REMOVED

   if {$failed} {
      add_proc_error "qconf_backslash_comma_output_check" "-1" "error printing hostgroup in qconf_backslash_comma_output_check -- failed for $failures"
   }
}

#****** check.60/check_double_output() *****************************************
#  NAME
#     check_double_output() 
#
#  SYNOPSIS
#     check_double_output { string1 string2 } 
#
#  FUNCTION
#     Search in string2 for a sequence of characters that exactly match multiple
#     times the characters in string1.
#
#     The function raises an error if no string was found and if
#     the string was found 2 times.
#
#  INPUTS
#     string1 - string which could be 2 time in string1 
#     string2 - string to search in 
#
#*******************************************************************************
proc check_double_output { string1 string2 } {
   global CHECK_OUTPUT

   set index [ string last "$string1" "$string2" ]
   if { $index > 0 } {
      set string2 [ string range "$string2" 0 $index ] 
      if { [ string first "$string1" "$string2" ] >= 0 } {
         add_proc_error "check_double_output" -1 "detected issue 1767\n$string1 printed 2 or more times" 
      } 
   } elseif { $index < 0 } {
      add_proc_error "check_double_output" -1 "qconf doesn't reject invalid values"
   }
}

#****** check.60/qconf_issue1767() *********************************************
#  NAME
#     qconf_issue1767()  
#
#  SYNOPSIS
#     qconf_issue1767 { } 
#
#  FUNCTION
#     Tests for Issue 1767 
#
#     Some error messages were printed 2 times because a library function was
#     called which called the ERROR macro and returned an answer_list.
#
#  SEE ALSO
#     check_double_output
#*******************************************************************************
proc qconf_issue1767 {} {
   global ts_config CHECK_OUTPUT
   
   set master_host [resolve_host $ts_config(master_host)]

   set tmp_file1 [ get_tmp_file_name ]
   set tmp_file2 [ get_tmp_file_name ]

   set local_arch [resolve_arch [gethostname]]
   #invalid urgency_slots setting
   set REJECTED [translate $master_host 1 0 0 [ sge_macro MSG_PE_REJECTINGURGENCYSLOTS_S ] "invalid" ]
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -sp mytestpe > $tmp_file1  } result ]
   set exit_code [catch { exec sed "s/min/invalid/" $tmp_file1 > $tmp_file2  } result ]
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -Mp $tmp_file2  } result ]
   check_double_output $REJECTED $result

   #invalid pe name
   set REJECTED [translate $master_host 1 0 0 [ sge_macro MSG_PE_INVALIDCHARACTERINPE_S ] ".mytestpe" ]
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -sp mytestpe > $tmp_file1  } result ]
   set exit_code [catch { exec sed "s/mytestpe/.mytestpe/" $tmp_file1 > $tmp_file2  } result ]
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -Ap $tmp_file2  } result ]
   check_double_output $REJECTED $result

   #invalid startprocargs 
   set REJECTED [translate $master_host 1 0 0 [ sge_macro  MSG_PE_STARTPROCARGS_SS ] "mytestpe" "unknown variable \"invalid\"" ]
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -sp mytestpe | sed /start_proc_args/d > $tmp_file1  } result ]
   set exit_code [catch { exec echo "start_proc_args '\$invalid'" >> $tmp_file1 } result ]
   puts $CHECK_OUTPUT $result
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -Mp $tmp_file1  } result ]
   check_double_output $REJECTED $result

   #invalid stopprocargs 
   set REJECTED [translate $master_host 1 0 0 [ sge_macro MSG_PE_STOPPROCARGS_SS ] "mytestpe" "unknown variable \"invalid\"" ]
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -sp mytestpe | sed /stop_proc_args/d > $tmp_file1  } result ]
   set exit_code [catch { exec echo "stop_proc_args '\$invalid'" >> $tmp_file1 } result ]
   puts $CHECK_OUTPUT $result
   set exit_code [catch { exec "$ts_config(product_root)/bin/$local_arch/qconf" -Mp $tmp_file1  } result ]
   check_double_output $REJECTED $result
}

#                                                             max. column:     |
#****** qconf/qconf_shgrp_tree_check() ******
#
#  NAME
#     qconf_shgrp_tree_check - Display tree like structure of host group 
#
#  SYNOPSIS
#     qconf_shgrp_tree_check { } - Call get_shgrp_tree_error for group "@qconf_test"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host.60/get_hostgroup_tree()
# sge_host.60/get_hostgroup_tree_error()
#*******************************
proc qconf_shgrp_tree_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER

   # First do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -shgrp_tree ...\n"
   set result0 [get_hostgroup_tree "@qconf_test" ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_tree @qconf_test succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # next do a negative test
   puts $CHECK_OUTPUT "Negative test for qconf -shgrp_tree ...\n"
   set result1 [get_hostgroup_tree "wrong_hostgroup" result $ts_config(master_host) $CHECK_USER 0]

   if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_tree wrong_hostgroup succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_shgrp_resolved_check() ******
#
#  NAME
#     qconf_shgrp_resolved_check - Display list of host group 
#
#  SYNOPSIS
#     qconf_shgrp_resolved_check { } - Call "qconf -shgrp_resolved @qconf_test"
#                            Check that the output contains   "$ts_config(master_host)"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host.60/get_hostgroup_resolved()
# sge_host.60/get_hostgroup_resolved_error()
#*******************************
proc qconf_shgrp_resolved_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER

   # First do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -shgrp_resolved ...\n"
   set result0 [get_hostgroup_resolved "@qconf_test" ]
   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_resolved @qconf_test  succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # next do a negative test
   puts $CHECK_OUTPUT "Negative test for qconf -shgrp_resolved ...\n"
   set result1 [get_hostgroup_resolved "wrong_hostgroup" result $ts_config(master_host) $CHECK_USER 0]

   if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_resolved wrong_hostgroup succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }
}
#****** qconf/check.60.exp/qconf_modify_hostgroup() ******
#  NAME
#     qconf_modify_hostgroup - Modify host group
#
#  SYNOPSIS
#     qconf_modify_hostgroup { } - Call mod_hostgroup to modify hsot group
#                         from CLI or file
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_modify_hostgroup {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER

   set host [host_conf_get_suited_hosts]

   # Now modify the host list
   puts $CHECK_OUTPUT "Modify host group  @qconf_test  from file ...\n"
   set chgar(hostlist) "$host"
   set result1 [mod_hostgroup "@qconf_test" chgar]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Mhgrp succeded\n"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Now do it with a wrong parameter
   puts $CHECK_OUTPUT "Modify host group  @qconf_test wrongly from file ...\n"
   set chgar(stuff) "$host"
   set result11 [mod_hostgroup "@qconf_test" chgar 1 $host $CHECK_USER 0]

   if { ( $result11 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Mhgrp failed  correctly\n"
   } else {
      # See IZ 1968 on why this does not fail as expected
      puts $CHECK_OUTPUT "result is $result11"
   }

    # Now do it with a wrong parameter again
   puts $CHECK_OUTPUT "Modify host group  @qconf_test wrongly from file  again...\n"
   set chgar(hostlist) whatever
   set result11 [mod_hostgroup "@qconf_test" chgar 1 $host $CHECK_USER 0]

   if { ( $result11 == -3 ) } {
      puts $CHECK_OUTPUT "qconf -Mhgrp failed  correctly again \n"
   } else {
      # See IZ 1968 on why this does not fail as expected
      puts $CHECK_OUTPUT "result is $result11"
   }

   # Now do it from CLI with wrong param again
   set chgar(hostlist) "stuff"
   puts $CHECK_OUTPUT "Modify host group  @qconf_test  wrongly from CLI again...\n"
   set result21 [mod_hostgroup "@qconf_test" chgar 0 $host $CHECK_USER 0]

   if { ( $result21 == -3 ) } {
      puts $CHECK_OUTPUT "qconf -mhgrp failed  correctly\n"
   } else {
      puts $CHECK_OUTPUT "result is $result21"
   }
}

#                                                             max. column:     |
#****** qconf/check.exp.60/qconf_purge_queue() ******
#
#  NAME
#     qconf_purge_queue - Purge queue "qconf_queue.q"
#
#  SYNOPSIS
#     qconf_purge_queue { } - Call add_queue qconf_queue.q $ts_config(master_host) new_queue
#                             Use "qconf -purge queue qname qconf_queue.q"
#                             Then clean up with "qconf -dq qconf_queue.q"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_queue/add_queue()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_purge_queue {} {
   global ts_config
   global CHECK_OUTPUT CHECK_USER

   # add a test queue
   set host [host_conf_get_suited_hosts]
   set new_queue(load_thresholds) "np_load_avg=10"
   add_queue qconf_queue.q $host new_queue
   set qi [get_queue_instance "qconf_queue.q" $host]
   
   # negative test for the testsuite function - it shall only accept
   # queue instances or queue domains
   set ret [purge_queue "cluster_queue" "prolog" "" "" 0]
   if {$ret != -5} {
      add_proc_error "qconf_purge_queue" -1 "purge_queue accepted a cluster queue name"
   }
   
   # negative test:
   # purge without attribute name
   set ret [purge_queue $qi "" "" "" 0]
   if {$ret != -7} {
      add_proc_error "qconf_purge_queue" -1 "purge_queue accepted an empty string as attribute"
   }

   # negative test: qconf -purge from non admin host
   set non_cluster_host [host_conf_get_unused_host]
   if {$non_cluster_host != ""} {
      set ret [purge_queue $qi "load_thresholds" $non_cluster_host "" 0]
      if {$ret == 0} {
         add_proc_error "qconf_purge_queue" -1 "qconf -purge from $non_cluster_host (non cluster host) should have failed"
      }
   }

   # Now try load_thresholds for purge on a queue instance
   # set queue instance specific value
   mod_attr "queue" "load_thresholds" "load_avg=20" $qi
   puts $CHECK_OUTPUT "Positive test of qconf -purge load_thresholds ...\n"
   set result [purge_queue $qi "load_thresholds"]
   if {$result == 0} {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result"
   }

   # negative test - purging it a second time may not work
   set result [purge_queue $qi "load_thresholds" "" "" 0]
   if {$result == -2} {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds second call failed as expected"
   } else {
      add_proc_error "qconf_purge_queue" -1 "qconf -purge for the second time on the same attribute should have failed"
   }

   # Now try load_thresholds for purge on a queue domain
   # set queue domain specific value
   mod_attr "queue" "load_thresholds" "load_avg=20" "qconf_queue.q@@qconf_test"
   puts $CHECK_OUTPUT "Positive test of qconf -purge load_thresholds ...\n"
   set result [purge_queue "qconf_queue.q@@qconf_test" "load_thresholds"]
   if {$result == 0} {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds qconf_queue.q@@qconf_test succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result"
   }

   # negative test - purging it a second time may not work
   set result [purge_queue "qconf_queue.q@@qconf_test" "load_thresholds" "" "" 0]
   if {$result == -2} {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds second call failed as expected"
   } else {
      add_proc_error "qconf_purge_queue" -1 "qconf -purge for the second time on the same attribute should have failed"
   }

   # Now purge queue "wrong_queue.q"
   puts $CHECK_OUTPUT "Negative test of qconf -purge load_thresholds...\n"
   set result [purge_queue [get_queue_instance "wrong_queue.q" $host] "load_thresholds" "" "" 0]
   if {$result == -1} {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds wrong_queue.q failed as expected"
   } else {
      add_proc_error "qconf_purge_queue" -1 "qconf -purge with a wrong queue didn't fail"
   }

   # Now purge wrong queue domain
   # it doesn't complain about the hostgroup not existing, but about not finding the value
   puts $CHECK_OUTPUT "Negative test of qconf -purge load_thresholds...\n"
   set result [purge_queue "qconf_queue.q@@non_existing_hgroup" "load_thresholds" "" "" 0]
   if {$result == -2} {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds wrong_queue.q failed as expected"
   } else {
      add_proc_error "qconf_purge_queue" -1 "qconf -purge with a wrong queue didn't fail"
   }


   # Now delete queue "qconf_queue.q"
   puts $CHECK_OUTPUT "Positive test of qconf -dq qconf_queue.q...\n"
   set result [del_queue "qconf_queue.q" $host 1]

   if {$result == 0} {
      puts $CHECK_OUTPUT "qconf -dq qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_de_check() ******
# 
#  NAME
#     qconf_de_check -- ??? 
#
#  SYNOPSIS
#     qconf_de_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_de_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_USER CHECK
   puts $CHECK_OUTPUT "testing qconf -de ..."

   # Setup
   set execd [host_conf_get_suited_hosts]
   set arch [resolve_arch $ts_config(master_host)]

   puts $CHECK_OUTPUT "using execd host $execd"

   # the tmp_file is automatically removed from testsuite
   set tmp_file [get_tmp_file_name]
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf -se $execd | grep -v load_values | grep -v processors > $tmp_file" } result ]
   if { $catch_result != 0 } {
      add_proc_error "qconf_de_check" "-1" "could not store execd config: $result"
   }
   puts $CHECK_OUTPUT "tmp file is: $tmp_file"
   puts $CHECK_OUTPUT "doing qconf -dattr hostgroup hostlist $execd @allhosts:"
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf -dattr hostgroup hostlist $execd @allhosts @qconf_test" } result ]
   puts $CHECK_OUTPUT $result
 
   if { $catch_result != 0 } {
      add_proc_error "qconf_de_check" "-1" "could not remove host from hostgroup @allhosts: $result"
   }

 
   # Test
   puts $CHECK_OUTPUT "doing qconf -de $execd"
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf" "-de" "$execd" } result ]
   puts $CHECK_OUTPUT $result
   
   set EXEC_HOST_REMOVED [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_REMOVEDFROMLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] [resolve_host $execd 1] "execution host"]

   puts $CHECK_OUTPUT "looking for : \"$EXEC_HOST_REMOVED\""
   puts $CHECK_OUTPUT "answer was  : \"$result\""

   if { [ string match "*$EXEC_HOST_REMOVED*" $result ] == 0 } {
      add_proc_error "qconf_de_check" "-1" "could not delete live execd: $result\nBug 1269: qconf -de still crashes qmaster"
   }
   puts $CHECK_OUTPUT "removed execd $execd from cluster"

   puts $CHECK_OUTPUT "doing qconf -Ae $tmp_file"
   catch { eval exec "$ts_config(product_root)/bin/$arch/qconf -Ae $tmp_file" } result 
   puts $CHECK_OUTPUT $result

   puts $CHECK_OUTPUT "doing qconf -aattr hostgroup hostlist $execd @allhosts"
   catch { eval exec "$ts_config(product_root)/bin/$arch/qconf -aattr hostgroup hostlist $execd @allhosts" } result
   puts $CHECK_OUTPUT $result

   puts $CHECK_OUTPUT "added execd $execd to cluster"
}

