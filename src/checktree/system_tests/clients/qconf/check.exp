#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env
global check_category

# define a level initialization procedure:
set check_init_level_procedure "qconf_init_level"

# define test's name and run level descriptions
set check_name            "qconf"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level    0
set check_description(0)  "test all qconf options (test not complete)"

# define test's dependencies
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)


global qconf_original_host_groups qconf_original_usersets
# setup and cleanup functions
set check_setup_function "qconf_setup"
set check_cleanup_function "qconf_cleanup"

# define test's procedure order
set check_functions     ""
lappend check_functions "qconf_addqueues"             ;# functions to call (in order)
lappend check_functions "qconf_removequeues"
lappend check_functions "qconf_auser"
lappend check_functions "qconf_duser"
lappend check_functions "qconf_Auser"
lappend check_functions "qconf_muser"
lappend check_functions "qconf_Muser"
lappend check_functions "qconf_segfault"
lappend check_functions "qconf_se"
lappend check_functions "qconf_sel"

# TODO: the aattr/rattr checks are broken or not fully 
# ported to 6.0
#lappend check_functions "qconf_aattr_check"
#lappend check_functions "qconf_rattr_check"
#lappend check_functions "qconf_Aattr_check"
#lappend check_functions "qconf_Rattr_check"

# Show options DONE
lappend check_functions "qconf_scal_check"   	;# List calendars
lappend check_functions "qconf_scall_check"	;# List all calalendars
lappend check_functions "qconf_sconfl_check"	;# List all hosts with configurations
lappend check_functions "qconf_sds_check"	;# List detached settings in the cluster  config
lappend check_functions "qconf_secl_check"	;# List event client list
lappend check_functions "qconf_sep_check"	;# List processors
lappend check_functions "qconf_sm_check"	;# List  managers
lappend check_functions "qconf_so_check"	;# List operators 
lappend check_functions "qconf_ss_check"	;# List submit hosts
lappend check_functions "qconf_sss_check"	;# Show scheduler status
lappend check_functions "qconf_sul_check"	;# Show user list
lappend check_functions "qconf_sprjl_check"	;# Show project list

# New options, non-show DONE
lappend check_functions "qconf_add_delete_manager"	;# Add and delete manager users 
lappend check_functions "qconf_add_show_mod_del_queue"	;# Add, show, modify and delete queue "qconf_queue.q"
lappend check_functions "qconf_add_show_delete_stnode"	;# Add, show and delete share tree nodes
lappend check_functions "qconf_create_modify_sharetree"  ;# create and modify a sharetree (qconf -Mstree)
lappend check_functions "qconf_del_sharetree"            ;# delete the whole sharetree (qconf -dstree)
lappend check_functions "qconf_event_client"	;# Create, show and delete event clients
lappend check_functions "qconf_add_delete_modify_calendar"	;# Add, delete and modify calendar
lappend check_functions "qconf_add_delete_modify_replace_attr"	;# Add, delete and modify attributes
lappend check_functions "qconf_modify_checkpoint"	;# Create, modify and delete checkpoint 
lappend check_functions "qconf_add_project"        ;# qconf -aprj / qconf -Aprj
lappend check_functions "qconf_modify_exechost"	;# Modify exec host
lappend check_functions "qconf_modify_project";# Modify project
lappend check_functions "qconf_modify_userlist";# Modify user list
lappend check_functions "qconf_modify_sched_conf";# Modify scheduler config
lappend check_functions "qconf_issue_2023"

global queue_names

global submitjob_jobid

proc qconf_init_level {} {
   global ts_config CHECK_OUTPUT
   global CHECK_ACT_LEVEL check_name

   if {$CHECK_ACT_LEVEL == 0} {
      if {[llength $ts_config(execd_nodes)] < 2} {
         puts $CHECK_OUTPUT "need at least 2 execd hosts for check $check_name"
         return -1
      }

      return 0
   }

  return -1  ;# no other level else
}

proc qconf_setup {} {
   global ts_config CHECK_OUTPUT CHECK_USER 
   global qconf_original_host_groups qconf_original_usersets qconf_orig_queues qconf_project qconf_sched_config qconf_userlist 
   global backup_allhosts
   global queue_names

   puts $CHECK_OUTPUT "setup ..."

   set queue_names ""
   for {set i 0} {$i < 1000}  {incr i 1} {
      lappend queue_names "q.$i"
   }
 
   # host group setup for GE >= 6.0
   if {$ts_config(gridengine_version) >= 60} {
      # we'll create additional host groups later on - remember the list of hostgroups
      # for cleanup
      set output [start_sge_bin qconf -shgrpl]
      set output [string trim $output]
      set qconf_original_host_groups {}
      foreach hg $output {
         puts $CHECK_OUTPUT "saving known hostgroup \"$hg\" for cleanup procedure"
         lappend qconf_original_host_groups $hg
      }

      # create a test hostgroup
      set qconf_hgrp_setup(group_name) "@qconf_test"
      set qconf_hgrp_setup(hostlist)   "$ts_config(execd_nodes)"
      add_hostgroup "@qconf_test" qconf_hgrp_setup
   }


   set output [start_sge_bin qconf -sul]
   set output [string trim $output]
   set qconf_original_usersets {}
   foreach user $output {
      lappend qconf_original_usersets $user
      puts $CHECK_OUTPUT "saving known userset \"$output\" for cleanup procedure"
   }

   # Save initial queue list; make it a global var, to be used in cleanup
   set qconf_orig_queues [get_queue_list]

   set qconf_project "qconf_project"
   # Create new project
   set qconf_prj_setup(name) "$qconf_project"

   puts $CHECK_OUTPUT "Create project $qconf_project ...\n"
   set result [add_prj qconf_prj_setup]

   puts $CHECK_OUTPUT "Create userlist qconf_userlist ...\n"
   add_access_list $CHECK_USER qconf_userlist

   puts $CHECK_OUTPUT "Save existing  scheduler config ...\n"
   get_schedd_config qconf_sched_config

   set_error 0 ""
}


proc qconf_cleanup {} {
   global ts_config CHECK_OUTPUT 
   global qconf_original_host_groups qconf_original_usersets qconf_orig_queues qconf_sched_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER qconf_prj_setup
  
   puts $CHECK_OUTPUT "cleanup ..."

   # in GE >= 6.0: cleanup hostgroups
   if {$ts_config(gridengine_version) >= 60} {
      set output [start_sge_bin qconf -shgrpl]
      set output [string trim $output]
      foreach hg $output {
         puts $CHECK_OUTPUT "testing hostgroup \"$hg\" ..."
         if {[lsearch -exact $qconf_original_host_groups $hg] < 0} {
            puts $CHECK_OUTPUT "deleting unexpected hostgroup \"$hg\" ..."
            del_hostgroup $hg
         }
      }
   }

   puts $CHECK_OUTPUT "Delete userlist qconf_userlist ...\n"
   set result [start_sge_bin "qconf" "-dul qconf_userlist" "" ""]

   set output [start_sge_bin qconf -sul]
   set output [string trim $output]
   foreach userg $output {
      puts $CHECK_OUTPUT "testing usergroup \"$userg\" ..."
      if { [lsearch -exact $qconf_original_usersets $userg] < 0 } {
         puts $CHECK_OUTPUT "deleting unexpected usergroup \"$userg\" ..."
         set res [start_sge_bin qconf "-dusergrp $userg"]
         puts $CHECK_OUTPUT $res
      }
   }

   # The original stuff is here
   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # Delete stuff I created
   del_manager "qconf_user"
   
   # Get list of new queues. Those created during the
   # tests will be deleted here.

   set qconf_new_queues [get_queue_list]

   puts $CHECK_OUTPUT "Deleting queues created during qconf... \n"
   foreach elem  $qconf_orig_queues {
      foreach new_elem $qconf_new_queues {
         if { $elem == $new_elem } {
	    continue
         } else {
	         del_queue $new_elem ""
         }

      }
   }

   # Re-set it back
   set my_project "qconf_project"
   puts $CHECK_OUTPUT "Delete project $my_project ...\n"
   set result [del_project $my_project]

   # Set sched back to what it was....
   puts $CHECK_OUTPUT "Set scheduler to original config ...\n"
   set result [mod_schedd_config qconf_sched_config]


   set_error 0 ""
}

proc qconf_auser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -auser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_auser" -1 "error showing user qconf_test_user"
      }
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}

proc qconf_duser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER
   puts $CHECK_OUTPUT "testing qconf -duser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      del_user "qconf_test_user"

      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_auser" -1 "error user qconf_test_user should have been deleted"
      }
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}


proc qconf_Auser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -Auser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user 1
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_auser" -1 "error showing user qconf_test_user"
      }
      del_user "qconf_test_user"
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}


proc qconf_muser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -muser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_muser" -1 "error showing user qconf_test_user"
      }
      # now modifiy user
      set new_conf(name)  "qconf_test_user"
      set new_conf(default_project) "NONE"
      mod_user new_conf 
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      puts $CHECK_OUTPUT $output
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_muser" -1 "error modify user qconf_test_user"
      }

      # now delete user
      del_user "qconf_test_user"


      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}

proc qconf_Muser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -Muser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_Muser" -1 "error showing user qconf_test_user"
      }
      # now modifiy user
      set new_conf(name)  "qconf_test_user"
      set new_conf(default_project) "NONE"
      mod_user new_conf 1
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      puts $CHECK_OUTPUT $output
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_Muser" -1 "error modify user qconf_test_user"
      }

      # now delete user
      del_user "qconf_test_user"


      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}



# run qconf -aq
#                                                             max. column:     |
#****** qconf/qconf_addqueues() ******
# 
#  NAME
#     qconf_addqueues -- ??? 
#
#  SYNOPSIS
#     qconf_addqueues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_addqueues {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH queue_names CHECK_OUTPUT

   set q_param(load_thresholds)       "np_load_avg=7.00"

   set test_host [lindex $ts_config(execd_nodes) 0]

   set count 0
   foreach queue $queue_names {
      if { $count > 50 } {
         puts $CHECK_OUTPUT "adding queue \"$queue\" with vi"
         add_queue $queue $test_host q_param 0
         set count 0
      } else {
         puts $CHECK_OUTPUT "adding queue \"$queue\" with file"
         add_queue $queue $test_host q_param
      }
      incr count 1
   }

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qconf/qconf_removequeues() ******
# 
#  NAME
#     qconf_removequeues -- ??? 
#
#  SYNOPSIS
#     qconf_removequeues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_removequeues {} {
   global ts_config
   global queue_names CHECK_OUTPUT

   set test_host [lindex $ts_config(execd_nodes) 0]

   foreach queue $queue_names {
     puts $CHECK_OUTPUT "deleting queue \"$queue\""
     del_queue $queue $test_host 0 1
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/check_exec_conf() ******
# 
#  NAME
#     check_exec_conf -- ??? 
#
#  SYNOPSIS
#     check_exec_conf { host_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host_list   - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_exec_conf { host_list attr_name check_value } {
  global CHECK_OUTPUT

  foreach host $host_list {
     get_exechost host_config $host
     set host_attr_value $host_config($attr_name)

     puts $CHECK_OUTPUT "host \"$host\": $attr_name is set to \"$host_attr_value\"" 

     if { [ string compare $check_value $host_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$host_attr_value\""
        add_proc_error "check_exec_conf" -1 "\"$check_value\" is not \"$host_attr_value\"" 
     }
  } 
}

# check all queues in queue_list for attr_name and compare it with check_value
#                                                             max. column:     |
#****** qconf/check_queue_conf() ******
# 
#  NAME
#     check_queue_conf -- ??? 
#
#  SYNOPSIS
#     check_queue_conf { queue_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     queue_list  - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_queue_conf { queue_list attr_name check_value } {

  global CHECK_OUTPUT

  foreach queue $queue_list {
     get_queue $queue q_config
     set q_attr_value $q_config($attr_name)

     puts $CHECK_OUTPUT "queue \"$queue\": $attr_name is set to \"$q_attr_value\"" 

     if { [ string compare $check_value $q_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$q_attr_value\""
        add_proc_error "check_queue_conf" -1 "\"$check_value\" is not \"$q_attr_value\"" 
     }
  } 
}



# obj_nm is "queue" or "exechost" 
# attr_nm is "object"
# val is value
# obj_id_lst is a list with names of the queues or hostnames to be modified
#                                                             max. column:     |
#****** qconf/qconf_aattr_check() ******
# 
#  NAME
#     qconf_aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_aattr_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue qtype PARALLEL $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"

    
   # check queue add parameter list
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue load_thresholds \"mem_free=1M\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   # check global host add user_lists list
   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   puts $CHECK_OUTPUT "adding deadlineusers to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"deadlineusers\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers"

   puts $CHECK_OUTPUT "adding defaultdepartment to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"defaultdepartment\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers defaultdepartment"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Aattr_check() ******
# 
#  NAME
#     qconf_Aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Aattr_check {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names 
   global CHECK_ACTUAL_TEST_PATH

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"

   puts $CHECK_OUTPUT "adding qtype PARALLEL and load_thresholds mem_free=1M to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue_wrong_syntax  $queue_names" 
   } output ]
   if {$result != 1} {
      set_error -1 "exit state is not 1 (used wrong file syntax format)"
   }
   
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue $queue_names" 
   } output ]

   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_rattr_check() ******
# 
#  NAME
#     qconf_rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_rattr_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names

   puts $CHECK_OUTPUT "replaceing exechost user_lists with NONE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr exechost user_lists \"NONE\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output

   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   puts $CHECK_OUTPUT "replaceing queues qtype with BATCH INTERACTIVE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue qtype \"BATCH INTERACTIVE\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"

   puts $CHECK_OUTPUT "replaceing queues load_thresholds with np_load_avg=7.00"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue load_thresholds \"np_load_avg=7.00\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"



   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Rattr_check {} {
}

proc qconf_segfault {} {
   global ts_config CHECK_OUTPUT CHECK_ARCH CHECK_HOST CHECK_USER

   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-as \"\""]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      puts $CHECK_OUTPUT $output
      add_proc_error "qconf_segfault" -1 "qconf -as \"\" failed - see Issue: 1732"
   }
   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-ah \"\""]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      puts $CHECK_OUTPUT $output
      add_proc_error "qconf_segfault" -1 "qconf -ah \"\" failed - see Issue: 1732"
   }

   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-ae localhost"]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      puts $CHECK_OUTPUT $output
      add_proc_error "qconf_segfault" -1 "qconf -ah \"\" failed - see Issue: 1884"
   } else {
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-de localhost"]
   }


   set_error 0 "ok"
}

proc qconf_se {} {
   global ts_config
  
   # test hosts
   set cluster_host [lindex $ts_config(execd_nodes) 0]
   set non_cluster_host [host_conf_get_unused_host]

   # fields delivered by qconf -se
   if {$ts_config(gridengine_version) == 53} {
      set qconf_se_fields "hostname load_scaling complex_list complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling resource_capability_factor"
   } else {
      set qconf_se_fields "hostname load_scaling complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling report_variables"
   }

   # positive check
   # check qconf -se <an exec host>, check completeness of result
   if {[get_exechost exec_host $cluster_host] == 0} {
      foreach elem $qconf_se_fields {
         if {![info exists exec_host($elem)]} {
            add_proc_error "qconf_se" -1 "$elem is missing in result of qconf -se"
         }
      }
   }

   # negative checks
   # check qconf -se <a non exec host>
   if {$non_cluster_host != ""} {
      if {[get_exechost exec_host $non_cluster_host "" "" 0] == 0} {
         add_proc_error "qconf_se" -1 "qconf -se $non_cluster_host (non cluster host) should have failed"
      }
   }

   # check qconf -se from a non admin/submit host
   if {$non_cluster_host != ""} {
      if {[get_exechost exec_host $cluster_host $non_cluster_host "" 0] == 0} {
         add_proc_error "qconf_se" -3 "qconf -se called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889"
      }
   }

   set_error 0 "ok"
}

proc qconf_sel {} {
   global ts_config
  
   # test hosts
   set non_cluster_host [host_conf_get_unused_host]

   # positive check
   # qconf -sel, has to match testsuite's execd_nodes list
   if {[get_exechost_list exechost_list] == 0} {
      if {[host_list_compare $exechost_list $ts_config(execd_nodes)] != 0} {
         add_proc_error "qconf_sel" -1 "exec host list delivered by qconf does not match testsuite exec host list:\n$exechost_list\n$ts_config(execd_nodes)"
      }
   }

   # negative check
   # call qconf -sel on a non admin/submit host
   if {$non_cluster_host != ""} {
      if {[get_exechost_list exechost_list $non_cluster_host "" 0] == 0} {
         add_proc_error "qconf_sel" -3 "qconf -sel called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889"
      }
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qconf/qconf_scal_check() ******
#
#  NAME
#     qconf_scal_check - Check known calendar "always_suspend"
#
#  SYNOPSIS
#     qconf_scal_check { } - Call get_calendar with calendar "always_suspend"
#                            Then call get_calendar with a wrong calendar name,
#                            like "wrong_calendar". 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calendar()
# sge_calendar/get_calender_error()
#
#*******************************
proc qconf_scal_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH


   # First do a positive test, give a valid calendar name, "always_suspend"
   puts $CHECK_OUTPUT "Positive test for qconf -scal always_suspend...\n"
   set result0 [get_calendar "always_suspend" ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -scal always_suspend succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Next do a negative test, give a invalid calendar name, "wrong_calendar"
   puts $CHECK_OUTPUT "Negative test for qconf -scal wrong_calendar...\n"
   set result1 [get_calendar "wrong_calendar" result $CHECK_HOST $CHECK_USER 0 ]

   if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -scal wrong_calendar succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"

   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_scall_check() ******
#
#  NAME
#     qconf_scall_check - Check all known calendars 
#
#  SYNOPSIS
#     qconf_scall_check { } - Call get_calender_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calender_list()
#*******************************
proc qconf_scall_check {} {

   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -scall ...\n"
   set result0 [get_calender_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -scall succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"

   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_sconfl_check() ******
#
#  NAME
#     qconf_sconfl_check - Display a list of hosts  for  which  configurations
#                          are  available.  
#
#  SYNOPSIS
#     qconf_sconfl_check { } - Call get_config_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_config_list()
#*******************************

proc qconf_sconfl_check {} {

   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
    puts $CHECK_OUTPUT "Positive test for qconf -sconfl ...\n"

   set result0 [get_queue_config_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sconfl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_sds_check() ******
#
#  NAME
#     qconf_sds_check - Display detached settings in the cluster  config
#
#  SYNOPSIS
#     qconf_sds_check { } - Call get_detached_settings
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_detached_settings()
#*******************************

proc qconf_sds_check {} {

   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH
  
   # First do a positive test
   set result0 [get_detached_settings]


   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sds succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                                      max. column:     |
#****** qconf/qconf_secl_check() ******
#
#  NAME
#     qconf_secl_check - Display the event client list
#
#  SYNOPSIS
#     qconf_secl_check { } - Call get_event_client_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_event_client/get_event_client_list()
#*******************************

proc qconf_secl_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -secl ...\n"

   set result0 [get_event_client_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -secl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                               max. column:     | #
#****** qconf/qconf_sep_check() ******  
#  NAME
#     qconf_sep_check - Display the processor list
#
#  SYNOPSIS
#     qconf_sep_check { } - Call get_processor_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_sep_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # DO A Positive test
   puts $CHECK_OUTPUT "Positive test for qconf -sep ...\n"
   set result0 [get_processor_list]

  if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sep succeded\n"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sm_check() ******
#
#  NAME
#     qconf_sm_check - Display list of managers
#
#  SYNOPSIS
#     qconf_sm_check { } - Call get_manager_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_manager_list()
#*******************************
proc qconf_sm_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -sm ...\n"

   set result0 [get_manager_list]

  if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sm succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_so_check() ******
#
#  NAME
#     qconf_so_check - Display list of operators
#
#  SYNOPSIS
#     qconf_so_check { } - Call get_operator_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_operator_list()
#*******************************
proc qconf_so_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -so ...\n"
   set result0 [get_operator_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -so succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_ss_check() ******
#
#  NAME
#     qconf_ss_check - Display list of submit hosts
#
#  SYNOPSIS
#     qconf_ss_check { } - Call get_submithost_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_submithost_list()
#*******************************
proc qconf_ss_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -ss ...\n"
   set result0 [get_submithost_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -ss succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sss_check() ******
#
#  NAME
#     qconf_sss_check - Display scheduler status
#
#  SYNOPSIS
#     qconf_sss_check { } - Call "qconf -sss "
#                            Check that the output contains   "$CHECK_HOST"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_sss_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive tests
   puts $CHECK_OUTPUT "Positive test for qconf -sss ...\n"
   set result0 [get_scheduler_status]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sss succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sul_check() ******
#
#  NAME
#     qconf_sul_check - Display user list
#
#  SYNOPSIS
#     qconf_sul_check { } - Call get_userset_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/get_userset_list()
#*******************************
proc qconf_sul_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do q positive test
   puts $CHECK_OUTPUT "Positive test for qconf -sul ...\n"
   set result0 [get_userset_list userset_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sul succeded"
   } else {
      add_proc_error "qconf_sul_check" -1 "qconf -sul failed"
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sprjl_check() ******
#
#  NAME
#     qconf_sprjl_check - Display project list
#
#  SYNOPSIS
#     qconf_sprjl_check { } - Call "qconf -sprjl "
#                            Check that the output contains   "mytestproject"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_sprjl_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

    # Do a positive test
    puts $CHECK_OUTPUT "Positive test for qconf -sprjl ...\n"
    set result0 [get_project_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sprjl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_add_delete_manager() ******
#
#  NAME
#     qconf_add_delete_manager - Add and delete manager user
#
#  SYNOPSIS
#     qconf_add_delete_manager { } - Call add_manager, get_manager_list,
#	                             del_manager
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/add_manager()
# sge_users/get_manager_list()
# sge_users/del_manager()
#*******************************
proc qconf_add_delete_manager {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First add manager "qconf_user"
   puts $CHECK_OUTPUT "Positive test for qconf -am ...\n"
   set result0 [add_manager "qconf_user"]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -am qconf_user succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Now show manager list, check that  "qconf_user" is there
   puts $CHECK_OUTPUT "Positive test for qconf -sm ...\n"
   set result22 [get_manager_list ]

   if { ( $result22 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sm succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result22"
   }

   # Now delete manager "qconf_user"
   puts $CHECK_OUTPUT "Positive test for qconf -dm ...\n"
   set result2 [del_manager "qconf_user"]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dm qconf_user succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now delete manager "qconf_user" again
   puts $CHECK_OUTPUT "Negative test for qconf -dm ...\n"
   set result3 [del_manager "qconf_user"] 

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dm qconf_user again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qconf/qconf_add_show_mod_del_queue() ******
#
#  NAME
#     qconf_add_show_mod_del_queue - Add, show modify and delete queue "qconf_queue.q"
#
#  SYNOPSIS
#     qconf_add_show_mod_del_queue { } - Call add_queue qconf_queue.q $CHECK_HOST new_queue
#                                then   "qconf -sq qconf_queue.q" to show new queue
#                                Use "qconf -M(m)q queue qname qconf_queue.q"
#                                Also use "qconf -purge queue qname qconf_queue.q"
#                                Then clean up with "qconf -dq qconf_queue.q"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_queue/add_queue()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_mod_del_queue {} {
   global ts_config env 
   global CHECK_OUTPUT CHECK_USER 

   # First add queue "qconf_queue.q". Set the new name to "qconf_queue.q, 
   # host to $host

   set host [lindex $ts_config(execd_nodes) 0]
   puts $CHECK_OUTPUT "Adding queue qconf_queue.q ...\n"
   add_queue qconf_queue.q $host new_queue 

   # Now do positive test on qconf -sql
   puts $CHECK_OUTPUT "Positive test of qconf -sql ...\n"
   set result2 [get_queue_list ]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sql succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now modify queue qconf_queue.q
   set new_queue(seq_no)  "2"
   puts $CHECK_OUTPUT "Modifying information for qconf_queue.q ...\n"
   set result21 [mod_queue "qconf_queue.q" "" new_queue ]

   if { ( $result21 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Mq succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result21"
   }
 
   # Now modify queue qconf_queue.q slow
   set new_queue(seq_no)  "1"
   puts $CHECK_OUTPUT "Modifying information for qconf_queue.q slow...\n"
   set result22 [mod_queue "qconf_queue.q" "" new_queue 0]

   if { ( $result22 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -mq succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result22"
   }

   #  Now try to modify a invalid seq. no
   set new_queue(seq_no) "-1"
   puts $CHECK_OUTPUT "Negative test of qconf -Mq qconf_queue.q, seq.  number...\n"
   set result23 [mod_queue "qconf_queue.q" "" new_queue 1  $host $CHECK_USER 0]

   if { ( $result23 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Mq wrong_project failed successfully"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1982
      puts $CHECK_OUTPUT "result is $result23"
   }
 
   # Now clear queue "qconf_queue.q"
   set new_queue(qname) "qconf_queue.q"
   set new_queue(projects) "none"
   puts $CHECK_OUTPUT "Clearing queue qconf_queue.q ...\n"
   set result3 [clear_queue "qconf_queue.q"]

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }
   
   # Now try to clear it again!
   puts $CHECK_OUTPUT "Clearing queue qconf_queue.q again...\n"
   set result4 [clear_queue "qconf_queue.q"]

   if { ( $result4 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   #  Now try to clear a non-existing queue, "wrong_queue.q"
   puts $CHECK_OUTPUT "Negative test of qconf -cq wrong_queue.q ...\n"
   set result5 [clear_queue "wrong_queue.q" result $host $CHECK_USER 0]

   if { ( $result5 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q succeded"
   } else {
      # See IZ 1976 for why this returns wrongly 0
      puts $CHECK_OUTPUT "result is $result5"
   }

   # Now delete queue "qconf_queue.q"
   puts $CHECK_OUTPUT "Positive test of qconf -dq qconf_queue.q...\n"
   set result4 [del_queue  "qconf_queue.q" $host 1]

   if { ( $result4  == 0 )} {
      puts $CHECK_OUTPUT "qconf -dq qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now try to clear a non-existant queue
   puts $CHECK_OUTPUT "Negative test of qconf -cq qconf_queue.q...\n"
   set result5 [clear_queue "qconf_queue.q"]

   if { ( $result5 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result5"
   }

   set_error 0 "ok"

}
#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_host() ******
#
#  NAME
#     qconf_add_show_delete_host - Add, show and delete host execd_nodes 1
#
#  SYNOPSIS
#     qconf_add_show_delete_host { } - Call "qconf -dh execd_host "
#	                         Show it with "qconf -sh"
#                                Then add it ack with "qconf -ah execd_host"
#                                Try to add it again
#                                Show it with "qconf -sh"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_host {} {
   global ts_config env CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_ROOT
   global CHECK_OUTPUT CHECK_USER 

   set host [lindex $ts_config(execd_nodes) 0]
   set other_host [lindex $ts_config(execd_nodes) 1]


   # First delete host $other_host. 
   puts $CHECK_OUTPUT "Positive test of qconf -dh $other_host...\n"
   set result1 [del_adminhost $other_host]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dh $other_host succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Try deleting $other_host again
   puts $CHECK_OUTPUT "Negative test of qconf -dh  $other_host...\n"
   set result4 [del_adminhost $other_host $host $CHECK_USER 0]

   if { ( $result4 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -dh $other_host again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now show admin hosts 
   puts $CHECK_OUTPUT "Positive test of qconf -sh  $other_host...\n"
   set result3 [get_adminhost_list]

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sh succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }

  
 # Now add back $other_host
   puts $CHECK_OUTPUT "Positive test of qconf -ah  $other_host...\n"
   set result5 [add_adminhost $other_host]

   if { ( $result5 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -ah $other_host succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result5"
   }

   # Now try adding it again
   puts $CHECK_OUTPUT "Negative test of qconf -ah $other_host ...\n"

   set result6 [add_adminhost $other_host]

   if { ( $result6 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -ah $other_host again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result6"
   }

   set_error 0 "ok"

}

#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_stnode() ******
#
#  NAME
#     qconf_add_show_delete_stnode - Add, show and delete sharetree
#
#  SYNOPSIS
#     qconf_add_show_delete_stnode { } - Call "qconf -astnode ..."
#                                Show it with "qconf -sstnode qconf_proj"
#                                Then delete it with "qconf -dstnode qconf_proj"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# performance/large_cluster/check.exp/large_cluster_setup_sharetree()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_stnode {} {
   global ts_config env 
   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

   set host [lindex $ts_config(execd_nodes) 0]
   set other_host [lindex $ts_config(execd_nodes) 1]

   set project "mytestproject"

   # Add users
   # Some of them might already exist - in this case we call mod_user
   get_user_list current_user_list
   puts $CHECK_OUTPUT "Adding  user $CHECK_USER to project $project ...\n"

   foreach user "$CHECK_USER $CHECK_FIRST_FOREIGN_SYSTEM_USER" {
      if {[info exists new_user]} {
         unset new_user
      }
      puts $CHECK_OUTPUT "Adding  user $user to project $project ...\n"
      set new_user(name) $user
      set new_user(default_project) $project
      if {[lsearch -exact $current_user_list $user] < 0} {
         add_user new_user 1
      } else {
         mod_user new_user 1
      }
   }

   # Now add policies to the project $project
   puts $CHECK_OUTPUT "Adding  30 shares to $CHECK_USER to project $project and 70 shares to $CHECK_FIRST_FOREIGN_SYSTEM_USER...\n"
   set result1 [add_sharetree_node $project $CHECK_USER 30 $CHECK_FIRST_FOREIGN_SYSTEM_USER 70]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -astnode /$project succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }
  
   # Now do a negative test on -astnode, add users again
   puts $CHECK_OUTPUT "Adding  30 shares to $CHECK_USER to project $project and 70 shares to $CHECK_FIRST_FOREIGN_SYSTEM_USER again....n"
   set result2 [add_sharetree_node $project $CHECK_USER 30 $CHECK_FIRST_FOREIGN_SYSTEM_USER 70 $host $CHECK_USER 0]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -astnode /$project again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now show the sharetree list
   puts $CHECK_OUTPUT "Now show sharetree list for $project... \n"
   set result3 [get_sharetree_list $project]

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sstnode /$project succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }

   # Modify shares in project $project
   puts $CHECK_OUTPUT "Now modify shares for user $CHECK_USER, $CHECK_FIRST_FOREIGN_SYSTEM_USER for  $project... \n"
   set result4 [mod_sharetree_node $project $CHECK_USER 50 $CHECK_FIRST_FOREIGN_SYSTEM_USER 50]

   if { ( $result4 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -mstnode /$project succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now show the sharetree list again
   puts $CHECK_OUTPUT "Now show sharetree list for $project again... \n"
   set result5 [get_sharetree_list $project]
   if  { ( $result5 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sstnode /$project again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result5"
   }

   
   # Delete $project/$CHECK_USER
   puts $CHECK_OUTPUT "Now  delete user $CHECK_USER from  $project ... \n"
   set result6 [del_sharetree_node $project  $CHECK_USER]
  
   if { ( $result6 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dstnode /$project/$CHECK_USER succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result6"
   }

   # Delete $project/$CHECK_FIRST_FOREIGN_SYSTEM_USER
   puts $CHECK_OUTPUT "Now  delete user $CHECK_FIRST_FOREIGN_SYSTEM_USER from  $project ... \n"
   set result6 [del_sharetree_node $project  $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   if { ( $result6 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dstnode /$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result6"
   }
   
   # Delete users CHECK_USER, CHECK_FIRST_FOREIGN_SYSTEM_USER from userlist
   puts $CHECK_OUTPUT "Now  delete user $CHECK_USER from  userlist ... \n"
   del_user $CHECK_USER
   puts $CHECK_OUTPUT "Now  delete user $CHECK_FIRST_FOREIGN_SYSTEM_USER from  userlist ... \n"
   del_user $CHECK_FIRST_FOREIGN_SYSTEM_USER

   set_error 0 "ok"

}


#                                                             max. column:     |
#****** qconf/qconf_event_client() ******
#
#  NAME
#     qconf_event_client - Create and then destroy an event client
#
#  SYNOPSIS
#     qconf_event_client { } - First create an INTERACTIVE only queue
#                             Then start qevent -ts as special user 
#                            ts_def_con2
#                            Check event client list with qconf -secl
#			     Then kill event client with qconf -kec
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_event_client {} {
   global ts_config env CHECK_SOURCE_DIR
   global CHECK_OUTPUT CHECK_USER 

   set up_arch [resolve_build_arch $ts_config(master_host)]
   set event_client_bin $CHECK_SOURCE_DIR/$up_arch/qevent

   if { [file isfile $event_client_bin] != 1 } {
      set_error -3 "could not open event client binary: $event_client_bin"
      return -3
   }
   puts $CHECK_OUTPUT "using event client: $event_client_bin"

   # start event client on master host, using special user ts_def_con2
   puts $CHECK_OUTPUT "starting event client with -ts option ..."
   set event_client_sid [ open_remote_spawn_process $ts_config(master_host) "ts_def_con2" $event_client_bin "-ts"]
   set event_client_id [lindex $event_client_sid 1]

   # First do a list of event clients
   puts $CHECK_OUTPUT "Show event client with -secl option ..."
   set result0 [get_event_client_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -secl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Kill now event clients

   set result1 [del_event_client_list "" $event_client_id]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -kec $event_client_id succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   close_spawn_process $event_client_sid
   
   # Restart event client to do a -kec all

   # start event client on master host, using special user ts_def_con2
   puts $CHECK_OUTPUT "Re-starting event client with -ts option ..."
   set event_client_sid1 [ open_remote_spawn_process $ts_config(master_host) "ts_def_con2" $event_client_bin "-ts"]
   set event_client_id1 [lindex $event_client_sid1 1]

   set result2 [del_event_client_list "all" ""]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -kec all succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   close_spawn_process $event_client_sid1
   
   set_error 0 "ok"
}

#****** qconf/qconf_add_delete_modify_calendar() ******
#
#  NAME
#     qconf_add_delete_modify_calendar - Create modify then destroy a calendar
#
#  SYNOPSIS
#     qconf_add_delete_modify_calendar { } - First create a calendar, interactively
#                                            Then modify it and delete it.
#                                            Then create it in fast add mode, 
#                                            Then delete it again
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_delete_modify_calendar {} {
   global ts_config env CHECK_SOURCE_DIR
   global CHECK_OUTPUT CHECK_USER 

   set cal_name "qconf_calendar"

   set new_cal(calendar_name)  "$cal_name"
   set new_cal(week)           "mon-sun=0-24=suspended"

   # First do a list of event clients
   puts $CHECK_OUTPUT "Add calendar $cal_name ..."
   set result0 [add_calendar new_cal]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Acal succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }
  
   set mod_cal(calendar_name)  "$cal_name"
   set mod_cal(week)           "mon-fri=0-23=suspended"

   # Now modify it 
   puts $CHECK_OUTPUT "Modify calendar $cal_name ..."
   set result01 [mod_calendar mod_cal]

   if { ( $result01 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Mcal succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result01"
   }

   # Now delete it 
   puts $CHECK_OUTPUT "Delete calendar $cal_name ..."
   set result1 [del_calendar $cal_name]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dcal succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }
  
   # Now do a slow add
   puts $CHECK_OUTPUT "Add calendar $cal_name slow..."
   set result2 [add_calendar new_cal 0]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -acal slow succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now modify it slow
   puts $CHECK_OUTPUT "Modify calendar $cal_name slow..."
   set result21 [mod_calendar mod_cal 0]

   if { ( $result21 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -mcal slow  succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result21"
   }

   # Now delete it  again
   puts $CHECK_OUTPUT "Delete calendar $cal_name again..."
   set result3 [del_calendar $cal_name]

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dcal again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }

   set_error 0 "ok"

}

#****** qconf/qconf_add_delete_modify_replace_attr() ******
#
#  NAME
#     qconf_add_delete_modify_replace_attr - Create modify then destroy attributes of object queue qocnf_queue.q . Can also be object exechost....
#
#  SYNOPSIS
#     qconf_add_delete_modify_replace_attr { } - First create a temporary queue, qocnf_queue.q
#                                            Then modify it and delete it.
#                                            Then create it in slow add mode
#                                            Then modify it slow and delete it 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_attributes/get_attr()
# sge_attributes/mod_attr()
#*******************************
proc qconf_add_delete_modify_replace_attr {} {
   global ts_config env CHECK_SOURCE_DIR
   global CHECK_OUTPUT CHECK_USER 

   set queue_name "qconf_queue.q"
   set host [lindex $ts_config(execd_nodes) 0]

   # First create the queue
   puts $CHECK_OUTPUT "Create  queue $queue_name ...\n"
   set new_queue(qname) "$queue_name"
   set new_queue(hostlist) "$host"
   set result0 [add_queue $queue_name $host new_queue]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -aq  $queue_name succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Now modify attribute slots for obj_spec queue: -mattr queue slots 0 
   set obj_spec "queue"
   set attr_name "slots"
   set val "1"
   set target "$queue_name\@$host"

   puts $CHECK_OUTPUT "Modify $obj_spec  $attr_name  ..."
   set result01 [mod_attr  $obj_spec $attr_name $val $target]

   if { ( $result01 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Mattr succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result01"
   }

   # Now modify non-existent attribute stuff 
   set attr_name "stuff"
   set val "100"

   puts $CHECK_OUTPUT "Modify $obj_spec  $attr_name  ..."
   set result02 [mod_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result02 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Mattr with wrong attribute succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      puts $CHECK_OUTPUT "result is $result02"
   }
  
   # Now modify its attribute from CLI
   set attr_name "slots"
   set val "1"
   puts $CHECK_OUTPUT "Modify $obj_spec $attr_name from CLI ...\n"
   set result02 [mod_attr  $obj_spec $attr_name $val $target 0]

   if { ( $result02 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -mattr succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result02"
   }

  # Now modify its attribute from CLI wrongly
   set attr_name "stuff"
   set val "200"
   puts $CHECK_OUTPUT "Modify $obj_spec $attr_name from CLI wrongly ...\n"
   set result03 [mod_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result03 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -mattr wrongly succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result03"
   }

   # Now show these attributes
   set attr_name "slots"
   set val "0"
   puts $CHECK_OUTPUT "Show $obj_spec  $attr_name  ..."
   set result03 [get_attr $obj_spec $attr_name $target]

   if { ( $result03 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sobjl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result03"
   }

   # Now replace attribute slots for obj_spec queue: -Rattr queue slots 0
   puts $CHECK_OUTPUT "Replace $obj_spec  $attr_name  ..."
   set result04 [replace_attr  $obj_spec $attr_name $val $target]

   if { ( $result04 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Rattr succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result04"
   }

   # Now try to add wrong stuff
   set attr_name "stuff"
   set val "100"
   puts $CHECK_OUTPUT "Add $obj_spec  $attr_name  slow..."
   set result21 [add_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result21 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -aattr wrongly succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result21"
   }

   # Now try to add wrong stuff fast
   puts $CHECK_OUTPUT "Add $obj_spec  $attr_name  fast..."
   set result22 [add_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result22 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Aattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      puts $CHECK_OUTPUT "result is $result22"
   }

   # Now replace non-existent attribute stuff
   set attr_name "stuff"
   set val "100"

   puts $CHECK_OUTPUT "Replace $obj_spec  $attr_name  slow..."
   set result31 [replace_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result31 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -rattr wrongly succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result31"
   }

   # Now replace non-existent attribute stuff from file

   puts $CHECK_OUTPUT "Replace $obj_spec  $attr_name from file  ..."
   set result32 [replace_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result32 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Rattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      puts $CHECK_OUTPUT "result is $result32"
   }

   # Now try to delete non-existant stuff
   puts $CHECK_OUTPUT "Delete  attr  $attr_name  slow..."
   set result31 [del_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result31 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -dattr wrongly succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result31"
   }

   # Now try to delete non-existant stuff fast
   puts $CHECK_OUTPUT "Delete  attr  $attr_name  fast..."
   set result32 [del_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result32 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Dattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      puts $CHECK_OUTPUT "result is $result32"
   }

   # Now delete it via -dattr using good values
   set attr_name "slots"
   set val "1"
   puts $CHECK_OUTPUT "Delete attr $attr_name on $queue_name slow ...\n"
   set result22 [del_attr $obj_spec $attr_name $val $target 0]

   if { ( $result22 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dattr slow succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result22"
   }

   # Now delete queue

   puts $CHECK_OUTPUT "Delete queue $queue_name ..."
   set result4 [del_queue  $queue_name $host 1]

   if { ( $result4  == 0 )} {
      puts $CHECK_OUTPUT "qconf -dq $queue_name succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   set_error 0 "ok"

}

#****** qconf/qconf_modify_checkpoint() ******
#
#  NAME
#     qconf_modify_checkpoint - Modify chekcpoint
#
#  SYNOPSIS
#     qconf_modify_checkpoint { } - Call "qconf -Mckpt "
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_modify_checkpoint {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER 

   # First let's create queue qconf_queue.q
   set queue_name "qconf_queue.q"
   puts $CHECK_OUTPUT "Create  queue $queue_name ...\n"

   set new_queue(qname) "$queue_name"
   set host [lindex $ts_config(execd_nodes) 0]
   set result0 [add_queue $queue_name $host new_queue ]

   if {$result0 == 0} {
      puts $CHECK_OUTPUT "qconf -Aq  $queue_name succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Next, let's create a checkpoint
   set myarray(ckpt_name) "qconf_ckpt_name"
   puts $CHECK_OUTPUT "Create  checkpoint  $myarray(ckpt_name) ...\n"

   set result1 [add_checkpointobj myarray]

   if {$result1 == 0} {
      puts $CHECK_OUTPUT "qconf -ackpt  succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Now modify it using set_checkpointobj
   set myarray(clean_command) "ls"
   puts $CHECK_OUTPUT "Modify  checkpoint  $myarray(ckpt_name) ...\n"
   set result2 [mod_checkpointobj myarray 1]

   if {$result2 == 0} {
      puts $CHECK_OUTPUT "qconf -Mckpt succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now modify it using CLI
   set myarray(clean_command) "none"
   puts $CHECK_OUTPUT "Modify  checkpoint  $myarray(ckpt_name) using CLI...\n"
   set result21 [mod_checkpointobj myarray 0]

   if {$result21 == 0} {
      puts $CHECK_OUTPUT "qconf -mckpt  succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result21"
   }

   # Now try to modify using a non-existent checkpoint
   set myarray(ckpt_name) "qconf_ckpt_wrong"
   puts $CHECK_OUTPUT "Modify wrong checkpoint $myarray(ckpt_name) ...\n"
   set result21 [mod_checkpointobj myarray 1 "" "" 0]

   if {$result21 == -1} {
      puts $CHECK_OUTPUT "qconf -Mckpt failed correctly"
   } else {
      puts $CHECK_OUTPUT "result is $result21"
   }

   # Now try to modify using a non-existent checkpoint slow
# TODO: we have to modify the way how handle_vi_edit works.
#       at least, handle_vi_edit has to accept multiple error messages.
#       Best might be to pass arrays of messages to handle_vi_edit, similar to
#       handle_sge_error.
#   puts $CHECK_OUTPUT "Modify wrong checkpoint $myarray(ckpt_name) slow ...\n"
#   set result22 [mod_checkpointobj myarray 0 "" "" 0]
#
#   if {$result22 == -9} {
#      puts $CHECK_OUTPUT "qconf -mckpt failed correctly"
#   } else {
#      puts $CHECK_OUTPUT "result is $result22"
#   }

   # Now delete checkpoint
   set myarray(ckpt_name) "qconf_ckpt_name"
   puts $CHECK_OUTPUT "Delete checkpoint $myarray(ckpt_name) ..."
   set result4 [del_checkpointobj $myarray(ckpt_name)]

   if {$result4 == 0} {
      puts $CHECK_OUTPUT "qconf -dckpt $myarray(ckpt_name) succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now delete queue
   puts $CHECK_OUTPUT "Delete queue $queue_name ..."
   set result8 [del_queue  $queue_name $host 1]

   if {$result8 == 0} {
      puts $CHECK_OUTPUT "qconf -dq $queue_name succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result8"
   }

   set_error 0 "ok"
}

#****** qconf/qconf_modify_exechost() ******
#  NAME
#     qconf_modify_exechost - Modify exec host
#
#  SYNOPSIS
#     qconf_sep_check { } - Call set_exechost to modify exechost
#                         from CLI or file
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_modify_exechost {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER

   set host [lindex $ts_config(execd_nodes) 0]

   # Save the initial values
   get_exechost old_values $host

   # First create project qconf_test_prj
   set prj_setup(name) "qconf_test_prj"
   set my_project "qconf_test_prj"
   puts $CHECK_OUTPUT "Create project $my_project ...\n"
   set result [add_prj prj_setup]
   puts $CHECK_OUTPUT $result

   # Modify exechost fast
   puts $CHECK_OUTPUT "Modify exec host  $host  from file ...\n"
   set new_exechost_charray(projects) "$my_project"
   set result0 [mod_exechost new_exechost_charray $host]

  if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Me succeded\n"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Now modify from CLI
   puts $CHECK_OUTPUT "Modify exec host $host from CLI ...\n"
   set result1 [mod_exechost new_exechost_charray $host 0]

  if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -me succeded\n"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Modify exechost fast wrongly
   puts $CHECK_OUTPUT "Modify exec host  $host  from file wrongly...\n"
   set new_exechost_charray(projects) "qconf_wrong_prj"
   set result1 [mod_exechost new_exechost_charray $host 1 $host $CHECK_USER 0]

  if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Me failed  successfully \n"
   } else {
     # See IZ 1967 for why this returns wrongly 0
     puts $CHECK_OUTPUT "result is $result1"
   }
   
   # Now modify from CLI wrongly
   puts $CHECK_OUTPUT "Modify exec host $host from CLI wrongly...\n"
   set result12 [mod_exechost new_exechost_charray $host 0 $host $CHECK_USER 0]

  if { ( $result12 == -3 ) } {
      puts $CHECK_OUTPUT "qconf -me failed  successfully\n"
   } else {
      puts $CHECK_OUTPUT "result is $result12"
   }

   # Now restore the old values
   puts $CHECK_OUTPUT "Restoring old values for  $host  ...\n"
   set result2 [mod_exechost old_values $host 0]

  if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -me succeded\n"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }
  
  # Now delete project qconf_test_prj
   puts $CHECK_OUTPUT "Delete project $my_project ...\n"
   set result [del_project $my_project]

   set_error 0 "ok"
}

#****** qconf/qconf_modify_project() ******
#
#  NAME
#     qconf_modify_project - Modify project's fshare
#
#  SYNOPSIS
#     qconf_modify_project { } - Call mod_project
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_project {} {
   global ts_config env qconf_project
   global CHECK_OUTPUT CHECK_USER

   set host [lindex $ts_config(execd_nodes) 0]
   set my_project "$qconf_project"

   # Next modify fast
   puts $CHECK_OUTPUT "Modify project $my_project fast ...\n"
   set old_values(fshare) "0"
   set result1 [mod_project $my_project old_values]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Mprj $my_project succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Next modify slow
   puts $CHECK_OUTPUT "Modify project $my_project slow ...\n"
   set result2 [mod_project $my_project old_values 0]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -mprj $my_project succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Next modify fast wrong
   puts $CHECK_OUTPUT "Modify project $my_project fast with wrong attribute  ...\n"
   set old_values(stuff) "5"
   set result21 [mod_project $my_project old_values 1 $host $CHECK_USER 0]

   if { ( $result21 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Mprj $my_project failed  correctly"
   } else {
      # See IZ 1968 on why this does not fail as expected
      puts $CHECK_OUTPUT "result is $result21"
   }

   # Next modify fast wrong again
   puts $CHECK_OUTPUT "Modify project $my_project wrong fast again ...\n"
   set old_values(fshare) "-1"

   set result3 [mod_project $my_project old_values 1 $host $CHECK_USER 0]

   if { ( $result3 == -2 ) } {
      puts $CHECK_OUTPUT "qconf -Mprj $my_project failed again correctly"
   } else {
      # See IZ 1968 on why this does not fail as expected
      puts $CHECK_OUTPUT "result is $result3"
   }

   # Next modify slow
   puts $CHECK_OUTPUT "Modify project $my_project  wrong slow ...\n"
   set result4 [mod_project $my_project old_values 0 $host $CHECK_USER 0]

   if { ( $result4 == -3 ) } {
      puts $CHECK_OUTPUT "qconf -mprj $my_project failed  correctly"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   set_error 0 "ok"
}

#****** qconf/qconf_modify_userlist() ******
#
#  NAME
#     qconf_modify_userlist - Modify userlist's fshare
#
#  SYNOPSIS
#     qconf_modify_userlist { } - Call mod_userlist
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_userlist {} {
   global ts_config env qconf_userlist
   global CHECK_OUTPUT CHECK_USER

   set host [lindex $ts_config(execd_nodes) 0]
  
   set userlist "qconf_userlist"
   set attribute "entries"
   set value "$CHECK_USER"

   # Get present config
   #get_ulist $userlist current_ul

   set current_ul(name) "$userlist"
   set current_ul($attribute) "$value"

   # Now modify fast
   puts $CHECK_OUTPUT "Modify userlist $userlist fast ...\n"
   set result1 [mod_userlist $userlist current_ul ]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Mu fast succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Next modify slow
   set attribute "entries"
   set value "NONE"
   set current_ul($attribute) "$value"
   puts $CHECK_OUTPUT "Modify userlist $userlist slow ...\n"

   set result2 [mod_userlist $userlist current_ul 0]
   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -mu slow succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }


   # Now modify slow with wrong attribute
   set userlist "qconf_userlist"
   set attribute "oticket"
   set value "-1"
   set current_ul($attribute) "$value"
   puts $CHECK_OUTPUT "Modify attribute $attribute wrong slow ...\n"
   set result4 [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if { ( $result4 == -4 ) } {
      puts $CHECK_OUTPUT "qconf -mu failed successfully"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now modify fast with wrong value
   puts $CHECK_OUTPUT "Modify userlist $userlist wrong fast ...\n"
   set result3 [mod_userlist $userlist current_ul 1 $host $CHECK_USER 0]

   if { ( $result3 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Mu failed successfully"
   } else {
      # See IZ 1983 on why this does not fail as expected
      puts $CHECK_OUTPUT "result is $result3"
   }

   set_error 0 "ok"
}

#****** qconf/qconf_modify_sched_conf() ******
#
#  NAME
#     qconf_modify_sched_conf - Modify scheduler config
#
#  SYNOPSIS
#     qconf_modify_sched_conf { } - Call mod_schedd_config
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_sched_conf {} {
   global ts_config env 
   global CHECK_OUTPUT CHECK_USER

   set host [lindex $ts_config(execd_nodes) 0]

   # Next modify fast
   set mysched_config(maxujobs) "10"

   puts $CHECK_OUTPUT "Modify schedd fast ...\n"
   set result1 [mod_schedd_config mysched_config ]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -Msconf succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Next modify slow
   set mysched_config(maxujobs) "5"
   puts $CHECK_OUTPUT "Modify schedd slow ...\n"
   set result2 [mod_schedd_config mysched_config 0]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -msconf succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Next modify slow with wrong values
   set mysched_config(maxujobs) "-1"
   puts $CHECK_OUTPUT "Modify schedd slow ...\n"
   set result3 [mod_schedd_config mysched_config 0 $host $CHECK_USER 0]

   if { ( $result3 == -2 ) } {
      puts $CHECK_OUTPUT "qconf -msconf failed successfully"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }

   # Next modify fast with wrong values
   puts $CHECK_OUTPUT "Modify schedd fast ...\n"
   set result4 [mod_schedd_config mysched_config 1 $host $CHECK_USER 0]

   if { ( $result4 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -Msconf failed successfully"
   } else {
      # See IZ 1975 on why this does not fail as expected
      puts $CHECK_OUTPUT "result is $result4"
   }

   set_error 0 "ok"
}

#****** qconf/qconf_issue_2023() ******
#
#  NAME
#     qconf_issue_2023 - Test for Issue 2023
#
#  SYNOPSIS
#     qconf_issue_2023 { } - 
#
#  FUNCTION
#     Check qconf issue 2023 
#
#*******************************
proc qconf_issue_2023 {} {
   global ts_config env qconf_userlist
   global CHECK_OUTPUT CHECK_USER

   set host [lindex $ts_config(execd_nodes) 0]
  
   set userlist "qconf_userlist"
   set attribute "entries"
   set value "$CHECK_USER"

   set current_ul(name) "$userlist"
   set current_ul($attribute) "$value "

   set result1 [mod_userlist $userlist current_ul ]
   if { ( $result1 != 0 ) } {
      add_proc_error "qconf_issue_2023" -1 "rejects configuration, when attribute value ends with a space character"
      puts $CHECK_OUTPUT "result is $result1"
   }

   set_error 0 "ok"
}

#****** check/qconf_create_modify_sharetree() **********************************
#  NAME
#     qconf_create_modify_sharetree() -- test qconf -Mstree
#
#  SYNOPSIS
#     qconf_create_modify_sharetree { } 
#
#  FUNCTION
#     Tests qconf -Mstree option.
#     Positive tests adding a new sharetree and modifying a sharetree.
#
#     Negative tests as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_create_modify_sharetree {} {
   global ts_config CHECK_OUTPUT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete an already existing sharetree
   del_sharetree

   # create a sharetree
   stree_buffer_init stree
   stree_buffer_add_node stree "/default" 10
   stree_buffer_add_node stree "/mytestproject" 20
   stree_buffer_add_node stree "/mytestproject/default" 30
   stree_buffer_commit stree

   # modify the sharetree
   stree_buffer_mod_node stree "/default" 20
   stree_buffer_del_node stree "/mytestproject"
   stree_buffer_commit stree

   # read in the sharetree - it may only contain the / and the /default nodes
   # with correct number of shares
   stree_buffer_read stree2
   if {[llength $stree2(index)] != 2 || 
       [lindex $stree2(index) 0] != "/" || 
       [lindex $stree2(index) 1] != "/default"} {
      add_proc_error "qconf_create_modify_sharetree" -1 "sharetree should only contain the nodes / and /default, but contains\n$stree2(index)"
   }

   # delete the sharetree
   del_sharetree

   # try to create/modify a sharetree with insufficient permissions
   # - as non admin user
   # - from non admin host
   set ret [stree_buffer_commit stree "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210} {
      add_proc_error "qconf_create_modify_sharetree" -1 "qconf -Mstree should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_unused_host]
   set ret [stree_buffer_commit stree $non_cluster_host "" 0]
   if {$ret != -201} {
      add_proc_error "qconf_create_modify_sharetree" -1 "qconf -Mstree should have failed on host $non_cluster_host"
   }

   # delete a sharetree created due to errors in the permission check
   del_sharetree

   set_error 0 "ok"
}

#****** check/qconf_del_sharetree() ********************************************
#  NAME
#     qconf_del_sharetree() -- test qconf -dstree
#
#  SYNOPSIS
#     qconf_del_sharetree { } 
#
#  FUNCTION
#     Tests qconf -dstree.
#     Positive test with and without sharetree.
#     
#     Negative tests as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_del_sharetree {} {
   global ts_config CHECK_OUTPUT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete an already existing sharetree
   del_sharetree

   # build a sharetree and delete it - must give error code 0
   stree_buffer_init stree
   stree_buffer_add_node stree "/default" 10
   stree_buffer_add_node stree "/mytestproject" 20
   stree_buffer_add_node stree "/mytestproject/default" 30
   stree_buffer_commit stree

   set ret [del_sharetree]
   if {$ret != 0} {
      add_proc_error "qconf_del_sharetree" -1 "qconf -dstree should have reported success"
   }

   # test qconf action when there is no sharetree to delete
   set ret [del_sharetree]
   if {$ret != 1} {
      add_proc_error "qconf_del_sharetree" -1 "qconf -dstree should have reported \"No sharetree\""
   }

   # try to delete a sharetree with insufficient permissions
   # - as non admin user
   # - from non admin host
   stree_buffer_commit stree
   set ret [del_sharetree "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210} {
      add_proc_error "qconf_create_modify_sharetree" -1 "qconf -Mstree should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_unused_host]
   set ret [del_sharetree $non_cluster_host "" 0]
   if {$ret != -201} {
      add_proc_error "qconf_create_modify_sharetree" -1 "qconf -Mstree should have failed on host $non_cluster_host"
   }

   # delete the sharetree
   del_sharetree

   set_error 0 "ok"
}

#****** check/qconf_add_project() **********************************************
#  NAME
#     qconf_add_project() -- test qconf -aprj / -Aprj
#
#  SYNOPSIS
#     qconf_add_project { } 
#
#  FUNCTION
#     Test adding projects (qconf -aprj and qconf -Aprj).
#     Positive tests.
#
#     Negative tests creating duplicates and project name being a keyword,
#     and as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_add_project {} {
   global ts_config CHECK_OUTPUT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # test adding projects
   set project(name) "qconf_add_prj"

   add_prj project 0 ;# slow add
   del_prj "qconf_add_prj"

   add_prj project 1 ;# fast add

   # test adding duplicates (must fail)
   # TODO: it's difficult to handle all the default error conditions
   # in handle_vi_edit (e.g. host and user permissions).
   # until this is fixed, we cannot do negative tests with qconf calling the editor.
   #set ret [add_prj project 0 "" "" 0] ;# slow add duplicate
   #if {$ret != -2} {
   #   add_proc_error "qconf_add_project" -1 "qconf -aprj should have failed for duplicate"
   #}
   set ret [add_prj project 1 "" "" 0] ;# fast add duplicate
   if {$ret != -2} {
      add_proc_error "qconf_add_project" -1 "qconf -Aprj should have failed for duplicate"
   }

   del_prj "qconf_add_prj"

   # test other errors
   set project(name) "default"
   #set ret [add_prj project 0 "" "" 0] ;# slow add incorrect prj (name is keyword)
   #if {$ret >= 0} {
   #   add_proc_error "qconf_add_project" -1 "qconf -aprj should have failed for a project named \"default\""
   #}
   set ret [add_prj project 1 "" "" 0] ;# fast add incorrect prj (name is keyword)
   if {$ret >= 0} {
      add_proc_error "qconf_add_project" -1 "qconf -Aprj should have failed for a project named \"default\""
   }

   # try to add a project with insufficient permissions
   # - as non admin user
   # - from non admin host
   set project(name) "qconf_add_prj"
   #set ret [add_prj project 0 "" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" 0]
   #if {$ret != -210} {
   #   add_proc_error "qconf_add_project" -1 "qconf -aprj should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   #}
   set ret [add_prj project 1 "" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" 0]
   if {$ret != -210} {
      add_proc_error "qconf_add_project" -1 "qconf -Aprj should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }

   set non_cluster_host [host_conf_get_unused_host]
   #set ret [add_prj project 0 $non_cluster_host "" 0]
   #if {$ret != -201} {
   #   add_proc_error "qconf_add_project" -1 "qconf -aprj should have failed on host $non_cluster_host"
   #}
   set ret [add_prj project 1 $non_cluster_host "" 0]
   if {$ret != -201} {
      add_proc_error "qconf_add_project" -1 "qconf -Aprj should have failed on host $non_cluster_host"
   }

   set_error 0 "ok"
}

