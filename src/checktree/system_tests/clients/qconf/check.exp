#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name 
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env ts_config
global check_category

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qconf_init_level"

# define test's name and run level descriptions
set check_name            "qconf"
set check_category        "COMPATIBILITY SYSTEM VERIFIED JGDI"
set check_highest_level    0
set check_description(0)  "test all qconf options (test not complete)"

# define test's dependencies
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)


global qconf_original_host_groups qconf_original_usersets
# setup and cleanup functions
set check_setup_function "qconf_setup"
set check_cleanup_function "qconf_cleanup"

# define test's procedure order
set check_functions     ""
lappend check_functions "qconf_addqueues"             ;# functions to call (in order)
lappend check_functions "qconf_removequeues"
lappend check_functions "qconf_auser"
lappend check_functions "qconf_duser"
lappend check_functions "qconf_Auser"
lappend check_functions "qconf_muser"
lappend check_functions "qconf_Muser"
lappend check_functions "qconf_segfault"
lappend check_functions "qconf_se"
lappend check_functions "qconf_sel"

# TODO: the aattr/rattr checks are broken or not fully 
# ported to 6.0
#lappend check_functions "qconf_aattr_check"
#lappend check_functions "qconf_rattr_check"
#lappend check_functions "qconf_Aattr_check"
#lappend check_functions "qconf_Rattr_check"

# Show options DONE
lappend check_functions "qconf_scal_check"   	;# List calendars
lappend check_functions "qconf_scall_check"	;# List all calalendars
lappend check_functions "qconf_sconfl_check"	;# List all hosts with configurations
lappend check_functions "qconf_sds_check"	;# List detached settings in the cluster  config
append_check_and_exclude_in_jgdi "qconf_secl_check" "No event clients that JGDI returns is an unknown error"	;# List event client list
lappend check_functions "qconf_sep_check"	;# List processors
lappend check_functions "qconf_sm_check"	;# List  managers
lappend check_functions "qconf_so_check"	;# List operators 
lappend check_functions "qconf_ss_check"	;# List submit hosts
lappend check_functions "qconf_sss_check"	;# Show scheduler status
lappend check_functions "qconf_sul_check"	;# Show user list
lappend check_functions "qconf_sprjl_check"	;# Show project list

# New options, non-show DONE
append_check_and_exclude_in_jgdi "qconf_add_delete_manager" "Options *q do not hadle queue instances"	;# Add and delete manager users 
append_check_and_exclude_in_jgdi "qconf_add_show_mod_del_queue" "JGDI Shell can't handle queue instances (bug)" 	;# Add, show, modify and delete queue "qconf_queue.q"
append_check_and_exclude_in_jgdi "qconf_add_show_delete_stnode" "Options *stnode not implemented" ;# Add, show and delete share tree nodes
append_check_and_exclude_in_jgdi "qconf_create_modify_sharetree" "Options *stree not implemented" ;# create and modify a sharetree (qconf -Mstree)
append_check_and_exclude_in_jgdi "qconf_del_sharetree" "Options *stree not implemented"           ;# delete the whole sharetree (qconf -dstree)
append_check_and_exclude_in_jgdi "qconf_event_client" "-kec fails for all"	;# Create, show and delete event clients
lappend check_functions "qconf_add_delete_modify_calendar"	;# Add, delete and modify calendar
append_check_and_exclude_in_jgdi "qconf_add_delete_modify_replace_attr" "Options -Mattr/-sobjl not implemented" ;# Add, delete and modify attributes
lappend check_functions "qconf_modify_checkpoint" ;# Create, modify and delete checkpoint 
lappend check_functions "qconf_add_project"        ;# qconf -aprj / qconf -Aprj
lappend check_functions "qconf_modify_exechost"	;# Modify exec host
lappend check_functions "qconf_modify_project";# Modify project
lappend check_functions "qconf_modify_userlist";# Modify user list
lappend check_functions "qconf_modify_sched_conf";# Modify scheduler config
lappend check_functions "qconf_issue_2023"
append_check_and_exclude_in_jgdi "qconf_brief_exercise" "Some issues like with -au";# check the output messages

global queue_names

global submitjob_jobid

proc qconf_init_level {} {
   global ts_config
   global CHECK_ACT_LEVEL check_name CHECK_JGDI_ENABLED

   if {[llength $ts_config(execd_nodes)] < 2} {
      ts_log_config "need at least 2 execd hosts for this check"
      return -1
   }
   #Check we are running at least 6.2 for JGDI
   if {$CHECK_JGDI_ENABLED} {
      if {$ts_config(gridengine_version) < 62} {
         ts_log_config "jgdi shell supported from sge 6.2 version"
         return -1
      }
   }

   #Always allow run level 0
   if { $CHECK_ACT_LEVEL == 0 } {
      return 0
   }

   return -1  ;# no other level else
}

proc qconf_setup {} {
   global ts_config CHECK_USER 
   global qconf_original_host_groups qconf_original_usersets qconf_orig_queues qconf_project qconf_sched_config qconf_userlist 
   global backup_allhosts
   global queue_names CHECK_JGDI_ENABLED

   ts_log_fine "setup ..."

   set queue_names ""
   set MAX 1000
   if {$CHECK_JGDI_ENABLED} {
      set MAX 3
   }
   for {set i 0} {$i < $MAX}  {incr i 1} {
      lappend queue_names "q.$i"
   }
 
   # host group setup for GE >= 6.0
   if {$ts_config(gridengine_version) >= 60} {
      # we'll create additional host groups later on - remember the list of hostgroups
      # for cleanup
      set output [start_sge_bin qconf -shgrpl]
      set output [string trim $output]
      set qconf_original_host_groups {}
      foreach hg $output {
         ts_log_fine "saving known hostgroup \"$hg\" for cleanup procedure"
         lappend qconf_original_host_groups $hg
      }

      # create a test hostgroup
      set qconf_hgrp_setup(group_name) "@qconf_test"
      set qconf_hgrp_setup(hostlist)   "$ts_config(execd_nodes)"
      add_hostgroup "@qconf_test" qconf_hgrp_setup
   }

   get_userset_list output
   set output [string trim $output]
   set qconf_original_usersets {}
   foreach user $output {
      lappend qconf_original_usersets $user
      ts_log_fine "saving known userset \"$output\" for cleanup procedure"
   }

   # Save initial queue list; make it a global var, to be used in cleanup
   get_queue_list qconf_orig_queues

   set qconf_project "qconf_project"
   ts_log_fine "Create project $qconf_project ...\n"
   set result [add_project $qconf_project]

   ts_log_fine "Create userlist qconf_userlist ...\n"
   add_access_list $CHECK_USER qconf_userlist

   ts_log_fine "Save existing scheduler config ...\n"
   get_schedd_config qconf_sched_config
}


proc qconf_cleanup {} {
   global ts_config
   global qconf_original_host_groups qconf_original_usersets qconf_orig_queues qconf_sched_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER qconf_prj_setup

   ts_log_fine "cleanup ..."

   # in GE >= 6.0: cleanup hostgroups
   if {$ts_config(gridengine_version) >= 60} {
      set output [start_sge_bin qconf -shgrpl]
      set output [string trim $output]
      foreach hg $output {
         ts_log_fine "testing hostgroup \"$hg\" ..."
         if {[lsearch -exact $qconf_original_host_groups $hg] < 0} {
            ts_log_fine "deleting unexpected hostgroup \"$hg\" ..."
            del_hostgroup $hg
         }
      }
   }

   ts_log_fine "Delete userlist qconf_userlist ...\n"
   set result [start_sge_bin "qconf" "-dul qconf_userlist" "" ""]

   set output [start_sge_bin qconf -sul]
   set output [string trim $output]
   foreach userg $output {
      ts_log_fine "testing userset \"$userg\" ..."
      if { [lsearch -exact $qconf_original_usersets $userg] < 0 } {
         ts_log_fine "deleting unexpected usergroup \"$userg\" ..."
         set res [start_sge_bin qconf "-dul $userg"]
         ts_log_fine $res
      }
   }

   # The original stuff is here
   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # Delete stuff I created
   del_manager "qconf_user"
   
   # Get list of new queues. Those created during the
   # tests will be deleted here.

   get_queue_list qconf_new_queues

   ts_log_fine "Deleting queues created during qconf... \n"
   foreach elem  $qconf_orig_queues {
      foreach new_elem $qconf_new_queues {
         if { $elem == $new_elem } {
	    continue
         } else {
	         del_queue $new_elem ""
         }

      }
   }

   # Re-set it back
   set my_project "qconf_project"
   ts_log_fine "Delete project $my_project ...\n"
   set result [del_project $my_project]

   # Set sched back to what it was....
   ts_log_fine "Set scheduler to original config ...\n"
   set result [mod_schedd_config qconf_sched_config]

   # Re-set resource quota sets
   if {$ts_config(gridengine_version) >= 61} {
      if {[get_rqs_list rqs_names "" "" 0] == 0} {
         foreach elem $rqs_names {
            ts_log_fine "Removing resource quota sets $elem ...\n"
            del_rqs $elem
         }
      }
   }
}

proc qconf_auser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -auser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if {[string first "mytestproject" $output] < 0} {
         ts_log_severe "error showing user $test_user"
      }
   }
}

proc qconf_duser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -duser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      del_user "qconf_test_user"

      set output [start_sge_bin "qconf" "-suser qconf_test_user"]
      if {[string first "mytestproject" $output] >= 0} {
         ts_log_severe "error user qconf_test_user should have been deleted"
      }
   }
}


proc qconf_Auser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -Auser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user 1
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if {[string first "mytestproject" $output] < 0} {
         ts_log_severe "error showing user $test_user"
      }
      del_user "$test_user"
   }
}


proc qconf_muser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -muser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if { [string first "mytestproject" $output] < 0  } {
         ts_log_severe "error showing user $test_user"
      }
      # now modify user
      set new_conf(default_project) "NONE"
      mod_user $test_user new_conf 
      set output [start_sge_bin "qconf" "-suser $test_user"]
      ts_log_fine $output
      if {[string first "mytestproject" $output] >= 0} {
         ts_log_severe "error modify user $test_user"
      }

      # now delete user
      del_user $test_user
   }
}

proc qconf_Muser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -Muser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if { [string first "mytestproject" $output] < 0  } {
         ts_log_severe "error showing user $test_user"
      }
      # now modifiy user
      set new_conf(default_project) "NONE"
      mod_user "$test_user" new_conf 1
      set output [start_sge_bin "qconf" "-suser $test_user"]
      ts_log_fine $output
      if {[string first "mytestproject" $output] >= 0} {
         ts_log_severe "error modify user $test_user"
      }

      # now delete user
      del_user "$test_user"
   }
}



# run qconf -aq
#                                                             max. column:     |
#****** qconf/qconf_addqueues() ******
# 
#  NAME
#     qconf_addqueues -- ??? 
#
#  SYNOPSIS
#     qconf_addqueues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_addqueues {} {
   global ts_config
   global queue_names test_host

   set q_param(load_thresholds)       "np_load_avg=7.00"

   set test_host [host_conf_get_suited_hosts]

   set count 0
   foreach queue $queue_names {
      if { $count > 50 } {
         ts_log_fine "adding queue \"$queue\" with vi"
         add_queue $queue $test_host q_param 0
         set count 0
      } else {
         ts_log_fine "adding queue \"$queue\" with file"
         add_queue $queue $test_host q_param
      }
      incr count 1
   }
}



#                                                             max. column:     |
#****** qconf/qconf_removequeues() ******
# 
#  NAME
#     qconf_removequeues -- ??? 
#
#  SYNOPSIS
#     qconf_removequeues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_removequeues {} {
   global ts_config
   global queue_names test_host

   foreach queue $queue_names {
     ts_log_fine "deleting queue \"$queue\""
     del_queue $queue $test_host 0 1
   }
}

#                                                             max. column:     |
#****** qconf/check_exec_conf() ******
# 
#  NAME
#     check_exec_conf -- ??? 
#
#  SYNOPSIS
#     check_exec_conf { host_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host_list   - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_exec_conf { host_list attr_name check_value } {

  foreach host $host_list {
     get_exechost host_config $host
     set host_attr_value $host_config($attr_name)

     ts_log_fine "host \"$host\": $attr_name is set to \"$host_attr_value\"" 

     if { [ string compare $check_value $host_attr_value ] != 0 } {
        ts_log_fine "\"$check_value\" is not \"$host_attr_value\""
        ts_log_severe "\"$check_value\" is not \"$host_attr_value\"" 
     }
  } 
}

# check all queues in queue_list for attr_name and compare it with check_value
#                                                             max. column:     |
#****** qconf/check_queue_conf() ******
# 
#  NAME
#     check_queue_conf -- ??? 
#
#  SYNOPSIS
#     check_queue_conf { queue_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     queue_list  - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_queue_conf { queue_list attr_name check_value } {
  foreach queue $queue_list {
     get_queue $queue q_config
     set q_attr_value $q_config($attr_name)

     ts_log_fine "queue \"$queue\": $attr_name is set to \"$q_attr_value\"" 

     if { [ string compare $check_value $q_attr_value ] != 0 } {
        ts_log_fine "\"$check_value\" is not \"$q_attr_value\""
        ts_log_severe "\"$check_value\" is not \"$q_attr_value\"" 
     }
  } 
}



# obj_nm is "queue" or "exechost" 
# attr_nm is "object"
# val is value
# obj_id_lst is a list with names of the queues or hostnames to be modified
#                                                             max. column:     |
#****** qconf/qconf_aattr_check() ******
# 
#  NAME
#     qconf_aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_aattr_check {} {
   global ts_config
   global queue_names

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   ts_log_fine "adding qtype PARALLEL to queues $queue_names"
   set output [start_sge_bin "qconf" "-aattr queue qtype PARALLEL $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"

    
   # check queue add parameter list
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
   ts_log_fine "adding qtype PARALLEL to queues $queue_names"
   set output [start_sge_bin "qconf" "-aattr queue load_thresholds \"mem_free=1M\" $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   # check global host add user_lists list
   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   ts_log_fine "adding deadlineusers to user_lists of all execd hosts"
   set output [start_sge_bin "qconf" "-aattr exechost user_lists \"deadlineusers\" $ts_config(execd_nodes)"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers"

   ts_log_fine "adding defaultdepartment to user_lists of all execd hosts"
   set output [start_sge_bin "qconf" "-aattr exechost user_lists \"defaultdepartment\" $ts_config(execd_nodes)"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers defaultdepartment"
}

#                                                             max. column:     |
#****** qconf/qconf_Aattr_check() ******
# 
#  NAME
#     qconf_Aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Aattr_check {} {
   global ts_config queue_names 
   global CHECK_ACTUAL_TEST_PATH

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"

   ts_log_fine "adding qtype PARALLEL and load_thresholds mem_free=1M to queues $queue_names"
   set output [start_sge_bin "qconf" "-Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue_wrong_syntax  $queue_names"]
   if {$prg_exit_state != 1} {
      ts_log_severe "exit state is not 1 (used wrong file syntax format)"
   }
   set output [start_sge_bin "qconf" "-Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"
}

#                                                             max. column:     |
#****** qconf/qconf_rattr_check() ******
# 
#  NAME
#     qconf_rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_rattr_check {} {
   global ts_config
   global queue_names

   ts_log_fine "replaceing exechost user_lists with NONE"
   set output [start_sge_bin "qconf" "-rattr exechost user_lists \"NONE\" $ts_config(execd_nodes)"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output

   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   ts_log_fine "replaceing queues qtype with BATCH INTERACTIVE"
   set output [start_sge_bin "qconf" "-rattr queue qtype \"BATCH INTERACTIVE\" $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"

   ts_log_fine "replaceing queues load_thresholds with np_load_avg=7.00"
   set output [start_sge_bin "qconf" "-rattr queue load_thresholds \"np_load_avg=7.00\" $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Rattr_check {} {
}

proc qconf_segfault {} {
   global ts_config CHECK_USER

   set output [start_sge_bin "qconf" "-as \"\""]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      ts_log_fine $output
      ts_log_severe "qconf -as \"\" failed - see Issue: 1732"
   }
   set output [start_sge_bin "qconf" "-ah \"\""]

   if { [string match "*egmentation ?ault*" $output] == 1 } {
      ts_log_fine $output
      ts_log_severe "qconf -ah \"\" failed - see Issue: 1732"
   }

   set output [start_sge_bin "qconf" "-ae localhost"]

   if { [string match "*egmentation ?ault*" $output] == 1 } {
      ts_log_fine $output
      ts_log_severe "qconf -ah \"\" failed - see Issue: 1884"
   } else {
      set output [start_sge_bin "qconf" "-de localhost"]
   }
}

proc qconf_se {} {
   global ts_config
  
   # test hosts
   set cluster_host [host_conf_get_suited_hosts]
   set non_cluster_host [host_conf_get_unused_host]

   # fields delivered by qconf -se
   if {$ts_config(gridengine_version) == 53} {
      set qconf_se_fields "hostname load_scaling complex_list complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling resource_capability_factor"
   } else {
      set qconf_se_fields "hostname load_scaling complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling report_variables"
   }

   # positive check
   # check qconf -se <an exec host>, check completeness of result
   if {[get_exechost exec_host $cluster_host] == 0} {
      foreach elem $qconf_se_fields {
         if {![info exists exec_host($elem)]} {
            ts_log_severe "$elem is missing in result of qconf -se"
         }
      }
   }

   # negative checks
   # check qconf -se <a non exec host>
   if {$non_cluster_host != ""} {
      if {[get_exechost exec_host $non_cluster_host "" "" 0] == 0} {
         ts_log_severe "qconf -se $non_cluster_host (non cluster host) should have failed"
      }
   }

   # check qconf -se from a non admin/submit host
   if {$non_cluster_host != ""} {
      set result [get_exechost exec_host $cluster_host $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $result "any"]} {
         ts_log_info "qconf -se called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889 fixed for release >= 6.1"
      }
   }
}

proc qconf_sel {} {
   global ts_config
  
   # test hosts
   set non_cluster_host [host_conf_get_unused_host]

   # positive check
   # qconf -sel, has to match testsuite's execd_nodes list
   if {[get_exechost_list exechost_list] == 0} {
      if {[host_list_compare $exechost_list $ts_config(execd_nodes) 1 1] != 0} {
         ts_log_severe "exec host list delivered by qconf does not match testsuite exec host list:\nexec host list: $exechost_list\ntestsuite execd host list: $ts_config(execd_nodes)"
      }
   }

   # negative check
   # call qconf -sel on a non admin/submit host
   if {$non_cluster_host != ""} {
      set result [get_exechost_list exechost_list $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $result "any"]} {
         ts_log_info "qconf -sel called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889 fixed for release >= 6.1"
      }
   }
}


#                                                             max. column:     |
#****** qconf/qconf_scal_check() ******
#
#  NAME
#     qconf_scal_check - Check known calendar "always_suspend"
#
#  SYNOPSIS
#     qconf_scal_check { } - Call get_calendar with calendar "always_suspend"
#                            Then call get_calendar with a wrong calendar name,
#                            like "wrong_calendar". 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calendar()
# sge_calendar/get_calender_error()
#
#*******************************
proc qconf_scal_check {} {
   global ts_config env
   global CHECK_USER


   # First do a positive test, give a valid calendar name, "always_suspend"
   ts_log_fine "Positive test for qconf -scal always_suspend...\n"
   set result0 [get_calendar "always_suspend" ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -scal always_suspend succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Next do a negative test, give a invalid calendar name, "wrong_calendar"
   ts_log_fine "Negative test for qconf -scal wrong_calendar...\n"
   set result1 [get_calendar "wrong_calendar" result $ts_config(master_host) $CHECK_USER 0 ]

   if { ( $result1 == -1 ) } {
      ts_log_fine "qconf -scal wrong_calendar succeded"
   } else {
      ts_log_fine "result is $result1"

   }
}

#                                                             max. column:     |
#****** qconf/qconf_scall_check() ******
#
#  NAME
#     qconf_scall_check - Check all known calendars 
#
#  SYNOPSIS
#     qconf_scall_check { } - Call get_calendar_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calendar_list()
#*******************************
proc qconf_scall_check {} {

   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -scall ...\n"
   set result0 [get_calendar_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -scall succeded"
   } else {
      ts_log_fine "result is $result0"

   }
}

#                                                             max. column:     |
#****** qconf/qconf_sconfl_check() ******
#
#  NAME
#     qconf_sconfl_check - Display a list of hosts  for  which  configurations
#                          are  available.  
#
#  SYNOPSIS
#     qconf_sconfl_check { } - Call get_config_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_config_list()
#*******************************

proc qconf_sconfl_check {} {

   global ts_config env
   global CHECK_USER

   # Do a positive test
    ts_log_fine "Positive test for qconf -sconfl ...\n"

   set result0 [get_queue_config_list ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sconfl succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_sds_check() ******
#
#  NAME
#     qconf_sds_check - Display detached settings in the cluster  config
#
#  SYNOPSIS
#     qconf_sds_check { } - Call get_detached_settings
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_detached_settings()
#*******************************

proc qconf_sds_check {} {

   global ts_config env queue_names
   global CHECK_USER 
  
   # First do a positive test
   ts_log_fine "1) Doing positive test!"

   set result0 [get_detached_settings]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sds succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   #Now check if the error code is set incase of error
   #for forcing the error we set the cq conf as:
   #qconf -sq tq | head -3
   # qname                 tq
   # hostlist              NONE
   # seq_no                0,[@allhosts=1]
   ts_log_fine "2) Doing exit code test in case of error!\n"

   set nohost "NONE" 

   # Just take the first queue name for testing!
   set queue [lindex $queue_names 0]
   set q_param(seq_no)	"0,\[@qconf_test=1\]"

   ts_log_fine "adding queue \"$queue\" with vi"
   add_queue $queue $nohost q_param 0

   #We know we are getting an error
   set result0 [get_detached_settings output "" "" 0]

   #Need to check if the error code is set to non-zero
   if { ( $result0 == 0 ) } {
      ts_log_severe "qconf -sds wrong exit code on error"
   } else {
      ts_log_fine "qconf -sds exit code on error - succeded\n$result0"
   }

   #clean up the queue
   del_queue $queue $nohost 0 1

}

#                                                      max. column:     |
#****** qconf/qconf_secl_check() ******
#
#  NAME
#     qconf_secl_check - Display the event client list
#
#  SYNOPSIS
#     qconf_secl_check { } - Call get_event_client_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_event_client/get_event_client_list()
#*******************************

proc qconf_secl_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -secl ...\n"

   set result0 [get_event_client_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -secl succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                               max. column:     | #
#****** qconf/qconf_sep_check() ******  
#  NAME
#     qconf_sep_check - Display the processor list
#
#  SYNOPSIS
#     qconf_sep_check { } - Call get_processor_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_sep_check {} {
   global ts_config env
   global CHECK_USER

   # DO A Positive test
   ts_log_fine "Positive test for qconf -sep ...\n"
   set result0 [get_processor_list]

  if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sep succeded\n"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sm_check() ******
#
#  NAME
#     qconf_sm_check - Display list of managers
#
#  SYNOPSIS
#     qconf_sm_check { } - Call get_manager_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_manager_list()
#*******************************
proc qconf_sm_check {} {
   global ts_config env
   global CHECK_USER

   # First do a positive test
   ts_log_fine "Positive test for qconf -sm ...\n"

   set result0 [get_manager_list]

  if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sm succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_so_check() ******
#
#  NAME
#     qconf_so_check - Display list of operators
#
#  SYNOPSIS
#     qconf_so_check { } - Call get_operator_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_operator_list()
#*******************************
proc qconf_so_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -so ...\n"
   set result0 [get_operator_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -so succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_ss_check() ******
#
#  NAME
#     qconf_ss_check - Display list of submit hosts
#
#  SYNOPSIS
#     qconf_ss_check { } - Call get_submithost_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_submithost_list()
#*******************************
proc qconf_ss_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -ss ...\n"
   set result0 [get_submithost_list ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -ss succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sss_check() ******
#
#  NAME
#     qconf_sss_check - Display scheduler status
#
#  SYNOPSIS
#     qconf_sss_check { } - Call "qconf -sss "
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_sss_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive tests
   ts_log_fine "Positive test for qconf -sss ...\n"
   set result0 [get_scheduler_status]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sss succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sul_check() ******
#
#  NAME
#     qconf_sul_check - Display user list
#
#  SYNOPSIS
#     qconf_sul_check { } - Call get_userset_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/get_userset_list()
#*******************************
proc qconf_sul_check {} {
   global ts_config env
   global CHECK_USER

   # Do q positive test
   ts_log_fine "Positive test for qconf -sul ...\n"
   set result0 [get_userset_list userset_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sul succeded"
   } else {
      ts_log_severe "qconf -sul failed"
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sprjl_check() ******
#
#  NAME
#     qconf_sprjl_check - Display project list
#
#  SYNOPSIS
#     qconf_sprjl_check { } - Call "qconf -sprjl "
#                            Check that the output contains   "mytestproject"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_sprjl_check {} {
   global ts_config env
   global CHECK_USER

    # Do a positive test
    ts_log_fine "Positive test for qconf -sprjl ...\n"
    set result0 [get_project_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sprjl succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_add_delete_manager() ******
#
#  NAME
#     qconf_add_delete_manager - Add and delete manager user
#
#  SYNOPSIS
#     qconf_add_delete_manager { } - Call add_manager, get_manager_list,
#	                             del_manager
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/add_manager()
# sge_users/get_manager_list()
# sge_users/del_manager()
#*******************************
proc qconf_add_delete_manager {} {
   global ts_config env
   global CHECK_USER

   # First add manager "qconf_user"
   ts_log_fine "Positive test for qconf -am ...\n"
   set result0 [add_manager "qconf_user"]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -am qconf_user succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Now show manager list, check that  "qconf_user" is there
   ts_log_fine "Positive test for qconf -sm ...\n"
   set result22 [get_manager_list ]

   if { ( $result22 == 0 ) } {
      ts_log_fine "qconf -sm succeded"
   } else {
      ts_log_fine "result is $result22"
   }

   # Now delete manager "qconf_user"
   ts_log_fine "Positive test for qconf -dm ...\n"
   set result2 [del_manager "qconf_user"]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -dm qconf_user succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now delete manager "qconf_user" again
   ts_log_fine "Negative test for qconf -dm ...\n"
   set result3 [del_manager "qconf_user"] 

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -dm qconf_user again succeded"
   } else {
      ts_log_fine "result is $result3"
   }
}


#                                                             max. column:     |
#****** qconf/qconf_add_show_mod_del_queue() ******
#
#  NAME
#     qconf_add_show_mod_del_queue - Add, show modify and delete queue "qconf_queue.q"
#
#  SYNOPSIS
#     qconf_add_show_mod_del_queue { } - Call add_queue qconf_queue.q $ts_config(master_host) new_queue
#                                then   "qconf -sq qconf_queue.q" to show new queue
#                                Use "qconf -M(m)q queue qname qconf_queue.q"
#                                Also use "qconf -purge queue qname qconf_queue.q"
#                                Then clean up with "qconf -dq qconf_queue.q"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_queue/add_queue()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_mod_del_queue {} {
   global ts_config env 
   global CHECK_USER 

   # First add queue "qconf_queue.q". Set the new name to "qconf_queue.q, 
   # host to $host

   set host [host_conf_get_suited_hosts]
   ts_log_fine "Adding queue qconf_queue.q ..."
   add_queue qconf_queue.q $host new_queue 

   #Now test for qconf -sq queue@host
   #qconf -sq q@host | grep complex_values should show NONE
   set qconf_qinst "qconf_queue.q@$host"
   ts_log_fine "Testing qconf -sq `$qconf_qinst'..."
   set result [start_sge_bin "qconf" "-sq $qconf_qinst"]
   if {$prg_exit_state != 0} {
      ts_log_severe "qconf -sq $qconf_qinst failed:\n$result"
      return
   }

   # split each line as listelement
   set op_rows [split $result "\n"]
 
   #test if the complex_values attrib has any value!
   foreach elem $op_rows {
       if {[string first "complex_values" $elem] >=0} {
          ts_log_fine "qconf -sq retured $elem"
 			if {[string last "NONE" $elem] >=0} {
 				ts_log_fine "qconf -sq queue@host successfull"
 			} else {
            ts_log_severe "qconf -sq queue@host should have output NONE for complex_values, but output was:\n$result"
 			}		
 			break
 		}
   }

   # Now do positive test on qconf -sql
   ts_log_fine "Positive test of qconf -sql ..."
   set result [get_queue_list queue_list]

   if {$result == 0} {
      ts_log_fine "qconf -sql succeded"
   } else {
      ts_log_fine "qconf -sql succeded" ;# error raised in get_queue_list
   }

   # Now modify queue qconf_queue.q
   set new_queue(seq_no)  "2"
   ts_log_fine "Modifying information for qconf_queue.q ..."
   set result [mod_queue "qconf_queue.q" "" new_queue]

   if {$result == 0} {
      ts_log_fine "qconf -Mq succeded"
   } else {
      ts_log_fine "result is $result" ;# error raised in mod_queue
   }
 
   # Now modify queue qconf_queue.q slow
   set new_queue(seq_no)  "1"
   ts_log_fine "Modifying information for qconf_queue.q slow..."
   set result [mod_queue "qconf_queue.q" "" new_queue 0]

   if {$result == 0} {
      ts_log_fine "qconf -mq succeded"
   } else {
      ts_log_fine "result is $result" ;# error raised in mod_queue
   }

   #  Now try to modify a invalid seq. no
   set new_queue(seq_no) "-1"
   ts_log_fine "Negative test of qconf -Mq qconf_queue.q, seq.  number..."
   set result [mod_queue "qconf_queue.q" "" new_queue 1  $host $CHECK_USER 0]

   if {$result < 0} {
      ts_log_fine "qconf -Mq wrong_project failed successfully"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1982
      ts_log_severe "mod_queue with invalid sequence number should have failed, but exit code (from handle_sge_errors) was $result"
   }
 
   # Now clear queue "qconf_queue.q"
   ts_log_fine "Clearing queue qconf_queue.q ... - "
   set result [clear_queue "qconf_queue.q" cq_output]

   if {$result == 0} {
      ts_log_fine "OK"
   } else {
      ts_log_fine "failed" ;# error raised in clear_queue
   }
   
   # Now try to clear it again!
   ts_log_fine "Clearing queue qconf_queue.q again... - "
   set result [clear_queue "qconf_queue.q" cq_output]

   if {$result == 0} {
      ts_log_fine "OK"
   } else {
      ts_log_fine "failed" ;# error raised in clear_queue
   }

   #  Now try to clear a non-existing queue, "wrong_queue.q"
   ts_log_fine "Negative test of qconf -cq wrong_queue.q ... - "
   set result [clear_queue "wrong_queue.q" cq_output $host $CHECK_USER 0]

   if {$result == -1} {
      ts_log_fine "OK"
   } else {
      if {$ts_config(gridengine_version) >= 61} {
         ts_log_severe "clear_queue with non existing queue name should have failed, but exit code (from handle_sge_errors) was $result"
      }
   }

   # Now delete queue "qconf_queue.q"
   ts_log_fine "Positive test of qconf -dq qconf_queue.q... -"
   set result [del_queue "qconf_queue.q" $host 1 1]

   if {$result == 0} {
      ts_log_fine "OK"
   } else {
      ts_log_fine "failed" ;# error raised in del_queue
   }
}
#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_host() ******
#
#  NAME
#     qconf_add_show_delete_host - Add, show and delete host execd_nodes 1
#
#  SYNOPSIS
#     qconf_add_show_delete_host { } - Call "qconf -dh execd_host "
#	                         Show it with "qconf -sh"
#                                Then add it ack with "qconf -ah execd_host"
#                                Try to add it again
#                                Show it with "qconf -sh"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_host {} {
   global ts_config env CHECK_ACTUAL_TEST_PATH
   global CHECK_USER 

   set hosts [host_conf_get_suited_hosts 2]
   set host       [lindex $hosts 0]
   set other_host [lindex $hosts 1]


   # First delete host $other_host. 
   ts_log_fine "Positive test of qconf -dh $other_host...\n"
   set result1 [del_adminhost $other_host]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -dh $other_host succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Try deleting $other_host again
   ts_log_fine "Negative test of qconf -dh  $other_host...\n"
   set result4 [del_adminhost $other_host $host $CHECK_USER 0]

   if { ( $result4 == -1 ) } {
      ts_log_fine "qconf -dh $other_host again succeded"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now show admin hosts 
   ts_log_fine "Positive test of qconf -sh  $other_host...\n"
   set result3 [get_adminhost_list]

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -sh succeded"
   } else {
      ts_log_fine "result is $result3"
   }

  
 # Now add back $other_host
   ts_log_fine "Positive test of qconf -ah  $other_host...\n"
   set result5 [add_adminhost $other_host]

   if { ( $result5 == 0 ) } {
      ts_log_fine "qconf -ah $other_host succeded"
   } else {
      ts_log_fine "result is $result5"
   }

   # Now try adding it again
   ts_log_fine "Negative test of qconf -ah $other_host ...\n"

   set result6 [add_adminhost $other_host]

   if { ( $result6 == 0 ) } {
      ts_log_fine "qconf -ah $other_host again succeded"
   } else {
      ts_log_fine "result is $result6"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_stnode() ******
#
#  NAME
#     qconf_add_show_delete_stnode - Add, show and delete sharetree
#
#  SYNOPSIS
#     qconf_add_show_delete_stnode { } - Call "qconf -astnode ..."
#                                Show it with "qconf -sstnode qconf_proj"
#                                Then delete it with "qconf -dstnode qconf_proj"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# performance/large_cluster/check.exp/large_cluster_setup_sharetree()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_stnode {} {
   global ts_config env 
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

   set hosts [host_conf_get_suited_hosts 2]
   set host       [lindex $hosts 0]
   set other_host [lindex $hosts 1]

   set project "mytestproject"

   # Submit a dummy job to make sure we have a user list
   # (user will be automatically created)
   submit_job "-o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 1"

   # Add users
   # Some of them might already exist - in this case we call mod_user
   get_user_list current_user_list
   ts_log_fine "Adding  user $CHECK_USER to project $project ...\n"

   foreach user "$CHECK_USER $CHECK_FIRST_FOREIGN_SYSTEM_USER" {
      if {[info exists new_user]} {
         unset new_user
      }
      ts_log_fine "Adding  user $user to project $project ...\n"
      set new_user(default_project) $project
      if {[lsearch -exact $current_user_list $user] < 0} {
         add_user "$user" new_user 1
      } else {
         mod_user "$user" new_user 1
      }
   }

   # Now add policies to the project $project
   ts_log_fine "Adding  30 shares to $CHECK_USER to project $project and 70 shares to $CHECK_FIRST_FOREIGN_SYSTEM_USER...\n"
   set result1 [add_sharetree_node $project $CHECK_USER 30 $CHECK_FIRST_FOREIGN_SYSTEM_USER 70]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -astnode /$project succeded"
   } else {
      ts_log_fine "result is $result1"
   }
  
   # Now do a negative test on -astnode, add users again
   ts_log_fine "Adding  30 shares to $CHECK_USER to project $project and 70 shares to $CHECK_FIRST_FOREIGN_SYSTEM_USER again....n"
   set result2 [add_sharetree_node $project $CHECK_USER 30 $CHECK_FIRST_FOREIGN_SYSTEM_USER 70 $host $CHECK_USER 0]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -astnode /$project again succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now show the sharetree list
   ts_log_fine "Now show sharetree list for $project... \n"
   set result3 [get_sharetree_list $project]

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -sstnode /$project succeded"
   } else {
      ts_log_fine "result is $result3"
   }

   # Modify shares in project $project
   ts_log_fine "Now modify shares for user $CHECK_USER, $CHECK_FIRST_FOREIGN_SYSTEM_USER for  $project... \n"
   set result4 [mod_sharetree_node $project $CHECK_USER 50 $CHECK_FIRST_FOREIGN_SYSTEM_USER 50]

   if { ( $result4 == 0 ) } {
      ts_log_fine "qconf -mstnode /$project succeded"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now show the sharetree list again
   ts_log_fine "Now show sharetree list for $project again... \n"
   set result5 [get_sharetree_list $project]
   if  { ( $result5 == 0 ) } {
      ts_log_fine "qconf -sstnode /$project again succeded"
   } else {
      ts_log_fine "result is $result5"
   }

   
   # Delete $project/$CHECK_USER
   ts_log_fine "Now  delete user $CHECK_USER from  $project ... \n"
   set result6 [del_sharetree_node $project  $CHECK_USER]
  
   if { ( $result6 == 0 ) } {
      ts_log_fine "qconf -dstnode /$project/$CHECK_USER succeded"
   } else {
      ts_log_fine "result is $result6"
   }

   # Delete $project/$CHECK_FIRST_FOREIGN_SYSTEM_USER
   ts_log_fine "Now  delete user $CHECK_FIRST_FOREIGN_SYSTEM_USER from  $project ... \n"
   set result6 [del_sharetree_node $project  $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   if { ( $result6 == 0 ) } {
      ts_log_fine "qconf -dstnode /$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER succeded"
   } else {
      ts_log_fine "result is $result6"
   }
   
   # Delete users CHECK_USER, CHECK_FIRST_FOREIGN_SYSTEM_USER from userlist
   ts_log_fine "Now  delete user $CHECK_USER from  userlist ... \n"
   del_user $CHECK_USER
   ts_log_fine "Now  delete user $CHECK_FIRST_FOREIGN_SYSTEM_USER from  userlist ... \n"
   del_user $CHECK_FIRST_FOREIGN_SYSTEM_USER
}


#                                                             max. column:     |
#****** qconf/qconf_event_client() ******
#
#  NAME
#     qconf_event_client - Create and then destroy an event client
#
#  SYNOPSIS
#     qconf_event_client { } - First create an INTERACTIVE only queue
#                             Then start qevent -ts as special user 
#                            ts_def_con2
#                            Check event client list with qconf -secl
#			     Then kill event client with qconf -kec
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_event_client {} {
   global ts_config env
   global CHECK_USER 

   set up_arch [resolve_build_arch $ts_config(master_host)]
   set event_client_bin $ts_config(source_dir)/$up_arch/qevent

   if { [file isfile $event_client_bin] != 1 } {
      ts_log_config "could not open event client binary: $event_client_bin"
      return -3
   }
   ts_log_fine "using event client: $event_client_bin"

   # start event client on master host, using special user ts_def_con2
   ts_log_fine "starting event client with -ts option ..."
   set event_client_sid [ open_remote_spawn_process $ts_config(master_host) "ts_def_con2" $event_client_bin "-ts"]
   set event_client_id [lindex $event_client_sid 1]

   # First do a list of event clients
   ts_log_fine "Show event client with -secl option ..."
   set result0 [get_event_client_list ]

   if {$result0 == 0} {
      ts_log_fine "qconf -secl succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Kill now event clients

   set result1 [del_event_client_list "" $event_client_id]

   if {$result1 == 0} {
      ts_log_fine "qconf -kec $event_client_id succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   close_spawn_process $event_client_sid
   
   # Restart event client to do a -kec all

   # start event client on master host, using special user ts_def_con2
   ts_log_fine "Re-starting event client with -ts option ..."
   set event_client_sid1 [ open_remote_spawn_process $ts_config(master_host) "ts_def_con2" $event_client_bin "-ts"]
   set event_client_id1 [lindex $event_client_sid1 1]

   set result2 [del_event_client_list "all" ""]

   if {$result2 == 0} {
      ts_log_fine "qconf -kec all succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   close_spawn_process $event_client_sid1
}

#****** qconf/qconf_add_delete_modify_calendar() ******
#
#  NAME
#     qconf_add_delete_modify_calendar - Create modify then destroy a calendar
#
#  SYNOPSIS
#     qconf_add_delete_modify_calendar { } - First create a calendar, interactively
#                                            Then modify it and delete it.
#                                            Then create it in fast add mode, 
#                                            Then delete it again
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_delete_modify_calendar {} {
   global ts_config env
   global CHECK_USER 

   set cal_name "qconf_calendar"
   set new_cal(week)           "mon-sun=0-24=suspended"

   # First do a list of event clients
   ts_log_fine "Add calendar $cal_name ..."
   set result0 [add_calendar "$cal_name" new_cal]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -Acal succeded"
   } else {
      ts_log_fine "result is $result0"
   }
  
   set mod_cal(calendar_name)  "$cal_name"
   set mod_cal(week)           "mon-fri=0-23=suspended"

   # Now modify it 
   ts_log_fine "Modify calendar $cal_name ..."
   set result01 [mod_calendar "$cal_name" mod_cal]

   if { ( $result01 == 0 ) } {
      ts_log_fine "qconf -Mcal succeded"
   } else {
      ts_log_fine "result is $result01"
   }

   # Now delete it 
   ts_log_fine "Delete calendar $cal_name ..."
   set result1 [del_calendar $cal_name]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -dcal succeded"
   } else {
      ts_log_fine "result is $result1"
   }
  
   # Now do a slow add
   ts_log_fine "Add calendar $cal_name slow..."
   set result2 [add_calendar "$cal_name" new_cal 0]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -acal slow succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now modify it slow
   ts_log_fine "Modify calendar $cal_name slow..."
   set result21 [mod_calendar "$cal_name" mod_cal 0]

   if { ( $result21 == 0 ) } {
      ts_log_fine "qconf -mcal slow  succeded"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now delete it  again
   ts_log_fine "Delete calendar $cal_name again..."
   set result3 [del_calendar $cal_name]

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -dcal again succeded"
   } else {
      ts_log_fine "result is $result3"
   }
}

#****** qconf/qconf_add_delete_modify_replace_attr() ******
#
#  NAME
#     qconf_add_delete_modify_replace_attr - Create modify then destroy attributes of object queue qocnf_queue.q . Can also be object exechost....
#
#  SYNOPSIS
#     qconf_add_delete_modify_replace_attr { } - First create a temporary queue, qocnf_queue.q
#                                            Then modify it and delete it.
#                                            Then create it in slow add mode
#                                            Then modify it slow and delete it 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_attributes/get_attr()
# sge_attributes/mod_attr()
#*******************************
proc qconf_add_delete_modify_replace_attr {} {
   global ts_config env
   global CHECK_USER 

   set queue_name "qconf_queue.q"
   set host [host_conf_get_suited_hosts]

   # First create the queue
   ts_log_fine "Create  queue $queue_name ...\n"
   set new_queue(qname) "$queue_name"
   set new_queue(hostlist) "$host"
   set result0 [add_queue $queue_name $host new_queue]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -aq  $queue_name succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Now test if qconf rejects an empty file for Mattr
   set obj_spec "queue"
   set attr_name ""
   set val ""
   set target [get_queue_instance $queue_name $host]

   ts_log_fine "Try fast add with empty file ..."
   set result01 [mod_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if {$result01 != -2} {
      ts_log_info "Negative test qconf -Mattr <emptyfile> Failed! $result01"
   } else {
      ts_log_fine "Negative test:qconf -Mattr <emptyfile> Success!"
   }   

   # Now modify attribute slots for obj_spec queue: -mattr queue slots 0 
   set attr_name "slots"
   set val "1"

   ts_log_fine "Modify $obj_spec  $attr_name  ..."
   set result01 [mod_attr  $obj_spec $attr_name $val $target]

   if { ( $result01 == 0 ) } {
      ts_log_fine "qconf -Mattr succeded"
   } else {
      ts_log_fine "result is $result01"
   }

   # Now modify non-existent attribute stuff 
   set attr_name "stuff"
   set val "100"

   ts_log_fine "Modify $obj_spec  $attr_name  ..."
   set result02 [mod_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result02 == -1 ) } {
      ts_log_fine "qconf -Mattr with wrong attribute succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result02"
   }
  
   # Now modify its attribute from CLI
   set attr_name "slots"
   set val "1"
   ts_log_fine "Modify $obj_spec $attr_name from CLI ...\n"
   set result02 [mod_attr  $obj_spec $attr_name $val $target 0]

   if { ( $result02 == 0 ) } {
      ts_log_fine "qconf -mattr succeded"
   } else {
      ts_log_fine "result is $result02"
   }

  # Now modify its attribute from CLI wrongly
   set attr_name "stuff"
   set val "200"
   ts_log_fine "Modify $obj_spec $attr_name from CLI wrongly ...\n"
   set result03 [mod_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result03 == -1 ) } {
      ts_log_fine "qconf -mattr wrongly succeded"
   } else {
      ts_log_fine "result is $result03"
   }

   # Now show these attributes
   set attr_name "slots"
   set val "0"
   ts_log_fine "Show $obj_spec  $attr_name  ..."
   set result03 [get_attr $obj_spec $attr_name $target]

   if { ( $result03 == 0 ) } {
      ts_log_fine "qconf -sobjl succeded"
   } else {
      ts_log_fine "result is $result03"
   }

   # Now replace attribute slots for obj_spec queue: -Rattr queue slots 0
   ts_log_fine "Replace $obj_spec  $attr_name  ..."
   set result04 [replace_attr  $obj_spec $attr_name $val $target]

   if { ( $result04 == 0 ) } {
      ts_log_fine "qconf -Rattr succeded"
   } else {
      ts_log_fine "result is $result04"
   }

   # Now try to add wrong stuff
   set attr_name "stuff"
   set val "100"
   ts_log_fine "Add $obj_spec  $attr_name  slow..."
   set result21 [add_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result21 == -1 ) } {
      ts_log_fine "qconf -aattr wrongly succeded"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now try to add wrong stuff fast
   ts_log_fine "Add $obj_spec  $attr_name  fast..."
   set result22 [add_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result22 == -1 ) } {
      ts_log_fine "qconf -Aattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result22"
   }

   # Now replace non-existent attribute stuff
   set attr_name "stuff"
   set val "100"

   ts_log_fine "Replace $obj_spec  $attr_name  slow..."
   set result31 [replace_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result31 == -1 ) } {
      ts_log_fine "qconf -rattr wrongly succeded"
   } else {
      ts_log_fine "result is $result31"
   }

   # Now replace non-existent attribute stuff from file

   ts_log_fine "Replace $obj_spec  $attr_name from file  ..."
   set result32 [replace_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result32 == -1 ) } {
      ts_log_fine "qconf -Rattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result32"
   }

   # Now try to delete non-existant stuff
   ts_log_fine "Delete  attr  $attr_name  slow..."
   set result31 [del_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result31 == -1 ) } {
      ts_log_fine "qconf -dattr wrongly succeded"
   } else {
      ts_log_fine "result is $result31"
   }

   # Now try to delete non-existant stuff fast
   ts_log_fine "Delete  attr  $attr_name  fast..."
   set result32 [del_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result32 == -1 ) } {
      ts_log_fine "qconf -Dattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result32"
   }

   # Now delete it via -dattr using good values
   set attr_name "slots"
   set val "1"
   ts_log_fine "Delete attr $attr_name on $queue_name slow ...\n"
   set result22 [del_attr $obj_spec $attr_name $val $target 0]

   if { ( $result22 == 0 ) } {
      ts_log_fine "qconf -dattr slow succeded"
   } else {
      ts_log_fine "result is $result22"
   }

   # Now delete queue

   ts_log_fine "Delete queue $queue_name ..."
   set result4 [del_queue  $queue_name $host 1]

   if { ( $result4  == 0 )} {
      ts_log_fine "qconf -dq $queue_name succeded"
   } else {
      ts_log_fine "result is $result4"
   }
}

#****** qconf/qconf_modify_checkpoint() ******
#
#  NAME
#     qconf_modify_checkpoint - Modify chekcpoint
#
#  SYNOPSIS
#     qconf_modify_checkpoint { } - Call "qconf -Mckpt "
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_modify_checkpoint {} {
   global ts_config env
   global CHECK_USER 

   # First let's create queue qconf_queue.q
   set queue_name "qconf_queue.q"
   ts_log_fine "Create  queue $queue_name ..."

   set new_queue(qname) "$queue_name"
   set host [host_conf_get_suited_hosts]
   set result0 [add_queue $queue_name $host new_queue ]

   if {$result0 == 0} {
      ts_log_fine "qconf -Aq  $queue_name succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Next, let's create a checkpoint
   set myarray(ckpt_name) "qconf_ckpt_name"
   ts_log_fine "Create  checkpoint  $myarray(ckpt_name) ..."

   set result1 [add_checkpointobj myarray]

   if {$result1 == 0} {
      ts_log_fine "qconf -ackpt  succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Now modify it using set_checkpointobj
   set myarray(clean_command) "ls"
   ts_log_fine "Modify checkpoint $myarray(ckpt_name) ..."
   set result2 [mod_checkpointobj myarray 1]

   if {$result2 == 0} {
      ts_log_fine "qconf -Mckpt succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now modify it using CLI
   set myarray(clean_command) "none"
   ts_log_fine "Modify checkpoint $myarray(ckpt_name) using CLI..."
   set result21 [mod_checkpointobj myarray 0]

   if {$result21 == 0} {
      ts_log_fine "qconf -mckpt succeded"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now try to modify using a non-existent checkpoint
   set myarray(ckpt_name) "qconf_ckpt_wrong"
   ts_log_fine "Modify wrong checkpoint $myarray(ckpt_name) ..."
   set result21 [mod_checkpointobj myarray 1 "" "" 0]

   if {$result21 == -1} {
      ts_log_fine "qconf -Mckpt failed correctly"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now try to modify using a non-existent checkpoint slow
# TODO: we have to modify the way how handle_vi_edit works.
#       at least, handle_vi_edit has to accept multiple error messages.
#       Best might be to pass arrays of messages to handle_vi_edit, similar to
#       handle_sge_error.
#   ts_log_fine "Modify wrong checkpoint $myarray(ckpt_name) slow ...\n"
#   set result22 [mod_checkpointobj myarray 0 "" "" 0]
#
#   if {$result22 == -9} {
#      ts_log_fine "qconf -mckpt failed correctly"
#   } else {
#      ts_log_fine "result is $result22"
#   }

   # Now delete checkpoint
   set myarray(ckpt_name) "qconf_ckpt_name"
   ts_log_fine "Delete checkpoint $myarray(ckpt_name) ..."
   set result4 [del_checkpointobj $myarray(ckpt_name)]

   if {$result4 == 0} {
      ts_log_fine "qconf -dckpt $myarray(ckpt_name) succeded"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now delete queue
   ts_log_fine "Delete queue $queue_name ..."
   set result8 [del_queue  $queue_name $host 1]

   if {$result8 == 0} {
      ts_log_fine "qconf -dq $queue_name succeded"
   } else {
      ts_log_fine "result is $result8"
   }
}

#****** qconf/qconf_modify_exechost() ******
#  NAME
#     qconf_modify_exechost - Modify exec host
#
#  SYNOPSIS
#     qconf_sep_check { } - Call set_exechost to modify exechost
#                         from CLI or file
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_modify_exechost {} {
   global ts_config env
   global CHECK_USER

   set host [host_conf_get_suited_hosts]

   # Save the initial values
   get_exechost old_values $host

   # First create project qconf_test_prj
   set my_project "qconf_test_prj"
   ts_log_fine "Create project $my_project ...\n"
   set result [add_project "$my_project"]
   ts_log_fine $result

   # Modify exechost fast
   ts_log_fine "Modify exec host  $host  from file ...\n"
   set new_exechost_charray(projects) "$my_project"
   set result0 [mod_exechost new_exechost_charray $host]

  if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -Me succeded\n"
   } else {
      ts_log_fine "result is $result0"
   }

   # Now modify from CLI
   ts_log_fine "Modify exec host $host from CLI ...\n"
   set result1 [mod_exechost new_exechost_charray $host 0]

  if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -me succeded\n"
   } else {
      ts_log_fine "result is $result1"
   }

   # Modify exechost fast wrongly
   ts_log_fine "Modify exec host  $host  from file wrongly...\n"
   set new_exechost_charray(projects) "qconf_wrong_prj"
   set result1 [mod_exechost new_exechost_charray $host 1 $host $CHECK_USER 0]

  if { ( $result1 == -1 ) } {
      ts_log_fine "qconf -Me failed  successfully \n"
   } else {
     # See IZ 1967 for why this returns wrongly 0
     ts_log_fine "result is $result1"
   }
   
   # Now modify from CLI wrongly
   ts_log_fine "Modify exec host $host from CLI wrongly...\n"
   set result12 [mod_exechost new_exechost_charray $host 0 $host $CHECK_USER 0]

  if { ( $result12 == -3 ) } {
      ts_log_fine "qconf -me failed  successfully\n"
   } else {
      ts_log_fine "result is $result12"
   }

   # Now restore the old values
   ts_log_fine "Restoring old values for  $host  ...\n"
   set result2 [mod_exechost old_values $host 0]

  if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -me succeded\n"
   } else {
      ts_log_fine "result is $result2"
   }
  
  # Now delete project qconf_test_prj
   ts_log_fine "Delete project $my_project ...\n"
   set result [del_project $my_project]
}

#****** qconf/qconf_modify_project() ******
#
#  NAME
#     qconf_modify_project - Modify project's fshare
#
#  SYNOPSIS
#     qconf_modify_project { } - Call mod_project
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_project {} {
   global ts_config qconf_project

   set my_project "$qconf_project"

   # Next modify fast
   ts_log_fine "Modify project $my_project fast ...\n"
   set old_values(fshare) "0"
   set result1 [mod_project $my_project old_values]

   if {$result1 == 0} {
      ts_log_fine "qconf -Mprj $my_project succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Next modify slow
   ts_log_fine "Modify project $my_project slow ...\n"
   set result2 [mod_project $my_project old_values 0]

   if {$result2 == 0} {
      ts_log_fine "qconf -mprj $my_project succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Next modify fast wrong
   ts_log_fine "Modify project $my_project fast with wrong attribute  ...\n"
   set old_values(stuff) "5"
   set result21 [mod_project $my_project old_values 1 "" "" 0]

   if {$result21 == -1} {
      ts_log_fine "qconf -Mprj $my_project failed  correctly"
   } else {
      # See IZ 1968 on why this does not fail as expected
      ts_log_fine "result is $result21"
   }

   # Next modify fast wrong again
   ts_log_fine "Modify project $my_project wrong fast again ...\n"
   set old_values(fshare) "-1"

   set result3 [mod_project $my_project old_values 1 "" "" 0]

   if {$result3 == -2} {
      ts_log_fine "qconf -Mprj $my_project failed again correctly"
   } else {
      # See IZ 1968 on why this does not fail as expected
      ts_log_fine "result is $result3"
   }

   # Next modify slow
   ts_log_fine "Modify project $my_project  wrong slow ...\n"
   set result4 [mod_project $my_project old_values 0 "" "" 0]

   if {$result4 == -3} {
      ts_log_fine "qconf -mprj $my_project failed  correctly"
   } else {
      ts_log_fine "result is $result4"
   }
}

#****** qconf/qconf_modify_userlist() ******
#
#  NAME
#     qconf_modify_userlist - Modify userlist's fshare
#
#  SYNOPSIS
#     qconf_modify_userlist { } - Call mod_userlist
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_userlist {} {
   global ts_config env qconf_userlist
   global CHECK_USER

   set host [host_conf_get_suited_hosts]
  
   set userlist "qconf_userlist"
   set attribute "entries"
   set value "$CHECK_USER"

   # Get present config
   #get_userset $userlist current_ul

   set current_ul(name) "$userlist"
   set current_ul($attribute) "$value"

   # Now modify fast
   ts_log_fine "1) Modify userlist $userlist fast ...\n"
   set result1 [mod_userlist $userlist current_ul ]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -Mu fast succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Next modify slow
   set attribute "entries"
   set value "NONE"
   set current_ul($attribute) "$value"
   ts_log_fine "2) Modify userlist $userlist slow ...\n"

   set result2 [mod_userlist $userlist current_ul 0]
   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -mu slow succeded"
   } else {
      ts_log_fine "result is $result2"
   }


   # Now modify slow with wrong attribute
   set userlist "qconf_userlist"
   set attribute "oticket"
   set value "-1"
   set current_ul($attribute) "$value"
   ts_log_fine "3) Modify attribute $attribute wrong slow ...\n"
   set result4 [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if { ( $result4 == -4 ) } {
      ts_log_fine "qconf -mu failed successfully"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now modify fast with wrong value
   ts_log_fine "4) Modify userlist $userlist wrong fast ...\n"
   set result3 [mod_userlist $userlist current_ul 1 $host $CHECK_USER 0]

   if { ( $result3 == -1 ) } {
      ts_log_fine "qconf -Mu failed successfully"
   } else {
      # See IZ 1983 on why this does not fail as expected
      ts_log_fine "result is $result3"
   }

   #test if setting wrong value in userset type throws error
   set attribute "oticket"
   set value "0"
   set current_ul($attribute) "$value"
   set attribute "type"
   set value "BADTYPE"
   set current_ul($attribute) "$value"
   ts_log_fine "5) Setting invalid type for userset ...\n"
   set result5 [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if { ( $result5 == -5 ) } {
      ts_log_fine "qconf -mu for invalid userset type failed successfully"
   } else {
      ts_log_fine "result is $result5"
   }

   #test if setting blank value in userset type throws error
   set value "    "
   set current_ul($attribute) "$value"
   ts_log_fine "6) Setting blank type for userset ...\n"
   set result6 [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if { ( $result6 == -6 ) } {
      ts_log_fine "qconf -mu for blank userset type failed successfully"
   } else {
      ts_log_fine "result is $result6"
   }
 
}

#****** qconf/qconf_modify_sched_conf() ******
#
#  NAME
#     qconf_modify_sched_conf - Modify scheduler config
#
#  SYNOPSIS
#     qconf_modify_sched_conf { } - Call mod_schedd_config
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_sched_conf {} {
   global ts_config env 
   global CHECK_USER

   set host [host_conf_get_suited_hosts]

   # Next modify fast
   set mysched_config(maxujobs) "10"

   ts_log_fine "Modify schedd fast ...\n"
   set result1 [mod_schedd_config mysched_config ]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -Msconf succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Next modify slow
   set mysched_config(maxujobs) "5"
   ts_log_fine "Modify schedd slow ...\n"
   set result2 [mod_schedd_config mysched_config 0]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -msconf succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Next modify slow with wrong values
   set mysched_config(maxujobs) "-1"
   ts_log_fine "Modify schedd slow ...\n"
   set result3 [mod_schedd_config mysched_config 0 $host $CHECK_USER 0]

   if { ( $result3 == -2 ) } {
      ts_log_fine "qconf -msconf failed successfully"
   } else {
      ts_log_fine "result is $result3"
   }

   # Next modify fast with wrong values
   ts_log_fine "Modify schedd fast ...\n"
   set result4 [mod_schedd_config mysched_config 1 $host $CHECK_USER 0]

   if { ( $result4 == -1 ) } {
      ts_log_fine "qconf -Msconf failed successfully"
   } else {
      # See IZ 1975 on why this does not fail as expected
      ts_log_fine "result is $result4"
   }
}

#****** qconf/qconf_issue_2023() ******
#
#  NAME
#     qconf_issue_2023 - Test for Issue 2023
#
#  SYNOPSIS
#     qconf_issue_2023 { } - 
#
#  FUNCTION
#     Check qconf issue 2023 
#
#*******************************
proc qconf_issue_2023 {} {
   global ts_config env qconf_userlist
   global CHECK_USER

   set host [host_conf_get_suited_hosts]
  
   set userlist "qconf_userlist"
   set attribute "entries"
   set value "$CHECK_USER"

   set current_ul(name) "$userlist"
   set current_ul($attribute) "$value "

   set result1 [mod_userlist $userlist current_ul ]
   if { ( $result1 != 0 ) } {
      ts_log_severe "rejects configuration, when attribute value ends with a space character"
      ts_log_fine "result is $result1"
   }
}

#****** check/qconf_create_modify_sharetree() **********************************
#  NAME
#     qconf_create_modify_sharetree() -- test qconf -Mstree
#
#  SYNOPSIS
#     qconf_create_modify_sharetree { } 
#
#  FUNCTION
#     Tests qconf -Mstree option.
#     Positive tests adding a new sharetree and modifying a sharetree.
#
#     Negative tests as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_create_modify_sharetree {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete an already existing sharetree
   del_sharetree

   # create a sharetree
   stree_buffer_init stree
   stree_buffer_add_node stree "/default" 10
   stree_buffer_add_node stree "/mytestproject" 20
   stree_buffer_add_node stree "/mytestproject/default" 30
   stree_buffer_commit stree

   # modify the sharetree
   stree_buffer_mod_node stree "/default" 20
   stree_buffer_del_node stree "/mytestproject"
   stree_buffer_commit stree

   # read in the sharetree - it may only contain the / and the /default nodes
   # with correct number of shares
   stree_buffer_read stree2
   if {[llength $stree2(index)] != 2 || 
       [lindex $stree2(index) 0] != "/" || 
       [lindex $stree2(index) 1] != "/default"} {
      ts_log_severe "sharetree should only contain the nodes / and /default, but contains\n$stree2(index)"
   }

   # delete the sharetree
   del_sharetree

   # try to create/modify a sharetree with insufficient permissions
   # - as non admin user
   # - from non admin host
   set ret [stree_buffer_commit stree "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210} {
      ts_log_severe "qconf -Mstree should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_unused_host]
   if {$non_cluster_host != ""} {
      set ret [stree_buffer_commit stree $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Mstree should have failed on host $non_cluster_host"
      }
   }

   # delete a sharetree created due to errors in the permission check
   del_sharetree
}

#****** check/qconf_del_sharetree() ********************************************
#  NAME
#     qconf_del_sharetree() -- test qconf -dstree
#
#  SYNOPSIS
#     qconf_del_sharetree { } 
#
#  FUNCTION
#     Tests qconf -dstree.
#     Positive test with and without sharetree.
#     
#     Negative tests as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_del_sharetree {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete an already existing sharetree
   del_sharetree

   # build a sharetree and delete it - must give error code 0
   stree_buffer_init stree
   stree_buffer_add_node stree "/default" 10
   stree_buffer_add_node stree "/mytestproject" 20
   stree_buffer_add_node stree "/mytestproject/default" 30
   stree_buffer_commit stree

   set ret [del_sharetree]
   if {$ret != 0} {
      ts_log_severe "qconf -dstree should have reported success"
   }

   # test qconf action when there is no sharetree to delete
   set ret [del_sharetree]
   if {$ret != 1} {
      ts_log_severe "qconf -dstree should have reported \"No sharetree\""
   }

   # try to delete a sharetree with insufficient permissions
   # - as non admin user
   # - from non admin host
   stree_buffer_commit stree
   set ret [del_sharetree "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210} {
      ts_log_severe "qconf -dstree should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_unused_host]
   if {$non_cluster_host != ""} {
      set ret [del_sharetree $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -dstree should have failed on host $non_cluster_host"
      }
   }

   # delete the sharetree
   del_sharetree
}

#****** check/qconf_add_project() **********************************************
#  NAME
#     qconf_add_project() -- test qconf -aprj / -Aprj
#
#  SYNOPSIS
#     qconf_add_project { } 
#
#  FUNCTION
#     Test adding projects (qconf -aprj and qconf -Aprj).
#     Positive tests.
#
#     Negative tests creating duplicates and project name being a keyword,
#     and as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_add_project {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # test adding projects
   set MY_PROJECT_NAME "qconf_add_prj"

   add_project "$MY_PROJECT_NAME" project 0 ;# slow add
  
   del_project "$MY_PROJECT_NAME"

   add_project "$MY_PROJECT_NAME"  ;# fast add

   # test adding duplicates (must fail)
   # TODO: it's difficult to handle all the default error conditions
   # in handle_vi_edit (e.g. host and user permissions).
   # until this is fixed, we cannot do negative tests with qconf calling the editor.
   #set ret [add_project $MY_PROJECT_NAME project 0 "" "" 0] ;# slow add duplicate
   #if {$ret != -2} {
   #   ts_log_severe "qconf -aprj should have failed for duplicate"
   #}

   set ret [add_project "$MY_PROJECT_NAME" project 1 "" "" 0] ;# fast add duplicate
   if {$ret != -2} {
      ts_log_severe "qconf -Aprj should have failed for duplicate"
   }

   del_project "$MY_PROJECT_NAME"

   # test other errors
   set MY_PROJECT_NAME "default"
   #set ret [add_project "$MY_PROJECT_NAME" project 0 "" "" 0] ;# slow add incorrect prj (name is keyword)
   #if {$ret >= 0} {
   #   ts_log_severe "qconf -aprj should have failed for a project named \"default\""
   #}

   set ret [add_project "$MY_PROJECT_NAME" project 1 "" "" 0] ;# fast add incorrect prj (name is keyword)
   if {$ret >= 0} {
      ts_log_severe "qconf -Aprj should have failed for a project named \"default\""
   }

   # try to add a project with insufficient permissions
   # - as non admin user
   # - from non admin host
   set MY_PROJECT_NAME "qconf_add_prj"
   #set ret [add_project "$MY_PROJECT_NAME" project 0 "" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" 0]
   #if {$ret != -210} {
   #   ts_log_severe "qconf -aprj should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   #}
   set ret [add_project "$MY_PROJECT_NAME" project 1 "" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" 0]
   if {$ret != -210} {
      ts_log_severe "qconf -Aprj should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }

   set non_cluster_host [host_conf_get_unused_host]
   set ret [add_project "$MY_PROJECT_NAME" project 0 $non_cluster_host "" 0]
   #if {$ret != -201} {
   #   ts_log_severe "qconf -aprj should have failed on host $non_cluster_host"
   #}

   if {$non_cluster_host != ""} {
      set ret [add_project "$MY_PROJECT_NAME" project 1 $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Aprj should have failed on host $non_cluster_host"
      }
   }
}

proc qconf_brief_exercise {} {
   ts_log_fine "* * * PROJECT * * *"
   set right_param(oticket) "10"
   qconf_messages_basic_check project right_param
   unset right_param

   ts_log_fine "* * * USERSET * * *"
   set right_param(type) "ACL DEPT"
   qconf_messages_basic_check userset right_param
   unset right_param
   # aja: TODO: adjust the functional tests
   add_access_list "user1 user2 user3" "set1,set2"
   del_user_from_access_list "user4" "set1" "" "" 0                             ;# del user nonex. user err
   del_user_from_access_list "user1" "set3" "" "" 0                             ;# del user nonex. acl err
   del_user_from_access_list "user1" "set1" "" "" 0                             ;# del user nonex. acl ok
   del_user_from_access_list "user1 user2" "set2" "" "" 0                       ;# del user mix error
   del_access_list "set1,set2" "" "" 0                                          ;# del acl ok

   ts_log_fine "* * * PARALLEL ENVIRONMENT * * *"
   set right_param(slots) "10"
   qconf_messages_basic_check pe right_param
   unset right_param

   ts_log_fine "* * * CALENDAR * * *"
   set right_param(week) "mon-sun=0-24=off"
   qconf_messages_basic_check calendar right_param
   unset right_param

   ts_log_fine "* * * HOSTGROUP * * *"
   set right_param(hostlist)       "@allhosts"
   set args(name_prefix) "@"
   qconf_messages_basic_check hostgroup right_param args
   unset right_param
   unset args

   ts_log_fine "* * * USER * * *"
   set right_param(oticket) "10"
   qconf_messages_basic_check user right_param
   unset right_param
   # aja: TODO: test the rest functionality

   ts_log_fine "* * * QUEUE * * *"
   set right_param(load_thresholds)       "np_load_avg=7.0"
   set args(hostlist) [gethostname]
   set args(ignore_hostlist) 1
   set args(del_cqueue) 1
   qconf_messages_basic_check queue right_param args
   unset right_param
   unset args

}

#****** check.exp/qconf_messages_basic_check() *********************************
# 
#  NAME
#     qconf_messages_basic_check - basic test of qconf interfaces and the 
#                                  messages returned by the qconf client.
#
#  SYNOPSIS
#     qconf_messages_basic_check { object valid_object_params args }
#
#  FUNCTION
#     check the basic functionality of qconf command, play with the objects and
#     the returned messages from qconf client. 
#
#  INPUTS
#     object              - the name of the object 
#                           [ex.: project, user, hostgroup, queue, ...]
#     valid_object_params - the array with the valid attributes to check the 
#                           successfull add/mod functions
#                           object <name> parameter is ignored for this test, but
#                           can be set to check the name validation (not yet 
#                           implemented)
#     {arguments ""}      - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#
#*******************************************************************************
proc qconf_messages_basic_check {object valid_object_params {arguments ""}} {
   upvar $valid_object_params ok_param
   upvar $arguments args

   explore_expected_arguments args name_prefix hostlist ignore_hostlist del_cqueue

   set obj_name_attr [get_object_name_attribute $object]
   # set the valid name for the object
   set object_name fake_${object}
   if {![string match "$name_prefix*" $object_name]} {
         set object_name ${name_prefix}${object_name}
   }

   set param($obj_name_attr) $object_name
   # required attributes - set the default value
   set_${object}_defaults object_defaults
   if {[info exist object_defaults(hostlist)]} {
      set param(hostlist) "NONE"
   }

   # check the get_$object_list function
 #  qconf_check_list $object param args
   # check invalid name for the object
   # aja: TODO: other name validation
   if {[string compare $name_prefix ""] != 0} {
      eval add_${object} test_${object} $hostlist param 0 "\"\"" "\"\"" 0       ;# add $object wrong name slow err
      eval add_${object} test_${object} $hostlist param 1 "\"\"" "\"\"" 0       ;# add $object wrong name fast err
   }
   # add/mod/del/get object game
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue "\"\"" "\"\"" 0 ;# del nonex. $object err
   eval get_${object} $object_name out "\"\"" "\"\"" 0                          ;# get nonex. $object err
   eval mod_${object} ${object_name} $hostlist param 0 "\"\"" "\"\"" 0          ;# mod nonex. $object slow err
   eval mod_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# mod nonex. $object fast err
   eval add_${object} $object_name $hostlist param 0                            ;# add $object slow ok
   eval add_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# add already exists $object slow err
   eval mod_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# mod file unchanged slow err
   eval mod_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# mod file unchanged fast err
   # now we use the array with the valid attributes and parameters
   foreach elem [array names ok_param] {
      # we don't want to check the object name change
      if {[string compare $elem $obj_name_attr] != 0} {
         if {[info exists param($elem)]} {
            set bckp_param($elem) $param($elem)
         }
         set param($elem) $ok_param($elem)
      }
   }
   eval mod_${object} $object_name $hostlist param 0                            ;# mod $object slow ok
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue       ;# del $object ok
   eval add_${object} $object_name $hostlist param                              ;# add $object fast ok
   # for the test of successfull modification change back the parameters
   foreach elem [array names bckp_param] {
      set param($elem) $bckp_param($elem)
   }
   eval mod_${object} $object_name $hostlist param 1                            ;# mod $object fast ok
   eval add_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# add already exists $object fast err
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue       ;# del $object ok
   # let's test the wrong parameters
   set test_attributes ""
   # ulong attributes
   lappend test_attributes "oticket"
   lappend test_attributes "fshare"
   lappend test_attributes "slots"
   lappend test_attributes "delete_time"
   # userset dependent attributes
   lappend test_attributes "acl"
   lappend test_attributes "xacl"
   lappend test_attributes "user_lists"
   lappend test_attributes "xuser_lists"
   # project dependent attributes
   lappend test_attributes "default_project"
   # calendar attributes
   lappend test_attributes "year"
   lappend test_attributes "week"
   # host attributes
   lappend test_attributes "hostlist"
   # directory attributes
   lappend test_attributes "start_proc_args"
   lappend test_attributes "stop_proc_args"
   # complex attributes
   lappend test_attributes "load_thresholds"
   # aja: TODO: add attributes for testing (queue, pe,...)

   foreach attr $test_attributes {
      if {[info exists object_defaults($attr)]} {
         qconf_check_wrong_parameter $object param "$attr" args
      }
   }

   # aja: TODO: test missing required attribute
   # aja: TODO: test non-existing attribute   
}

#****** check.exp/qconf_check_list() *******************************************
# 
#  NAME
#     qconf_check_list - basic test of qconf get <object> list function.
#
#  SYNOPSIS
#     qconf_check_list { object valid_object_params args }
#
#  FUNCTION
#     basic test of qconf get <object> list function - either when any object
#     exists, or when no object exists
#
#  INPUTS
#     object              - the name of the object 
#                           [ex.: project, user, hostgroup, queue, ...]
#     valid_object_params - the array with the valid attributes to check the 
#                           successfull add/mod functions
#                           object <name> parameter is ignored for this test, but
#                           can be set to check the name validation (not yet 
#                           implemented)
#     {arguments ""}      - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#     {referencies ""}    - ...
#
#  SEE ALSO
#      check.exp/qconf_messages_basic_check
#      check.exp/explore_expected_arguments
#*******************************************************************************
proc qconf_check_list {object valid_object_params {arguments ""} {referencies ""}} {
   upvar $valid_object_params valid_object
   set obj_name_attr [get_object_name_attribute $object]
   upvar $arguments args

   ts_log_fine "Basic test of get_${object}_list function"

   explore_expected_arguments args name_prefix hostlist ignore_hostlist del_cqueue

   # check if any object exist
   if {[eval get_${object}_list bckp "\"\"" "\"\"" 0] == 0} {
      # object exists
      if {[info exists bckp]} {
         set ind 0
         set all_count 0
         # Back up the existing objects
         foreach obj $bckp {
            incr all_count
            if { [eval get_${object} "$obj" "out$ind" "\"\"" "\"\"" 1] == 0 } { ;# get $object ok
                if {[eval del_${object} "$obj" $hostlist $ignore_hostlist $del_cqueue "\"\"" "\"\"" 0] == 0} {;# del $object ok
                  incr ind
               } else {
                  unset out$ind
                  # aja: TODO: referencies
               }
            } else {
            }
         }
         # test the nonex. object if the list is empty
         if {$ind == $all_count} {
            eval get_${object}_list out "\"\"" "\"\"" 0                         ;# get $object list err
         } else {
            ts_log_fine "get_${object}_list with nonex. $object not tested"
         }
         # Restore the objects
         for {set i 0} {$i < $ind} {incr i} {
            unset obj
            array set obj [array get out$i]
            if {[info exists obj(hostlist)]} {
               set hostlist $obj(hostlist)
            }
            eval add_${object} $obj($obj_name_attr) $hostlist obj               ;# add $object fast ok
            unset out$i
         }
         unset bckp
      }
   } else {
      # no object exists
      eval get_${object}_list out "\"\"" "\"\"" 0                               ;# get $object list err
      set oname "$valid_object($obj_name_attr)"
      if {![string match "$name_prefix*" $oname]} {
         set object_name ${name_prefix}${object_name}
      }
      eval add_${object} "$oname" $hostlist valid_object                        ;# add $object fast ok
      eval get_${object}_list                                                   ;# get $object list ok
      eval del_${object} "$oname" $hostlist $ignore_hostlist $del_cqueue        ;# del $object ok
   }

}
    
#****** check.exp/qconf_check_wrong_parameter() ********************************
# 
#  NAME
#     qconf_check_wrong_parameter - basic test of qconf mod/add functions 
#                                   with the wrong parameter
#
#  SYNOPSIS
#     qconf_check_wrong_parameter { object valid_object_params {arguments ""} }
#
#  FUNCTION
#     basic test of qconf get <object> list function - either when any object
#     exists, or when no object exists
#
#  INPUTS
#     object              - the name of the object 
#                           [ex.: project, user, hostgroup, queue, ...]
#     valid_object_params - the array with the valid attributes to check the 
#                           successfull add/mod functions
#                           object <name> parameter is ignored for this test, but
#                           can be set to check the name validation (not yet 
#                           implemented)
#     attribute           - attribute to change to invoke the wrong parameter
#                           error
#     {arguments ""}      - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#     {value "universalNOTVALIDvalue"} - the wrong value for the attribute
#
#  SEE ALSO
#      check.exp/qconf_messages_basic_check
#*******************************************************************************
proc qconf_check_wrong_parameter {object valid_object_params attribute {arguments ""} {value "universalNOTVALIDvalue"}} {
   upvar $arguments args

   ts_log_fine "Check the add/mod $object functionality with the wrong parameter \"$attribute\""

   explore_expected_arguments args name_prefix hostlist ignore_hostlist del_cqueue

   set obj_name_attr [get_object_name_attribute $object]

   foreach elem [array names valid_object_param] {
      set param($elem) $valid_object_param($elem)
   }

   if {[info exists param($obj_name_attr)]} {
      set object_name param($obj_name_attr)
   } else {
      set object_name wrong_${object}
   }

   if {![string match "$name_prefix*" $object_name]} {
         set object_name ${name_prefix}${object_name}
   }

   eval add_${object} $object_name $hostlist param                              ;# add $object fast ok
   set param($attribute) $value
   if {[string compare $object "queue"] == 0 && [string compare $attribute "hostlist"] == 0} {
       set hostlist $value
   }
   eval mod_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# mod wrong param slow err
   eval mod_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# mod wrong param fast err
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue       ;# del $object ok
   eval add_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# add wrong param fast err
   eval add_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# wrong param slow err

}

#****** check.exp/explore_expected_arguments() *********************************
# 
#  NAME
#     explore_expected_arguments - set the expected arguments
#
#  SYNOPSIS
#     explore_expected_arguments { arguments name_prefix hostlist }
#
#  FUNCTION
#     basic test of qconf get <object> list function - either when any object
#     exists, or when no object exists
#
#  INPUTS
#     arguments          - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#     name_prefix         - variable for name_prefix argument
#     hostlist            - variable for hostlist argument
#     ignore_hostlist     - variable for del_queue function
#     del_cqueue          - variable for del_queue function
#
#*******************************************************************************
proc explore_expected_arguments {arguments name_prefix hostlist ignore_hostlist del_cqueue} {
   upvar $arguments args
   upvar $name_prefix nm
   upvar $hostlist hst
   upvar $ignore_hostlist ign
   upvar $del_cqueue dcq

   set hst ""
   set nm ""
   set ign ""
   set dcq ""
   foreach arg [array names args] {
      if {[string compare $arg "name_prefix"] == 0} {
         set nm $args($arg)
      }
      if {[string compare $arg "hostlist"] == 0} {
         set hst $args($arg)
      }
      if {[string compare $arg "ignore_hostlist"] == 0} {
         set ign $args($arg)
      }
      if {[string compare $arg "del_cqueue"] == 0} {
         set dcq $args($arg)
      }
   }
}

# set the attribure which holds the name of the object
proc get_object_name_attribute {object} {
   set obj_name_attr "name"
   set_${object}_defaults chgar
   foreach elem [array names chgar] {
      if {[string first "name" "$elem"] != -1} {
         set obj_name_attr "$elem"
         break
      }
   }
   return $obj_name_attr
}
