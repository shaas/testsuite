#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qdel_init_level"


# define test's name and run level descriptions
set check_name            "qdel"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   3
set check_description(0)  "checking all options in job pending state"
set check_description(1)  "checking all options in job pending and hold state"
set check_description(2)  "checking all options in job running state"
set check_description(3)  "checking all options in job running and hold state" 

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "qdel_setup"
set check_cleanup_function "qdel_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "qdel_help"                   ;# print this help
lappend check_functions "qdel_submit_delete_when_transfered"
lappend check_functions "qdel_job_task_list"          ;# delete all jobs given in list
lappend check_functions "qdel_delete_job_0"           ;# try to delete job id 0
lappend check_functions "qdel_delete_unknown_jobid"   ;# delete job not running
lappend check_functions "qdel_delete_negative_jobid"
lappend check_functions "qdel_all"                   ;# delete all jobs of current user
lappend check_functions "qdel_uall"                  ;# delete all jobs of all users
lappend check_functions "qdel_user_list"             ;# delete all jobs of users specified in list
lappend check_functions "qdel_force"                 ;# force action
lappend check_functions "qdel_iz_125_case_2"         ;# implement Case 2) of iz 125 
lappend check_functions "qdel_iz_125_case_3"         ;# implement Case 3) of iz 125 
lappend check_functions "qdel_iz_125_case_4"         ;# implement Case 4) of iz 125 
lappend check_functions "qdel_iz_125_case_5"         ;# implement Case 5) of iz 125 
lappend check_functions "qdel_delete_task_range"     ;# implement task range deletion

# check's globals
global hold_state
global pending_state
global queue

proc qdel_init_level {} {
  global CHECK_ACT_LEVEL hold_state pending_state queue

  set queue "qdel.q"

  switch -- $CHECK_ACT_LEVEL {
     "0" { set hold_state 0 ; set pending_state 1 ; return 0 }
     "1" { set hold_state 1 ; set pending_state 1 ; return 0 }
     "2" { set hold_state 0 ; set pending_state 0 ; return 0 }
     "3" { set hold_state 1 ; set pending_state 0 ; return 0 }
  }

  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

#                                                             max. column:     |
#****** qdel/qdel_setup() ******
# 
#  NAME
#     qdel_setup -- ??? 
#
#  SYNOPSIS
#     qdel_setup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_setup {} {
   global ts_config
   global queue

   set q_param(load_thresholds)       "np_load_avg=7.00"
   set q_param(slots)                 "50"

   add_queue $queue [lindex $ts_config(execd_nodes) 0] q_param
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qdel/qdel_cleanup() ******
# 
#  NAME
#     qdel_cleanup -- ??? 
#
#  SYNOPSIS
#     qdel_cleanup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_cleanup {} {
   global ts_config
   global queue CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER 
   global CHECK_SECOND_FOREIGN_SYSTEM_USER

   delete_all_jobs
   wait_for_end_of_all_jobs 120

   del_queue $queue [lindex $ts_config(execd_nodes) 0] 0 1

   puts $CHECK_OUTPUT "do qmod -c for all queues"
   foreach hostname $ts_config(execd_nodes) {
      set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c [get_queue_instance all.q $hostname]" } output ]
      puts $CHECK_OUTPUT $output
   }

   set_error 0 "ok"
}

proc qdel_submit_delete_when_transfered {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global submit_del_qconfig submit_del_check_queue CHECK_USER
   global CHECK_HOST CHECK_PRODUCT_ROOT CHECK_DEBUG_LEVEL
   global CHECK_ACT_LEVEL

   # we only execute this check in runlevel 0 - the other runlevels have no meaning here
   if { $CHECK_ACT_LEVEL == 0 } {
      # cleanup from earlier checks
      delete_all_jobs
      wait_for_end_of_all_jobs 60

      # we submit sleeper jobs and delete them immediately after they entered
      # transfering / running state
      # we do this 25 times for every architecture
      set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh"
      set runs 25
      while { $runs > 0 } { 
         foreach elem $ts_config(unique_arch_nodes) {
            set arguments "-o /dev/null -e /dev/null -q [get_queue_instance all.q $elem]"
            set job_id [submit_job "$arguments $job_script"]
            if {$job_id > 0} {
               trigger_scheduling
               set job_state [wait_for_jobstart $job_id "leeper" 120]
               if {$job_state == -1} {
                  set runs 0
               }
               delete_job $job_id
            }
         }
         incr runs -1
      }
      wait_for_end_of_all_jobs 100
   }

   # clear possible error states of queues
   foreach host $ts_config(execd_nodes) {
      set qinstance [get_queue_instance "all.q" $host]
      set output [start_sge_bin "qmod" "-c $qinstance"]
      puts $CHECK_OUTPUT $output
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qdel/are_jobs_deleted() ******
# 
#  NAME
#     are_jobs_deleted -- ??? 
#
#  SYNOPSIS
#     are_jobs_deleted { job_list } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     job_list - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc are_jobs_deleted { job_list } {

   global CHECK_OUTPUT
   set del_jobs ""

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             if { [ lsearch $del_jobs "$job_id" ] != 0 } { 
                lappend del_jobs $job_id 
             }
             incr jobs_deleted 1
          }
       }
     
       puts $CHECK_OUTPUT "Jobs_deleted: $del_jobs"
       puts $CHECK_OUTPUT "All jobs:     $job_list"
 
       if {$jobs_deleted == [llength $job_list]} {
          return 0
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 120 } {
          return -1
       }
       sleep 1
   }   

}

#                                                             max. column:     |
#****** qdel/submit_testjobs() ******
# 
#  NAME
#     submit_testjobs -- ??? 
#
#  SYNOPSIS
#     submit_testjobs { { user "" } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     { user "" } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc submit_testjobs { { user "" } { additional_job_args "" } {testjob_count "4" } {array_job ""} {check_job_state 1}} {
   global ts_config
  global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT 
  global CHECK_OUTPUT CHECK_USER CHECK_ARCH CHECK_HOST ts_config

  set joblist ""
  set year [exec date "+%Y"] 
  set year [ expr ( $year + 1 ) ]

  set jobargs "$array_job -o /dev/null -e /dev/null -N qdel_check"

  if { ($pending_state == 1)  } {
     set jobargs "$jobargs -a ${year}12312359"   ;# start at silvester next year!

     if { ($hold_state == 1)  } {
        set jobargs "$jobargs -h"   ;# set hold flag
     }
  }
 
  set jobargs "$additional_job_args $jobargs -q [get_queue_instance $queue [lindex $ts_config(execd_nodes) 0]] $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 3000"

   if {$user == ""} {
      set user $CHECK_USER
   }
  
   # no user specified (using local user name (starter of testsuite))
   for {set count 1} {$count <= $testjob_count} {incr count +1} {
      set jobresult [submit_job $jobargs 1 60 "" $user]     ;# submit_job has it's own error handling
      if {$jobresult > 0 } {
         lappend joblist $jobresult
      }
   }

  if {$check_job_state} {
     if { $pending_state == 0 } {
        # wait for all job to run
        foreach elem $joblist {
           wait_for_jobstart  $elem "qdel_check" 400  
        }

        if { ($hold_state == 1)  } {
           # set hold flag for all jobs 
           foreach elem $joblist {
              hold_job $elem 
           } 
        }
     } else {
        # wait for all job to get in pending state
        foreach elem $joblist {
           wait_for_jobpending $elem "qdel_check" 400  
        }
     }
  }

  return $joblist
}

#                                                             max. column:     |
#****** qdel/qdel_iz_125_case_x() ******
#
#  NAME
#     qdel_iz_125_case_x -- ???
#
#  SYNOPSIS
#     qdel_iz_125_case_x { { user "" } }
#
#  FUNCTION
#     ???
#
#  INPUTS
#     { user "" } - ???
#
#  RESULT
#     ???
#
#  EXAMPLE
#     ???
#
#  NOTES
#      Scenarios:
#
#     2) more than one qdel JOBID should always return a status text
#	 see qdel/qdel_125_case_2()
#
#     3) test array qdel:
#     a) submit array 1-10
#        delete tasks 5-10
#     b) wait for task running, delete tasks (2-3)
#     c) delete tasks 2-5 (only task 4 should be reported, error state=0)
#     d) delete 6-7 (error state=1)
#
#
#    [  ( check if it isn't already done)
#       test deletion of single job:
#        a) job is pending
#        b) job is running
#        c) job is unkown ]
#
#	see qdel/qdel_125_case_3()
#
#     4) New test: submit and then delete -pe jobs
#        see qdel/qdel_125_case_4()
#
#     5) New test: submit 1000 jobs, delete them, check that they are all deleted.
#        see qdel/qdel_125_case_5()
#
#     6) New test: submit a task array and delete the range of tasks
#        jobid.1-jobid.10
#
#  BUGS
#     ???
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_iz_125_case_2 { { user "" } { additional_job_args "" }} {
   global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT
   global CHECK_OUTPUT CHECK_ARCH CHECK_HOST ts_config
   global queue CHECK_HOST CHECK_USER
  
   set hostname $ts_config(master_host) 
   set arch [resolve_arch $hostname]
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"

   # 2) Submit a job. Delete it once....

   set job_list [submit_testjobs "" "" 1]

   sleep 5

   set result0 [ start_remote_prog $hostname $CHECK_USER $qdel_program  $job_list ]

   # Check that we get a response
   set string1 [translate $hostname 0 1 0 "deleted job "]
   set string2 [translate $hostname 0 1 0 "job "]
   set string3 [translate $hostname 0 1 0 "does not exist "]
   set string4 [translate $hostname 0 1 0 "registered the job "]
   set string5 [translate $hostname 0 1 0 "for deletion "]

   # in case of errors, break
   set do_continue 1

   if { (  [string first [concat "$string1 " [lindex $job_list 0] ] $result0] >= 0 ) ||
   (  [string first [concat "$string2 " \"[lindex $job_list 0]\" "$string3" ] $result0] >= 0 ) ||
   (  [string first [concat "$string4 " [lindex $job_list 0] "$string5" ] $result0] >= 0 ) } {

  	   puts $CHECK_OUTPUT "first delete OK"
   } else {
	   add_proc_error "qdel_iz_125_case_2" -1 "First delete of case 2), IZ 125 failed:\n$result0"
      set do_continue 0
   }

   # Delete it 2x
   set result00 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_list ]

   # Check that we get a response
   # qdel always has to return some text.
   # if result00 is empty, we hit IZ 1860
   if {[string trim $result00] == ""} {
      add_proc_error "qdel_iz_125_case_2" "-3" "qdel didn't return any text - this is IZ 1860"
      set do_continue 0
   }

   if ($do_continue) {
      if { ( [string first [concat "$string1" \"[lindex $job_list 0]]\" $result00] >= 0 ) ||
      ( [string first [concat "$string2" \"[lindex $job_list 0]\" "$string3" ] $result00] >= 0 ) ||
      ( [string first [concat "$string4" [lindex $job_list 0] "$string5" ] $result00] >= 0 ) } {

         puts $CHECK_OUTPUT "second delete OK"
      } else {
         add_proc_error "qdel_iz_125_case_2" -1 "Second delete of case 2), IZ 125 failed:\n$result00"
         set do_continue 0
      }
   }

   if ($do_continue) {
      # Delete it again  (3x)
      set result000 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_list ]

      # Check that we get a response
      if { ( [string first [concat "$string1"  \"[lindex $job_list 0]]\" $result000] >= 0 ) ||
      ( [string first [concat "$string2" \"[lindex $job_list 0]\" "$string3" ] $result000] >= 0 ) ||
      ( [string first [concat "$string4"  [lindex $job_list 0] "$string5" ] $result000] >= 0 ) } {
         puts $CHECK_OUTPUT "third delete OK"
      } else {
         add_proc_error "qdel_iz_125_case_2" -1 "Third delete of case 2), IZ 125 failed:\n$result000"
         set do_continue 0
      }
   }

   if ($do_continue) {
      # Sleep a little
      sleep 10
      
      # Then delete it again! (4x)
      set result01 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_list ]

      # Check that we get a response
      if { ( [string first [concat "$string1" \"[lindex $job_list 0]]\" $result01] >= 0 ) ||
      ( [string first [concat "$string2" \"[lindex $job_list 0]\" "$string3" ] $result01] >= 0 ) ||
      ( [string first [concat "$string4" [lindex $job_list 0] "$string5" ] $result01] >= 0 ) } {
         puts $CHECK_OUTPUT "fourth delete OK"
      } else {
         add_proc_error "qdel_iz_125_case_2" -1 "Fourth delete of case 2), IZ 125 failed:\n$result01"
         set do_continue 0
      }
   }


   if ($do_continue) {
      # And delete again! (5x)
      set result011 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_list ]

      # Check that we get a response
      if { ( [string first [concat "$string1" \"[lindex $job_list 0]]\" $result011] >= 0 ) ||
      ( [string first [concat "$string2" \"[lindex $job_list 0]\" "$string3" ] $result011] >= 0 ) ||
      ( [string first [concat "$string4"  [lindex $job_list 0] "$string5" ] $result011] >= 0 ) } {
         puts $CHECK_OUTPUT "fourth delete OK"
      } else {
         add_proc_error "qdel_iz_125_case_2" -1 "Fifth delete of case 2), IZ 125 failed:\n$result011"
         set do_continue 0
      }
   }

   delete_all_jobs
   set_error 0 "ok"
}

#*******************************
proc qdel_iz_125_case_3 { { user "" } { additional_job_args "" }} {


   global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT
   global CHECK_OUTPUT CHECK_ARCH CHECK_HOST ts_config
   global queue CHECK_HOST CHECK_USER

   set hostname $ts_config(master_host)
   set arch [resolve_arch $hostname]
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"

	
   # 3) Setup list of tasks to be deleted: the first 5; the remaing 5 are
   # for wait and delete.
   set array_job_list [submit_testjobs "" "" 1 "-t 1:10"]
   #puts $CHECK_OUTPUT "Array job list is $array_job_list"

   # Use the tag "qdel_array" to pick out the tasks. Subtasks will be labeled
   # No.1, No.2, ... No.10. Delete "No.5 .. No.10"

   # Setup list of tasks to be deleted: 5 - 10
   set delete_list "$array_job_list.5 $array_job_list.6 $array_job_list.7 $array_job_list.8 $array_job_list.9 $array_job_list.10"

   # Delete here tasks 5 - 10
   set result1 [ start_remote_prog $hostname $CHECK_USER $qdel_program $delete_list ]
   #puts $CHECK_OUTPUT  "result1 is $result1"
   #puts $CHECK_OUTPUT  "deleted jobs list $delete_list"

   # Check now that they have actually been deleted!

   set string1 [translate $hostname 0 1 0 "deleted job-array task "]
   set string2 [translate $hostname 0 1 0 "registered the job-array task "]
   set string3 [translate $hostname 0 1 0 "for deletion "]

   if { (  [string first [concat "$string1" [lindex $delete_list 0] ] $result1] >= 0 ) || 
   (  [string first [concat "$string2" [lindex $delete_list 0] "$string3" ] $result1] >= 0 ) &&
   (  [string first [concat "$string1" [lindex $delete_list 1] ] $result1] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list 1] "$string3" ] $result1] >= 0 ) &&
   (  [string first [concat "$string1" [lindex $delete_list 2] ] $result1] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list 2] "$string3" ] $result1] >= 0 ) &&
   (  [string first [concat "$string1" [lindex $delete_list 3] ] $result1] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list 3] "$string3" ] $result1] >= 0 ) &&
   (  [string first [concat "$string1" [lindex $delete_list 4] ] $result1] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list 4] "$string3" ] $result1] >= 0 ) &&
   (  [string first [concat "$string1" [lindex $delete_list 5] ] $result1] >= 0 )  ||
   (  [string first [concat "$string2" [lindex $delete_list 5] "$string3" ] $result1] >= 0 ) } {
       set_error 0 "ok"
   } else {
       set_error -1  "Case 3) deletion of tasks 5 - 10 failed"
       puts "the OR string is [concat "registered the job-array task " [lindex $delete_list 0] "for deletion" ] "
       puts $CHECK_OUTPUT  "result is $result1"
   }

   # End delete of tasks 5 - 10

   # Setup list of tasks to wait: the remaining 4

   set wait_list "$array_job_list.1 $array_job_list.2 $array_job_list.3 $array_job_list.4"
   set wait_list_delete "$array_job_list.2 $array_job_list.3"

   # Wait for tasks running; delete tasks 2 - 3.

   #wait_for_jobend  $wait_list  qdel_array 200
   set result2 [ start_remote_prog $hostname $CHECK_USER $qdel_program  $wait_list_delete ]
    
   # Check that those tasks have actually been deleted

   if { (  [string first [concat "$string1" [lindex $wait_list_delete 0] ] $result2] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list 0] "$string3" ] $result1] >= 0 ) &&
   (  [string first [concat "$string1" [lindex $wait_list_delete 1] ] $result2] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list 1] "$string3" ] $result1] >= 0 ) } {
      set_error 0 "ok"
   } else {
      set_error -1  "Case 3) deletion of tasks 2 - 3 failed"
      puts $CHECK_OUTPUT  "result is $result2"
   }

   sleep 5

   # Delete here tasks 2 - 5 ; only task 4 should be reported, error state=0

   set delete_list_2_5 "$array_job_list.2 $array_job_list.3 $array_job_list.4 $array_job_list.5"
   set result3 [ start_remote_prog $hostname $CHECK_USER $qdel_program $delete_list_2_5  ]

   sleep 5 

   # Check that only task 4 for was deleted

   set string4 [translate $hostname 0 1 0 "job" ]
   set string5 [translate $hostname 0 1 0 "task" ]
   set string6 [translate $hostname 0 1 0 " does not exist" ]

   if { (  [string first "$string4 \"$array_job_list\" $string5 \"2\"$string6"  $result3] >= 0 ) ||
   (  [string first "$string4 \"$array_job_list\" $string5 \"3\"$string6"  $result3] >= 0 ) ||
   (  [string first [concat "$string1" [lindex $delete_list_2_5 2]  ] $result3] >= 0 ) ||
   (  [string first [concat "$string2" [lindex $delete_list_2_5 2] "$string3" ] $result3] >= 0 ) ||
   (  [string first "$string4 \"$array_job_list\" $string5 \"5\"$string6"  $result3] >= 0 ) } { 
      set_error 0 "ok"
   } else {
      set_error -1  "Case 3) deletion of tasks 2 - 5 failed"
      puts $CHECK_OUTPUT "My string is [concat "registered the job-array task " [lindex $delete_list_2_5 2] "for deletion" ] "
      puts $CHECK_OUTPUT  "result is $result3"
   }

   # Delete here tasks 6 - 7 ; error state=1

   set result4 [ start_remote_prog $hostname $CHECK_USER $qdel_program "$array_job_list.6 $array_job_list.7" ]

   sleep 5

   if { ( [string first "$string4 \"$array_job_list\" $string5 \"6\" $string6"  $result4] >= 0 ) &&
   (  [string first "$string4 \"$array_job_list\" $string5 \"7\" $string6"  $result4] >= 0 ) } { 
      set_error 0 "ok"
   } else {
      set_error -1  "Case 3) deletion of tasks 6 - 7 failed"
      puts $CHECK_OUTPUT  "My string is [concat "$string4" \"$array_job_list\" " $string5" \"6\" $string6"] "
      puts $CHECK_OUTPUT  "result is $result4"
   }
   # A little cleanup
   delete_all_jobs

}

#*******************************
proc qdel_iz_125_case_4 { { user "" } { additional_job_args "" }} {

   global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT
   global CHECK_OUTPUT CHECK_ARCH CHECK_HOST ts_config
   global queue CHECK_HOST CHECK_USER

   set hostname  [lindex $ts_config(execd_nodes) 0]
   set arch [resolve_arch $hostname]
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"


   # Create queues for -pe jobs 


   set testq(load_thresholds) "np_load_avg=7.00"
   add_queue test1.q $hostname testq

   set mype1(pe_name) "mype1"
   set mype1(slots) 2
   set mype1(allocation_rule) "\$pe_slots"
   add_pe mype1
   assign_queues_with_pe_object test1.q $hostname mype1

   add_queue test2.q $hostname testq

   set mype2(pe_name) "mype2"
   set mype2(slots) 2
   set mype2(allocation_rule) "\$pe_slots"
   add_pe mype2
   assign_queues_with_pe_object test2.q $hostname mype2

   # Submit -pe jobs

   puts $CHECK_OUTPUT "submitting job requesting pe mype1 ..."

   set job_id_list ""
   set arguments "-o /dev/null -e /dev/null -h -pe mype1 2"
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 3000" ]
   lappend job_id_list $job_id
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 3000" ]
   lappend job_id_list $job_id
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 3000" ]
   lappend job_id_list $job_id


   puts $CHECK_OUTPUT "submitting job requesting pe mype2 ..."
   set arguments "-o /dev/null -e /dev/null -h -pe mype2 2"
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 3000" ]
   lappend job_id_list $job_id

   # Now delete them

   set result5 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_id_list ]

   set string1 [translate $hostname 0 1 0 "deleted job"]
   
   if { ( [string first [concat "$string1" [lindex $job_id_list 0]] $result5] >= 0 ) &&
   ( [string first [concat "$string1" [lindex $job_id_list 1]] $result5] >= 0 ) &&
   ( [string first [concat "$string1" [lindex $job_id_list 2]] $result5] >= 0 ) &&
   ( [string first [concat "$string1" [lindex $job_id_list 3]] $result5] >= 0 ) } {
      set_error 0 "ok"
      } else {
      set_error -1 "Case 4) deletion of pe tasks failed"
      puts $CHECK_OUTPUT  "result is $result5"
   }


   # Clean up the pe environment

   del_pe mype1
   del_pe mype2
   del_queue test1.q $hostname 0 1
   del_queue test2.q $hostname 0 1

   # Clean up the queues
   delete_all_jobs
}

#*******************************

proc qdel_iz_125_case_5 { { user "" } { additional_job_args "" }} {

   global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT
   global CHECK_OUTPUT CHECK_ARCH CHECK_HOST ts_config
   global queue CHECK_HOST CHECK_USER

   set hostname  [lindex $ts_config(execd_nodes) 0]
   set arch [resolve_arch $hostname]
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"

   # Submit 1000 jobs. Use submit_testjobs 1000, which submits jobs in sets of 20
   # Use 100 for now

   set job_id_list_1000 ""
   for {set count 1} {$count <= 1} {incr count +1} {
      set job_id_4 [submit_testjobs "" "" 100 "" 0]
      set job_id_list_1000 [concat $job_id_list_1000 $job_id_4] 
   }
   # Sleep a little

   sleep 10

   # Now delete all 1000 of them

   set result6 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_id_list_1000 ]
  
   # Sleep a little more

   sleep 10

   # Check that they all actually get deleted. I will sample every 100 jobs for now...

   set string1 [translate $hostname 0 1 0 "deleted job"]
   set string2 [translate $hostname 0 1 0 "registered the job "]
   set string3 [translate $hostname 0 1 0 "for deletion"]
   set string4 [translate $hostname 0 1 0 "job "]
   set string5 [translate $hostname 0 1 0 "does not exist"]
   set string6 [translate $hostname 0 1 0 "Waiting for job"]
   set string7 [translate $hostname 0 1 0 "(qdel_check) to get in pending state"]


   if { ( [string first [concat "$string1" [lindex $job_id_list_1000 0]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 0] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 0] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 0] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 10]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 10] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 10] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 10] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 20]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 20] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 20] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 20] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 30]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 30] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 30] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 30] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 40]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 40] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 40] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 40] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 50]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 50] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 50] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 50] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 60]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 60] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 60] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 60] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 70]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 70] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 70] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 70] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 80]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 80] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 80] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 80] "$string7"] $result6] >= 0 ) ||
   ( [string first [concat "$string1" [lindex $job_id_list_1000 90]] $result6] >= 0 ) ||
   ( [string first [concat "$string2" [lindex $job_id_list_1000 90] "$string3"] $result6] >= 0 ) ||
   ( [string first [concat "$string4" [lindex $job_id_list_1000 90] "$string5"] $result6] >= 0 ) ||
   ( [string first [concat "$string6" [lindex $job_id_list_1000 90] "$string7"] $result6] >= 0 ) } { 
      set_error 0 "ok"
   } else {
      puts $CHECK_OUTPUT  "Case 5) deletion of 1000 tasks failed"
      set_error -1 "result for 1000 qdel's is $result6"
   }

   # Clean up the queues
   delete_all_jobs
}

#                                                             max. column:     |
#****** qdel/qdel_delete_task_range() ******
#
#  NAME
#     qdel_delete_task_range -- ???
#
#  SYNOPSIS
#     qdel_delete_task_range { }
#
#  FUNCTION
#     qdel a valid range of jobs
#
#  INPUTS
#
#  RESULT
#     ???
#
#  EXAMPLE
#     ???
#
#  NOTES
#     ???
#
#  BUGS
#     ???
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_task_range {} {

   global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT
   global CHECK_OUTPUT CHECK_ARCH CHECK_HOST ts_config
   global queue CHECK_HOST CHECK_USER

   set hostname  [lindex $ts_config(execd_nodes) 0]
   set arch [resolve_arch $hostname]
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"
   set qstat_program "$CHECK_PRODUCT_ROOT/bin/$arch/qstat"


   # Submit a task array of 10 tasks
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   set job_id_10 [submit_testjobs "" "" 1 "-t 1:10" ]
   set job_range [concat [lindex $job_id_10 0].1-10]

   # Now delete all 10 of them

   set result10 [ start_remote_prog $hostname $CHECK_USER $qdel_program $job_range ]
 

   # Sleep a little

   sleep 5

   # Now check with qstat that there are no more jobs

   set result11 [ start_remote_prog $hostname $CHECK_USER $qstat_program "" ]

   set string1 [translate $hostname 0 1 0 "qdel_check"]
   set string2 [translate $hostname 0 1 0 "deleted job-array tasks 1-10:1 of job "]

   if { ( [ string first "$string1"  $result11 ] < 0 ) ||
        ( [ string first [concat "$string2" [lindex $job_id_10 0]] $result11 ] >=0  ) } {
      set_error 0 "ok"
   } else {
      set_error -1 "Case 6) of the iz_125 tests was not ok"
      puts $CHECK_OUTPUT "job range is  $job_range"
      puts $CHECK_OUTPUT "result of job range deletion is $result11"
      puts $CHECK_OUTPUT "My string is [concat "$string2" [lindex $job_id_10 0]]"
   }

   # Clean up the queues
   delete_all_jobs
}

#                                                             max. column:     |
#****** qdel/qdel_delete_job_0() ******
# 
#  NAME
#     qdel_delete_job_0 -- ??? 
#
#  SYNOPSIS
#     qdel_delete_job_0 { } 
#
#  FUNCTION
#
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ???
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_job_0 {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT

   delete_all_jobs
   wait_for_end_of_all_jobs 60


   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "0" } output ]
   
   puts $CHECK_OUTPUT "qdel output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qdel exit state: $state"  
 
   if {$state != 1 } {
      set_error -1 "exit state is not 1"
   }

   set output_length [string length $output]
   puts $CHECK_OUTPUT "output length: $output_length"

   if {$output_length < 10 } {
      set_error -1 "possible wrong output - please check output manually"
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qdel/qdel_help() ******
# 
#  NAME
#     qdel_help -- ??? 
#
#  SYNOPSIS
#     qdel_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_help {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_PRODUCT_VERSION_NUMBER
   global qdel_help_lines

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set output [start_sge_bin "qdel" "-help"]

   puts $CHECK_OUTPUT "qdel output    : \n---"
   puts $CHECK_OUTPUT "$output"
   puts $CHECK_OUTPUT "---\n"
   puts $CHECK_OUTPUT "qdel exit state: $prg_exit_state"

   if {$prg_exit_state != 0} {
      set_error -1 "exit state is not 0"
   }

   set output [string trim $output]

   if {[string first $CHECK_PRODUCT_VERSION_NUMBER $output] < 0} {
      set_error -1 "version string ($CHECK_PRODUCT_VERSION_NUMBER) not found"
   } 
 
   set lines [split $output "\n"]
   set nr_of_lines [llength $lines] 

   puts $CHECK_OUTPUT "Output has $nr_of_lines lines"

   if {$nr_of_lines != $qdel_help_lines} {
      add_proc_error "qdel_help" -1 "help output has $nr_of_lines, but expected are $qdel_help_lines lines:\n$output"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qdel/qdel_job_task_list() ******
# 
#  NAME
#     qdel_job_task_list -- ??? 
#
#  SYNOPSIS
#     qdel_job_task_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_job_task_list {} {

    global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH env

    delete_all_jobs
    wait_for_end_of_all_jobs 60

    # submit jobs to delete
    set job_list [submit_testjobs]

    set result 0

    set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel $job_list" } qdel_output ] 
    
    puts $CHECK_OUTPUT "qdel_result = $result"
    puts $CHECK_OUTPUT "qdel_output = $qdel_output"

    # Errorhandling not functional yet because qdel returns always 0 it doesn't matter if the job exists or not
    if { $result != 0 } {
       set_error -1 "qdel_job_task_list: Could not delete jobs (exit status: $result) "
    }

    set time [timestamp]
    while {1} {
       set jobs_deleted 0
       foreach job_id $job_list {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result != -1} {
             incr jobs_deleted 1
          }
       }

       if {$jobs_deleted == 0} {
          set_error 0 "no error"
          return
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 300 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list"
          break  
       }
    }    
}

#                                                             max. column:     |
#****** Checks/qdel/qdel_delete_unknown_jobid() ******
# 
#  NAME
#     qdel_delete_unknown_jobid -- check deletion of unknown jobs / tasks
#
#  SYNOPSIS
#     qdel_delete_unknown_jobid { } 
#
#  FUNCTION
#     Execute qdel commands to delete jobs, tasks and taskranges that
#     are unknown to the system.
#     Checks if the errors output match the expected patterns.
#
#*******************************
proc qdel_delete_unknown_jobid {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_USER

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown jobid
   set unknown_jobid [ expr ( [ lindex $job_list [ expr ( [ llength $job_list] - 1 ) ] ] + 1 ) ]
   lappend job_list $unknown_jobid 
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXIST_SU] "job" $unknown_jobid ]  
   } else {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXIST_SS] "job" $unknown_jobid]  
   }

   qdel_delete_unknown_jobid_proc $job_list "$default_output"

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown taskid
   set last_jobid "[lindex $job_list end]"
   set unknown_taskid 5
   set job_list [lreplace $job_list end end "$last_jobid.$unknown_taskid"]
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASK_UU] $last_jobid $unknown_taskid] 
   } else {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASK_SU] $last_jobid $unknown_taskid] 
   }
   qdel_delete_unknown_jobid_proc $job_list "$default_output"
   delete_job $last_jobid

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown taskid range
   set last_jobid "[lindex $job_list end]"
   set empty_taskrange "5-10:2"
   set job_list [lreplace $job_list end end "$last_jobid.$empty_taskrange"]
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASKRANGE_UUUU] $last_jobid "5" "10" "2"]
   } else {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASKRANGE_SUUU] $last_jobid "5" "9" "2"]
   }
   qdel_delete_unknown_jobid_proc $job_list "$default_output"
   delete_job $last_jobid 1
   # wait for job to leave queue
#      sleep 5
}

proc qdel_delete_unknown_jobid_proc {job_list default_output} {
  global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH env

  set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel $job_list" } qdel_output ] 

  puts $CHECK_OUTPUT "qdel_result = $result"
  puts $CHECK_OUTPUT "qdel_output = $qdel_output"

  if { [string first "\[" $qdel_output ] == 0  } {
     #remove [xxxxx] message id
     puts $CHECK_OUTPUT "removing message id from output ..."
     set cut [string first "\]" $qdel_output ]
     incr cut 2
     set qdel_output [string range $qdel_output $cut end] 
     puts $CHECK_OUTPUT "qsub qdel_output is: \"$qdel_output\""
  }
 

  if { $result != 0 } {
     set_error -1 "exit state is not 0"
  } 

  set nr_of_jobs [llength $job_list]
  set qd_out [split $qdel_output "\n"]
  set nr_of_output_lines [llength $qd_out]

  puts $CHECK_OUTPUT "nr_of_jobs = $nr_of_jobs"
  puts $CHECK_OUTPUT "nr_of_output_lines = $nr_of_output_lines"

  if { $nr_of_jobs != $nr_of_output_lines } {
     set_error -1 "nr of jobs doesn't match output lines"
  }

  set last_job_output [ lindex $qd_out [ expr ( $nr_of_output_lines - 1 ) ] ]
  if { [string first "\[" $last_job_output ] == 0  } {
     #remove [xxxxx] message id
     puts $CHECK_OUTPUT "removing message id from output ..."
     set cut [string first "\]" $last_job_output ]
     incr cut 2
     set last_job_output [string range $last_job_output $cut end] 
     puts $CHECK_OUTPUT "qsub last_job_output is: \"$last_job_output\""
  }

  puts $CHECK_OUTPUT "last job output: \"$last_job_output\""
  puts $CHECK_OUTPUT "should be:       \"$default_output\""

  if { [ string compare $default_output $last_job_output  ] != 0 } {
     set_error -1 "deleting of not existing job produces wrong output (\"$last_job_output\")"
  } else {
     puts $CHECK_OUTPUT "ok"
  }

  set_error 0 "ok"
}




#                                                             max. column:     |
#****** qdel/qdel_delete_negative_jobid() ******
# 
#  NAME
#     qdel_delete_negative_jobid -- ??? 
#
#  SYNOPSIS
#     qdel_delete_negative_jobid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_negative_jobid {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT


   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-1" } output ]
   
   puts $CHECK_OUTPUT "qdel output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qdel exit state: $state"  
 
   if {$state != 1 } {
      set_error -1 "exit state is not 1"
   }

   set output_length [string length $output]
   puts $CHECK_OUTPUT "output length: $output_length"

   if {$output_length < 10 } {
      set_error -1 "possible wrong output - please check output manually"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qdel/qdel_all() ******
# 
#  NAME
#     qdel_all -- ??? 
#
#  SYNOPSIS
#     qdel_all { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_all {} {
   global ts_config
   global CHECK_OUTPUT CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   if {$ts_config(gridengine_version) == 53} {
      set all_args "all"
      set all_args_remote "all"
   } else {
      set all_args "*"
      set all_args_remote "'*'"
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs] 
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"
 

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"
 
   
   # now delete jobs of user 1
   set result [ catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "$all_args" } qdel_output ] 
   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output" 
   if { $result != 0 } {
       set_error -1 "qdel_job_task_list: Could not delete jobs $job_list_user1 (exit status: $result) "
   }

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list_user1 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 4} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 60 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list_user1"
          break  
       }
       puts -nonewline $CHECK_OUTPUT "."
       flush $CHECK_OUTPUT
       sleep 1 
   }    


   # now check if user2 has still his jobs
   foreach job_id $job_list_user2 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(3) jobs of different user deleted" 
          }
   } 
  
   # now submit new jobs for user 1
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"

   # now delete jobs of user 2
   set result [start_sge_bin "qdel" "$all_args_remote" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list_user2 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 4} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 60 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list_user2"
          break  
       }
       puts -nonewline $CHECK_OUTPUT "."
       flush $CHECK_OUTPUT
       sleep 1
   }     

   # now check if user1 has still his jobs
   foreach job_id $job_list_user1 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(4) jobs of different user deleted" 
          }
   } 

   # now delete jobs of user1
   set result [ catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "$all_args" } qdel_output ] 
   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output" 
   if { $result != 0 } {
       set_error -1 "qdel_job_task_list: Could not delete jobs $job_list_user1 (exit status: $result) "
   }

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list_user1 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 4} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 60 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list_user1"
          break  
       }
       sleep 1
       puts -nonewline $CHECK_OUTPUT "."
       flush $CHECK_OUTPUT
   }   


   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qdel/qdel_uall() ******
# 
#  NAME
#     qdel_uall -- ??? 
#
#  SYNOPSIS
#     qdel_uall { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_uall {} {
   global ts_config
   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER 
   global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 
   
   delete_all_jobs
   wait_for_end_of_all_jobs 60

   if {$ts_config(gridengine_version) == 53} {
      set uall_args "-uall"
   } else {
      set uall_args "-u '*'"
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"
 
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   set job_list_user3 [submit_testjobs $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 3 has jobs $job_list_user3"


   # now delete all jobs as user 2 ( only submit user )
   set result [start_sge_bin "qdel" $uall_args "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now delete all jobs as user 3 ( only submit user )
   set result [start_sge_bin "qdel" $uall_args "" $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # test if all jobs are still there:
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"
   puts $CHECK_OUTPUT "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(5) jobs of different user deleted" 
          }
   } 

   # now delete all jobs as user 1 ( manager )
   set result [start_sge_bin "qdel" $uall_args "" $CHECK_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now check if all jobs are deleted
   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 12} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 300 } {
          set_error -1 "timeout while waiting for end of testjobs $all_jobs"
          break  
       }
       sleep 1
   }   
   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qdel/qdel_user_list() ******
# 
#  NAME
#     qdel_user_list -- ??? 
#
#  SYNOPSIS
#     qdel_user_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_user_list {} {

   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_HOST
   global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH
   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"
 
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   set job_list_user3 [submit_testjobs $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 3 has jobs $job_list_user3"


   # now delete all jobs as user 2 ( only submit user ) of user 3 ( only submit user)
   set result [start_sge_bin "qdel" "-u $CHECK_SECOND_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now delete all jobs as user 2 ( only submit user ) of user 1 ( manager )
   set result [start_sge_bin "qdel" "-u $CHECK_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now delete all jobs as user 2 ( only submit user ) of user 1 && user 3
   set result [start_sge_bin "qdel" "-u $CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 


   # test if all jobs are still there:
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"
   puts $CHECK_OUTPUT "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(1) jobs of different user deleted" 
          }
   } 


   # now delete all jobs as user 2 ( only submit user ) of user 2 ( himself ) 
   set result [start_sge_bin "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now test if his jobs are deleted
   if { [ are_jobs_deleted $job_list_user2] != 0 } {
      set_error -1 "(1) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER are deleted"
   } 

   # submit new jobs for user 2
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"



   # now delete all jobs as user 2
   set result [start_sge_bin "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "starting qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"
   puts $CHECK_OUTPUT "as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now test if his jobs are deleted
   if { [ are_jobs_deleted $job_list_user2] != 0 } {
      set_error -1 "(2) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 
   # now test if the jobs of user1 and user3 are still here
   set all_jobs "$job_list_user1 $job_list_user3"
   puts $CHECK_OUTPUT "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             puts $CHECK_OUTPUT "job $job_id is not running"
             set_error -1 "(2) jobs of different user deleted" 
          }
   }  

   # submit new jobs for user 2
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"

   # now delete all jobs as user 1 (manager)
   set result [ catch { 
      eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" 
   } qdel_output ] 
   puts $CHECK_OUTPUT "starting qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"
   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output" 
   if { $result != 0 } {
       set_error -1 "Could not delete jobs $job_list_user1 (exit status: $result)"
   }

   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3" 

   set mytimeout [ expr ( [timestamp] + 30 ) ]
   set was_error 1
   while { [timestamp] < $mytimeout } {
      if { [ are_jobs_deleted $all_jobs] == 0 } {
         set was_error 0
         break
      } 
   }
   if { $was_error != 0 } {
      set_error -1 "not all jobs are deleted ($all_jobs)"
   } else {
      set_error 0 "no errors"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_force() ******
# 
#  NAME
#     qdel_force -- ??? 
#
#  SYNOPSIS
#     qdel_force { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_force {} {
   global ts_config
   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER 
   global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_HOST pending_state CHECK_PRODUCT_TYPE CHECK_COMMD_PORT

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # unset ENABLE_FORCED_QDEL with set_config
   get_config saved_array 
   puts $CHECK_OUTPUT "qmaster_params=$saved_array(qmaster_params)"
   set saved_qmaster_params $saved_array(qmaster_params) 
   if { $saved_qmaster_params != "none" } {
      set change_array(qmaster_params) "none"  
      set_config change_array
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   set test_host [lindex $ts_config(execd_nodes) 0]

   # shutdown execd
   set output [start_sge_bin "qconf" "-ke $test_host"]
   puts $output
   sleep 2

   # now test if his jobs still running or pending 
   set all_jobs "$job_list_user1 $job_list_user2"
   foreach job_id $all_jobs {
       set result [ is_job_running $job_id "qdel_check" ]
       if {$result == -1} {
          set_error -1 "jobs $all_jobs should still be in the queueing system" 
       }
   }  

   # delete the jobs of user 1 as user 1 without -f switch
   set qdel_output [start_sge_bin "qdel" $job_list_user1 "" "" result]

   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output"

   if { $result != 0 } {
      set_error -1 "exit state is not 0"
   }    

   # delete the jobs of user 2 as user 2 without -f switch
   set result [start_sge_bin "qdel" "$job_list_user2" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   if { $pending_state == 0} {
      # when jobs were in running state
      puts $CHECK_OUTPUT "running jobs must still be in the queue"
      sleep 10
      # now test if his jobs still running or pending 
      set all_jobs "$job_list_user1 $job_list_user2"
      foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "jobs $all_jobs should still be in the queueing system" 
          }
      }
     
      # now restart execd
      startup_execd $test_host
   } 

   # wait for deletion of the jobs
   if { [ are_jobs_deleted $all_jobs] != 0 } {
       set_error -1 "(3) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 

   if {$pending_state != 0} { 

      # now restart execd
      startup_execd $test_host
   }
  # ok - qdel without execd is ok, now check the -f option 

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   # shutdown execd
   set output [start_sge_bin "qconf" "-ke $test_host"]
   puts $output
   sleep 2

   # now test if his jobs still running or pending 
   set all_jobs "$job_list_user1 $job_list_user2"
   foreach job_id $all_jobs {
      set result [ is_job_running $job_id "qdel_check" ]
      if {$result == -1} {
         set_error -1 "jobs $all_jobs should still be in the queueing system" 
      }
   }  

   # delete the jobs of user 1 as user 1 with -f switch
   set qdel_output [start_sge_bin "qdel" "-f $job_list_user1" "" "" result]

   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output"

   if { $result != 0 } {
      set_error -1 "exit state is not 0"
   }    

   # delete the jobs of user 2 as user 2 with -f switch
   set result [start_sge_bin "qdel" "-f $job_list_user2" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER prg_exit_state 120]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # wait for deletion of the jobs of user 1 (manager)
   if { [ are_jobs_deleted $job_list_user1] != 0 } {
       set_error -1 "(4) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 

   if {$pending_state != 0} {
      # wait for deletion of the jobs of user 2 (submit user)
      if { [ are_jobs_deleted $job_list_user2] != 0 } {
          set_error -1 "(5) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
      }  
   } else {
      puts $CHECK_OUTPUT "running jobs of user $CHECK_FIRST_FOREIGN_SYSTEM_USER must still be in the queue"
      sleep 10
      # if jobs were running the submituser (user2) can't use the force flag!   
      # now test if his jobs still running or pending 
      foreach job_id $job_list_user2 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "jobs $all_jobs should still be in the queueing system" 
          }
      }
      
      # set ENABLE_FORCED_QDEL with set_config
      set change_array(qmaster_params) "ENABLE_FORCED_QDEL" 
      set_config change_array          
      puts $CHECK_OUTPUT "qmaster_params set to $change_array(qmaster_params)"

      # delete the jobs of user 2 as user 2 with -f switch
      set result [start_sge_bin "qdel" "-f $job_list_user2" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER prg_exit_state 120]
      puts $CHECK_OUTPUT "qdel_output = \n$result" 

      # wait for deletion of the jobs of user 2 (submit user) (now it must go)
      if { [ are_jobs_deleted $job_list_user2] != 0 } {
          set_error -1 "(6) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted (ENABLE_FORCED_QDEL is not working)"
      }  

   } 

   set change_array(qmaster_params) $saved_qmaster_params
   set_config change_array
   puts $CHECK_OUTPUT "qmaster_params set to $change_array(qmaster_params)"

   # now restart execd
   startup_execd $test_host
   wait_for_load_from_all_queues 300

   set_error 0 "no errors"
}

# ------------------------------------------

