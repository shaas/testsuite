#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qdel_init_level"

# define test's name and run level descriptions
set check_name            "qdel"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   3
set check_description(0)  "checking all options in job pending state"
set check_description(1)  "checking all options in job pending and hold state"
set check_description(2)  "checking all options in job running state"
set check_description(3)  "checking all options in job running and hold state" 

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "qdel_setup"
set check_cleanup_function "qdel_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "qdel_help"                   ;# print this help
lappend check_functions "qdel_submit_delete_when_transfered"
lappend check_functions "qdel_job_task_list"          ;# delete all jobs given in list
lappend check_functions "qdel_delete_job_0"           ;# try to delete job id 0
lappend check_functions "qdel_delete_unknown_jobid"   ;# delete job not running
lappend check_functions "qdel_delete_negative_jobid"
lappend check_functions "qdel_all"                   ;# delete all jobs of current user
lappend check_functions "qdel_uall"                  ;# delete all jobs of all users
lappend check_functions "qdel_user_list"             ;# delete all jobs of users specified in list
lappend check_functions "qdel_force"                 ;# force action
lappend check_functions "qdel_iz_125_case_2"         ;# implement Case 2) of iz 125 
lappend check_functions "qdel_iz_125_case_3"         ;# implement Case 3) of iz 125 
lappend check_functions "qdel_iz_125_case_4"         ;# implement Case 4) of iz 125 
lappend check_functions "qdel_iz_125_case_5"         ;# implement Case 5) of iz 125 
lappend check_functions "qdel_delete_task_range"     ;# implement task range deletion
lappend check_functions "qdel_delete_large_array"    ;# implement large array deletion

proc qdel_init_level {} {
  global CHECK_ACT_LEVEL
  global hold_state pending_state
if {$CHECK_ACT_LEVEL != 2} {
   return -1
}
  switch -- $CHECK_ACT_LEVEL {
     "0" { set hold_state 0 ; set pending_state 1 ; return 0 }
     "1" { set hold_state 1 ; set pending_state 1 ; return 0 }
     "2" { set hold_state 0 ; set pending_state 0 ; return 0 }
     "3" { set hold_state 1 ; set pending_state 0 ; return 0 }
  }

  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

#                                                             max. column:     |
#****** qdel/qdel_setup() ******
# 
#  NAME
#     qdel_setup -- ??? 
#
#  SYNOPSIS
#     qdel_setup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_setup {} {
   global ts_config
   global qdel_host qdel_queue qdel_qinstance

   set qdel_host [host_conf_get_suited_hosts]
   set qdel_queue "qdel.q"
   set qdel_qinstance [get_queue_instance $qdel_queue $qdel_host]

   set q_param(load_thresholds)       "np_load_avg=7.00"
   set q_param(slots)                 "50"

   add_queue $qdel_queue $qdel_host q_param
global check_functions
set check_functions "qdel_force"
}

proc qdel_translate_message {msg {p1 ""} {p2 ""} {p3 ""}} {
   global ts_config 

   set ret ""

   switch -exact -- $msg {
      ALREADY_DELETED {
         set ret [translate_macro MSG_JOB_ALREADYDELETED_U $p1]
      }
      REGISTERED_TASK {
         set ret [translate_macro MSG_JOB_REGDELTASK_SUU $p1 $p2 $p3]
      }
      REGISTERED_JOB {
         if {$ts_config(gridengine_version) >= 62} {
            set ret [translate_macro MSG_JOB_REGDELX_SSU $p1 "job" $p2]
         } else {
            set ret [translate_macro MSG_JOB_REGDELJOB_SU $p1 $p2]
         }
      }
      DELETED_TASK {
         set ret [translate_macro MSG_JOB_DELETETASK_SUU $p1 $p2 $p3]
      }
      DELETED_TASKS {
         set ret [translate_macro MSG_JOB_DELETETASKS_SSU $p1 $p2 $p3]
      }
      DELETED_JOB {
         if {$ts_config(gridengine_version) >= 62} {
            set ret [translate_macro MSG_JOB_DELETEX_SSU $p1 "job" $p2]
         } else {
            set ret [translate_macro MSG_JOB_DELETEJOB_SU $p1 $p2]
         }
      }
      DOESNOTEXIST_JOB {
         set ret [translate_macro MSG_SGETEXT_DOESNOTEXIST_SS "job" $p1]
      }
      DOESNOTEXIST_TASK {
         set ret [translate_macro MSG_SGETEXT_DOESNOTEXISTTASK_SU $p1 $p2]
      }
   }

}

#                                                             max. column:     |
#****** qdel/qdel_cleanup() ******
# 
#  NAME
#     qdel_cleanup -- ??? 
#
#  SYNOPSIS
#     qdel_cleanup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_cleanup {} {
   global ts_config
   global qdel_queue qdel_host

   delete_all_jobs
   wait_for_end_of_all_jobs

   del_queue $qdel_queue $qdel_host 0 1
}

proc qdel_submit_delete_when_transfered {} {
   global ts_config
   global CHECK_USER
   global CHECK_ACT_LEVEL

   # we only execute this check in runlevel 0 - the other runlevels have no meaning here
   if {$CHECK_ACT_LEVEL == 0} {
      # cleanup from earlier checks
      delete_all_jobs
      wait_for_end_of_all_jobs

      # we submit sleeper jobs and delete them immediately after they entered
      # transfering / running state
      # we do this 25 times for every architecture
      set job_script "$ts_config(product_root)/examples/jobs/sleeper.sh"
      set runs 25
      while {$runs > 0} { 
         foreach host $ts_config(unique_arch_nodes) { 
            set qinstance [get_queue_instance "all.q" $host]
            set arguments "-o /dev/null -e /dev/null -q $qinstance"
            set job_id [submit_job "$arguments $job_script"]
            if {$job_id > 0} {
               trigger_scheduling
               set job_state [wait_for_jobstart $job_id "leeper" 120]
               if {$job_state == -1} {
                  set runs 0
               }
               delete_job $job_id
            }
         }
         incr runs -1
      }
      wait_for_end_of_all_jobs 100
   }

   # clear possible error states of queues
   foreach host $ts_config(execd_nodes) {
      set qinstance [get_queue_instance "all.q" $host]
      set output [start_sge_bin "qmod" "-c $qinstance"]
      ts_log_fine $output
   }
}

#                                                             max. column:     |
#****** qdel/are_jobs_deleted() ******
# 
#  NAME
#     are_jobs_deleted -- ??? 
#
#  SYNOPSIS
#     are_jobs_deleted { job_list } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     job_list - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc are_jobs_deleted {job_list} {
   global ts_config

   set del_jobs {}
   set time [timestamp]
   while {1} {
      set jobs_deleted 0
      foreach job_id $job_list {
         set result [is_job_running $job_id "qdel_check"]
         if {$result == -1} {
            if {[lsearch $del_jobs "$job_id"] != 0} {
               lappend del_jobs $job_id
            }
            incr jobs_deleted 1
         }
      }
     
      ts_log_fine "Jobs_deleted: $del_jobs"
      ts_log_fine "All jobs:     $job_list"
 
      if {$jobs_deleted == [llength $job_list]} {
         return 0
      }

      set runtime [expr [timestamp] - $time]
      if {$runtime >= 120} {
         return -1
      }
      sleep 1
   }
}

#                                                             max. column:     |
#****** qdel/submit_testjobs() ******
# 
#  NAME
#     submit_testjobs -- ??? 
#
#  SYNOPSIS
#     submit_testjobs { { user "" } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     { user "" } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc submit_testjobs {{user ""} {additional_job_args ""} {testjob_count "4"} {array_job ""} {check_job_state 1}} {
   global ts_config CHECK_USER
   global qdel_qinstance hold_state pending_state

   set joblist {}
   set jobargs "$array_job -o /dev/null -e /dev/null -N qdel_check"

   if {$pending_state == 1} {
      set in_a_year [clock scan "1 year"]
      set start [clock format $in_a_year -format "%Y%m%d%H%M.%S"]
      set jobargs "$jobargs -a $start"   ;# start in a year from now

      if {$hold_state == 1} {
         set jobargs "$jobargs -h"   ;# set hold flag
      }
   }
 
   set jobargs "$additional_job_args $jobargs -q $qdel_qinstance $ts_config(product_root)/examples/jobs/sleeper.sh 3000"

   if {$user == ""} {
      set user $CHECK_USER
   }
  
   # no user specified (using local user name (starter of testsuite))
   for {set i 0} {$i < $testjob_count} {incr i} {
      set jobresult [submit_job $jobargs 1 60 "" $user]     ;# submit_job has it's own error handling
      if {$jobresult > 0} {
         lappend joblist $jobresult
      }
   }

   if {$check_job_state} {
      if {$pending_state == 0} {
         # wait for all job to run
         foreach elem $joblist {
            wait_for_jobstart  $elem "qdel_check" 400
         }

         if {$hold_state == 1} {
            # set hold flag for all jobs 
            foreach elem $joblist {
               hold_job $elem
            }
         }
      } else {
         # wait for all job to get in pending state
         foreach elem $joblist {
            wait_for_jobpending $elem "qdel_check" 400
         }
      }
   }

   return $joblist
}

#                                                             max. column:     |
#****** qdel/qdel_iz_125_case_x() ******
#
#  NAME
#     qdel_iz_125_case_x -- ???
#
#  SYNOPSIS
#     qdel_iz_125_case_x { { user "" } }
#
#  FUNCTION
#     ???
#
#  INPUTS
#     { user "" } - ???
#
#  RESULT
#     ???
#
#  EXAMPLE
#     ???
#
#  NOTES
#      Scenarios:
#
#     2) more than one qdel JOBID should always return a status text
#	 see qdel/qdel_125_case_2()
#
#     3) test array qdel:
#     a) submit array 1-10
#        delete tasks 5-10
#     b) wait for task running, delete tasks (2-3)
#     c) delete tasks 2-5 (only task 4 should be reported, error state=0)
#     d) delete 6-7 (error state=1)
#
#
#    [  ( check if it isn't already done)
#       test deletion of single job:
#        a) job is pending
#        b) job is running
#        c) job is unkown ]
#
#	see qdel/qdel_125_case_3()
#
#     4) New test: submit and then delete -pe jobs
#        see qdel/qdel_125_case_4()
#
#     5) New test: submit 1000 jobs, delete them, check that they are all deleted.
#        see qdel/qdel_125_case_5()
#
#     6) New test: submit a task array and delete the range of tasks
#        jobid.1-jobid.10
#
#  BUGS
#     ???
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_iz_125_case_2 {} {
   global ts_config CHECK_USER
  
   # 2) Submit a job.
   set job_list [submit_testjobs "" "" 1]

   # in case of errors, break
   set do_continue 1

   # these are the messages we might get
   set msg_deleted    [qdel_translate_message DELETED_JOB $CHECK_USER $job_list]
   set msg_registered [qdel_translate_message REGISTERED_JOB $CHECK_USER $job_list]
   set msg_already    [qdel_translate_message ALREADY_DELETED $job_list]
   set msg_notexist   [qdel_translate_message DOESNOTEXIST_JOB $job_list]

   # first delete
   set output [start_sge_bin "qdel" $job_list]

   if {[string first $msg_deleted $output] >= 0 ||
       [string first $msg_registered $output] >= 0} {
  	   ts_log_fine "first delete OK"
   } else {
	   ts_log_severe "First delete of case 2), IZ 125 failed:\n$output"
      set do_continue 0
   }

   # second delete
   if {$do_continue} {
      set output [start_sge_bin "qdel" $job_list]

      # Check that we get a response
      # qdel always has to return some text.
      # if output is empty, we hit IZ 1860
      if {[string trim $output] == ""} {
         ts_log_severe "qdel didn't return any text - this is IZ 1860"
         set do_continue 0
      }

      if {$do_continue} {
         if {[string first $msg_already $output] >= 0 ||
             [string first $msg_notexist $output] >= 0} {
            ts_log_fine "second delete OK"
         } else {
            ts_log_severe "Second delete of case 2), IZ 125 failed:\n$output"
            set do_continue 0
         }
      }
   }

   # third delete
   if {$do_continue} {
      set output [start_sge_bin "qdel" $job_list]

      # Check that we get a response
      if {[string first $msg_already $output] >= 0 ||
          [string first $msg_notexist $output] >= 0} {
         ts_log_fine "third delete OK"
      } else {
         ts_log_severe "Third delete of case 2), IZ 125 failed:\n$output"
         set do_continue 0
      }
   }

   # fourth delete
   if {$do_continue} {
      # Sleep a little - then the job should no longer be there
      sleep 10
      
      set output [start_sge_bin "qdel" $job_list]

      # Check that we get a response
      if {[string first $msg_notexist $output] >= 0} {
         ts_log_fine "fourth delete OK"
      } else {
         ts_log_severe "Fourth delete of case 2), IZ 125 failed:\n$output"
         set do_continue 0
      }
   }


   # fifth delete
   if {$do_continue} {
      set output [start_sge_bin "qdel" $job_list]

      # Check that we get a response
      if {[string first $msg_notexist $output] >= 0} {
         ts_log_fine "fifth delete OK"
      } else {
         ts_log_severe "Fifth delete of case 2), IZ 125 failed:\n$output"
         set do_continue 0
      }
   }

   delete_all_jobs
}

#*******************************
proc qdel_iz_125_case_3 {} {
   global ts_config CHECK_USER

   # 3) Setup list of tasks to be deleted: the first 5; the remaing 5 are
   # for wait and delete.
   set job [submit_testjobs "" "" 1 "-t 1:10"]

   # Use the tag "qdel_array" to pick out the tasks. Subtasks will be labeled
   # No.1, No.2, ... No.10. Delete "No.5 .. No.10"

   # Setup list of tasks to be deleted: 5 - 10
   set delete_list "$job.5 $job.6 $job.7 $job.8 $job.9 $job.10"

   # Delete here tasks 5 - 10
   set output [start_sge_bin "qdel" $delete_list]

   # Check now that they have actually been deleted!
   if {([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job  5] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job  5] $output] >= 0    ) &&
       ([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job  6] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job  6] $output] >= 0    ) &&
       ([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job  7] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job  7] $output] >= 0    ) &&
       ([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job  8] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job  8] $output] >= 0    ) &&
       ([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job  9] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job  9] $output] >= 0    ) &&
       ([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job 10] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job 10] $output] >= 0    )} {
      ts_log_fine "deletion of tasks 5-10 OK"
   } else {
       ts_log_severe  "Case 3) deletion of tasks 5-10 failed:\n$output"
   }
   # End delete of tasks 5 - 10

   # Setup list of tasks to wait: the remaining 4
   set wait_list "$job.1 $job.2 $job.3 $job.4"
   set wait_list_delete "$job.2 $job.3"

   # Wait for tasks running; delete tasks 2 - 3.
   set output [start_sge_bin "qdel" $wait_list_delete]
    
   # Check that those tasks have actually been deleted
   if {([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job 2] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job 2] $output] >= 0    ) &&
       ([string first [qdel_translate_message DELETED_TASK    $CHECK_USER $job 3] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job 3] $output] >= 0    )} {
      ts_log_fine "deletion of tasks 2-3 OK"
   } else {
      ts_log_severe  "Case 3) deletion of tasks 2-3 failed:\n$output"
   }

   # wait some time for the already deleted tasks to vanish
   sleep 10

   # Delete here tasks 2 - 5 ; only task 4 should be reported, error state=0
   set delete_list_2_5 "$job.2 $job.3 $job.4 $job.5"
   set output [start_sge_bin "qdel" $delete_list_2_5]

   # Check that only task 4 for was deleted.
   if {([string first [qdel_translate_message DELETED_TASK      $CHECK_USER $job 4] $output] >= 0 || 
        [string first [qdel_translate_message REGISTERED_TASK   $CHECK_USER $job 4] $output] >= 0    ) &&
        [string first [qdel_translate_message DOESNOTEXIST_TASK $job 2] $output] >= 0 &&
        [string first [qdel_translate_message DOESNOTEXIST_TASK $job 3] $output] >= 0 &&
        [string first [qdel_translate_message DOESNOTEXIST_TASK $job 5] $output] >= 0    } {
      ts_log_fine "deletion of task 4 OK, 2, 3, and 5 didn't exist"
   } else {
      ts_log_severe  "Case 3) deletion of tasks 2 - 5 failed:\n$output"
   }

   # Delete here tasks 6 - 7 ; they do not exist.
   set output [start_sge_bin "qdel" "$job.6 $job.7"]

   if {[string first [qdel_translate_message DOESNOTEXIST_TASK $job 6] $output] >= 0 &&
       [string first [qdel_translate_message DOESNOTEXIST_TASK $job 7] $output] >= 0    } {
      ts_log_fine "deletion of tasks 6 and 7 failed as expected"
   } else {
      ts_log_severe  "Case 3) deletion of tasks 6 - 7 failed:\n$output"
   }

   # A little cleanup
   delete_all_jobs
   wait_for_end_of_all_jobs
}

#*******************************
proc qdel_iz_125_case_4 {} {
   global ts_config CHECK_USER
   global qdel_host

   # Create queues for -pe jobs 
   set testq(load_thresholds) "np_load_avg=7.00"
   add_queue "test1.q" $qdel_host testq

   set mype1(pe_name) "mype1"
   set mype1(slots) 2
   set mype1(allocation_rule) "\$pe_slots"
   add_pe "mype1" mype1
   assign_queues_with_pe_object "test1.q" $qdel_host mype1

   add_queue "test2.q" $qdel_host testq

   set mype2(pe_name) "mype2"
   set mype2(slots) 2
   set mype2(allocation_rule) "\$pe_slots"
   add_pe "mype2" mype2
   assign_queues_with_pe_object "test2.q" $qdel_host mype2

   # Submit -pe jobs
   ts_log_fine "submitting jobs requesting pe mype1 ..."

   set job_id_list {}
   set arguments "-o /dev/null -e /dev/null -h -pe mype1 2"
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 3000"]
   lappend job_id_list $job_id
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 3000"]
   lappend job_id_list $job_id
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 3000"]
   lappend job_id_list $job_id

   ts_log_fine "submitting job requesting pe mype2 ..."
   set arguments "-o /dev/null -e /dev/null -h -pe mype2 2"
   set job_id [submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 3000"]
   lappend job_id_list $job_id

   # Now delete them
   set output [start_sge_bin "qdel" $job_id_list]

   if {[string first [qdel_translate_message DELETED_JOB $CHECK_USER [lindex $job_id_list 0]] $output] >= 0 &&
       [string first [qdel_translate_message DELETED_JOB $CHECK_USER [lindex $job_id_list 1]] $output] >= 0 &&
       [string first [qdel_translate_message DELETED_JOB $CHECK_USER [lindex $job_id_list 2]] $output] >= 0 &&
       [string first [qdel_translate_message DELETED_JOB $CHECK_USER [lindex $job_id_list 3]] $output] >= 0    } {
      } else {
      ts_log_severe "Case 4) deletion of pe jobs failed:\n$output"
   }

   # Clean up the pe environment
   del_pe "mype1"
   del_pe "mype2"
   del_queue "test1.q" $qdel_host 0 1
   del_queue "test2.q" $qdel_host 0 1

   # Clean up the queues
   delete_all_jobs
}

#*******************************

proc qdel_iz_125_case_5 {} {
   global ts_config CHECK_USER

   # we work on this number of jobs
   # we verify only every n'th job
   set num_jobs 100
   set step 10

   # Submit n jobs.
   set jobs [submit_testjobs "" "" $num_jobs "" 0]

   # Sleep a little
   sleep 10

   # Now delete all of them
   set output [start_sge_bin "qdel" $jobs]
  
   # Check that they all actually get deleted.
   for {set i 0} {$i < $num_jobs} {incr i $step} {
      set job [lindex $jobs $i]
      if {[string first [qdel_translate_message DELETED_JOB    $CHECK_USER $job 4] $output] >= 0 || 
          [string first [qdel_translate_message REGISTERED_JOB $CHECK_USER $job 4] $output] >= 0    } {
         ts_log_fine "job $i ($job) was deleted"
      } else {
         ts_log_severe "qdel on $num_jobs failed, job $i ($job) was not deleted:\n$output"
      }
   }

   # Clean up the queues
   delete_all_jobs
}

#                                                             max. column:     |
#****** qdel/qdel_delete_task_range() ******
#
#  NAME
#     qdel_delete_task_range -- ???
#
#  SYNOPSIS
#     qdel_delete_task_range { }
#
#  FUNCTION
#     qdel a valid range of jobs
#
#  INPUTS
#
#  RESULT
#     ???
#
#  EXAMPLE
#     ???
#
#  NOTES
#     ???
#
#  BUGS
#     ???
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_task_range {} {
   global ts_config CHECK_USER

   # Submit a task array of 10 tasks
   set job [submit_testjobs "" "" 1 "-t 1-10"]
   set job_range "${job}.1-10"

   # Now delete all 10 of them
   set output [start_sge_bin "qdel" $job_range]
   if {[string first [qdel_translate_message DELETED_TASKS   $CHECK_USER "1-10:1" $job] $output] >= 0 || 
       [string first [qdel_translate_message REGISTERED_TASK $CHECK_USER $job 1] $output] >= 0           } {
      ts_log_fine "deletion of $job_range succeeded"
   } else {
      ts_log_severe "deletion of $job_range failed:\n$output"
   }

   # Sleep a little
   sleep 10

   # Now check with qstat that there are no more jobs
   set output [start_sge_bin "qstat" ""]
   if {[string trim $output] != ""} {
      ts_log_severe "job $job_range was not deleted:\n$output"
   }

   # Clean up the queues
   delete_all_jobs
}

#                                                             max. column:     |
#****** qdel/qdel_delete_job_0() ******
# 
#  NAME
#     qdel_delete_job_0 -- ??? 
#
#  SYNOPSIS
#     qdel_delete_job_0 { } 
#
#  FUNCTION
#
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ???
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_job_0 {} {
   global ts_config

   delete_all_jobs
   wait_for_end_of_all_jobs

   set output [start_sge_bin "qdel" "0"]
   if {$prg_exit_state != 1} {
      ts_log_severe "prg_exit_state is not 1:\n$output"
   }

   if {[string length $output] < 10} {
      ts_log_severe "possible wrong output - please check output manually:\n$output"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_help() ******
# 
#  NAME
#     qdel_help -- ??? 
#
#  SYNOPSIS
#     qdel_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_help {} {
   global ts_config CHECK_PRODUCT_VERSION_NUMBER
   global qdel_help_lines

   delete_all_jobs
   wait_for_end_of_all_jobs

   set output [start_sge_bin "qdel" "-help"]

   if {$prg_exit_state != 0} {
      ts_log_severe "qdel -help failed:\n$output"
   }

   set output [string trim $output]
   if {[string first $CHECK_PRODUCT_VERSION_NUMBER $output] < 0} {
      ts_log_severe "version string ($CHECK_PRODUCT_VERSION_NUMBER) not found in qdel -help output:\n$output"
   } 
 
   set lines [split $output "\n"]
   set nr_of_lines [llength $lines] 

   if {$nr_of_lines != $qdel_help_lines} {
      ts_log_severe "help output has $nr_of_lines, but expected are $qdel_help_lines lines:\n$output"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_job_task_list() ******
# 
#  NAME
#     qdel_job_task_list -- ??? 
#
#  SYNOPSIS
#     qdel_job_task_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_job_task_list {} {
    global ts_config

    delete_all_jobs
    wait_for_end_of_all_jobs

    # submit jobs to delete
    set job_list [submit_testjobs]
    set qdel_output [start_sge_bin "qdel" $job_list]

    # Errorhandling not functional yet because qdel returns always 0 it doesn't matter if the job exists or not
    if {$prg_exit_state != 0} {
       ts_log_severe "qdel $job_list failed:\n$qdel_output"
    }

    set time [timestamp]
    while {1} {
       set jobs_deleted 0
      foreach job_id $job_list {
         set result [is_job_running $job_id "qdel_check"]
         if {$result != -1} {
            incr jobs_deleted 1
         }
      }

      if {$jobs_deleted == 0} {
         return
      }

      set runtime [expr [timestamp] - $time]
      if {$runtime >= 300} {
         ts_log_severe "timeout while waiting for end of testjobs $job_list"
         break  
      }
   }    
}

#                                                             max. column:     |
#****** Checks/qdel/qdel_delete_unknown_jobid() ******
# 
#  NAME
#     qdel_delete_unknown_jobid -- check deletion of unknown jobs / tasks
#
#  SYNOPSIS
#     qdel_delete_unknown_jobid { } 
#
#  FUNCTION
#     Execute qdel commands to delete jobs, tasks and taskranges that
#     are unknown to the system.
#     Checks if the errors output match the expected patterns.
#
#*******************************
proc qdel_delete_unknown_jobid {} {
   global ts_config

   delete_all_jobs
   wait_for_end_of_all_jobs

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown jobid
   set unknown_jobid [expr [lindex $job_list [expr [llength $job_list] - 1]] + 1]
   lappend job_list $unknown_jobid 
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate_macro MSG_SGETEXT_DOESNOTEXIST_SU "job" $unknown_jobid ]  
   } else {
      set default_output [translate_macro MSG_SGETEXT_DOESNOTEXIST_SS "job" $unknown_jobid]  
   }

   qdel_delete_unknown_jobid_proc $job_list $default_output

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown taskid
   set last_jobid "[lindex $job_list end]"
   set unknown_taskid 5
   set job_list [lreplace $job_list end end "$last_jobid.$unknown_taskid"]
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate_macro MSG_SGETEXT_DOESNOTEXISTTASK_UU $last_jobid $unknown_taskid] 
   } else {
      set default_output [translate_macro MSG_SGETEXT_DOESNOTEXISTTASK_SU $last_jobid $unknown_taskid] 
   }
   qdel_delete_unknown_jobid_proc $job_list $default_output
   delete_job $last_jobid

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown taskid range
   set last_jobid [lindex $job_list end]
   set empty_taskrange "5-10:2"
   set job_list [lreplace $job_list end end "$last_jobid.$empty_taskrange"]
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate_macro MSG_SGETEXT_DOESNOTEXISTTASKRANGE_UUUU $last_jobid "5" "10" "2"]
   } else {
      set default_output [translate_macro MSG_SGETEXT_DOESNOTEXISTTASKRANGE_SUUU $last_jobid "5" "9" "2"]
   }
   qdel_delete_unknown_jobid_proc $job_list $default_output
   delete_job $last_jobid 1
}

proc qdel_delete_unknown_jobid_proc {job_list default_output} {
   global ts_config

   set qdel_output ""
   start_sge_bin "qdel" "$job_list"
   incr output_lines(0) -1 ;# ignore last "\n"
   for {set i 1} {$i <= $output_lines(0)} {incr i} {
      append qdel_output $output_lines($i)
      if {$i != $output_lines(0)} {
         append qdel_output "\n"
      }
   }
  
   if {[string first "\[" $qdel_output] == 0} {
      ts_log_fine "removing message id from output ..."
      set cut [string first "\]" $qdel_output]
      incr cut 2
      set qdel_output [string range $qdel_output $cut end] 
      ts_log_fine "qsub qdel_output is: \"$qdel_output\""
  }
 

   if {$prg_exit_state == 0} {
      ts_log_severe "exit state is 0"
   } 

   set nr_of_jobs [llength $job_list]
   set qd_out [split $qdel_output "\n"]
   set nr_of_output_lines [llength $qd_out]

   if {$nr_of_jobs != $nr_of_output_lines} {
      ts_log_severe "nr of jobs doesn't match output lines"
   }

   set last_job_output [lindex $qd_out [expr $nr_of_output_lines - 1]]
   if {[string first "\[" $last_job_output] == 0} {
      ts_log_fine "removing message id from output ..."
      set cut [string first "\]" $last_job_output]
      incr cut 2
      set last_job_output [string range $last_job_output $cut end] 
      ts_log_fine "qsub last_job_output is: \"$last_job_output\""
   }

   if {[string compare $default_output $last_job_output] != 0} {
      ts_log_severe "deleting of not existing job produces wrong output (\"$last_job_output\")"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_delete_negative_jobid() ******
# 
#  NAME
#     qdel_delete_negative_jobid -- ??? 
#
#  SYNOPSIS
#     qdel_delete_negative_jobid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_negative_jobid {} {
   global ts_config

   delete_all_jobs
   wait_for_end_of_all_jobs

   set output [start_sge_bin "qdel" "-1"]
   if {$prg_exit_state == 0} {
      ts_log_severe "qdel with negative job id didn't fail:\n$output"
   }

   set output_length [string length $output]
   if {$output_length < 10 } {
      ts_log_severe "possible wrong output - please check output manually"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_all() ******
# 
#  NAME
#     qdel_all -- ??? 
#
#  SYNOPSIS
#     qdel_all { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_all {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   delete_all_jobs
   wait_for_end_of_all_jobs

   if {$ts_config(gridengine_version) == 53} {
      set all_args "all"
   } else {
      set all_args "'*'"
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs] 
   ts_log_fine "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"
   
   # now delete jobs of user 1
   set qdel_output [start_sge_bin "qdel" $all_args]
   if {$prg_exit_state != 0} {
       ts_log_severe "could not delete jobs $job_list_user1 (exit status: $prg_exit_state):\n$qdel_output"
   }

   set time [timestamp] 
   while {1} {
      set jobs_deleted 0
      foreach job_id $job_list_user1 {
         set result [is_job_running $job_id "qdel_check"]
         if {$result == -1} {
            incr jobs_deleted 1
         }
      }
 
      if {$jobs_deleted == 4} {
         break
      }

      set runtime [expr [timestamp] - $time]
      if {$runtime >= 60} {
         ts_log_severe "timeout while waiting for end of testjobs $job_list_user1"
         break
      }
      ts_log_progress
      sleep 1
   }

   # now check if user2 has still his jobs
   foreach job_id $job_list_user2 {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_severe "(3) jobs of different user deleted" 
      }
   } 
  
   # now submit new jobs for user 1
   set job_list_user1 [submit_testjobs]  
   ts_log_fine "user 1 has jobs $job_list_user1"

   # now delete jobs of user 2
   set result [start_sge_bin "qdel" "$all_args" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "qdel_output = \n$result" 

   set time [timestamp] 
   while {1} {
      set jobs_deleted 0
      foreach job_id $job_list_user2 {
         set result [is_job_running $job_id "qdel_check"]
         if {$result == -1} {
            incr jobs_deleted 1
         }
      }

      if {$jobs_deleted == 4} {
         break
      }

      set runtime [expr [timestamp] - $time]
      if { $runtime >= 60 } {
         ts_log_severe "timeout while waiting for end of testjobs $job_list_user2"
         break
      }
      ts_log_progress
      sleep 1
   }

   # now check if user1 has still his jobs
   foreach job_id $job_list_user1 {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_severe "(4) jobs of different user deleted" 
      }
   }

   # now delete jobs of user1
   set qdel_output [start_sge_bin "qdel" $all_args]
   if {$prg_exit_state != 0} {
      ts_log_severe "could not delete jobs $job_list_user1 (exit status: $prg_exit_state):\n$qdel_output"
   }

   set time [timestamp]
   while {1} {
      set jobs_deleted 0
      foreach job_id $job_list_user1 {
         set result [is_job_running $job_id "qdel_check"]
         if {$result == -1} {
            incr jobs_deleted 1
         }
      }

      if {$jobs_deleted == 4} {
         break
      }

      set runtime [expr [timestamp] - $time]
      if {$runtime >= 60} {
         ts_log_severe "timeout while waiting for end of testjobs $job_list_user1"
         break
      }
      sleep 1
      ts_log_progress
   }
}

#                                                             max. column:     |
#****** qdel/qdel_uall() ******
# 
#  NAME
#     qdel_uall -- ??? 
#
#  SYNOPSIS
#     qdel_uall { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_uall {} {
   global ts_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER

   delete_all_jobs
   wait_for_end_of_all_jobs

   if {$ts_config(gridengine_version) == 53} {
      set uall_args "-uall"
   } else {
      set uall_args "-u '*'"
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]
   ts_log_fine "user 1 has jobs $job_list_user1"
 
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"

   set job_list_user3 [submit_testjobs $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 3 has jobs $job_list_user3"

   # now delete all jobs as user 2 ( only submit user )
   set result [start_sge_bin "qdel" $uall_args "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   # now delete all jobs as user 3 ( only submit user )
   set result [start_sge_bin "qdel" $uall_args "" $CHECK_SECOND_FOREIGN_SYSTEM_USER]

   # test if all jobs are still there:
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"
   ts_log_fine "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_severe "(5) jobs of different user deleted" 
      }
   } 

   # now delete all jobs as user 1 ( manager )
   set result [start_sge_bin "qdel" $uall_args "" $CHECK_USER]
   ts_log_fine "qdel_output = \n$result" 

   # now check if all jobs are deleted
   set time [timestamp] 
   while {1} {
      set jobs_deleted 0
      foreach job_id $all_jobs {
         set result [is_job_running $job_id "qdel_check"]
         if {$result == -1} {
            incr jobs_deleted 1
         }
      }

      if {$jobs_deleted == 12} {
         break
      }

      set runtime [expr [timestamp] - $time]
      if {$runtime >= 300} {
         ts_log_severe "timeout while waiting for end of testjobs $all_jobs"
         break
      }
      sleep 1
   }
}

#                                                             max. column:     |
#****** qdel/qdel_user_list() ******
# 
#  NAME
#     qdel_user_list -- ??? 
#
#  SYNOPSIS
#     qdel_user_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_user_list {} {
   global ts_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER

   delete_all_jobs
   wait_for_end_of_all_jobs

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   ts_log_fine "user 1 has jobs $job_list_user1"
 
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"

   set job_list_user3 [submit_testjobs $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 3 has jobs $job_list_user3"

   # now delete all jobs as user 2 ( only submit user ) of user 3 ( only submit user)
   set result [start_sge_bin "qdel" "-u $CHECK_SECOND_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   # now delete all jobs as user 2 ( only submit user ) of user 1 ( manager )
   set result [start_sge_bin "qdel" "-u $CHECK_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   # now delete all jobs as user 2 ( only submit user ) of user 1 && user 3
   set result [start_sge_bin "qdel" "-u $CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   # test if all jobs are still there:
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"
   ts_log_fine "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_severe "(1) jobs of different user deleted"
      }
   }

   # now delete all jobs as user 2 ( only submit user ) of user 2 ( himself ) 
   set result [start_sge_bin "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   # now test if his jobs are deleted
   if {[are_jobs_deleted $job_list_user2] != 0} {
      ts_log_severe "(1) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER are deleted"
   }

   # submit new jobs for user 2
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"

   # now delete all jobs as user 2
   set result [start_sge_bin "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "starting qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"
   ts_log_fine "as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   ts_log_fine "qdel_output = \n$result" 

   # now test if his jobs are deleted
   if {[are_jobs_deleted $job_list_user2] != 0} {
      ts_log_severe "(2) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 

   # now test if the jobs of user1 and user3 are still here
   set all_jobs "$job_list_user1 $job_list_user3"
   ts_log_fine "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_fine "job $job_id is not running"
         ts_log_severe "(2) jobs of different user deleted"
      }
   }

   # submit new jobs for user 2
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"

   # now delete all jobs as user 1 (manager)
   set qdel_output [start_sge_bin "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"]
   ts_log_fine "starting qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"
   ts_log_fine "qdel_result = $prg_exit_state"
   ts_log_fine "qdel_output = $qdel_output" 
   if {$prg_exit_state != 0} {
      ts_log_severe "Could not delete jobs $job_list_user1 (exit status: $prg_exit_state):\n$qdel_output"
   }

   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"

   set mytimeout [expr [timestamp] + 30]
   set was_error 1
   while {[timestamp] < $mytimeout} {
      if {[are_jobs_deleted $all_jobs] == 0} {
         set was_error 0
         break
      }
   }
   if {$was_error != 0} {
      ts_log_severe "not all jobs are deleted ($all_jobs)"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_force() ******
# 
#  NAME
#     qdel_force -- ??? 
#
#  SYNOPSIS
#     qdel_force { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_force {} {
   global ts_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER
   global pending_state qdel_host

   delete_all_jobs
   wait_for_end_of_all_jobs

   # unset ENABLE_FORCED_QDEL with set_config
   get_config saved_array 
   ts_log_fine "qmaster_params=$saved_array(qmaster_params)"
   set saved_qmaster_params $saved_array(qmaster_params)
   if {$saved_qmaster_params != "none"} {
      set change_array(qmaster_params) "none"
      set_config change_array
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]
   ts_log_fine "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"


   # shutdown execd
   soft_execd_shutdown $qdel_host

   # now test if his jobs still running or pending 
   set all_jobs "$job_list_user1 $job_list_user2"
   foreach job_id $all_jobs {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_severe "jobs $all_jobs should still be in the queueing system"
      }
   }

   # delete the jobs of user 1 as user 1 without -f switch
   set qdel_output [start_sge_bin "qdel" $job_list_user1]

   if {$prg_exit_state != 0} {
      ts_log_severe "qdel $job_list_user1 failed:\n$qdel_output"
   }

   # delete the jobs of user 2 as user 2 without -f switch
   set result [start_sge_bin "qdel" "$job_list_user2" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   if {$pending_state == 0} {
      # when jobs were in running state
      ts_log_fine "running jobs must still be in the queue"
      sleep 10
      # now test if his jobs still running or pending
      set all_jobs "$job_list_user1 $job_list_user2"
      foreach job_id $all_jobs {
          set result [is_job_running $job_id "qdel_check"]
          if {$result == -1} {
             ts_log_severe "jobs $all_jobs should still be in the queueing system"
          }
      }

      # now restart execd
      startup_execd $qdel_host
   }

   # wait for deletion of the jobs
   if {[are_jobs_deleted $all_jobs] != 0} {
       ts_log_severe "(3) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   }

   if {$pending_state != 0} {
      # now restart execd
      startup_execd $qdel_host
   }

   # ok - qdel without execd is ok, now check the -f option 

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]
   ts_log_fine "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   ts_log_fine "user 2 has jobs $job_list_user2"

   # shutdown execd
   soft_execd_shutdown $qdel_host

   # now test if his jobs still running or pending
   set all_jobs "$job_list_user1 $job_list_user2"
   foreach job_id $all_jobs {
      set result [is_job_running $job_id "qdel_check"]
      if {$result == -1} {
         ts_log_severe "jobs $all_jobs should still be in the queueing system"
      }
   }

   # delete the jobs of user 1 as user 1 with -f switch
   set qdel_output [start_sge_bin "qdel" "-f $job_list_user1"]
   if {$prg_exit_state != 0} {
      ts_log_severe "exit state is not 0"
   }

   # delete the jobs of user 2 as user 2 with -f switch
   set result [start_sge_bin "qdel" "-f $job_list_user2" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER prg_exit_state 120]

   # wait for deletion of the jobs of user 1 (manager)
   if {[are_jobs_deleted $job_list_user1] != 0} {
      ts_log_severe "(4) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   }

   if {$pending_state != 0} {
      # wait for deletion of the jobs of user 2 (submit user)
      if {[are_jobs_deleted $job_list_user2] != 0} {
         ts_log_severe "(5) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
      }
   } else {
      ts_log_fine "running jobs of user $CHECK_FIRST_FOREIGN_SYSTEM_USER must still be in the queue"
      sleep 10
      # if jobs were running the submituser (user2) can't use the force flag!
      # now test if his jobs still running or pending
      foreach job_id $job_list_user2 {
         set result [is_job_running $job_id "qdel_check"]
         if {$result == -1} {
            ts_log_severe "jobs $all_jobs should still be in the queueing system"
         }
      }

      # set ENABLE_FORCED_QDEL with set_config
      set change_array(qmaster_params) "ENABLE_FORCED_QDEL"
      set_config change_array
      ts_log_fine "qmaster_params set to $change_array(qmaster_params)"

      # delete the jobs of user 2 as user 2 with -f switch
      set result [start_sge_bin "qdel" "-f $job_list_user2" "" $CHECK_FIRST_FOREIGN_SYSTEM_USER prg_exit_state 120]

      # wait for deletion of the jobs of user 2 (submit user) (now it must go)
      if {[are_jobs_deleted $job_list_user2] != 0} {
         ts_log_severe "(6) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted (ENABLE_FORCED_QDEL is not working)"
      }
   } 

   set change_array(qmaster_params) $saved_qmaster_params
   set_config change_array
   ts_log_fine "qmaster_params set to $change_array(qmaster_params)"

   # now restart execd
   startup_execd $qdel_host
   wait_for_load_from_all_queues 300
}

#****** qdel/qdel_delete_large_task() ******
#
#  NAME
#     qdel_delete_large_task
#
#  SYNOPSIS
#     This functions submits a large array job and then 
#     sends qdel to see if jobs are deleted. This tests for the case 
#     when deleting tasks within a job take a long time and make qmaster
#     unresponsive.
#
#  FUNCTION
#     qdel a valid range of jobs
#
#  INPUTS
#
#  RESULT
#     ???
#
#  EXAMPLE
#     ???
#
#  NOTES
#     ???
#
#  BUGS
#     CR 6288953
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_large_array {} {
   global ts_config
    
   set hostname [host_conf_get_suited_hosts]

   # Submit an array job of 5000 tasks
   set job [submit_testjobs "" "" 1 "-t 1-5000"]
   set job_range "$job.1-5000"

   trigger_scheduling
   sleep 10

   # Now delete all of the tasks within the job
   set output [start_sge_bin "qdel" $job_range]

   # Sleep a little
   sleep 30

   # Now check with qstat that there are no more jobs
   set output [start_sge_bin "qstat" ""]
   if {[string trim $output] != ""} {
      ts_log_severe "not all tasks of job $job were deleted:\n$output"
   }

   # Clean up the queues
   delete_all_jobs
   wait_for_end_of_all_jobs
}

# ------------------------------------------

