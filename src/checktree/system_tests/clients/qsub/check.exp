#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions
global check_category
global check_highest_level check_init_level_procedure
global ts_config
global check_root_access_needs
set check_root_access_needs "yes"

# setup check's highest level
set check_highest_level 0

# set description for each level
set check_description(0)  "check every qsub option"

set check_init_level_procedure "qsub_init_level"
set check_name         "qsub"
set check_category     "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)

# setup and cleanup functions
set check_setup_function "qsub_setup"
set check_cleanup_function "qsub_cleanup"

# define test's procedure order
set check_functions {}
lappend check_functions "check_submit"
lappend check_functions "qsub_starter_method"
lappend check_functions "check_start_time"  
lappend check_functions "check_hold"           
lappend check_functions "check_option_ac"
lappend check_functions "check_option_A"
lappend check_functions "check_option_clear"
lappend check_functions "check_option_c"
lappend check_functions "check_option_ckpt"
lappend check_functions "check_option_cwd"
lappend check_functions "check_option_C"
lappend check_functions "check_option_dc"
lappend check_functions "check_option_e"
lappend check_functions "check_option_hard"
lappend check_functions "check_option_help"
lappend check_functions "check_option_hold_jid"
lappend check_functions "check_option_j_y"
lappend check_functions "check_option_j_n"
lappend check_functions "check_option_l"
lappend check_functions "check_option_m"
lappend check_functions "check_option_notify"
lappend check_functions "check_option_now_yes"
lappend check_functions "check_option_now_no"
lappend check_functions "check_option_M"
lappend check_functions "check_option_N"
lappend check_functions "check_option_o"
lappend check_functions "check_option_P"
lappend check_functions "check_option_p"
lappend check_functions "check_option_pe"
lappend check_functions "check_option_q"
lappend check_functions "check_option_r_y"
lappend check_functions "check_option_r_n"
lappend check_functions "check_option_sc"
lappend check_functions "check_option_soft"
lappend check_functions "check_option_S"
lappend check_functions "check_option_t"
lappend check_functions "check_option_v"
lappend check_functions "check_option_verify"
lappend check_functions "check_option_V"
lappend check_functions "check_option_w"
lappend check_functions "check_option_@"
lappend check_functions "check_huge_script"
lappend check_functions "check_qhold_jobname"
lappend check_functions "check_qsub_ts_iz_72" ;# Testcase for TS IZ 72
 
#                                                             max. column:     |
#****** qsub/qsub_init_level() ******
# 
#  NAME
#     qsub_init_level -- ??? 
#
#  SYNOPSIS
#     qsub_init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qsub_init_level {} {
   global CHECK_ACT_LEVEL

   if {$CHECK_ACT_LEVEL == 0} {
      return 0
   }

   return -1 
}

proc qsub_setup {} {
   global ts_config
   global CHECK_JOB_OUTPUT_DIR
   global stored_configuration
   global job_output_dir test_host default_args default_q_args default_h_args
   global steps_per_queue size_interval
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT
   global HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE

   # set some global variables
   set num_queues [llength $ts_config(unique_arch_nodes)] 
   set job_output_dir $CHECK_JOB_OUTPUT_DIR

   # run host specific tests on a random host
   set test_host [host_conf_get_suited_hosts]

   # set default jobargs
   set default_args "-o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 5"
   set qinstance [get_queue_instance "all.q" $test_host]
   set default_q_args "-q $qinstance $default_args"
   set default_h_args "-l h=${test_host} $default_args"

   # setup huge_script test
   set HUGE_SCRIPT_MIN_SIZE 0
   set HUGE_SCRIPT_MAX_SIZE [expr 16 * 1024 * 1024]
   set HUGE_SCRIPT_STEPS    100
   set HUGE_SCRIPT_TIMEOUT  1000
   set HUGE_SCRIPT_PATTERN  "generated huge script file for testsuite, 100 characters per line .............................. end"
   set steps_per_queue [expr $HUGE_SCRIPT_STEPS / $num_queues]
   if {[expr $steps_per_queue * $num_queues] < $HUGE_SCRIPT_STEPS} {
      incr steps_per_queue
   }
   set steps_total [expr $steps_per_queue * $num_queues]
   set size_interval [expr $HUGE_SCRIPT_MAX_SIZE / $steps_total]

   # backup global config
   get_config stored_configuration
  
   # set config for fast scheduling / fast writing of accounting record
   if {$ts_config(gridengine_version) == 53} {
      set my_config(schedd_params) "$stored_configuration(schedd_params),FLUSH_SUBMIT_SEC=0"
   } else {
      set my_config(reporting_params) "accounting=true reporting=false flush_time=00:00:01 joblog=true sharelog=00:10:00"
   }
   set_config my_config

   if {$ts_config(gridengine_version) >= 60} {
      set my_schedd_conf(flush_submit_sec) "1"
      set_schedd_config my_schedd_conf 
   }
}

proc qsub_cleanup {} {
   global ts_config
   global stored_configuration
   global job_output_dir test_host default_args default_q_args default_h_args
   global steps_per_queue size_interval
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT
   global HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE

   delete_all_jobs
   wait_for_end_of_all_jobs

   if {$ts_config(gridengine_version) >= 60} {
      reset_schedd_config
   }
   set_config stored_configuration

   # unset our test global variables
   foreach var "stored_configuration job_output_dir test_host default_args default_q_args default_h_args steps_per_queue size_interval HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE" {
      if {[info exists $var]} {
         unset $var
      }
   }
}

proc qsub_submit_check {jobargs expect_submit_error {user ""} {host ""} {output_files 2}} {
   global ts_config CHECK_FIRST_FOREIGN_SYSTEM_USER
   global job_output_dir

   # default user is the first "foreign" user!
   if {$user == ""} {
      set user $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }

   # default submit host is "any host"
   if {$host == ""} {
      set host [host_conf_get_suited_hosts]
   }

   # if we expect a submit error, submit_job shall not do error checking
   set submit_error_check 1
   if {$expect_submit_error} {
      set submit_error_check 0
   }

   # submit job and evaluate result
   set job_id [submit_job $jobargs $submit_error_check 60 $host $user]
   if {$expect_submit_error} {
      if {$job_id > 0} {
         ts_log_severe "submission of job \"$jobargs\" as user $user on host \"$host\" should have failed"
         delete_job $job_id
      }
      # are done
      return 0
   } else {
      if {$job_id < 0} {
         ts_log_severe "submission of job \"$jobargs\" as user $user on host \"$host\" failed:\nerror $job_id"
         return 0
      }
   }

   # wait for job accounting record and expect 1 or 2 ($output_files) output/error files
   set time [expr [timestamp] + 300] 
   while {[timestamp] < $time}  {
      after 1000
      set back [was_job_running $job_id 0]
      if {$back != -1} {
         set back [del_job_files $job_id $job_output_dir $output_files]
         if {$back != $output_files} {
            ts_log_severe "job $job_id (\"$jobargs\") did not produce error and output file"
            return 0
         } else {
            # job ran through successfully
            return $job_id
         }
      }
   }

   # if we get here, we didn't find an accounting record within reasonable time
   ts_log_severe "timeout waiting for job $job_id (\"$jobargs\")"

   # cleanup
   delete_job $job_id
   del_job_files $job_id $job_output_dir 2
   return 0
}
 
#                                                             max. column:     |
#****** qsub/check_submit() ******
# 
#  NAME
#     check_submit -- ??? 
#
#  SYNOPSIS
#     check_submit { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_submit {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory
   
   # submit from every architecture
   foreach host $ts_config(unique_arch_nodes) {
      ts_log_fine "--> submit on host $host"
      qsub_submit_check $default_args 0 "" $host
   }

   # submit to every architecture
   foreach host $ts_config(unique_arch_nodes) {
      ts_log_fine "--> submit to host $host"
      qsub_submit_check "-l h=${host} $default_args" 0
   }
}

proc qsub_starter_method {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global job_output_dir test_host
   global default_q_args default_h_args

   set ok 1

   # first clean up output directory:
   setup_output_directory
  
   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   mod_queue all.q "" change_array

   set jobargs $default_q_args
   set result [submit_job $jobargs]

   if {$result < 0} {
      ts_log_severe "could not submit job: $jobargs"
      set ok 0
   }

   # Wait job to run and for end of job
   if {$ok} {
      set back [wait_for_jobstart $result "leeper" 300]
      if {$back != 0} {
         ts_log_severe "job $result doesn't start"
         set ok 0
      }
   }

   # Wait for end of job
   if {$ok} {
      set back [wait_for_jobend $result "leeper" 300 0]
      if {$back != 0} {
         ts_log_severe "job $result doesn't stop"
         set ok 0
      }
   }

   # check output file, should contain output from starter method
   if {$ok} {
      after 2000
      set outfilename "$job_output_dir/Sleeper.o$result"
      ts_log_fine "checking output file $outfilename"

      if {![file exists $outfilename]} {
         ts_log_severe "output file for job $result on host $test_host does not exist"
         set ok 0
      } else {
         set f [open $outfilename r]
         set files_ok 0
         set num_lines 0
         while {[gets $f line] >= 0} {
            incr num_lines
            ts_log_fine $line
               if {[string compare $line "starter method started"] == 0} {
               set files_ok 1
               break
            }
         }
         if {$num_lines == 0} {
            ts_log_severe "error reading from job output file for job $result on host $test_host"
            set ok 0
         } else {
            if {$files_ok == 0} {
               ts_log_severe "starter method was not started for job $result on host $test_host"
               set ok 0
            }
         }  
         close $f
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {!$ok && $result > 0} {
      delete_job $result
   }

   # unset starter method
   set change_array(starter_method) "none"
   mod_queue all.q "" change_array
}

#                                                             max. column:     |
#****** qsub/setup_output_directory() ******
# 
#  NAME
#     setup_output_directory -- ??? 
#
#  SYNOPSIS
#     setup_output_directory { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_output_directory {} {
   global ts_config
   global job_output_dir 
   
   if {[string length $job_output_dir] < 5} {
      ts_log_severe "job output dir path must at least have 5 characters\ngot \"$job_output_dir\""
      return -1
   }

   # create directory, if it does not yet exist
   # if it already exists, delete all files in it
   set files_deleted 0
   if {![file isdirectory "$job_output_dir"]} {
      file mkdir "$job_output_dir"
      ts_log_fine "new output directory \"$job_output_dir\" generated!"
   } else {
      ts_log_fine "deleting all files in output directory \"$job_output_dir\"!"
      set files [glob -nocomplain $job_output_dir/*]
      foreach elem $files {
         ts_log_fine $elem
         if {[file isfile $elem] == 1 } {
            ts_log_fine "deleting file $elem"
            incr files_deleted
            delete_file $elem
         }
      }
   }

   # make sure every user may create output files here
   file attributes $job_output_dir -permissions "a+rwx"

   return $files_deleted
}

#                                                             max. column:     |
#****** qsub/check_hold() ******
# 
#  NAME
#     check_hold -- ??? 
#
#  SYNOPSIS
#     check_hold { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_hold {} {
   global ts_config
   global job_output_dir test_host default_args

   set ok 1

   # first clean up output directory:  
   setup_output_directory

   set jobargs "-h $default_args"
   set result [submit_job $jobargs] 
   if {$result < 0} {
      ts_log_severe "error submitting job \"$jobargs\"\nerror $result"
   }
 
   # wait for job to get in pending state 
   if {[wait_for_jobpending $result "leeper" 200] != 0} {
      ts_log_severe "job $result is not in pending state"
      set ok 0
   }

   # job should not run within the next 2 minutes 
   if {$ok} {
      ts_log_fine "check_hold - set hold for job $result, job should not start"
      if {[wait_for_jobstart $result "leeper" 120 0] != -1} {
         ts_log_severe "job $result should not run until yet"
         set ok 0
      }
   }

   # release job
   if {$ok} {
      ts_log_fine "check_hold - ok now we release the job"
      release_job $result
   }

   # wait for job to start
   if {$ok} {
      if {[wait_for_jobstart $result "leeper" 300] == -1} {
         ts_log_severe "check_hold - job $result doesn't start"
         set ok 0
      }
   }
 
   # wait for end of job
   if {$ok} {
      if {[wait_for_jobend $result "leeper" 300 0] == -1} {
         ts_log_severe "check_hold - job $result doesn't stop"
         set ok 0
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {!$ok && $result > 0} {
      delete_job $result
   }
}

#                                                             max. column:     |
#****** qsub/check_start_time() ******
# 
#  NAME
#     check_start_time -- ??? 
#
#  SYNOPSIS
#     check_start_time { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_start_time {} {
   global ts_config
   global job_output_dir test_host

   # first clean up output directory:  
   setup_output_directory

   set now [clock seconds]
   set then [expr $now + 120]

   set start [clock format $then -format "%Y%m%d%H%M.%S"]

   set jobargs "-a $start -l h=${test_host} -o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 10"

   set ok 1

   # submit job
   set result [submit_job $jobargs]
   if {$result < 0} {
      ts_log_severe "error submitting job \"$jobargs\"\nerror $result"
   }

   # wait for job to get in pending state
   if {[wait_for_jobpending $result "leeper" 200] != 0} {
      ts_log_severe "job $result is not in pending state"
      set ok 0
   }

   # calulate time until job should run
   if {$ok} {
      set wait_time 10
      ts_log_fine "check_start_time - job should not start the next $wait_time seconds"
      set now [clock seconds]
      if {[wait_for_jobstart $result "leeper" $wait_time 0] != -1} {
         ts_log_severe "check_start_time - job $result should not run until yet"
         set ok 0
      }
   }

   # wait for job to start
   if {$ok} {
      ts_log_fine "check_start_time - ok now the job should start"
      if {[wait_for_jobstart $result "leeper" 300] == -1} {
         ts_log_severe "check_start_time - job $result doesn't start"
         set ok 0
      }
   }
 
   # wait for end of job
   if {$ok} {
      if {[wait_for_jobend $result "leeper" 300 0] == -1} {
         ts_log_severe "check_start_time - job $result doesn't stop"
         set ok 0
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if {$back != 2} {
      ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {!$ok && $result > 0} {
      delete_job $result
   }
}

#                                                             max. column:     |
#****** qsub/check_option_ac() ******
# 
#  NAME
#     check_option_ac -- ??? 
#
#  SYNOPSIS
#     check_option_ac { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ac {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global job_output_dir test_host

   # first clean up output directory:
   setup_output_directory

   set option "-ac myvar1=\"test 1\" -ac myvar2='test 2'"
   # We use a special job script which contains context variable settings
   set jobargs "$option -l h=${test_host} -o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/sleeper.sh 60"
   set result [submit_job $jobargs 0]

   if {$result < 0} {
      ts_log_severe "error submitting job \"$jobargs\"\nerror $result"
      return
   }

   set qstatoutput [start_sge_bin "qstat" "-j $result"]

   if {$prg_exit_state != 0} {
      ts_log_severe "error executing qstat -j $result"
      return
   }

   if {[regexp {context:([^\r\n]+\r?\n)} $qstatoutput match vars] != 1} {
      ts_log_severe "qsub $option - qsub error: context variables were not set"
      return
   }

   ts_log_fine "context variables: $vars"

   if {[regexp {[ \t,]myvar1=test 1[,\r\n]} $vars match] != 1} {
      ts_log_severe "qsub $option - qsub error: command-line context variable was not set"
      return
   } elseif {[regexp {[ \t,]myvar2=test 2[,\r\n]} $vars match] != 1} {
      ts_log_severe "qsub $option - qsub error: command-line context variable was not set"
      return
   } elseif {[regexp {[ \t,]myvar3=test 3[,\r\n]} $vars match] != 1} {
      ts_log_severe "qsub $option - qsub error: inline context variable was not set"
      return
   } elseif {[regexp {[ \t,]myvar4=test 4[,\r\n]} $vars match] != 1} {
      if {[regexp {[ \t,]myvar4='test 4'[,\r\n]} $vars match] == 1} {
         ts_log_info "qsub $option - qsub error: issue IZ1850 encountered only fixed for versions > 6.0"
         return
      }

      ts_log_severe "qsub $option - qsub error: inline context variable was not set"
      return
   }

   set time [expr [timestamp] + 300]
   while {[timestamp] < $time}  {
      after 1000
      set back [was_job_running $result 0]
      if {$back != -1} {
         set back [del_job_files $result $job_output_dir 2]
         if {$back != 2} {
            ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
         }
         return
      }
   }
 
   ts_log_severe "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_A() ******
# 
#  NAME
#     check_option_A -- ??? 
#
#  SYNOPSIS
#     check_option_A { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_A {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # positive tests
   foreach string [valid_job_has_valid_account_string "-A"] {
      set option "-A '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 0]

      if {$job_id > 0} {
         get_qacct $job_id
         set acct_string $qacct_info(account)
         if {$acct_string != $string} {
            ts_log_severe "account string requested with -A option missing in accounting record:\nexpected $string, but accounting record contains $acct_string\nfor job $job_id"
         }
      }
   }

   # negative tests
   foreach string [invalid_job_has_valid_account_string "-A"] {
      set option "-A '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 1]
   }
}

#                                                             max. column:     |
#****** qsub/check_option_clear() ******
# 
#  NAME
#     check_option_clear -- ??? 
#
#  SYNOPSIS
#     check_option_clear { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_clear {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-A blahblah -clear"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(account) == "blahblah"} {
         ts_log_severe "-clear option didn't earlier -A option"
      }
   }
}

#                                                             max. column:     |
#****** qsub/check_option_c() ******
# 
#  NAME
#     check_option_c -- ??? 
#
#  SYNOPSIS
#     check_option_c { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_c {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-c n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_ckpt() ******
# 
#  NAME
#     check_option_ckpt -- ??? 
#
#  SYNOPSIS
#     check_option_ckpt { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ckpt {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-ckpt testcheckpointobject"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_cwd() ******
# 
#  NAME
#     check_option_cwd -- ??? 
#
#  SYNOPSIS
#     check_option_cwd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_cwd {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-cwd"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_C() ******
# 
#  NAME
#     check_option_C -- ??? 
#
#  SYNOPSIS
#     check_option_C { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_C {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-C TESTPREFIX"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_dc() ******
# 
#  NAME
#     check_option_dc -- ??? 
#
#  SYNOPSIS
#     check_option_dc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_dc {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-dc myvar,myvar2"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_e() ******
# 
#  NAME
#     check_option_e -- ??? 
#
#  SYNOPSIS
#     check_option_e { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_e {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # we submit just with default args - they contain the -e option
   qsub_submit_check $default_args 0
}

#                                                             max. column:     |
#****** qsub/check_option_hard() ******
# 
#  NAME
#     check_option_hard -- ??? 
#
#  SYNOPSIS
#     check_option_hard { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hard {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-hard"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_help() ******
# 
#  NAME
#     check_option_help -- ??? 
#
#  SYNOPSIS
#     check_option_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_help {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-help"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1
}

#                                                             max. column:     |
#****** qsub/check_option_hold_jid() ******
# 
#  NAME
#     check_option_hold_jid -- ??? 
#
#  SYNOPSIS
#     check_option_hold_jid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hold_jid {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-hold_jid 1,2,3"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   # test with job names
   if {$ts_config(gridengine_version) >= 60} {
      set option "-hold_jid foo,bar"
      set jobargs "$option $default_args"
      qsub_submit_check $jobargs 0
   }
}

#                                                             max. column:     |
#****** qsub/check_option_j_y() ******
# 
#  NAME
#     check_option_j_y -- ??? 
#
#  SYNOPSIS
#     check_option_j_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_y {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-j y"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0 "" "" 1
}

#                                                             max. column:     |
#****** qsub/check_option_j_n() ******
# 
#  NAME
#     check_option_j_n -- ??? 
#
#  SYNOPSIS
#     check_option_j_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_n {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-j n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_l() ******
# 
#  NAME
#     check_option_l -- ??? 
#
#  SYNOPSIS
#     check_option_l { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_l {} {
   global ts_config
   global default_h_args

   # first clean up output directory:
   setup_output_directory

   # the default_h_args contain -l h=...
   set jobargs "$default_h_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_m() ******
# 
#  NAME
#     check_option_m -- ??? 
#
#  SYNOPSIS
#     check_option_m { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_m {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-m beas"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_notify() ******
# 
#  NAME
#     check_option_notify -- ??? 
#
#  SYNOPSIS
#     check_option_notify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_notify {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-notify"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_now_yes() ******
# 
#  NAME
#     check_option_now_yes -- ??? 
#
#  SYNOPSIS
#     check_option_now_yes { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_yes {} {
   global ts_config
   global default_args job_output_dir

   # first clean up output directory:
   setup_output_directory

   set option "-now yes"
   set jobargs "$option $default_args"

   for {set i 1} {$i <= 3} {incr i 1} {
      set result [submit_job $jobargs 0]
      if {$result != -6} {
         break
      } else {
         ts_log_info "bugtraq id: 4938859 ->\nqsub -now yes returned job could not be scheduled, try later - error - trying again ... (try $i)"
         ts_log_fine "sleeping 5 sec ..."
         after 5000
      }
   }
 
   ts_log_fine "\njob $result has args: \"$jobargs\""

   if {$result < 0} {
      ts_log_severe "could not submit job\n -> return value of submit_job: $result"
      return
   }

   set time [expr [timestamp] + 300]

   while {[timestamp] < $time} {
      after 1000
      set back [was_job_running $result 0]
      if {$back != -1} {
         set back [del_job_files $result $job_output_dir 2]
         if {$back != 2} {
            ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            return
         }
      }
   }
 
   ts_log_severe "timeout while waiting for job accounting"

   # negative test: expect job not to be scheduled
   # disable all queues
   #set result [submit_job $jobargs 0]
   #if {$result != -6} {
   #   ts_log_severe "qsub -now yes should have failed with all queues disabled"
   #}
   # enable all queues
}

#                                                             max. column:     |
#****** qsub/check_option_now_no() ******
# 
#  NAME
#     check_option_now_no -- ??? 
#
#  SYNOPSIS
#     check_option_now_no { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_no {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-now no"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_M() ******
# 
#  NAME
#     check_option_M -- ??? 
#
#  SYNOPSIS
#     check_option_M { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_M {} {
   global ts_config CHECK_REPORT_EMAIL_TO
   global default_args

   # can't run the check, if no email address has been configured
   if {[string compare $CHECK_REPORT_EMAIL_TO "none"] == 0} {
      ts_log_config "no email address configured - can't run qsub -M check"
      return
   }

   # first clean up output directory:
   setup_output_directory

   set option "-M $CHECK_REPORT_EMAIL_TO"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_N() ******
# 
#  NAME
#     check_option_N -- ??? 
#
#  SYNOPSIS
#     check_option_N { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_N {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # positive tests
   foreach string [valid_job_has_valid_account_string "-N"] {
      set option "-N '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 0]

      if {$job_id > 0} {
         get_qacct $job_id
         set acct_string $qacct_info(jobname)
         if {$acct_string != $string} {
            ts_log_severe "job name string requested with -N option missing in accounting record:\nexpected $string, but accounting record contains $acct_string\nfor job $job_id"
         }
      }
   }

   # negative tests
   foreach string [invalid_job_has_valid_account_string "-N"] {
      set option "-N '$string'"
      set jobargs "$option $default_args"
      set job_id [qsub_submit_check $jobargs 1]
   }
}

#                                                             max. column:     |
#****** qsub/check_option_o() ******
# 
#  NAME
#     check_option_o -- ??? 
#
#  SYNOPSIS
#     check_option_o { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_o {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # the default args already contain a -o option
   qsub_submit_check $default_args 0
}

#                                                             max. column:     |
#****** qsub/check_option_P() ******
# 
#  NAME
#     check_option_P -- ??? 
#
#  SYNOPSIS
#     check_option_P { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_P {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-P mytestproject"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(project) != "mytestproject"} {
         ts_log_severe "project specified by -P switch missing in accounting record"
      }
   }
}

#                                                             max. column:     |
#****** qsub/check_option_p() ******
# 
#  NAME
#     check_option_p -- ??? 
#
#  SYNOPSIS
#     check_option_p { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_p {} {
   global ts_config CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER
   global default_args

   # first clean up output directory:
   setup_output_directory

   # test -p option:
   # any user must be allowed to submit with negative -p
   # only superuser may submit with positive -p

   # set as admin user: complete range
   qsub_submit_check "-p -1023 $default_args" 0 $CHECK_USER ;# IZ 2055
   qsub_submit_check "-p 0 $default_args" 0 $CHECK_USER
   qsub_submit_check "-p 1024 $default_args" 0 $CHECK_USER

   qsub_submit_check "-p -1024 $default_args" 1 $CHECK_USER
   qsub_submit_check "-p 1025 $default_args" 1 $CHECK_USER

   # test as non admin user: only negative .. 0
   qsub_submit_check "-p -100 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER ;# IZ 2055
   qsub_submit_check "-p 0 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # Up to version 6.0, a positive priority from non operators will be silently 
   # set to 0 by qmaster.
   # Beginning with version 6.1, we will reject such jobs.
   if {$ts_config(gridengine_version) <= 60} {
      qsub_submit_check "-p 1 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER
   } else {
      qsub_submit_check "-p 1 $default_args" 1 $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }
}

#                                                             max. column:     |
#****** qsub/check_option_pe() ******
# 
#  NAME
#     check_option_pe -- ??? 
#
#  SYNOPSIS
#     check_option_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_pe {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-pe mytestpe 1-3"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(granted_pe) != "mytestpe"} {
         ts_log_severe "granted_pe missing in accounting record"
      }
      if {$qacct_info(slots) != 3} {
         ts_log_severe "slots incorrect in accounting record"
      }
   }
}

#                                                             max. column:     |
#****** qsub/check_option_q() ******
# 
#  NAME
#     check_option_q -- ??? 
#
#  SYNOPSIS
#     check_option_q { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_q {} {
   global ts_config
   global default_args test_host

   # first clean up output directory:
   setup_output_directory

   # submission to a queue instance (5.3 queue)
   set qinstance [get_queue_instance "all.q" $test_host]
   qsub_submit_check "-q $qinstance $default_args" 0

   # beginning with 6.0, we can also submit
   #  - to a cluster queue
   #  - to all queue instances on a host
   #  - to all qinstances of a hostgroup
   if {$ts_config(gridengine_version) >= 60} {
      qsub_submit_check "-q *@${test_host} $default_args" 0
      qsub_submit_check "-q *@@allhosts $default_args" 0
   }
}

#                                                             max. column:     |
#****** qsub/check_option_r_y() ******
# 
#  NAME
#     check_option_r_y -- ??? 
#
#  SYNOPSIS
#     check_option_r_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_y {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-r y"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_r_n() ******
# 
#  NAME
#     check_option_r_n -- ??? 
#
#  SYNOPSIS
#     check_option_r_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_n {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-r n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_sc() ******
# 
#  NAME
#     check_option_sc -- ??? 
#
#  SYNOPSIS
#     check_option_sc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_sc {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-sc myvar=test3"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_soft() ******
# 
#  NAME
#     check_option_soft -- ??? 
#
#  SYNOPSIS
#     check_option_soft { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_soft {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-soft"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_S() ******
# 
#  NAME
#     check_option_S -- ??? 
#
#  SYNOPSIS
#     check_option_S { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_S {} {
   global ts_config CHECK_USER CHECK_ACTUAL_TEST_PATH
   global default_args job_output_dir

   # first clean up output directory:
   setup_output_directory

   set option "-S /bin/sh"
   set jobargs "$option $default_args"
   if {[qsub_submit_check $jobargs 0] == 0} {
      ts_log_severe "Job with option -S /bin/sh failed!"
      return 1
   }

   # Special handling for Windows hosts, the shell can either be the Interix
   # shell (e.g. /bin/sh) or the Windows command processor
   # (e.g. C:\Windows\system32\cmd.exe).
   # The Interix shell is already tested with the general Unix test above, 
   # the Windows command processor is tested here:
   set windows_host ""
   if {[host_conf_have_windows]} {
      set windows_host [host_conf_get_windows_host]

      # The command processor is defined in the "COMSPEC" environment variable
      # on the Windows host. Read the value of the variable and convert the path
      # to Unix format, as qsub will only accept Unix style pathes for the
      # "-S" option.
      set windows_comspec_path [get_remote_env_value $windows_host "COMSPEC"]
      set windows_comspec_path [double_backslashes $windows_comspec_path]

      set unix_comspec_path [start_remote_prog $windows_host $CHECK_USER \
         "/bin/winpath2unix" "$windows_comspec_path" prg_exit_status 60 0 "" "" 1 1 1 1 1]
      set unix_comspec_path [string trimright $unix_comspec_path "\n\r"]

      # Check if retrieving and converting succeeded.
      if {$prg_exit_status != 0} {
         ts_log_severe "Can't convert Windows path of command processor (cmd.exe) to Unix format!\nCan't execute -S option test on Windows."
         return 1
      }
      if {[string length $unix_comspec_path] < 7} {
         ts_log_severe "Can't find Windows command processor (cmd.exe)\nCan't execute -S option test on Windows."
         return 1
      }

      set shell_option "-S $unix_comspec_path"
      set host_option "-l h=$windows_host"

      # First try to run a native Windows binary job with the given shell (cmd.exe) 
      set bin_option "-b y"
      set job_script "-o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/worker.exe 5"
      set jobargs "$bin_option $shell_option $host_option $job_script"
      qsub_submit_check $jobargs 0

      # Then try to run a shell script with the given shell (cmd.exe) 
      set job_script "-o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/hello.bat"
      set jobargs "$shell_option $host_option $job_script"
      qsub_submit_check $jobargs 0
   }
}

#                                                             max. column:     |
#****** qsub/check_option_t() ******
# 
#  NAME
#     check_option_t -- ??? 
#
#  SYNOPSIS
#     check_option_t { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_t {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   # positive tests
   set option "-t 2-8:2"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0 "" "" 8
 
   # negative test:
   set option "-t 1-2:-1"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set option "-t 1-2:xx"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set option "-t 1-500000"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1
}

#                                                             max. column:     |
#****** qsub/check_option_verify() ******
# 
#  NAME
#     check_option_verify -- ??? 
#
#  SYNOPSIS
#     check_option_verify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_verify {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-verify"
   set jobargs "$option $default_args"

   # cannot use submit_job - it would fail on -verify
   set output [start_sge_bin "qsub" $jobargs]

   # expect certain output:
   set found 0
   foreach line [split $output "\n"] {
      if {[string match "job_number:*unassigned*" $line]} {
         set found 1
         break
      }
   }

   if {!$found} {
      ts_log_severe "no verify output on -verify command:\n$output"
   }
}

#                                                             max. column:     |
#****** qsub/check_option_V() ******
# 
#  NAME
#     check_option_V -- ??? 
#
#  SYNOPSIS
#     check_option_V { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_V {} {
   global ts_config
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-V"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0
}

#                                                             max. column:     |
#****** qsub/check_option_w() ******
# 
#  NAME
#     check_option_w -- ??? 
#
#  SYNOPSIS
#     check_option_w { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_w {} {
   global job_output_dir
   global test_host default_args

   # first clean up output directory:
   setup_output_directory

   set option "-w e"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   # negative test: -w e -q <invalid queue> has to be rejected
   qsub_submit_check "-q blah $jobargs" 1
}

#                                                             max. column:     |
#****** qsub/check_option_@() ******
# 
#  NAME
#     check_option_@ -- ??? 
#
#  SYNOPSIS
#     check_option_@ { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_@ {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global default_args

   # first clean up output directory:
   setup_output_directory

   set option "-@ $CHECK_ACTUAL_TEST_PATH/commandfile.txt"
   set jobargs "$option $default_args"
   set result [submit_job $jobargs 0]

   if {$result != -2} {
      ts_log_severe "no help output on -@ commandfile option"
   }
}

#                                                             max. column:     |
#****** qsub/check_huge_script() ******
# 
#  NAME
#     check_huge_script -- ??? 
#
#  SYNOPSIS
#     check_huge_script { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_huge_script {} {
   global ts_config CHECK_PROTOCOL_DIR
   global job_output_dir test_host
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT steps_per_queue size_interval

   # first clean up output directory:
   setup_output_directory

   # protocol
   set protocol_filename "$CHECK_PROTOCOL_DIR/qsub_huge_script.txt"
   set protocol [open $protocol_filename "w"]
   puts $protocol "submitting huge scripts"
   puts $protocol "size       = size of the script"
   puts $protocol "submittime = time needed to submit the script, timeout after $HUGE_SCRIPT_TIMEOUT s"
   puts $protocol "schedtime  = time the job needs to startup"
   puts $protocol "runtime    = runtime of the job"
   puts $protocol ""
   puts $protocol "size\tsubmittime\tschedtime\truntime"
   flush $protocol

   for {set step 0} {$step < $steps_per_queue} {incr step} {
      # create a huge sleeper.sh
      set filename "$job_output_dir/sleeper.sh"
      file copy -force "$ts_config(product_root)/examples/jobs/sleeper.sh" "$filename"
      set f [open $filename a]
      puts $f "exit 0"
      set times [expr $size_interval * $step / [string length $HUGE_SCRIPT_PATTERN]]
      for {set i 0} {$i < $times} {incr i} {
         puts $f "$HUGE_SCRIPT_PATTERN"
      }
      close $f
   
      set submit_size [file size $filename]
      ts_log_fine "submitting job script of size $submit_size bytes allowing a timeout of $HUGE_SCRIPT_TIMEOUT s"
   
      set jobargs "-l h=${test_host} -o $job_output_dir -e $job_output_dir $filename 5"
      set submit_start [clock seconds]
      set result [submit_job $jobargs 1 $HUGE_SCRIPT_TIMEOUT]
      if {$result < 0} {
         ts_log_severe "could not submit job (result: $result)"
         close $protocol
         return
      } else {
         set sched_start [clock seconds]
         set submit_time [expr $sched_start - $submit_start]
         ts_log_fine "submitting lasted $submit_time s"
         wait_for_jobstart $result "Sleeper" $HUGE_SCRIPT_TIMEOUT
         set run_start [clock seconds]
         set sched_time [expr $run_start - $sched_start]
         wait_for_jobend $result "Sleeper" $HUGE_SCRIPT_TIMEOUT 0
         set run_end [clock seconds]
         set run_time [expr $run_end - $run_start]
         puts $protocol "$submit_size\t$submit_time\t$sched_time\t$run_time"
         flush $protocol
      }

      file delete $filename

      set back [del_job_files $result $job_output_dir 2]
      if {$back != 2} {
         ts_log_severe "job $result did not produce error and output file\njobargs: $jobargs"
         close $protocol
         return
      }
   }

   close $protocol
}
#
#
#****** qsub/check_qsub_ts_iz_72() ***********************************************
#  NAME
#     check_qsub_ts_iz_72() -- Testcase for TS IZ 72.
#
#  SYNOPSIS
#     1. submit an array job in hold
#     2. qalter one task into system hold
#     3. qalter one task into pending state
#     4. wait until the task has finsihed
#     5. check, if the task in system hold is still there.
#
#  FUNCTION
#     Check if TS IZ 72 has been fixed.
#  INPUTS
#
#*******************************************************************************
proc check_qsub_ts_iz_72 {} {
	global ts_config

   # Delete any remaining jobs
   delete_all_jobs
      
   # 1. submit an array job in hold
   submit_job "-h -t 1-2 -o /dev/null -j y -N TS_IZ_72 $ts_config(product_root)/examples/jobs/sleeper.sh 15"
	
   # Get the jobid with qstat_plain_parse
   # qstat_plain_output contains the plain qstat output in an assoc. array
   # qstat_plain_output(jobid) contains a list of jobids.
   qstat_plain_parse qstat_plain_output
   ts_log_fine "qstat array ..."
   parray qstat_plain_output

   # Now let's compare them by jobid. 
   set jobid_list $qstat_plain_output(index)
	set jobid [lindex $jobid_list 0]
   ts_log_fine "get the jobid ..."
	
   # 2. qalter one task into system hold
   start_sge_bin "qalter" "-h s $jobid.1"
	
   # 3. qalter one task into pending state
   start_sge_bin "qalter" "-h n $jobid.2"
	
   # 4. wait until the task has finished
   # TODO: wait_for_end_of_task ???
   # TODO: I don't understand this test at all!
   trigger_scheduling

   set my_timeout [timestamp]
   incr my_timeout 60
   while { [timestamp] < $my_timeout } {
      set states [get_job_state $jobid 1 task_id]
      set nr_of_tasks [llength $states]
      for {set i 0} {$i < $nr_of_tasks} {incr i 1} {
         ts_log_fine "task $task_id($i,task) state is \"$task_id($i,state)\""
      }
      if {$nr_of_tasks == 1} { 
         ts_log_fine "task 2 finished"
         break
      }
      after 2500
   }

   after 5000   ;# wait some extra time
	
   # 5. check, if the task in system hold is still there.
   qstat_plain_parse qstat_plain_output1
      
   ts_log_fine "qstat array at the end .... \n"
   parray qstat_plain_output1
	
	if {$qstat_plain_output1($jobid,state) != "hqw"} {
		ts_log_severe "Task 2 not in hold state"
	} elseif {$qstat_plain_output1($jobid,jatask) == "2"} {
		ts_log_severe "Task 2 is still around"
	} elseif {$qstat_plain_output1($jobid,jatask) == "1,2"} {
		ts_log_severe "Task 2 was never scheduled"
	} elseif {[llength $qstat_plain_output1($jobid,jatask)] == 2} {
	   ts_log_severe "Task 2 is still around"
	} else {
		ts_log_fine "Task in system hold is still around as expected"
	} 
	
	delete_all_jobs
   wait_for_end_of_all_jobs
}	
