#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr 
global check_category
global check_highest_level check_init_level_procedure
global ts_config
global check_root_access_needs

# some parameters to huge_script test
global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT
global HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE

set check_root_access_needs "yes"

set HUGE_SCRIPT_MIN_SIZE 0
set HUGE_SCRIPT_MAX_SIZE [expr 16 * 1024 * 1024]
set HUGE_SCRIPT_STEPS    100
set HUGE_SCRIPT_TIMEOUT  1000
set HUGE_SCRIPT_PATTERN  "generated huge script file for testsuite, 100 characters per line .............................. end"

# setup check's highest level

set check_highest_level 0

# set description for each level
set check_description(0)  "check every qsub option"

set check_init_level_procedure "qsub_init_level"
set check_name         "qsub"
set check_category     "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)
set check_functions    ""

# setup and cleanup functions
set check_setup_function "qsub_setup"
set check_cleanup_function "qsub_cleanup"

# define test's procedure order
lappend check_functions "check_submit"
lappend check_functions "qsub_starter_method"
lappend check_functions "check_start_time"  
lappend check_functions "check_hold"           
#lappend check_functions "check_deadline" 
lappend check_functions "check_option_ac"
lappend check_functions "check_option_A"
lappend check_functions "check_option_clear"
lappend check_functions "check_option_c"
lappend check_functions "check_option_ckpt"
lappend check_functions "check_option_cwd"
lappend check_functions "check_option_C"
lappend check_functions "check_option_dc"
lappend check_functions "check_option_e"
lappend check_functions "check_option_hard"
lappend check_functions "check_option_help"
lappend check_functions "check_option_hold_jid"
lappend check_functions "check_option_j_y"
lappend check_functions "check_option_j_n"
lappend check_functions "check_option_l"
lappend check_functions "check_option_m"
lappend check_functions "check_option_notify"
lappend check_functions "check_option_now_yes"
lappend check_functions "check_option_now_no"
lappend check_functions "check_option_M"
lappend check_functions "check_option_N"
lappend check_functions "check_option_o"
lappend check_functions "check_option_P"
lappend check_functions "check_option_p"
lappend check_functions "check_option_pe"
lappend check_functions "check_option_q"
lappend check_functions "check_option_r_y"
lappend check_functions "check_option_r_n"
lappend check_functions "check_option_sc"
lappend check_functions "check_option_soft"
lappend check_functions "check_option_S"
lappend check_functions "check_option_t"
lappend check_functions "check_option_v"
lappend check_functions "check_option_verify"
lappend check_functions "check_option_V"
lappend check_functions "check_option_w"
lappend check_functions "check_option_@"
lappend check_functions "check_huge_script"
lappend check_functions "check_qhold_jobname"

# test specific globals:
global CHECK_JOB_OUTPUT_DIR job_output_dir
global actual_host
set job_output_dir $CHECK_JOB_OUTPUT_DIR


#                                                             max. column:     |
#****** qsub/qsub_init_level() ******
# 
#  NAME
#     qsub_init_level -- ??? 
#
#  SYNOPSIS
#     qsub_init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qsub_init_level {} {
   global CHECK_ACT_LEVEL

   if {$CHECK_ACT_LEVEL == 0} {
      return 0
   }

   return -1 
}

proc qsub_submit_check {jobargs expect_submit_error {user ""} {host ""} {output_files 2}} {
   global ts_config CHECK_OUTPUT CHECK_FIRST_FOREIGN_SYSTEM_USER
   global job_output_dir

   # default user is the first "foreign" user!
   if {$user == ""} {
      set user $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }

   # default submit host is the master host
   if {$host == ""} {
      set host $ts_config(master_host)
   }

   # if we expect a submit error, submit_job shall not do error checking
   set submit_error_check 1
   if {$expect_submit_error} {
      set submit_error_check 0
   }

   # submit job and evaluate result
   set job_id [submit_job $jobargs $submit_error_check 60 $host $user]
   if {$expect_submit_error} {
      if {$job_id > 0} {
         add_proc_error "qsub_submit_check" -1 "submission of job \"$jobargs\" as user $user should have failed"
         delete_job $job_id
      }
      # are done
      return 0
   } else {
      if {$job_id < 0} {
         add_proc_error "qsub_submit_check" -1 "submission of job \"$jobargs\" as user $user failed:\nerror $job_id"
         return 0
      }
   }

   # wait for job accounting record and expect 1 or 2 ($output_files) output/error files
   set time [expr ([timestamp] + 300)] 
   while {[timestamp] < $time}  {
      sleep 1
      set back [was_job_running $job_id 0] 
      if {$back != -1} {
         set back [del_job_files $job_id $job_output_dir $output_files]
         if {$back != $output_files} {
            add_proc_error "qsub_submit_check" -1 "job $job_id (\"$jobargs\") did not produce error and output file"
            return 0
         } else {
            # job ran through successfully
            return $job_id
         }
      }
   }

   # if we get here, we didn't find an accounting record within reasonable time
   add_proc_error "qsub_submit_check" -1 "timeout waiting for job $job_id (\"$jobargs\")"

   # cleanup
   delete_job $job_id
   del_job_files $job_id $job_output_dir 2
}
 
#                                                             max. column:     |
#****** qsub/check_submit() ******
# 
#  NAME
#     check_submit -- ??? 
#
#  SYNOPSIS
#     check_submit { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_submit {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory
   
   # submit from every architecture
   foreach host $ts_config(unique_arch_nodes) {
      qsub_submit_check $default_args 0 "" $host
   }

   # submit to every architecture
   foreach host $ts_config(unique_arch_nodes) {
      qsub_submit_check "-l h=${host} $default_args" 0
   }

   set_error 0 "ok"
}


proc qsub_starter_method {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   global check_errno job_output_dir
   global check_errstr CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH
   global actual_host
   global default_q_args default_h_args

   set ok 1

   # first clean up output directory:  
   setup_output_directory
  
   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   mod_queue all.q "" change_array

   set jobargs $default_q_args
   set result [submit_job $jobargs] 

   if {$result < 0} {
      add_proc_error "qsub_starter_method" -1 "could not submit job: $jobargs"
      set ok 0
   }

   # Wait job to run and for end of job
   if {$ok} {
      set back [ wait_for_jobstart $result "leeper" 300 ]
      if { $back != 0 } {
         add_proc_error "qsub_starter_method" -1 "job $result doesn't start"
         set ok 0
      }
   }

   # Wait for end of job
   if {$ok} {
      set back [ wait_for_jobend $result "leeper" 300 ]
      if { $back != 0 } {
         add_proc_error "qsub_starter_method" -1 "job $result doesn't stop"
         set ok 0
      }
   }

   # check output file, should contain output from starter method
   if {$ok} {
      sleep 2
      set outfilename "$job_output_dir/Sleeper.o$result"
      puts $CHECK_OUTPUT "checking output file $outfilename"

      if { ![file exists $outfilename]} {
         add_proc_error "qsub_starter_method" -1 "output file for job $result on host $actual_host does not exist"
         set ok 0
      } else {
         set f [open $outfilename r]
         set files_ok 0
         set num_lines 0
         while {[gets $f line] >= 0} {
          incr num_lines
          puts $CHECK_OUTPUT $line
           if {[string compare $line "starter method started"] == 0} {
             set files_ok 1
             break
           }
         }
         if {$num_lines == 0} {
            add_proc_error "qsub_starter_method" -1 "error reading from job output file for job $result on host $actual_host"
            set ok 0
         } else {
           if {$files_ok == 0} {
               add_proc_error "qsub_starter_method" -1 "starter method was not started for job $result on host $actual_host"
               set ok 0
           }
         }  
         close $f
      }
   }

   # cleanup
   set back [del_job_files $result $job_output_dir 2]
   if { $back != 2 } {
      add_proc_error "qsub_starter_method" -1 "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {! $ok && $result > 0} {
      delete_job $result
   }

   # unset starter method
   set change_array(starter_method) "none"
   mod_queue all.q "" change_array

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qsub/setup_output_directory() ******
# 
#  NAME
#     setup_output_directory -- ??? 
#
#  SYNOPSIS
#     setup_output_directory { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_output_directory {} {
   global CHECK_OUTPUT job_output_dir 
   
   if {[string length $job_output_dir] < 5} {
      add_proc_error "setup_output_directory" -1 "job output dir path must at least have 5 characters\ngot \"$job_output_dir\""
      return -1
   }
  
   # create directory, if it does not yet exist
   # if it already exists, delete all files in it
   set files_deleted 0
   if {![file isdirectory "$job_output_dir"]} {
      file mkdir "$job_output_dir"
      puts $CHECK_OUTPUT "new output directory \"$job_output_dir\" generated!"
   } else {
      puts $CHECK_OUTPUT "deleting all files in output directory \"$job_output_dir\"!"
      set files [ glob -nocomplain $job_output_dir/* ]
      foreach elem $files {
         puts $CHECK_OUTPUT $elem
         if { [ file isfile $elem ] == 1 } {
            puts $CHECK_OUTPUT "deleting file $elem"
            incr files_deleted
            delete_file $elem
         } 
      }
   }

   # make sure every user may create output files here
   file attributes $job_output_dir -permissions "a+rwx"
   
   return $files_deleted 
}

#                                                             max. column:     |
#****** qsub/check_hold() ******
# 
#  NAME
#     check_hold -- ??? 
#
#  SYNOPSIS
#     check_hold { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_hold {} {
   global check_errno CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT job_output_dir actual_host
   global default_args

   set ok 1

   # first clean up output directory:  
   setup_output_directory

   set jobargs "-h $default_args"
   set result [submit_job $jobargs] 
   if {$result < 0} {
      add_proc_error "check_hold" -1 "error submitting job \"$jobargs\"\nerror $result"
      set_error 0 ok ; return
   }
 
   # wait for job to get in pending state 
   if {[wait_for_jobpending $result "leeper" 200] != 0} {
      add_proc_error "check_hold" -1 "job $result is not in pending state"
      set ok 0
   } 

   # job should not run within the next 2 minutes 
   if {$ok} {
      puts $CHECK_OUTPUT "check_hold - set hold for job $result, job should not start"
      if { [wait_for_jobstart $result "leeper" 120 0] != -1 } {
         add_proc_error "check_hold" -1 "job $result should not run until yet"
         set ok 0
      } 
   } 

   # release job
   if {$ok} {
      puts $CHECK_OUTPUT "check_hold - ok now we release the job"
      release_job $result
   }

   # wait for job to start
   if {$ok} {
      if {[wait_for_jobstart $result "leeper" 300] == -1} {
         add_proc_error "check_hold" -1 "check_hold - job $result doesn't start"
         set ok 0
      }
   }
 
   # wait for end of job
   if {$ok} {
      if {[wait_for_jobend $result "leeper" 300] == -1} {
         add_proc_error "check_hold" -1 "check_hold - job $result doesn't stop"
         set ok 0
      }
   }
   
   # cleanup
   set back [ del_job_files $result $job_output_dir 2 ] 
   if { $back != 2 } {
      add_proc_error "check_hold" -1 "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {! $ok && $result > 0} {
      delete_job $result
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qsub/check_start_time() ******
# 
#  NAME
#     check_start_time -- ??? 
#
#  SYNOPSIS
#     check_start_time { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_start_time {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   global check_errno job_output_dir
   global check_errstr CHECK_OUTPUT actual_host

   # first clean up output directory:  
   setup_output_directory
   
   set hour [exec date "+%H"]
   set minute [exec date "+%M"]

   if { [string first "0" $hour] == 0 } {
      set hour [string index $hour 1 ]
   }  
   if { [string first "0" $minute] == 0 } {
      set minute [string index $minute 1 ]
   }  

   if {$minute < 58 } {
     set minute [expr ($minute + 2) ]
   } else {
     set minute [expr ($minute + 2 - 60) ]
 
     if {$hour < 23 } {
        set hour [expr ($hour + 1) ]
     } else {
        set hour "00"
     }
   }

   set rhour $hour
   set rminute $minute

   if {$hour < 10} {
     set rhour "0$hour"
   }
   if {$minute < 10} {
     set rminute "0$minute"
   }
   
   set start "[exec date +\%Y\%m\%d]$rhour$rminute"

   set jobargs "-a $start -l h=${actual_host} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 60" 

   set time [timestamp]
   set seconds [exec date "+%S"]
   if { [string first "0" $seconds] == 0 } {
      set seconds [string index $seconds 1 ]
   }     

   set ok 1

   # submit job
   set result [submit_job $jobargs] 
   if {$result < 0} {
      add_proc_error "check_start_time" -1 "error submitting job \"$jobargs\"\nerror $result"
      set_error 0 ok ; return
   }

   # wait for job to get in pending state
   if {[wait_for_jobpending $result "leeper" 200] != 0} {
      add_proc_error "check_start_time" -1 "job $result is not in pending state"
      set ok 0
   } 
   
   # calulate time until job should run
   if {$ok} {
      set pend_time [expr ( [timestamp] - $time )]
      set wait_time [expr ( 120 - $pend_time - $seconds - 10 ) ] ;# 10 seconds are ok  
      puts $CHECK_OUTPUT "check_start_time - job should not start the next $wait_time seconds"
      set time [timestamp]
      if { [wait_for_jobstart $result "leeper" $wait_time 0] != -1 } {
         puts $CHECK_OUTPUT "check_start_time - time left: [expr ($wait_time - [expr ( [timestamp] - $time)] ) ]"
         add_proc_error "check_start_time" -1 "check_start_time - job $result should not run until yet"
         set ok 0
      }
   }


   # wait for job to start
   if {$ok} {
      puts $CHECK_OUTPUT "check_start_time - ok now the job should start"
      if { [wait_for_jobstart $result "leeper" 300] == -1 } {
         add_proc_error "check_start_time" -1 "check_start_time - job $result doesn't start"
         set ok 0
      }
   }
 
   # wait for end of job
   if {$ok} {
      if { [wait_for_jobend $result "leeper" 300] == -1 } {
         add_proc_error "check_start_time" -1 "check_start_time - job $result doesn't stop"
         set ok 0
      }
   }
  

   # cleanup
   set back [ del_job_files $result $job_output_dir 2 ] 
   if { $back != 2 } {
      add_proc_error "check_start_time" -1 "job $result did not produce error and output file\njobargs: $jobargs"
   }
   if {! $ok && $result > 0} {
      delete_job $result
   }

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qsub/check_deadline() ******
# 
#  NAME
#     check_deadline -- ??? 
#
#  SYNOPSIS
#     check_deadline { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_deadline {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   global check_errno actual_host
   global check_errstr CHECK_OUTPUT job_output_dir

   if {$ts_config(product_type) == "sge"} {
      add_proc_error "check_deadline" -3 "not possible in sge system"
      set_error 0 ok
      return
   }

   # Wait for zero deadlinejobs
   set nub_deadline_jobs 1
   while { $nub_deadline_jobs != 0 } {
      set nub_deadline_jobs 0 
      set job_list [ get_job_info -1 ]
      foreach line $job_list { 
        if { [ lindex $line 17 ] > 0 } {
            incr nub_deadline_jobs 
        }  
      }
      puts $CHECK_OUTPUT "waiting for zero deadline job count"
      sleep 1
   }

   # get current hour
   set hour [exec date "+%H"]
   if { [string first "0" $hour] == 0 } {
      set hour [string index $hour 1 ]
   }  

   # get current minute
   set minute [exec date "+%M"]
   if { [string first "0" $minute] == 0 } {
      set minute [string index $minute 1 ]
   }  


   # add 5 minutes
   set future_time 5

   if {$minute < [expr (60 - $future_time )] } {
     set minute [expr ($minute + $future_time) ]
   } else {
     set minute [expr ($minute + $future_time - 60) ]
 
     if {$hour < 23 } {
        set hour [expr ($hour + 1) ]
     } else {
        set hour "0"
     }
   }

   # use rhour and rminute for command string
   set rhour $hour
   set rminute $minute
   if {$hour < 10} {
     set rhour "0$hour"
   }
   if {$minute < 10} {
     set rminute "0$minute"
   }
  
   # finally get command option string 
   set deadline "[exec date +\%Y\%m\%d]$rhour$rminute"

   # deadline job (10 min) with deadline in 5 minutes
   set jobargs "-dl $deadline -l h=${actual_host} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 500" 
   # start job
   set result [submit_job $jobargs] 
   if {$result < 0 } {
      add_proc_error "check_deadline" -1 "could not submit job"
      return
   }


   # now job is in queueing system (get timestamp now)
   set time [timestamp]

   # look if only one job is running
   # if not delete the hob with higher jobid 
   set nub_deadline_jobs 0
   while { $nub_deadline_jobs != 1 } {
      sleep 2
      set nub_deadline_jobs 0 
      set job_list [ get_job_info -1 ]
      foreach line $job_list { 
        if { [ lindex $line 17 ] > 0 } {
            incr nub_deadline_jobs
            if {$nub_deadline_jobs > 1} {
               catch { exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel [lindex $line 0] }
               puts $CHECK_OUTPUT "check_deadline - delete job [lindex $line 0] "
               # retry if deleted job is from me
               if { $result == [lindex $line 0] } {
                  check_deadline
                  return
               }
            } 
        }  
      }
      
      puts $CHECK_OUTPUT "check_deadline - waiting for 1 deadline job (current count: $nub_deadline_jobs)"
   }
  
   puts $CHECK_OUTPUT "looking for job id $result"
   
   set old_tickets 0
   set deadl_jobs 1
   while {1} {
      set nub_deadline_jobs 0
      set job_tickets 0
      set job_info "none"
      set run_time [ expr ( [timestamp] - $time ) ]
      set job_list [ get_job_info -1 ]
      set found 0
      foreach line $job_list { 
         if { [lindex $line 0] == $result } {
            set job_info $line
            set job_tickets [ lindex $line 17 ]
            set found 1
         } 
         if { [ lindex $line 17 ] > 0 } {
            incr nub_deadline_jobs 
         } 
      }     
      
      if { ([was_job_running $result 0] != -1) } {
         set_error 0 ok
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            add_proc_error "check_deadline" -1 "job $result did not produce error and output file"
         }
         set_error 0 ok
         return
      }       
 
      if { $found == 0 } {
         continue
      }

      if { $job_tickets == 0 } {
         incr nub_deadline_jobs 1  
      } 
      set max_tickets 10000
      if { $nub_deadline_jobs > 1 } {
         set max_tickets [ expr ($max_tickets / $nub_deadline_jobs) ]
      }      

      puts $CHECK_OUTPUT "runtime: $run_time"
      puts $CHECK_OUTPUT "number of deadline jobs: $nub_deadline_jobs"
      puts $CHECK_OUTPUT "current tickets: $job_tickets"
 
      if { $deadl_jobs != $nub_deadline_jobs} {
         puts $CHECK_OUTPUT "deadline job count canched - can't use this run"
         set deadl_jobs $nub_deadline_jobs
      } else {
         # use dlcontr in case of 6.0
         if { ($run_time < 90) && ($job_tickets > [expr ($max_tickets / 2) ]  ) } {
            add_proc_error "check_deadline" -1 "check_deadline - job shouldn't have so much tickets until yet"
            set_error 0 ok
            return 
         }
         
         if { ($run_time > 200) && ($job_tickets < [expr ($max_tickets / 2) ] ) } {
            add_proc_error "check_deadline" -1 "check_deadline - job should have more tickets at this point of time"  
            set_error 0 ok
            return 
         }

         if { ($run_time > 400) && ($job_tickets < $max_tickets ) } {
            add_proc_error "check_deadline" -1 "check_deadline - job should have all tickets now"
            set_error 0 ok
            return   
         }
          
      }

      puts $CHECK_OUTPUT "$job_info"
      set old_tickets $job_tickets

      sleep 15
   }
   set back [ del_job_files $result $job_output_dir  2 ] 
   if { $back != 2 } {
      add_proc_error "check_deadline" -1 "job $result did not produce error and output file"
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_ac() ******
# 
#  NAME
#     check_option_ac -- ??? 
#
#  SYNOPSIS
#     check_option_ac { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ac {} {
   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH
   global CHECK_USER CHECK_HOST CHECK_ARCH actual_host

   # first clean up output directory:  
   setup_output_directory

   set option "-ac myvar1=\"test 1\" -ac myvar2='test 2'"
   # We use a special job script which contains context variable settings
   set jobargs "$option -l h=${actual_host} -o $job_output_dir -e $job_output_dir $CHECK_ACTUAL_TEST_PATH/sleeper.sh 60" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      add_proc_error "check_option_ac" -1 "error submitting job \"$jobargs\"\nerror $result"
      set_error 0 ok ; return
   }

   set qstatoutput [start_sge_bin "qstat" "-j $result"]

   if {$prg_exit_state != 0} {
      add_proc_error "check_option_ac" -1 "error executing qstat -j $result"
      set_error 0 ok ; return
   }

   if {[regexp {context:([^\r\n]+\r?\n)} $qstatoutput match vars] != 1} {
      add_proc_error "check_option_ac" -1 "qsub $option - qsub error: context variables were not set"
      set_error 0 ok ; return
   }

   puts $CHECK_OUTPUT "context variables: $vars"

   if {[regexp {[ \t,]myvar1=test 1[,\r\n]} $vars match] != 1} {
      add_proc_error "check_option_ac" -1 "qsub $option - qsub error: command-line context variable was not set"
      set_error 0 ok ; return
   } elseif {[regexp {[ \t,]myvar2=test 2[,\r\n]} $vars match] != 1} {
      add_proc_error "check_option_ac" -1 "qsub $option - qsub error: command-line context variable was not set"
      set_error 0 ok ; return
   } elseif {[regexp {[ \t,]myvar3=test 3[,\r\n]} $vars match] != 1} {
      add_proc_error "check_option_ac" -1 "qsub $option - qsub error: inline context variable was not set"
      set_error 0 ok ; return
   } elseif {[regexp {[ \t,]myvar4=test 4[,\r\n]} $vars match] != 1} {
      if {[regexp {[ \t,]myvar4='test 4'[,\r\n]} $vars match] == 1} {
         add_proc_error "check_option_ac" -3 "qsub $option - qsub error: issue IZ1850 encountered"
         set_error 0 ok ; return
      }

      add_proc_error "check_option_ac" -1 "qsub $option - qsub error: inline context variable was not set"
      set_error 0 ok ; return
   }

   set time [expr ([timestamp] + 300)] 

   while {[timestamp] < $time}  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            add_proc_error "check_option_ac" -1 "job $result did not produce error and output file\njobargs: $jobargs"
            set_error 0 ok ; return
         } else {
            set_error 0 ok
            return
         }
      }
   }
 
   add_proc_error "check_option_ac" -1 "timeout while waiting for job accounting"
   set_error 0 ok
}


#                                                             max. column:     |
#****** qsub/check_option_A() ******
# 
#  NAME
#     check_option_A -- ??? 
#
#  SYNOPSIS
#     check_option_A { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_A {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-A blahblah"
   set jobargs "$option $default_args"
 
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(account) != "blahblah"} {
         add_proc_error -1 "check_option_A" "account string requested with -A option missing in accounting record"
      }
   }

   set_error 0 ok
}


#                                                             max. column:     |
#****** qsub/check_option_clear() ******
# 
#  NAME
#     check_option_clear -- ??? 
#
#  SYNOPSIS
#     check_option_clear { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_clear {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-A blahblah -clear"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(account) == "blahblah"} {
         add_proc_error -1 "check_option_A" "-clear option didn't earlier -A option"
      }
   }

   set_error 0 ok
}



#                                                             max. column:     |
#****** qsub/check_option_c() ******
# 
#  NAME
#     check_option_c -- ??? 
#
#  SYNOPSIS
#     check_option_c { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_c {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-c n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_ckpt() ******
# 
#  NAME
#     check_option_ckpt -- ??? 
#
#  SYNOPSIS
#     check_option_ckpt { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ckpt {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-ckpt testcheckpointobject"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_cwd() ******
# 
#  NAME
#     check_option_cwd -- ??? 
#
#  SYNOPSIS
#     check_option_cwd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_cwd {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-cwd"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_C() ******
# 
#  NAME
#     check_option_C -- ??? 
#
#  SYNOPSIS
#     check_option_C { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_C {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-C TESTPREFIX"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_dc() ******
# 
#  NAME
#     check_option_dc -- ??? 
#
#  SYNOPSIS
#     check_option_dc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_dc {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-dc myvar,myvar2"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_e() ******
# 
#  NAME
#     check_option_e -- ??? 
#
#  SYNOPSIS
#     check_option_e { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_e {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   # we submit just with default args - they contain the -e option
   qsub_submit_check $default_args 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_hard() ******
# 
#  NAME
#     check_option_hard -- ??? 
#
#  SYNOPSIS
#     check_option_hard { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hard {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-hard"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_help() ******
# 
#  NAME
#     check_option_help -- ??? 
#
#  SYNOPSIS
#     check_option_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_help {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-help"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_hold_jid() ******
# 
#  NAME
#     check_option_hold_jid -- ??? 
#
#  SYNOPSIS
#     check_option_hold_jid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hold_jid {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-hold_jid 1,2,3"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   # test with job names
   if {$ts_config(gridengine_version) >= 60} {
      set option "-hold_jid foo,bar"
      set jobargs "$option $default_args"
      qsub_submit_check $jobargs 0
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_j_y() ******
# 
#  NAME
#     check_option_j_y -- ??? 
#
#  SYNOPSIS
#     check_option_j_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_y {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-j y"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0 "" "" 1

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_j_n() ******
# 
#  NAME
#     check_option_j_n -- ??? 
#
#  SYNOPSIS
#     check_option_j_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_n {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-j n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_l() ******
# 
#  NAME
#     check_option_l -- ??? 
#
#  SYNOPSIS
#     check_option_l { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_l {} {
   global ts_config CHECK_OUTPUT
   global default_h_args

   # first clean up output directory:  
   setup_output_directory

   # the default_h_args contain -l h=...
   set jobargs "$default_h_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_m() ******
# 
#  NAME
#     check_option_m -- ??? 
#
#  SYNOPSIS
#     check_option_m { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_m {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-m beas"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_notify() ******
# 
#  NAME
#     check_option_notify -- ??? 
#
#  SYNOPSIS
#     check_option_notify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_notify {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-notify"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_now_yes() ******
# 
#  NAME
#     check_option_now_yes -- ??? 
#
#  SYNOPSIS
#     check_option_now_yes { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_yes {} {
   global ts_config CHECK_OUTPUT
   global default_args job_output_dir

   # first clean up output directory:  
   setup_output_directory

   set option "-now yes"
   set jobargs "$option $default_args"
  

   for { set i 1} { $i <= 3 } { incr i 1 } {
      set result [submit_job $jobargs 0]
      if { $result != -6 } {
         break;
      } else {
         add_proc_error "check_option_now_yes" -3 "bugtraq id: 4938859 ->\nqsub -now yes returned job could not be scheduled, try later - error - trying again ... (try $i)"
         puts $CHECK_OUTPUT "sleeping 5 sec ..."
         sleep 5
      }
   }
   
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job\n -> return value of submit_job: $result"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_now_no() ******
# 
#  NAME
#     check_option_now_no -- ??? 
#
#  SYNOPSIS
#     check_option_now_no { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_no {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-now no"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_M() ******
# 
#  NAME
#     check_option_M -- ??? 
#
#  SYNOPSIS
#     check_option_M { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_M {} {
   global ts_config CHECK_OUTPUT 
   global CHECK_REPORT_EMAIL_TO
   global default_args

   # can't run the check, if no email address has been configured
   if {[string compare $CHECK_REPORT_EMAIL_TO "none"] == 0} {
      add_proc_error "check_option_M" -3 "no email address configured - can't run qsub -M check"  
      set_error 0 ok
      return
   }

   # first clean up output directory:  
   setup_output_directory

   set option "-M $CHECK_REPORT_EMAIL_TO"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_N() ******
# 
#  NAME
#     check_option_N -- ??? 
#
#  SYNOPSIS
#     check_option_N { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_N {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-N leeper_job"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(jobname) != "leeper_job"} {
         add_proc_error -1 "check_option_N" "job name specified by -N switch missing in accounting record"
      }
   }

   set_error 0 ok
}


#                                                             max. column:     |
#****** qsub/check_option_o() ******
# 
#  NAME
#     check_option_o -- ??? 
#
#  SYNOPSIS
#     check_option_o { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_o {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   # the default args already contain a -o option
   qsub_submit_check $default_args 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_P() ******
# 
#  NAME
#     check_option_P -- ??? 
#
#  SYNOPSIS
#     check_option_P { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_P {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-P mytestproject"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(project) != "mytestproject"} {
         add_proc_error -1 "check_option_P" "project specified by -P switch missing in accounting record"
      }
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_p() ******
# 
#  NAME
#     check_option_p -- ??? 
#
#  SYNOPSIS
#     check_option_p { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_p {} {
   global ts_config CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER
   global default_args

   # first clean up output directory:  
   setup_output_directory

   # test -p option:
   # any user must be allowed to submit with negative -p
   # only superuser may submit with positive -p
   
   # set as admin user: complete range
   qsub_submit_check "-p -1023 $default_args" 0 $CHECK_USER ;# IZ 2055
   qsub_submit_check "-p 0 $default_args" 0 $CHECK_USER
   qsub_submit_check "-p 1024 $default_args" 0 $CHECK_USER

   qsub_submit_check "-p -1024 $default_args" 1 $CHECK_USER
   qsub_submit_check "-p 1025 $default_args" 1 $CHECK_USER

   # test as non admin user: only negative .. 0
   qsub_submit_check "-p -100 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER ;# IZ 2055
   qsub_submit_check "-p 0 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # Up to version 6.0, a positive priority from non operators will be silently 
   # set to 0 by qmaster.
   # Beginning with version 6.5, we will reject such jobs.
   if {$ts_config(gridengine_version) <= 60} {
      qsub_submit_check "-p 1 $default_args" 0 $CHECK_FIRST_FOREIGN_SYSTEM_USER
   } else {
      qsub_submit_check "-p 1 $default_args" 1 $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_pe() ******
# 
#  NAME
#     check_option_pe -- ??? 
#
#  SYNOPSIS
#     check_option_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_pe {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-pe mytestpe 1-3"
   set jobargs "$option $default_args"
   set job_id [qsub_submit_check $jobargs 0 "" "" 4]

   if {$job_id > 0} {
      get_qacct $job_id
      if {$qacct_info(granted_pe) != "mytestpe"} {
         add_proc_error -1 "check_option_pe" "granted_pe missing in accounting record"
      }
      if {$qacct_info(slots) != 3} {
         add_proc_error -1 "check_option_pe" "slots incorrect in accounting record"
      }
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_q() ******
# 
#  NAME
#     check_option_q -- ??? 
#
#  SYNOPSIS
#     check_option_q { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_q {} {
   global ts_config CHECK_OUTPUT
   global default_args actual_host

   # first clean up output directory:  
   setup_output_directory

   # submission to a queue instance (5.3 queue)
   set qinstance [get_queue_instance "all.q" $actual_host]
   qsub_submit_check "-q $qinstance $default_args" 0

   # beginning with 6.0, we can also submit
   #  - to a cluster queue
   #  - to all queue instances on a host
   #  - to all qinstances of a hostgroup
   if {$ts_config(gridengine_version) >= 60} {
      qsub_submit_check "-q *@${actual_host} $default_args" 0
      qsub_submit_check "-q *@@allhosts $default_args" 0
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_r_y() ******
# 
#  NAME
#     check_option_r_y -- ??? 
#
#  SYNOPSIS
#     check_option_r_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_y {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-r y"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_r_n() ******
# 
#  NAME
#     check_option_r_n -- ??? 
#
#  SYNOPSIS
#     check_option_r_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_n {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-r n"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_sc() ******
# 
#  NAME
#     check_option_sc -- ??? 
#
#  SYNOPSIS
#     check_option_sc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_sc {} {
   global ts_config
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-sc myvar=test3"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_soft() ******
# 
#  NAME
#     check_option_soft -- ??? 
#
#  SYNOPSIS
#     check_option_soft { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_soft {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-soft"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_S() ******
# 
#  NAME
#     check_option_S -- ??? 
#
#  SYNOPSIS
#     check_option_S { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_S {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-S /bin/sh"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_t() ******
# 
#  NAME
#     check_option_t -- ??? 
#
#  SYNOPSIS
#     check_option_t { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_t {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-t 1-2:-1"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set option "-t 1-2:xx"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 1

   set option "-t 2-8:2"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0 "" "" 8
  
   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_verify() ******
# 
#  NAME
#     check_option_verify -- ??? 
#
#  SYNOPSIS
#     check_option_verify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_verify {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-verify"
   set jobargs "$option $default_args"
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result != -4 } {
      add_proc_error "check_option_verify" -1 "no verify output on -verify command"
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_V() ******
# 
#  NAME
#     check_option_V -- ??? 
#
#  SYNOPSIS
#     check_option_V { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_V {} {
   global ts_config CHECK_OUTPUT
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-V"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_w() ******
# 
#  NAME
#     check_option_w -- ??? 
#
#  SYNOPSIS
#     check_option_w { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_w {} {
   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT actual_host
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-w e"
   set jobargs "$option $default_args"
   qsub_submit_check $jobargs 0

   # negative test: -w e -q <invalid queue> has to be rejected
   qsub_submit_check "-q blah $jobargs" 1

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_option_@() ******
# 
#  NAME
#     check_option_@ -- ??? 
#
#  SYNOPSIS
#     check_option_@ { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_@ {} {
   global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH
   global default_args

   # first clean up output directory:  
   setup_output_directory

   set option "-@ $CHECK_ACTUAL_TEST_PATH/commandfile.txt"
   set jobargs "$option $default_args"
  
   set result [submit_job $jobargs 0]  

   if { $result != -2 } {
      add_proc_error "check_option_@" -1 "no help output on -@ commandfile option"
   }

   set_error 0 ok
}

#                                                             max. column:     |
#****** qsub/check_huge_script() ******
# 
#  NAME
#     check_huge_script -- ??? 
#
#  SYNOPSIS
#     check_huge_script { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_huge_script {} {
   global job_output_dir CHECK_PROTOCOL_DIR CHECK_ACT_LEVEL
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH actual_host
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT steps_per_queue size_interval
   global default_q_args default_h_args

   # first clean up output directory:  
   setup_output_directory

   # protocol
   set protocol_filename "$CHECK_PROTOCOL_DIR/qsub_huge_script.txt"
   if { $CHECK_ACT_LEVEL == 0 } {
      set protocol [open $protocol_filename "w"]
      puts $protocol "submitting huge scripts"
      puts $protocol "size       = size of the script"
      puts $protocol "submittime = time needed to submit the script, timeout after $HUGE_SCRIPT_TIMEOUT s"
      puts $protocol "schedtime  = time the job needs to startup"
      puts $protocol "runtime    = runtime of the job"
      puts $protocol ""
      puts $protocol "size\tsubmittime\tschedtime\truntime"
      flush $protocol
   } else {
      set protocol [open $protocol_filename "a"]
   }

   for { set step 0 } { $step < $steps_per_queue } { incr step } {
      # create a huge sleeper.sh
      set filename "$job_output_dir/sleeper.sh"
      file copy -force "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh" "$filename"
      set f [open $filename a]
      puts $f "exit 0"
      set times [expr ($CHECK_ACT_LEVEL * $size_interval * $steps_per_queue + $size_interval * $step) / [string length "$HUGE_SCRIPT_PATTERN"]]
      for { set i 0 } { $i < $times } { incr i} {
         puts $f "$HUGE_SCRIPT_PATTERN"
      }
      close $f
   
      set submit_size [file size $filename]
      puts $CHECK_OUTPUT "submitting job script of size $submit_size bytes allowing a timeout of $HUGE_SCRIPT_TIMEOUT s"
   
      set jobargs "-l h=${actual_host} -o $job_output_dir -e $job_output_dir $filename 5" 
      #puts $CHECK_OUTPUT "\njob has args: \"$jobargs\""
      
      set submit_start [clock seconds]
      set result [submit_job $jobargs 1 $HUGE_SCRIPT_TIMEOUT]
      if { $result < 0 } {
         add_proc_error "check_huge_script" -1 "could not submit job (result: $result)"
         close $protocol
         set_error 0 ok
         return
      } else {
         set sched_start [clock seconds]
         set submit_time [expr $sched_start - $submit_start]
         puts $CHECK_OUTPUT "submitting lasted $submit_time s"
         wait_for_jobstart $result "Sleeper" $HUGE_SCRIPT_TIMEOUT
         set run_start [clock seconds]
         set sched_time [expr $run_start - $sched_start]
         wait_for_jobend $result "Sleeper" $HUGE_SCRIPT_TIMEOUT
         set run_end [clock seconds]
         set run_time [expr $run_end - $run_start]
         puts $protocol "$submit_size\t$submit_time\t$sched_time\t$run_time"
         flush $protocol
      }
   
      file delete $filename
   
      set back [ del_job_files $result $job_output_dir 2 ] 
      if { $back != 2 } {
         add_proc_error "check_huge_script" -1 "job $result did not produce error and output file\njobargs: $jobargs"
         close $protocol
         set_error 0 ok
         return
      }
   }

   close $protocol
   set_error 0 "ok"
}

proc qsub_setup {} {
   global ts_config
   global stored_configuration
   global job_output_dir actual_host default_args default_q_args default_h_args
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_TIMEOUT HUGE_SCRIPT_STEPS steps_per_queue size_interval
   global HUGE_SCRIPT_MAX_SIZE

   # set some global variables
   set num_queues [llength $ts_config(unique_arch_nodes)] 

   # run host specific tests on a random host
   set idx [expr [timestamp] % $num_queues]
   set actual_host [lindex $ts_config(unique_arch_nodes) $idx] 

   # set default jobargs
   set default_args "-o $job_output_dir -e $job_output_dir $ts_config(product_root)/examples/jobs/sleeper.sh 5"
   set qinstance [get_queue_instance "all.q" $actual_host]
   set default_q_args "-q $qinstance $default_args"
   set default_h_args "-l h=${actual_host} $default_args"

   # setup huge_script test
   set steps_per_queue [expr $HUGE_SCRIPT_STEPS / $num_queues]
   if {[expr $steps_per_queue * $num_queues] < $HUGE_SCRIPT_STEPS} {
      incr steps_per_queue
   }
   set steps_total [expr $steps_per_queue * $num_queues]
   set size_interval [expr $HUGE_SCRIPT_MAX_SIZE / $steps_total]

   # backup global config
   get_config stored_configuration
  
   # set config for fast scheduling / fast writing of accounting record
   if {$ts_config(gridengine_version) == 53} {
      set my_config(schedd_params) "$stored_configuration(schedd_params),FLUSH_SUBMIT_SEC=0"
   } else {
      set my_config(reporting_params) "accounting=true reporting=false flush_time=00:00:01 joblog=true sharelog=00:10:00"
   }
   set_config my_config

   if {$ts_config(gridengine_version) >= 60} {
      set my_schedd_conf(flush_submit_sec) "1"
      set_schedd_config my_schedd_conf 
   }

   set_error 0 "ok"
}

proc qsub_cleanup {} {
   global ts_config
   global stored_configuration

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   if {$ts_config(gridengine_version) >= 60} {
      reset_schedd_config
   }
   set_config stored_configuration
   
   set_error 0 "ok"
}
