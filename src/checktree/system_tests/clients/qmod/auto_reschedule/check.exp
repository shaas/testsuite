#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# we need root access 
set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qmod_auto_reschedule_init_level"

# define test's name and run level descriptions
set check_name            "qmod_auto_reschedule"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   1 
set check_description(0)  "checking auto_reschedule with global reschedule_unknown 00:03:00"
set check_description(1)  "checking auto_reschedule with global reschedule_unknown 00:00:00"


# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_level_function "auto_reschedule_setup"
set check_cleanup_level_function "auto_reschedule_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "auto_reschedule_unknown_check"
lappend check_functions "auto_reschedule_unknown_check_master"


# CHECK description
# =================
# 
# disable all queues (but not auto_reschedule_host1.q and auto_reschedule_host2.q )
# 
# paramters
#
#  scheduler:
#  schedule_interval 00:00:04
#
#  global:
#  load_report_time           00:00:06
#  max_unheard                00:00:30
#  reschedule_value           00:03:00
#
#  auto_reschedule_host1:
#  reschedule_unknown         00:01:00
#
#  auto_reschedule_host2:
#  no changes
#
#  queue1:
#  hostname                   auto_reschedule_host1  
#  rerun                      TRUE
#  qtype                      BATCH INTERACTIVE PARALLEL CHECKPOINTING
#  load_thresholds            np_load_avg=8.00
#  slots                      100
#
#
#  queue2:
#  hostname                   auto_reschedule_host2  
#  rerun                      TRUE
#  qtype                      BATCH INTERACTIVE PARALLEL CHECKPOINTING
#  load_thresholds            np_load_avg=8.00
#  slots                      100
#
#  1) submit a job to each hosts ...
#     qsub -o /dev/null -e /dev/null -q auto_reschedule_host1.q -r y sleeper 10000
#     qsub -o /dev/null -e /dev/null -q auto_reschedule_host2.q -r y sleeper 10000
#
#     wait till jobs are in "r" state
#
#  2) kill execd on auto_reschedule_host1 and auto_reschedule_host2 
#
#  3) wait 80 sec for job on auto_reschedule_host1.q to get into pending state
#
#  4) job on auto_reschedule_host2.q should still run until 3 minutes are over
#
#  5) restart execds, wait for jobs to get rescheduled, remove jobs
#
#  6) 


# -------- local test procedures -----------------------------------------------

global auto_reschedule_host1 auto_reschedule_host2 queue1 queue2 global_resch
global stored_configuration
global stored_auto_reschedule_host1_config


proc qmod_auto_reschedule_init_level {} {
   global ts_config CHECK_OUTPUT CHECK_ACT_LEVEL CHECK_HOST
   global global_resch auto_reschedule_host1 auto_reschedule_host2
  
   if { [ llength $ts_config(execd_nodes) ] < 2 } {
      return -1
   }

   # This test only works if auto_reschedule_host2 is not the testsuite host
   if { [lindex $ts_config(execd_nodes) 0] != $CHECK_HOST } {
      set auto_reschedule_host2  [ lindex $ts_config(execd_nodes) 0  ]
      set auto_reschedule_host1  [ lindex $ts_config(execd_nodes) 1  ]
   } else {
      set auto_reschedule_host2  [ lindex $ts_config(execd_nodes) 1  ]
      set auto_reschedule_host1  [ lindex $ts_config(execd_nodes) 0 ]
   }

   set global_resch 1

   switch -- $CHECK_ACT_LEVEL {
     "0" { set global_resch 1
           return 0
         }
     "1" { set global_resch 0
           return 0 
         }
   }

   return -1  ;# no other level else
}

proc auto_reschedule_setup {} {
   global queue1 queue2 CHECK_OUTPUT auto_reschedule_host1 auto_reschedule_host2 CHECK_USER
   global CHECK_CORE_EXECD stored_configuration CHECK_CORE_MASTER
   global stored_auto_reschedule_host1_config global_resch CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL

   set new_queue(rerun)    "TRUE"
   set new_queue(qtype)    "BATCH INTERACTIVE PARALLEL CHECKPOINTING"
   set new_queue(load_thresholds) "np_load_avg=8.00"
   set new_queue(slots)    "100"
   add_queue queue1 $auto_reschedule_host1 new_queue
   set queue1 [get_queue_instance queue1 $auto_reschedule_host1]
 
   add_queue queue2 $auto_reschedule_host2 new_queue 
   set queue2 [get_queue_instance queue2 $auto_reschedule_host2]

   puts $CHECK_OUTPUT "added queues"

   set schedd_config(schedule_interval) "00:00:04"
   set_schedd_config schedd_config

   puts $CHECK_OUTPUT "changed schedd conf"


   if { [info exists stored_configuration] } {
      unset stored_configuration
   }
   get_config stored_configuration
   get_config tmp_config $auto_reschedule_host2
   if {![info exists tmp_config(execd_spool_dir)]} {
      get_config tmp_config
   }

   puts $CHECK_OUTPUT "waiting for change on host $auto_reschedule_host2 ..."
   set messages_name "$tmp_config(execd_spool_dir)/$auto_reschedule_host2/messages"
   set tail_id [open_remote_spawn_process $auto_reschedule_host2 $CHECK_USER "/usr/bin/tail" "-f $messages_name"]
   set sp_id [ lindex $tail_id 1 ] 


   set myconfig(load_report_time)   "00:00:06"
   set myconfig(max_unheard)        "00:00:15"


   if { $global_resch != 0 } {
      set global_reschedule_value "00:03:00" 
      set myconfig(reschedule_unknown) "00:03:00"
   } else {
      set global_reschedule_value "00:00:00" 
      set myconfig(reschedule_unknown) "00:00:00"
   }
   set_config myconfig
   puts $CHECK_OUTPUT "changed global config"


   get_config stored_auto_reschedule_host1_config $auto_reschedule_host1
   if { [info exists stored_auto_reschedule_host1_config(reschedule_unknown)] != 1 } {
       set stored_auto_reschedule_host1_config(reschedule_unknown) ""
   }
   set myhostconfig(reschedule_unknown) "00:01:00"
   set_config myhostconfig $auto_reschedule_host1

   puts $CHECK_OUTPUT "changed config for host $auto_reschedule_host1"

   puts $CHECK_OUTPUT "disabling all cluster queues"
   foreach host $CHECK_CORE_EXECD {
      set q [get_queue_instance all.q $host]
      puts $CHECK_OUTPUT $q
      disable_queue $q
   }


   set timeout 90
   puts $CHECK_OUTPUT "waiting for configuration change ..."
   expect {
     -i $sp_id full_buffer {
       add_proc_error "auto_reschedule_setup" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
     -i $sp_id timeout {
         add_proc_error "auto_reschedule_setup" -1 "setup failed (timeout waiting for config to change)"
      }
      -i $sp_id "using*${global_reschedule_value}*reschedule_unknown" {
         puts $CHECK_OUTPUT "configuration changed"
      }
   }

   close_spawn_process $tail_id

   wait_for_load_from_all_queues 200 
   puts $CHECK_OUTPUT "submitting job to queue $queue1 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue1 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30"
   set job_id1 [ submit_job $arguments ]

   puts $CHECK_OUTPUT "submitting job to queue $queue2 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue2 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 60"
   set job_id2 [ submit_job $arguments ]

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_jobend $job_id1 "Sleeper" 60
   wait_for_jobend $job_id2 "Sleeper" 60

   set_error 0 "ok"
}

proc auto_reschedule_unknown_check_master {} {
   global queue1 queue2 CHECK_OUTPUT auto_reschedule_host1 auto_reschedule_host2
   global CHECK_CORE_EXECD stored_configuration CHECK_PRODUCT_ROOT
   global CHECK_ADMIN_USER_SYSTEM CHECK_ARCH CHECK_PRODUCT_TYPE
   global global_resch CHECK_CORE_MASTER

   puts $CHECK_OUTPUT "submitting job to queue $queue1 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue1 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id1 [ submit_job $arguments ]

   puts $CHECK_OUTPUT "submitting job to queue $queue2 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue2 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id2 [ submit_job $arguments ]
   
   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100

   shutdown_master_and_scheduler $CHECK_CORE_MASTER [get_qmaster_spool_dir]

   puts $CHECK_OUTPUT "master and scheduler must be down now"

   puts $CHECK_OUTPUT "killing execd on host $auto_reschedule_host2"
   shutdown_system_daemon $auto_reschedule_host2 "execd"
   puts $CHECK_OUTPUT "execd on auto_reschedule_host2 ($auto_reschedule_host2) should be down now"   

   startup_qmaster
   puts $CHECK_OUTPUT "master and scheduler should be up again now"

   if { $global_resch != 0 } {
      # here we have global reshedule_unkown enabled
      puts $CHECK_OUTPUT "global reshedule_unkown enabled"
      wait_for_jobpending $job_id2 "Sleeper" 360
   } else {
      # here we have global reschedule_unkown set to 00:00:00
      puts $CHECK_OUTPUT "global reschedule_unkown set to 00:00:00"
      set my_timeout [ expr ( [timestamp] + 260 ) ]
      while { [timestamp] <= $my_timeout }  {
         set j_state [ is_job_running $job_id2 "Sleeper" ]
         if { $j_state != 1 } {
            add_proc_error "auto_reschedule_unknown_check" -1 "job $job_id2 should still run"
            break
         } else {
            set to_go [ expr ( $my_timeout - [timestamp] ) ]
            puts $CHECK_OUTPUT "job $job_id2 still running, continue in $to_go seconds ... "
         }
         sleep 10
      }
   }

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_end_of_transfer $job_id1 100

   # restart execds
   startup_execd $auto_reschedule_host2

   wait_for_jobstart $job_id2 "Sleeper" 300
   wait_for_end_of_transfer $job_id2 100

   delete_job $job_id1
   delete_job $job_id2
   
   wait_for_jobend $job_id1 "Sleeper" 200 0
   wait_for_jobend $job_id2 "Sleeper" 200 0

   set_error 0 "ok"
}

proc auto_reschedule_unknown_check {} {
   global queue1 queue2 CHECK_OUTPUT auto_reschedule_host1 auto_reschedule_host2
   global CHECK_CORE_EXECD stored_configuration CHECK_PRODUCT_ROOT
   global CHECK_ADMIN_USER_SYSTEM CHECK_ARCH CHECK_PRODUCT_TYPE
   global global_resch 

   puts $CHECK_OUTPUT "submitting job to queue $queue1 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue1 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id1 [ submit_job $arguments ]

   puts $CHECK_OUTPUT "submitting job to queue $queue2 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue2 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id2 [ submit_job $arguments ]

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100

   # shutdown execds
   puts $CHECK_OUTPUT "killing execd on host $auto_reschedule_host1 ..."
   shutdown_system_daemon $auto_reschedule_host1 "execd" 
   puts $CHECK_OUTPUT "killing execd on host $auto_reschedule_host2 ..."
   shutdown_system_daemon $auto_reschedule_host2 "execd"  

   set my_queue_names $queue1
   lappend my_queue_names $queue2
   wait_for_unknown_load 100 $my_queue_names
   puts $CHECK_OUTPUT "both execd should be down now"

   if { $global_resch != 0 } {
      # here we have global reshedule_unkown enabled
      wait_for_jobpending $job_id1  "Sleeper" 80
      set j_state [ is_job_running $job_id2 "Sleeper" ]
      if { $j_state != 1 } {
          add_proc_error "auto_reschedule_unknown_check" -1 "job $job_id2 should still run(1)"
      }
      wait_for_jobpending $job_id2  "Sleeper" 220
   } else {
      # here we have global reshedule_unkown set to 00:00:00
      set my_timeout [ expr ( [timestamp] + 250 ) ]
      wait_for_jobpending $job_id1  "Sleeper" 80
      while { [timestamp] <= $my_timeout }  {
         set j_state [ is_job_running $job_id2 "Sleeper" ]
         if { $j_state != 1 } {
            add_proc_error "auto_reschedule_unknown_check" -1 "job $job_id2 should still run(2)"
            break
         } else {
            set to_go [ expr ( $my_timeout - [timestamp] ) ]
            puts $CHECK_OUTPUT "job $job_id2 still running, continue in $to_go seconds ... "
         }
         sleep 10
      }
   }

   # restart execds
   startup_execd $auto_reschedule_host1
   startup_execd $auto_reschedule_host2 

   wait_for_load_from_all_queues 200 

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100
   
   delete_job $job_id1
   delete_job $job_id2
   
   wait_for_jobend $job_id1 "Sleeper" 200 0
   wait_for_jobend $job_id2 "Sleeper" 200 0

   set_error 0 "ok"
}

proc auto_reschedule_cleanup {} {
   global queue1 queue2 CHECK_OUTPUT auto_reschedule_host1 auto_reschedule_host2
   global CHECK_CORE_EXECD stored_configuration
   global stored_auto_reschedule_host1_config CHECK_USER

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   reset_schedd_config

   get_config tmp_config $auto_reschedule_host2
   if {![info exists tmp_config(execd_spool_dir)]} {
         get_config tmp_config
   }

   set messages_name "$tmp_config(execd_spool_dir)/$auto_reschedule_host2/messages"
   set tail_id [open_remote_spawn_process $auto_reschedule_host2 $CHECK_USER "/usr/bin/tail" "-f $messages_name"]
   set sp_id [ lindex $tail_id 1 ] 
   
   set_config stored_configuration
   set_config stored_auto_reschedule_host1_config $auto_reschedule_host1

   puts $CHECK_OUTPUT "removing queues ..."
   del_queue queue1 $auto_reschedule_host1 0 1
   del_queue queue2 $auto_reschedule_host2 0 1

   puts $CHECK_OUTPUT "enabling queues ..."
   foreach host $CHECK_CORE_EXECD {
      puts $CHECK_OUTPUT $host
      enable_queue [get_queue_instance all.q $host]
   }
    
   set timeout 300
   puts $CHECK_OUTPUT "waiting for configuration change ..."
   expect {
     -i $sp_id full_buffer {
       add_proc_error "auto_reschedule_cleanup" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
     -i $sp_id default {
         add_proc_error "auto_reschedule_cleanup" -1 "setup failed"
      }
      -i $sp_id "using*00:00:00*reschedule_unknown" {
         puts $CHECK_OUTPUT "configuration changed"
      }
   }

   close_spawn_process $tail_id

   wait_for_load_from_all_queues 200 

   set_error 0 "ok"
}
