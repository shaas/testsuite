#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# we need root access 
set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qmod_auto_reschedule_init_level"

# define test's name and run level descriptions
set check_name            "qmod_auto_reschedule"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   3 
set check_description(0)  "checking auto_reschedule with global reschedule_unknown 00:01:00"
set check_description(1)  "checking auto_reschedule with global reschedule_unknown 00:00:00"
set check_description(2)  "checking auto_reschedule with global reschedule_unknown 00:01:00 and ENABLE_RESCHEDULE_KILL"
set check_description(3)  "checking auto_reschedule with global reschedule_unknown 00:01:00, ENABLE_RESCHEDULE_KILL and ENABLE_RESCHEDULE_SLAVE"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_level_function "auto_reschedule_setup"
set check_cleanup_level_function "auto_reschedule_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "auto_reschedule_unknown_check"
lappend check_functions "auto_reschedule_unknown_check_master"

# CHECK description
# =================
# 
# disable all queues (but not auto_reschedule_host1.q and auto_reschedule_host2.q )
# 
# paramters
#
#  scheduler:
#  schedule_interval 00:00:04
#
#  global:
#  load_report_time           00:00:06
#  max_unheard                00:00:30
#  reschedule_value           00:01:00
#
#  auto_reschedule_host1:
#  reschedule_unknown         00:01:00
#
#  auto_reschedule_host2:
#  no changes
#
#  queue1:
#  hostname                   auto_reschedule_host1  
#  rerun                      TRUE
#  qtype                      BATCH INTERACTIVE PARALLEL CHECKPOINTING
#  load_thresholds            np_load_avg=8.00
#  slots                      100
#
#
#  queue2:
#  hostname                   auto_reschedule_host2  
#  rerun                      TRUE
#  qtype                      BATCH INTERACTIVE PARALLEL CHECKPOINTING
#  load_thresholds            np_load_avg=8.00
#  slots                      100
#
#  1) submit different jobs to each hosts ...
#     wait till jobs are in "r" state
#
#  2) kill execd on auto_reschedule_host1 and auto_reschedule_host2 
#
#  3) wait 80 sec for first job on auto_reschedule_host1.q to get into pending state,
#     second stay running in runlevel 0 and 1 and gets killed in runlevel 2 and 3
#
#  4) job on auto_reschedule_host2.q should still run until 3 minutes are over
#
#  5) restart execds, wait for jobs to get rescheduled, remove jobs
#
# -------- local test procedures -----------------------------------------------

proc qmod_auto_reschedule_init_level {} {
   global ts_config CHECK_ACT_LEVEL
  
   if {[llength $ts_config(execd_nodes)] < 2} {
      return -1
   }

   switch -- $CHECK_ACT_LEVEL {
      0 -
      1 {
         return 0
      }
      2 -
      3 {
         if {$ts_config(gridengine_version) >= 62} {
            return 0
         } else {
           return -1
         }
      }
   }

   return -1  ;# no other level else
}

proc auto_reschedule_setup {} {
   global ts_config CHECK_ACT_LEVEL
   global CHECK_USER
   global queue1 queue2 auto_reschedule_host1 auto_reschedule_host2
   global stored_configuration
   global stored_auto_reschedule_host1_config global_resch reschedule_kill reschedule_slave
  
   # This test only works if auto_reschedule_host2 is not the testsuite host
   set hosts [host_conf_get_suited_hosts 2]
   if {[lindex $hosts 0] != $ts_config(master_host)} {
      set auto_reschedule_host2 [lindex $hosts 0]
      set auto_reschedule_host1 [lindex $hosts 1]
   } else {
      set auto_reschedule_host2 [lindex $hosts 1]
      set auto_reschedule_host1 [lindex $hosts 0]
   }

   switch -- $CHECK_ACT_LEVEL {
      0 {
         set global_resch 1
         set reschedule_kill 0
         set reschedule_slave 0
      }
      1 {
         set global_resch 0
         set reschedule_kill 0
         set reschedule_slave 0
      }
      2 {
         set global_resch 1
         set reschedule_kill 1
         set reschedule_slave 0
      }
      3 {
         set global_resch 1
         set reschedule_kill 1
         set reschedule_slave 1
      }
   }

   # create parallel environment
   set pe(slots)              1000
   set pe(allocation_rule)    "\$round_robin"
   set pe(control_slaves)     TRUE
   set pe(job_is_first_task)  FALSE
   add_pe "tight" pe

   # set new_queue(rerun)    "TRUE"
   set new_queue(qtype)    "BATCH INTERACTIVE"
   set new_queue(load_thresholds) "np_load_avg=8.00"
   set new_queue(slots)    "100"
   set new_queue(pe_list) "tight"

   add_queue "queue1" $auto_reschedule_host1 new_queue
   set queue1 [get_queue_instance "queue1" $auto_reschedule_host1]
 
   add_queue "queue2" $auto_reschedule_host2 new_queue 
   set queue2 [get_queue_instance "queue2" $auto_reschedule_host2]

   set schedd_config(schedule_interval) "00:00:04"
   set_schedd_config schedd_config

   get_config stored_configuration
   get_config tmp_config $auto_reschedule_host2
   if {![info exists tmp_config(execd_spool_dir)]} {
      get_config tmp_config
   }

   ts_log_fine "waiting for change on host $auto_reschedule_host2 ..."
   set messages_name "$tmp_config(execd_spool_dir)/$auto_reschedule_host2/messages"
   set tail_id [open_remote_spawn_process $auto_reschedule_host2 $CHECK_USER "/usr/bin/tail" "-f $messages_name"]
   set sp_id [lindex $tail_id 1] 

   set myconfig(load_report_time)   "00:00:05"
   set myconfig(max_unheard)        "00:00:10"

   if {$global_resch != 0} {
      set global_reschedule_value "00:01:00" 
      set myconfig(reschedule_unknown) "00:01:00"
   } else {
      set global_reschedule_value "00:00:00" 
      set myconfig(reschedule_unknown) "00:00:00"
   }
   if {$reschedule_kill != 0} {
      if {$reschedule_slave != 0} {
         set myconfig(qmaster_params) "ENABLE_RESCHEDULE_KILL=true,ENABLE_RESCHEDULE_SLAVE=true"
      } else {
         set myconfig(qmaster_params) "ENABLE_RESCHEDULE_KILL=true"
      }
   }
   set_config myconfig
   ts_log_fine "changed global config"

   get_config stored_auto_reschedule_host1_config $auto_reschedule_host1
   set myhostconfig(reschedule_unknown) "00:00:30"
   set_config myhostconfig $auto_reschedule_host1

   ts_log_fine "changed config for host $auto_reschedule_host1"

   ts_log_fine "disabling all cluster queues"
   foreach host $ts_config(execd_nodes) {
      set q [get_queue_instance all.q $host]
      disable_queue $q
   }

   set timeout 90
   ts_log_fine "waiting for configuration change ..."
   expect {
     -i $sp_id full_buffer {
       ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
     -i $sp_id timeout {
         set output $expect_out(buffer)
         ts_log_severe "setup failed (timeout waiting for config to change):\noutput:\n$output"
      }
      -i $sp_id "using*${global_reschedule_value}*reschedule_unknown" {
         ts_log_fine "configuration changed"
      }
   }

   close_spawn_process $tail_id
}

proc auto_reschedule_cleanup {} {
   global ts_config
   global queue1 queue2 auto_reschedule_host1 auto_reschedule_host2
   global stored_configuration
   global stored_auto_reschedule_host1_config
   global CHECK_USER

   delete_all_jobs
   wait_for_end_of_all_jobs

   reset_schedd_config

   get_config tmp_config $auto_reschedule_host2
   if {![info exists tmp_config(execd_spool_dir)]} {
      get_config tmp_config
   }

   set messages_name "$tmp_config(execd_spool_dir)/$auto_reschedule_host2/messages"
   set tail_id [open_remote_spawn_process $auto_reschedule_host2 $CHECK_USER "/usr/bin/tail" "-f $messages_name"]
   set sp_id [lindex $tail_id 1] 
   
   reset_config_and_propagate stored_configuration
   reset_config_and_propagate stored_auto_reschedule_host1_config $auto_reschedule_host1

   ts_log_fine "removing queues ..."
   del_queue queue1 $auto_reschedule_host1 0 1
   del_queue queue2 $auto_reschedule_host2 0 1

   ts_log_fine "removing pe ..."
   del_pe "tight"

   ts_log_fine "enabling queues ..."
   foreach host $ts_config(execd_nodes) {
      ts_log_fine $host
      enable_queue [get_queue_instance all.q $host]
   }
    
   set timeout 300
   ts_log_fine "waiting for configuration change ..."
   expect {
     -i $sp_id full_buffer {
       ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
     -i $sp_id default {
         ts_log_severe "setup failed"
      }
      -i $sp_id "using*00:00:00*reschedule_unknown" {
         ts_log_fine "configuration changed"
      }
   }

   close_spawn_process $tail_id
   wait_for_load_from_all_queues 200 
}

proc auto_reschedule_unknown_check_master {} {
   global ts_config
   global queue1 queue2 auto_reschedule_host1 auto_reschedule_host2
   global global_resch reschedule_kill reschedule_slave

   set my_outputs "-o /dev/null -e /dev/null"

   ts_log_fine "submitting job to queue $queue1 ..."
   set arguments "$my_outputs -q $queue1 -r y $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id1 [submit_job $arguments]

   ts_log_fine "submitting job to queue $queue2 ..."
   set arguments "$my_outputs -q $queue2 -r y $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id2 [submit_job $arguments]

   ts_log_fine "submitting job to queue $queue2 ..."
   set arguments "$my_outputs -q $queue2 $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id3 [submit_job $arguments]

   ts_log_fine "submitting pe job with master queue $queue2 ..."
   set arguments "$my_outputs -pe tight 4 -masterq $queue2 $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id4 [submit_job $arguments]

   ts_log_fine "submitting pe job with master queue $queue1 ..."
   set arguments "$my_outputs -pe tight 4 -masterq $queue1 $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id5 [submit_job $arguments]
   
   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100
   wait_for_jobstart $job_id3 "Sleeper" 100
   wait_for_jobstart $job_id4 "Sleeper" 100
   wait_for_jobstart $job_id5 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100
   wait_for_end_of_transfer $job_id3 100
   wait_for_end_of_transfer $job_id4 100
   wait_for_end_of_transfer $job_id5 100

   shutdown_master_and_scheduler $ts_config(master_host) [get_qmaster_spool_dir]

   ts_log_fine "master and scheduler must be down now"

   ts_log_fine "killing execd on host $auto_reschedule_host2"
   shutdown_system_daemon $auto_reschedule_host2 "execd"
   ts_log_fine "execd on auto_reschedule_host2 ($auto_reschedule_host2) should be down now"   

   startup_qmaster
   ts_log_fine "master and scheduler should be up again now"

   if {$global_resch != 0} {
      # here we have global reschedule_unkown enabled
      ts_log_fine "global reschedule_unkown enabled"
      wait_for_jobpending $job_id2 "Sleeper" 100 
      if {$reschedule_kill == 0} {
         if {[is_job_running $job_id3 "Sleeper"] != 1} {
            ts_log_severe "job $job_id3 should still run"
         }
         if {[is_job_running $job_id4 "Sleeper"] != 1} {
            ts_log_severe "pe (master) job $job_id4 should still run"
         }
         if {[is_job_running $job_id5 "Sleeper"] != 1} {
            ts_log_severe "pe (slave) job $job_id5 should still run"
         }
      } else {
         if {[is_job_running $job_id3 "Sleeper"] != -1} {
            ts_log_severe "job $job_id3 should be reaped"
         }
         if {[is_job_running $job_id4 "Sleeper"] != -1} {
            ts_log_severe "pe (master) job $job_id4 should be reaped"
         }
         if {$reschedule_slave == 0} {
            if {[is_job_running $job_id5 "Sleeper"] != 1} {
               ts_log_severe "pe (slave) job $job_id5 should still run"
            }
         } else {
            if {[is_job_running $job_id5 "Sleeper"] != -1} {
               ts_log_severe "pe (slave) job $job_id5 should be reaped"
            }
         }
      }
   } else {
      # here we have global reschedule_unkown set to 00:00:00
      ts_log_fine "global reschedule_unkown set to 00:00:00"
      set my_timeout [expr [timestamp] + 100]
      while {[timestamp] <= $my_timeout}  {

         if {[is_job_running $job_id2 "Sleeper"] != 1} {
            ts_log_severe "job $job_id2 should still run"
            break
         }
         if {[is_job_running $job_id3 "Sleeper"] != 1} {
            ts_log_severe "job $job_id3 should still run"
            break
         }
         if {[is_job_running $job_id4 "Sleeper"] != 1} {
            ts_log_severe "job $job_id4 should still run"
            break
         }
         if {[is_job_running $job_id5 "Sleeper"] != 1} {
            ts_log_severe "job $job_id5 should still run"
            break
         }

         set to_go [expr $my_timeout - [timestamp]]
         ts_log_fine "job $job_id2 and $job_id3 still running, continue in $to_go seconds ... "
         after 10000
      }
   }

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_end_of_transfer $job_id1 100

   # restart execds
   startup_execd $auto_reschedule_host2

   wait_for_jobstart $job_id2 "Sleeper" 300
   wait_for_end_of_transfer $job_id2 100

   delete_job $job_id1
   delete_job $job_id2
   if {$reschedule_kill == 0} {
      delete_job $job_id3
      delete_job $job_id4
      delete_job $job_id5
   } else {
      if {$reschedule_slave == 0} {
         delete_job $job_id5
      }
   }

   wait_for_jobend $job_id1 "Sleeper" 200 0
   wait_for_jobend $job_id2 "Sleeper" 200 0
   wait_for_jobend $job_id3 "Sleeper" 200 0
   wait_for_jobend $job_id4 "Sleeper" 200 0
   wait_for_jobend $job_id5 "Sleeper" 200 0
}

proc auto_reschedule_unknown_check {} {
   global ts_config
   global queue1 queue2 auto_reschedule_host1 auto_reschedule_host2
   global global_resch CHECK_ACT_LEVEL

   if {$CHECK_ACT_LEVEL != 0 && $CHECK_ACT_LEVEL != 1} {
      ts_log_fine "skipping test for runlevel $CHECK_ACT_LEVEL ..."
      return
   }

   ts_log_fine "submitting job to queue $queue1 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue1 -r y $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id1 [submit_job $arguments]

   ts_log_fine "submitting job to queue $queue2 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue2 -r y $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id2 [submit_job $arguments]

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100

   # shutdown execds
   ts_log_fine "killing execd on host $auto_reschedule_host1 ..."
   shutdown_system_daemon $auto_reschedule_host1 "execd" 
   ts_log_fine "killing execd on host $auto_reschedule_host2 ..."
   shutdown_system_daemon $auto_reschedule_host2 "execd"  

   set my_queue_names $queue1
   lappend my_queue_names $queue2
   wait_for_unknown_load 100 $my_queue_names
   ts_log_fine "both execd should be down now"

   if {$global_resch != 0} {
      # here we have global reshedule_unkown enabled
      wait_for_jobpending $job_id1  "Sleeper" 80
      set j_state [ is_job_running $job_id2 "Sleeper" ]
      if {$j_state != 1} {
          ts_log_severe "job $job_id2 should still run(1)"
      }
      wait_for_jobpending $job_id2  "Sleeper" 220
   } else {
      # here we have global reshedule_unkown set to 00:00:00
      set my_timeout [expr [timestamp] + 250]
      wait_for_jobpending $job_id1  "Sleeper" 80
      while {[timestamp] <= $my_timeout}  {
         set j_state [is_job_running $job_id2 "Sleeper"]
         if {$j_state != 1} {
            ts_log_severe "job $job_id2 should still run(2)"
            break
         } else {
            set to_go [expr $my_timeout - [timestamp]]
            ts_log_fine "job $job_id2 still running, continue in $to_go seconds ... "
         }
         after 10000
      }
   }

   # restart execds
   startup_execd $auto_reschedule_host1
   startup_execd $auto_reschedule_host2 

   wait_for_load_from_all_queues 200 

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100
   
   delete_job $job_id1
   delete_job $job_id2
   
   wait_for_jobend $job_id1 "Sleeper" 200 0
   wait_for_jobend $job_id2 "Sleeper" 200 0
}

