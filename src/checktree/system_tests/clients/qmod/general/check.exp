#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr row
global check_category
global check_init_level_procedure

set check_init_level_procedure "qmod_general_init_level"
set check_name         "qmod_general"
set check_category     "COMPATIBILITY SYSTEM L10N VERIFIED"

set check_description(0)  "checking all options, except rescheduling (-r)"
set check_needs        "init_core_system"  ;# dependencies of this check (name of other check)

# setup and cleanup functions
set check_setup_function "qmod_setup"
set check_cleanup_function "qmod_cleanup"

# define test's procedure order
set check_functions    "" 
lappend check_functions    "qmod_check_default_status"
lappend check_functions    "qmod_help"
lappend check_functions    "qmod_disable"
lappend check_functions    "qmod_enable"
lappend check_functions    "qmod_suspend"
lappend check_functions    "qmod_unsuspend"
lappend check_functions    "qmod_clearerrorstate"
lappend check_functions    "qmod_forceaction"
# ---- Wildchart test ------------------------------
lappend check_functions    "qmod_wildcard_disable"
lappend check_functions    "qmod_wildcard_enable"
lappend check_functions    "qmod_issue_1131"

global qmod_num_help_lines
global test_queue
global qmod_test_queues

set qmod_test_queues ""
lappend qmod_test_queues "qmod0"
lappend qmod_test_queues "qmod1"
lappend qmod_test_queues "qmod2"



proc qmod_general_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }

   return -1  ;# no other level else
}

#                                                             max. column:     |
#****** qmod/qmod_addqueues() ******
# 
#  NAME
#     qmod_addqueues -- ??? 
#
#  SYNOPSIS
#     qmod_addqueues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     Adds all queues from qmod_test_queues to
#     the cluster
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_setup {} {
   global ts_config
   global CHECK_OUTPUT
   global test_host test_queue qmod_test_queues 

   set test_host [lindex $ts_config(execd_nodes) 0]
   foreach queue_name $qmod_test_queues {
      set q_param(slots)                 "2"
      set q_param(load_thresholds)       "np_load_avg=6.75"      
      add_queue $queue_name $test_host q_param
   }

   set test_queue [get_queue_instance "qmod0" $test_host]

   set_error 0 "ok"        
}

#                                                             max. column:     |
#****** qmod/qmod_removequeues() ******
# 
#  NAME
#     qmod_removequeues -- ??? 
#
#  SYNOPSIS
#     qmod_removequeues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     Removes all queues from qmod_test_queues from
#     the cluster
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_cleanup {} {
   global test_host qmod_test_queues

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   foreach queue_name $qmod_test_queues {
     del_queue $queue_name $test_host 0 1
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_wildcard_enable() ******
#
#  NAME
#     qmod_wildcard_enable -- ??? 
#
#  SYNOPSIS
#     qmod_wildcard_enable { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_wildcard_enable {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT qmod_test_queues test_host
   
   #enable all queues on the test host
   set queue_name "qmod*"
   set queue_instance [get_queue_instance $queue_name $test_host] 
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -e $queue_name" } output ]
   
   if {$result != 0} {
     add_proc_error "qmod_wildcard_enable" -1 "exit state of \"qmod -e $queue_name\" is not 0"
   }            
   
   foreach queue_name $qmod_test_queues {
      set queue_instance [get_queue_instance $queue_name $test_host]
      puts $CHECK_OUTPUT "get state of queue \"$queue_instance\""
      set state [ get_queue_state $queue_instance ] 
      if { [ string compare $state "" ] != 0  } {
         add_proc_error "qmod_wildcard_enable" -1 "queue $queue_name is not in original state"
         return
      }      
   }
   
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_wildcard_disable() ******
# 
#  NAME
#     qmod_wildcard_disable -- ??? 
#
#  SYNOPSIS
#     qmod_wildcard_disable { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_wildcard_disable { } {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT test_host qmod_test_queues
   
   #disable all queues on the test host
   set queue_name [get_queue_instance "qmod*" $test_host] 
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -d $queue_name" } output ]
   
   if {$result != 0} {
     add_proc_error "qmod_wildcard_disable" -1 "exit state of \"qmod -e $queue_name\" is not 0"
   }            
   
   foreach queue_name $qmod_test_queues {
      set queue_instance [get_queue_instance $queue_name $test_host] 
      puts $CHECK_OUTPUT "get state of queue \"$queue_instance\""
      set state [ get_queue_state $queue_instance ] 
      if { [ string compare $state "d" ] != 0  } {
         add_proc_error "qmod_wildcard_disable" -1 "queue $queue_instance is not disabled"
         return
      }      
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_issue_1131() ******
# 
#  NAME
#     qmod_issue_1131
#
#     Tests the qmod -e "@<host>" call which causes a segmentation
#     fault in N1GE 6.0.
#
#  SYNOPSIS
#     qmod_issue_1131 { } 
#
#  FUNCTION
#     qmod_issue_1131 
#
#  NOTES
#     Tests the qmod -e "@<host>" call which causes a segmentation
#     fault in N1GE 6.0.
#
#  BUGS
#       1131
#
#*******************************
proc qmod_issue_1131 {} {
   global ts_config
   global CHECK_OUTPUT CHECK_ARCH
   global test_host

   set queue_name "@$test_host"
   set result [ catch { eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qmod -d $queue_name" } output ]
   
   if { $result != 0 } {
     add_proc_error "qmod_issue_1131" -1 "exit state of \"qmod -e $queue_name\" is not 0"
   }

   set INVALID_QUEUE_NAME [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_QUEUE_INVALIDQ_S] $queue_name]
   
   if { [ string compare $output $INVALID_QUEUE_NAME ] != 0 } {
      add_proc_error "qmod_issue_1131" -2 "issue 1131 still exists, qmod -e \"@<host>\" crashes qmaster"
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_check_default_status() ******
# 
#  NAME
#     qmod_check_default_status -- ??? 
#
#  SYNOPSIS
#     qmod_check_default_status { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_check_default_status {} {
  global CHECK_OUTPUT test_queue

  puts $CHECK_OUTPUT "try to get queue state of $test_queue"
  set status [ get_queue_state "$test_queue" ]
  puts $CHECK_OUTPUT $status

  if { [string compare $status ""] != 0 } {
     set_error -1 "queue $test_queue is not in default status (= no state)"
  } 
  set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_help() ******
# 
#  NAME
#     qmod_help -- ??? 
#
#  SYNOPSIS
#     qmod_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_help {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_PRODUCT_VERSION_NUMBER
   global qmod_num_help_lines

   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod" "-help" } output ]

   puts $CHECK_OUTPUT "qmod output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qmod exit state: $state"

   if {$state != 0} {
      set_error -1 "exit state is not 0"
   }

   if { [ string first $CHECK_PRODUCT_VERSION_NUMBER $output] < 0 } {
      set_error -1 "version string ($CHECK_PRODUCT_VERSION_NUMBER) not found"
   } 
 
   set lines [ split $output "\n"]
   set nr_of_lines [ llength $lines ] 

   puts $CHECK_OUTPUT "Output has $nr_of_lines lines"

   if { $nr_of_lines != $qmod_num_help_lines } {
      set_error -1 "help output has not $qmod_num_help_lines lines"
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_disable() ******
# 
#  NAME
#     qmod_disable -- ??? 
#
#  SYNOPSIS
#     qmod_disable { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_disable {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -d $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -d $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string first $state "d" ] < 0  } {
      set_error -1 "queue $test_queue is not disabled"
   }
   
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_enable() ******
# 
#  NAME
#     qmod_enable -- ??? 
#
#  SYNOPSIS
#     qmod_enable { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_enable {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -e $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -e $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }
   
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_suspend() ******
# 
#  NAME
#     qmod_suspend -- ??? 
#
#  SYNOPSIS
#     qmod_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_suspend {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -s $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -s $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string first $state "s" ] < 0 } {
      set_error -1 "queue $test_queue is not in suspend state"
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_unsuspend() ******
# 
#  NAME
#     qmod_unsuspend -- ??? 
#
#  SYNOPSIS
#     qmod_unsuspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_unsuspend {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -us $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -us $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }
   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qmod/qmod_clearerrorstate() ******
# 
#  NAME
#     qmod_clearerrorstate -- ??? 
#
#  SYNOPSIS
#     qmod_clearerrorstate { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_clearerrorstate {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 

   # set queue prolog to a non existing script - this will produce an error state
   mqattr prolog "/tmp/foo/bar/non_existing_prolog.sh" $test_queue

   # submit testjob to set the queue in error
   set job_id [ submit_job "-o /dev/null -e /dev/null -q $test_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" ] 

   # wait for queue to get in error state
   set time [timestamp]
   while {1} {
      set state [ get_queue_state $test_queue ] 
      if { [ string first "E" $state ] >=  0  } {
         break
      }

      set runtime [expr ( [timestamp] - $time) ]
      if { $runtime >= 300 } {
         set_error -1 "timeout waiting for queue $test_queue to get in error state"
         break;
      }

      sleep 1
   }
 
   # remove the prolog
   mqattr prolog none $test_queue

   # now wait for jobstart - should not happen as queue is in error state
   set result [wait_for_jobstart $job_id "leeper" 120 0]
   if {$result != -1} {
      set_error -1 "job $job_id should not start until yet"
   }

   # clear error state
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -c $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }
 
   # now wait for jobend
   wait_for_jobstart $job_id "leeper" 300
   wait_for_jobend   $job_id "leeper" 300 

   qmod_clear_all_error_states

   set_error 0 "ok" 
}

# Due to a bug, in N1GE 6 an invalid queue prolog will set the host into error state
# we have to clear it after the qmod_clearerrorstate test.
proc qmod_clear_all_error_states {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global test_host qmod_test_queues

   set queue_list $qmod_test_queues
   lappend queue_list "all.q"
   
   foreach queue $queue_list {
      set qinstance [get_queue_instance $queue $test_host]
      puts $CHECK_OUTPUT "clear error state of $qinstance"
      catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c $qinstance" } output
      puts $CHECK_OUTPUT "$output"
   }
}

# do to:
# 1) set running job to suspend
# 2) manualy (kill command) set job to running
# 3) set suspended job to suspend 
# 4) command must write something like (job already suspended)
# 5) manualy check if job is still running (should run)
# 6) use -f flag (force) to suspend job again
# 7) manualy check if job is still running (should be suspended again)
#                                                             max. column:     |
#****** qmod/qmod_forceaction() ******
# 
#  NAME
#     qmod_forceaction -- ??? 
#
#  SYNOPSIS
#     qmod_forceaction { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_forceaction {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_USER test_host test_queue CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH

   # the characters used in ps output for the suspenede state may vary from arch to arch
   set suspended_states [host_get_suspended_states $test_host]

   # submit testjob to set the queue in error
   set job_id [ submit_job "-N QMOD -q $test_queue -o /dev/null -e /dev/null $ts_config(testsuite_root_dir)/scripts/work_pid.sh 300" ] 
   # now wait for jobstart
   wait_for_jobstart $job_id "QMOD" 300
   wait_for_end_of_transfer $job_id 300 
  

   # now wait for 5 processes in this process group
   set time_out [ expr ( [timestamp] + 60 ) ]
   set procgroup_ok 0
   while { [timestamp] < $time_out } {
      set state [get_suspend_state_of_job $job_id $test_host "pid_list" 0] 
      set grppid [get_grppid_of_job $job_id $test_host]
      puts $CHECK_OUTPUT "Job has real state \"$state\""
      puts $CHECK_OUTPUT "Job has grp pid \"$grppid\""
      puts $CHECK_OUTPUT "pid_list is $pid_list and has length [llength $pid_list]"
      if { [llength $pid_list] == 1 } {
         puts $CHECK_OUTPUT "found 1 process member - ok"
         set procgroup_ok 1
         break;
      }
   }
   if { $procgroup_ok != 1 } {
      set_error -1 "not 1 process in processgroup \"$grppid\""
   }
 

   # set job in suspend mode
   puts $CHECK_OUTPUT "suspend job ..."
   suspend_job $job_id
 
   set state [string index [get_suspend_state_of_job $job_id $test_host] 0]
   set grppid [ get_grppid_of_job $job_id $test_host]
   puts $CHECK_OUTPUT "Job has real state \"$state\""
   puts $CHECK_OUTPUT "Job has grp pid \"$grppid\""
  
   puts $CHECK_OUTPUT "Suspend states for host $test_host are \"$suspended_states\""
   if {[string first $state $suspended_states] == -1} {
      set_error -1 "job $job_id (grppid: $grppid) is not in suspend state"
   }


   puts $CHECK_OUTPUT "unsuspend job with kill command ..."
   # unsunspend job per kill command
   switch -- [resolve_arch $test_host] {
      "glinux" {
         foreach pidnr $pid_list {
            start_remote_prog $test_host $CHECK_USER "/bin/kill" "-CONT $pidnr"
            #set result [ catch { eval exec "/bin/kill -CONT $pidnr" } ]
         }
      }
      "alinux" {
         # on our alinux they have confused the CONT and STOP signal numbers ;-)
         start_remote_prog $test_host $CHECK_USER "/bin/kill" "-STOP -$grppid"
         #set result [ catch { eval exec "/bin/kill -STOP -$grppid" } ]
      }

      default {
         start_remote_prog $test_host $CHECK_USER "kill" "-CONT -$grppid"
         #set result [ catch { eval exec "kill -CONT -$grppid" } ]
      }
   }

#   sleep 5

   set state [string index [get_suspend_state_of_job $job_id $test_host] 0]
   puts $CHECK_OUTPUT "Job has real state \"$state\""

   if {[string first $state $suspended_states] >= 0} {
      set_error -1 "job $job_id (grppid: $grppid) is still in suspend state"
   }   

   # set job in suspend mode (is already in suspend (in SGE system))
   puts $CHECK_OUTPUT "suspend job (queueing system thinks it is still suspended) ..."
   suspend_job $job_id 0 0

   set state [string index [get_suspend_state_of_job $job_id $test_host] 0]
   puts $CHECK_OUTPUT "Job has real state \"$state\""
   
   if {[string first $state $suspended_states] >= 0} {
      set_error -1 "job $job_id (grppid: $grppid) is still in suspend state without force flag"
   }    
 
   # set job in suspend mode (is already in suspend (in SGE system)) with force flag set
   puts $CHECK_OUTPUT "suspend job with force flag ..." 
   suspend_job $job_id 1

   set state [string index [get_suspend_state_of_job $job_id $test_host] 0]
   puts $CHECK_OUTPUT "Job has real state \"$state\""
   
   if {[string first $state $suspended_states] == -1} {
      set_error -1 "job $job_id (grppid: $grppid) is still not in suspend state with using force flag"
   }    

   # ok unsuspend the job
   puts $CHECK_OUTPUT "unsuspend job"
   unsuspend_job $job_id

   # delete job and wait for jobend
   puts $CHECK_OUTPUT "delete job and wait for jobend ..."
   delete_job $job_id 1

   # let's see if all processes are killed
   get_ps_info 0 $test_host
   
   for {set i 0} {$i < $ps_info(proc_count) } {incr i 1} {
      puts $CHECK_OUTPUT "ps_info(pgid,$i)     = $ps_info(pgid,$i), command is \"$ps_info(command,$i)\""
      
      if { $ps_info(pgid,$i) == $grppid } {
         puts $CHECK_OUTPUT "process $ps_info(pid,$i) is still in ps list"
         set_error -1 "process $ps_info(pid,$i) is still in ps list"
      }
   }

   set_error 0 "ok"
}
