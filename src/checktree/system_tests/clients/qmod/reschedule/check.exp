#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# we need root access 
set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "qmod_reschedule_init_level"

# define test's name and run level descriptions
set check_name            "qmod_reschedule"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   0
set check_description(0)  "checking reschedule option of qmod"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_level_function "reschedule_setup"
set check_cleanup_level_function "reschedule_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "reschedule_submit_jobs"
lappend check_functions "reschedule_checkpointing"
lappend check_functions "reschedule_checkpointing_forced"
lappend check_functions "reschedule_qsh_qlogin_qrsh_qrlogin"
lappend check_functions "reschedule_pe_jobs"
lappend check_functions "reschedule_deleted_job"

# -------- local test procedures -----------------------------------------------
global rerun_queue rerun_queue2
set rerun_queue    "re_true.q"
set rerun_queue2   "re_true2.q"

global no_rerun_queue
set no_rerun_queue "resch_false.q"

global rerun_host no_rerun_host
global stored_configuration
global pe_names pe_alloc_rule
set pe_names      ""
set pe_alloc_rule ""
lappend pe_names      "reschpe_1" 
lappend pe_alloc_rule "1"
lappend pe_names      "reschpe_2" 
lappend pe_alloc_rule "2"
lappend pe_names      "reschpe_rr" 
lappend pe_alloc_rule "\$round_robin"
lappend pe_names      "reschpe_fill" 
lappend pe_alloc_rule "\$fill_up"


proc qmod_reschedule_init_level {} {
   global CHECK_ACT_LEVEL CHECK_HOST hold_state pending_state queue
   global rerun_host no_rerun_host CHECK_CORE_EXECD CHECK_OUTPUT

   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      return -1
   }

   set rerun_host    [ lindex $CHECK_CORE_EXECD 0  ]
   set no_rerun_host [ lindex $CHECK_CORE_EXECD 1  ]

   switch -- $CHECK_ACT_LEVEL {
      "0" { return 0 } 
   }

   return -1  ;# no other level else
}


#
#                                                             max. column:     |
#
#****** check/reschedule_setup() ******
#  NAME
#     reschedule_setup -- ??? 
#
#  SYNOPSIS
#     reschedule_setup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_setup {} {
   global pe_names pe_alloc_rule
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2

   set schedd_config(schedule_interval) "0:0:4"
   set_schedd_config schedd_config

   if { [info exists stored_configuration] } {
      unset stored_configuration
   }
   get_config stored_configuration
   set myconfig(load_report_time) "00:00:6"
   set_config myconfig

   puts $CHECK_OUTPUT "disabling all cluster queues"
   foreach host $CHECK_CORE_EXECD {
      puts ${host}
      disable_queue [get_queue_instance all.q $host]
   }

   puts $CHECK_OUTPUT "using host \"$rerun_host\" for queue with rerun=TRUE"
   puts $CHECK_OUTPUT "using host \"$no_rerun_host\" for queue with rerun=FALSE"

   set new_queue(rerun)    "TRUE"
   set new_queue(qtype)    "BATCH INTERACTIVE PARALLEL CHECKPOINTING"
   set new_queue(load_thresholds) "np_load_avg=8.00"
   set new_queue(slots)    "100"
   add_queue $rerun_queue $rerun_host new_queue 
   add_queue $rerun_queue2 $no_rerun_host new_queue

   set new_queue(rerun)    "FALSE"
   add_queue $no_rerun_queue $no_rerun_host new_queue



   # add checkpointobject for test
   puts $CHECK_OUTPUT "creating checkpointobjects ..."
   set new_checkpointobj(ckpt_name)  "qmod_with_r"
   set new_checkpointobj(interface)  "userdefined"
   set new_checkpointobj(when) "r"
   add_checkpointobj "new_checkpointobj"
   assign_queues_with_ckpt_object $rerun_queue $rerun_host qmod_with_r

   set new_checkpointobj(ckpt_name)  "qmod_without_r"
   set new_checkpointobj(when) "s"
   add_checkpointobj "new_checkpointobj"
   assign_queues_with_ckpt_object $rerun_queue $rerun_host qmod_without_r

   # add pe_object for test
   puts $CHECK_OUTPUT "creating pe object ..."
   set new_peobj(slots)            "5"
   set index 0
   foreach elem $pe_names { 
      set new_peobj(pe_name) $elem
      set new_peobj(allocation_rule) [lindex $pe_alloc_rule $index]
      incr index 1
      add_pe new_peobj
      assign_queues_with_pe_object $rerun_queue $rerun_host $new_peobj(pe_name)
      assign_queues_with_pe_object $rerun_queue2 $no_rerun_host $new_peobj(pe_name)
   } 

   set_error 0 "ok"
}


#
#                                                             max. column:     |
#
#****** check/reschedule_submit_jobs() ******
#  NAME
#     reschedule_submit_jobs -- ??? 
#
#  SYNOPSIS
#     reschedule_submit_jobs { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_submit_jobs {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
  
   set jobs ""
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q [get_queue_instance $rerun_queue $rerun_host] -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -q [get_queue_instance $rerun_queue $rerun_host] -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -q [get_queue_instance $rerun_queue $rerun_host] $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -q [get_queue_instance $no_rerun_queue $no_rerun_host] -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -q [get_queue_instance $no_rerun_queue $no_rerun_host] -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]
 
   set arguments "$my_outputs -q [get_queue_instance $no_rerun_queue $no_rerun_host] $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set jobs_string ""
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 60
      append jobs_string "$elem "
   }

   puts $CHECK_OUTPUT "running jobs: $jobs_string"

   puts $CHECK_OUTPUT "disabling queues $no_rerun_queue and $rerun_queue"
   disable_queue [get_queue_instance $no_rerun_queue $no_rerun_host]
   disable_queue [get_queue_instance $rerun_queue $rerun_host]

   
   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $jobs_string" } output ]
   
   puts $CHECK_OUTPUT $output

  
   set sched_jobs    "[lindex $jobs 0] [lindex $jobs 2] [lindex $jobs 4 ]"
   set no_sched_jobs "[lindex $jobs 1] [lindex $jobs 3] [lindex $jobs 5 ]"
   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 60
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 60
   }

   puts $CHECK_OUTPUT "using force flag for job [lindex $jobs 1] ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r [lindex $jobs 1]" } output ]
   puts $CHECK_OUTPUT $output
   puts $CHECK_OUTPUT "waiting for job [lindex $jobs 1] to get in pending state ..."
   wait_for_jobpending [lindex $jobs 1] "Sleeper" 60

   enable_queue [get_queue_instance $no_rerun_queue $no_rerun_host]
   enable_queue [get_queue_instance $rerun_queue $rerun_host]

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 300
   }
   
   puts $CHECK_OUTPUT "disabling queues $no_rerun_queue and $rerun_queue"
   disable_queue [get_queue_instance $no_rerun_queue $no_rerun_host]
   disable_queue [get_queue_instance $rerun_queue $rerun_host]


   # send qmod -r to each job in queue 
   puts $CHECK_OUTPUT "sending qmod -r to queues $no_rerun_queue and $rerun_queue"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r [get_queue_instance $no_rerun_queue $no_rerun_host] [get_queue_instance $rerun_queue $rerun_host]" } output ]
   puts $CHECK_OUTPUT $output

   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 60
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 60
   }

   puts $CHECK_OUTPUT "using force flag for job [lindex $jobs 1] ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r [lindex $jobs 1]" } output ]
   puts $CHECK_OUTPUT $output
   puts $CHECK_OUTPUT "waiting for job [lindex $jobs 1] to get in pending state ..."
   wait_for_jobpending [lindex $jobs 1] "Sleeper" 60
   
   enable_queue [get_queue_instance $no_rerun_queue $no_rerun_host]
   enable_queue [get_queue_instance $rerun_queue $rerun_host]

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 300
   }

   # cleanup jobs
   foreach elem $jobs {
      delete_job $elem
      wait_for_jobend $elem "Sleeper" 60 0
   }
   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_checkpointing() ******
#  NAME
#     reschedule_checkpointing -- ??? 
#
#  SYNOPSIS
#     reschedule_checkpointing { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_checkpointing {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
   
   set jobs ""
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -ckpt qmod_with_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -ckpt qmod_with_r -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set jobs_string ""
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 80
      append jobs_string "$elem "
   }

   puts $CHECK_OUTPUT "running jobs: $jobs_string"

   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue [get_queue_instance $rerun_queue $rerun_host]
   
   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $jobs_string" } output ]
   
   puts $CHECK_OUTPUT $output
  
   set sched_jobs    "[lindex $jobs 0]"
   set no_sched_jobs "[lindex $jobs 1] [lindex $jobs 2] [lindex $jobs 3]"
   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 60
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 60
   }
   enable_queue [get_queue_instance $rerun_queue $rerun_host]
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 80
   }
   
   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue [get_queue_instance $rerun_queue $rerun_host]


   # send qmod -r to each job in queue 
   puts $CHECK_OUTPUT "sending qmod -r to queue $rerun_queue"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r [get_queue_instance $rerun_queue $rerun_host]" } output ]
   puts $CHECK_OUTPUT $output


   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 60
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 60
   }

   enable_queue [get_queue_instance $rerun_queue $rerun_host]

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 80
   }

   # cleanup jobs
   foreach elem $jobs {
      delete_job $elem
      wait_for_jobend $elem "Sleeper" 60 0
   }
 
   set_error 0 "ok"
}

proc reschedule_checkpointing_forced {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
 
   set jobs ""
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -ckpt qmod_with_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -ckpt qmod_with_r -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]
 

   set jobs_string ""
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 80
      append jobs_string "$elem "
   }

   puts $CHECK_OUTPUT "running jobs: $jobs_string"

   

   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue [get_queue_instance $rerun_queue $rerun_host]

   
   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -f -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r $jobs_string" } output ]
   
   puts $CHECK_OUTPUT $output

  
   set sched_jobs    "[lindex $jobs 0] [lindex $jobs 1] [lindex $jobs 2] [lindex $jobs 3]"
   set no_sched_jobs ""
   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 60
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 60
   }
   enable_queue [get_queue_instance $rerun_queue $rerun_host]
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 80
   }
   
   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue [get_queue_instance $rerun_queue $rerun_host]


   # send qmod -r to each job in queue 
   puts $CHECK_OUTPUT "sending qmod -f -r to queue $rerun_queue"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r [get_queue_instance $rerun_queue $rerun_host]" } output ]
   puts $CHECK_OUTPUT $output


   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 60
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 60
   }

   enable_queue [get_queue_instance $rerun_queue $rerun_host]

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 60
      wait_for_end_of_transfer $elem 80
   }

   # cleanup jobs
   foreach elem $jobs {
      delete_job $elem
      wait_for_jobend $elem "Sleeper" 60 0
   }
 
   set_error 0 "ok"
}


#
#                                                             max. column:     |
#
#****** check/reschedule_qsh_qlogin_qrsh_qrlogin() ******
#  NAME
#     reschedule_qsh_qlogin_qrsh_qrlogin -- ??? 
#
#  SYNOPSIS
#     reschedule_qsh_qlogin_qrsh_qrlogin { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_qsh_qlogin_qrsh_qrlogin {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_DEBUG_LEVEL CHECK_USER CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SCRIPT_FILE_DIR CHECK_CORE_EXECD CHECK_HOST

   # JG: TODO: use open_remote_spawn_process - we could run out of filehandles here
   set qrsh_id    [ open_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -now no -q [get_queue_instance $rerun_queue $rerun_host]" ]
   set qrsh_id2   [ open_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -now no -q [get_queue_instance $rerun_queue $rerun_host] sleep 10000" ]
   set qsh_id     [ open_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qsh -now no -q [get_queue_instance $rerun_queue $rerun_host]" ]
     
   set qlogin_out_file [get_tmp_file_name "" "qlogin" "txt" ]

   puts $CHECK_OUTPUT "try to $CHECK_SCRIPT_FILE_DIR/qlogin.sh $qlogin_out_file $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qlogin -q [get_queue_instance $rerun_queue $rerun_host]"

   set qlogin_id  [ open_spawn_process "$CHECK_SCRIPT_FILE_DIR/qlogin.sh $qlogin_out_file $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qlogin -now no -q [get_queue_instance $rerun_queue $rerun_host]" ]
   set qlogin_spawn_id [lindex $qlogin_id 1]
   set no_jobs 4
   set result ""
   set my_timeout [timestamp]
   incr my_timeout 60
   while { [ string first "login:" $result] < 0 } {
      after 2000
      catch { eval exec "cat $qlogin_out_file" } result
      puts $CHECK_OUTPUT $result
      if { $my_timeout < [timestamp] } {
         break;
      } 
   }

   # on some systems (Solaris 10), telnet doesn't present a login, but tries 
   # to login current user first
   if { [ string first "assword:" $result ] < 0 } {
      if { [ string first "login:" $result] < 0 } {
          add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "qlogin error, expected login:, received $result"
      }
     
      send -i $qlogin_spawn_id -- "$CHECK_USER\n"
      set timeout 5
      expect {
         -i $qlogin_spawn_id eof { 
             puts $CHECK_OUTPUT "got eof" 
             add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "qlogin unexpected eof"
         }
         -i $qlogin_spawn_id timeout {
             puts $CHECK_OUTPUT "got timeout"
         }
      }
      set result ""
   }

   set my_timeout [timestamp]
   incr my_timeout 120
   set timeout 0
   while { [ string first "assword:" $result] < 0 } {     
      sleep 2
      catch { eval exec "cat $qlogin_out_file" } result
      puts $CHECK_OUTPUT $result
      if { $my_timeout < [timestamp] } {
         add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "timeout waiting for qlogin password question"
         break;
      } 
   }

   if { [ string first "closed" $result] >= 0 } {
       add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "qlogin error, connection closed"
   }

   set end_time [expr ( [timestamp] + 60 )]
   set ru_jobs 0
   while { $ru_jobs != $no_jobs } {
      get_extended_job_info ""
      set running_jobs [ split $job_info(index) "," ]
      set jobs ""
      set jobs_string ""
      set job_names "" 
      foreach elem $running_jobs {
         set jobid [ string trim $elem ]
         if { $jobid >= 0 } {
            puts $CHECK_OUTPUT $job_info($jobid,queue)
#            if { [ string first [string trim $job_info($jobid,queue)] $rerun_queue ] >= 0 } {
               lappend jobs $jobid
               append jobs_string "$jobid "
               lappend job_names "$job_info($jobid,name)"
#            }
            puts $CHECK_OUTPUT "job: $jobid, name: $job_info($jobid,name), $job_info($jobid,queue)"
         }
      }
      set ru_jobs [ llength $jobs ]
      puts $CHECK_OUTPUT "found $ru_jobs jobs"
      unset job_info
      after 1000
      set now [timestamp]
      if { $now > $end_time } {
         add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" "-1" "timeout waiting for processes"
         break
      }
   }

   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue [get_queue_instance $rerun_queue $rerun_host]

   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $jobs_string" } output ]
   puts $CHECK_OUTPUT $output
    
   puts $CHECK_OUTPUT "jobs $jobs_string should still run ..."
   set index 0
   foreach elem $jobs_string {
      wait_for_jobstart $elem [lindex $job_names $index] 60
      wait_for_end_of_transfer $elem 80
      incr index 1
   }

   enable_queue [get_queue_instance $rerun_queue $rerun_host]
 
   foreach elem $jobs_string {
      delete_job $elem
   }
   puts $CHECK_OUTPUT "closing jobs"

   close_spawn_process $qrsh_id 1
   close_spawn_process $qrsh_id2 1
   close_spawn_process $qsh_id 1
   if { $qlogin_id != -1 } {
      send -i $qlogin_spawn_id -- "\003"
      close_spawn_process $qlogin_id 1
   }

   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_pe_jobs() ******
#  NAME
#     reschedule_pe_jobs -- ??? 
#
#  SYNOPSIS
#     reschedule_pe_jobs { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_pe_jobs {} {
   global ts_config
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2 pe_names
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD

   if { $ts_config(gridengine_version) == 53 } {
      add_proc_error reschedule_pe_jobs -3 "test would fail in 5.3 systems, as queue names are truncated in qstat output\nWould have to call qstat -f to figure out master and slave queues"
      set_error 0 "unsupported"
      return
   }

   foreach pe $pe_names {

       puts $CHECK_OUTPUT "submitting job to pe $pe ..."
       set my_outputs "-o /dev/null -e /dev/null"
       set my_job "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5000"
       set arguments "$my_outputs -pe $pe 2 -masterq [get_queue_instance $rerun_queue $rerun_host] $my_job"
       set job [submit_job $arguments]
       puts $CHECK_OUTPUT "job $job submitted"

       wait_for_jobstart $job "Sleeper" 100
       
       set mytime [ expr ( [timestamp] + 100 ) ]
       set run 1
       set master_queue ""
       set slave_queue ""
       while { $run == 1 } {
          set job_info [get_standard_job_info $job 1]
          foreach elem $job_info {
             puts $CHECK_OUTPUT $elem
             if { [string first "MASTER" $elem ] >= 0 } {
                set master_queue [lindex $elem 7]
                puts $CHECK_OUTPUT "master runs on queue $master_queue"
             }
             if { [string first "SLAVE" $elem ] >= 0 } {
                set slave_queue [lindex $elem 7]
                puts $CHECK_OUTPUT "slave runs on queue $slave_queue"
             }
          }
          puts $CHECK_OUTPUT "-----------" 
          if { $master_queue != "" && $slave_queue != "" } {
             puts $CHECK_OUTPUT "MASTER and SLAVE task are running!"
             set run 0
          }
          set nowtime [timestamp]
          if { $nowtime > $mytime } {
             set run 0
             add_proc_error "reschedule_pe_jobs" -1 "timeout waiting for MASTER and SLAVE task of job $job, pe $pe"
          } 
          sleep 1
       }


       if { [string first $rerun_queue $master_queue] != 0 } {
          puts $CHECK_OUTPUT "\"$master_queue\"\n\"$rerun_queue\""
          add_proc_error "reschedule_pe_jobs" "-1" "job $job: master task is not on queue $rerun_queue, pe $pe"
       }
      
       if { [string compare $pe "reschpe_1"] == 0 } {
          if { [string first $rerun_queue2 $slave_queue] != 0 } {
             puts $CHECK_OUTPUT "\"$slave_queue\"\n\"$rerun_queue2\""
             add_proc_error "reschedule_pe_jobs" "-1" "job $job: slave task is not on queue $rerun_queue2, pe $pe"
          }
       }


       # ok jobs are running and we now his running queues now
       puts $CHECK_OUTPUT "disabling queue $rerun_queue and $rerun_queue2"
       disable_queue [get_queue_instance $rerun_queue $rerun_host]
       disable_queue [get_queue_instance $rerun_queue2 $no_rerun_host]


       if { [ string compare $slave_queue $master_queue ] != 0 } {
          puts $CHECK_OUTPUT "rescheduling SLAVE task queue \"$slave_queue\""     
          set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $slave_queue" } output ]
          puts $CHECK_OUTPUT $output

          sleep 10          

          puts $CHECK_OUTPUT "job $job should still run ..."
          wait_for_jobstart $job "Sleeper" 60
       } 
 
       puts $CHECK_OUTPUT "rescheduling MASTER task queue \"$master_queue\""     
       set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $master_queue" } output ]
       puts $CHECK_OUTPUT $output

       wait_for_jobpending $job "Sleeper" 60
       set run 1
       set job_info [get_standard_job_info $job 1]
       foreach elem $job_info {
          puts $CHECK_OUTPUT $elem
          if { [string first "MASTER" $elem ] >= 0 } {
             add_proc_error "reschedule_pe_jobs" -1 "no MASTER task should run, pe $pe"
          }
          if { [string first "SLAVE" $elem ] >= 0 } {
             add_proc_error "reschedule_pe_jobs" -1 "no SLAVE task should run, pe $pe"
          }
       } 



       puts $CHECK_OUTPUT "enable queue $rerun_queue and $rerun_queue2"
       enable_queue [get_queue_instance $rerun_queue $rerun_host]
       enable_queue [get_queue_instance $rerun_queue2 $no_rerun_host]
 
       if { [wait_for_jobstart $job "Sleeper" 45] == 0 } {
          set mytime [ expr ( [timestamp] + 45 ) ]
          set run 1
          set master_queue ""
          set slave_queue ""
          while { $run == 1 } {
             set job_info [get_standard_job_info $job 1]
             foreach elem $job_info {
                puts $CHECK_OUTPUT $elem
                if { [string first "MASTER" $elem ] >= 0 } {
                   set master_queue [lindex $elem 7]
                   puts $CHECK_OUTPUT "master runs on queue $master_queue"
                }
                if { [string first "SLAVE" $elem ] >= 0 } {
                   set slave_queue [lindex $elem 7]
                   puts $CHECK_OUTPUT "slave runs on queue $slave_queue"
                }
             } 
             if { $master_queue != "" && $slave_queue != "" } {
                puts $CHECK_OUTPUT "MASTER and SLAVE task are running!"
                set run 0
             }
             set nowtime [timestamp]
             if { $nowtime > $mytime } {
                set run 0
                add_proc_error "reschedule_pe_jobs" -1 "timeout waiting for MASTER and SLAVE task of job $job, pe $pe"
             } 
             sleep 1
          }
       } else {
          add_proc_error "reschedule_pe_jobs" -1 "job $job does not start, pe $pe"
       } 
       if { [is_job_running $job "Sleeper"] != 1 } {
          add_proc_error "reschedule_pe_jobs" -1 "job $job is not running!!"
       }

       delete_job $job
       # wait for job without check if he is already running
       # ==> when job is faster deleted, wait_for_jobend will not find the job and
       #     report an error

       wait_for_jobend $job "Sleeper" 60 0
   }
   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_deleted_job() ******
#  NAME
#     reschedule_deleted_job -- ??? 
#
#  SYNOPSIS
#     reschedule_deleted_job { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_deleted_job {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2
   global pe_names pe_alloc_rule CHECK_ADMIN_USER_SYSTEM
   global CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE CHECK_ARCH
   global CHECK_ADMIN_USER_SYSTEM CHECK_CORE_EXECD

   puts $CHECK_OUTPUT "submitting job to queue $no_rerun_queue ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q [get_queue_instance $no_rerun_queue $no_rerun_host] -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id [ submit_job $arguments ]

   wait_for_jobstart $job_id "Sleeper" 100
   wait_for_end_of_transfer $job_id 100


   # shutdown execd
   puts $CHECK_OUTPUT "shutdown execd on host $no_rerun_host ..."
   catch {exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ke $no_rerun_host} output
   puts $output

   puts $CHECK_OUTPUT "deleting job $job_id ..."
   delete_job $job_id


   puts $CHECK_OUTPUT "job should still be in queue, but in delete state ..."
   if { [is_job_running $job_id "Sleeper"] != 1 } {
      add_proc_error "reschedule_deleted_job" -1 "job $job_id is not running!! (queue: $no_rerun_queue)"
   }


   puts $CHECK_OUTPUT "reschedule of job $job_id ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $job_id" } output ]
   puts $CHECK_OUTPUT $output

   
 
   # restart execd
   puts $CHECK_OUTPUT "restarting execd on host $no_rerun_host ..."
   startup_execd $no_rerun_host
   wait_for_load_from_all_queues 200 

   wait_for_jobend $job_id "Sleeper" 200 0
   
   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_cleanup() ******
#  NAME
#     reschedule_cleanup -- ??? 
#
#  SYNOPSIS
#     reschedule_cleanup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_cleanup {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2
   global pe_names pe_alloc_rule CHECK_CORE_EXECD

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   reset_schedd_config
   set_config stored_configuration

   puts $CHECK_OUTPUT "removing checkpointobjects ..."
   del_checkpointobj "qmod_with_r"
   del_checkpointobj "qmod_without_r"

   foreach elem $pe_names { 
      del_pe $elem
   } 

   puts $CHECK_OUTPUT "removing queues ..."
   del_queue $rerun_queue $rerun_host 0 1
   del_queue $no_rerun_queue $no_rerun_host 0 1
   del_queue $rerun_queue2 $no_rerun_host 0 1

   puts $CHECK_OUTPUT "enabling queues ..."
   foreach host $CHECK_CORE_EXECD {
      puts $host
      enable_queue [get_queue_instance all.q $host]
   }
   
   set_error 0 "ok"
}
