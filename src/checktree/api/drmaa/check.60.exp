#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "drmaa_init_level"

# define test's name and run level descriptions
set check_name            "drmaa"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   205
set check_description(200)  "tests to verify DRMAA 0.95 library: single threaded"
set check_description(201)  "tests to verify DRMAA 0.95 library: multi threaded"
set check_description(202)  "tests to verify DRMAA 0.95 library: additional interfaces"
set check_description(203)  "tests to verify DRMAA 1.0 library: single threaded"
set check_description(204)  "tests to verify DRMAA 1.0 library: multi threaded"
set check_description(205)  "tests to verify DRMAA 1.0 library: additional interfaces"

# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function "drmaa_setup"
set check_cleanup_function "drmaa_cleanup"

# define test's procedure order
set check_functions ""
lappend check_functions "drmaa_check"

# this function is called each time before
# a new run level is started
proc drmaa_init_level {} {
  global CHECK_ACT_LEVEL

  # returning -1 causes disabling a certain runlevel
  # here per run level settings can be prepared
  switch -- $CHECK_ACT_LEVEL {
     "200" {
        return 0
     }
     "201" {
        return 0
     }
     "202" {
        return 0
     }
     "203" {
        return 0
     }
     "204" {
        return 0
     }
     "205" {
        return 0
     }
  } 

  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

proc drmaa_setup {} {
   global drmaa_config

   # must forbit reschedule on job exiting with 99 
   # must forbit job error upon job exiting with 100
   # otherwise drmaa_test ST_EXIT_STATUS never finishes

   # backup old settings
   get_config drmaa_config

   # set new value
   set new_config(qmaster_params) "FORBID_RESCHEDULE=TRUE,FORBID_APPERROR=TRUE"
   set new_config(delegated_file_staging) "true"
   set_config new_config

   # setup file staging scripts

   set_error 0 "ok"
}

# undo what we've done in drmaa_setup
proc drmaa_cleanup  {} {
   global backup_qmaster_params drmaa_config ts_config

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # undo configuration changes that were made for this test
   set_config drmaa_config

   # restore DRMAA library version
   foreach host $ts_config(unique_arch_nodes) {
      drmaa_redirect_lib "0.95" $host
   }

   set_error 0 "ok"
}

# here the actual test is done
proc drmaa_check {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_USER
   global CHECK_ACT_LEVEL CHECK_SCRIPT_FILE_DIR CHECK_TESTSUITE_ROOT

   foreach host $ts_config(unique_arch_nodes) {
      set compile_arch_mt [resolve_build_arch_installed_libs $host]

      set binary_path "$ts_config(source_dir)/$compile_arch_mt"
      puts $CHECK_OUTPUT "host is $host has arch $compile_arch_mt mt bin path $binary_path"
      set level $CHECK_ACT_LEVEL

      if {$level <= 202} {
         drmaa_redirect_lib "0.95" $host
      } else {
         drmaa_redirect_lib "1.0" $host
         incr level -3
      }

      switch -- $level {
         "200" { 
            # -- do all ST_DRMAA_CONTROL tests
            drmaa_test_failing_control_operations $host $binary_path

            # unset SGE_ROOT and try test_drmaa -h
            puts "starting single threaded test test_drmaa -h without SGE_ROOT"
            set test_output [ start_remote_prog $host $CHECK_USER "unset" "SGE_ROOT\n$binary_path/test_drmaa -h" \
                  prg_exit_state 500 0 "" 0 1]
            if { $prg_exit_state == 0 } {
               add_proc_error drmaa_check -1 "test_drmaa -h without SGE_ROOT must exit with unequal 0 at host $host"
               break
            }

            # the ST_INPUT_BECOMES_OUTPUT test
            drmaa_test_st_input_becomes_output $host $binary_path

            # -- tests without an argument
            foreach st_test "ST_ERROR_CODES ST_MULT_INIT ST_MULT_EXIT \
               ST_SUPPORTED_ATTR ST_SUPPORTED_VATTR ST_VERSION ST_DRM_SYSTEM \
               ST_CONTACT ST_EMPTY_SESSION_WAIT \
               ST_EMPTY_SESSION_SYNCHRONIZE_DISPOSE \
               ST_EMPTY_SESSION_SYNCHRONIZE_NODISPOSE ST_DRMAA_IMPL \
               ST_UNSUPPORTED_ATTR ST_UNSUPPORTED_VATTR" {
               
               puts "starting single threaded test $st_test"
               drmaa_test $host $binary_path $st_test ""
            }
           
            # -- tests to ensure control operations on session without jobs result in DRMAA_ERRNO_SUCCESS 
            foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME \
                  DRMAA_CONTROL_HOLD DRMAA_CONTROL_RELEASE \
                  DRMAA_CONTROL_TERMINATE" {
               puts "starting single threaded test ST_EMPTY_SESSION_CONTROL $control_op"
               drmaa_test $host $binary_path ST_EMPTY_SESSION_CONTROL "$control_op"
            }

            # -- tests with a <sleeper_job> argument
            foreach st_test "ST_SUBMIT_WAIT ST_BULK_SUBMIT_WAIT \
                  ST_BULK_SINGLESUBMIT_WAIT_INDIVIDUAL \
                  ST_SUBMITMIXTURE_SYNC_ALL_DISPOSE \
                  ST_SUBMITMIXTURE_SYNC_ALL_NODISPOSE \
                  ST_SUBMITMIXTURE_SYNC_ALLIDS_DISPOSE \
                  ST_SUBMITMIXTURE_SYNC_ALLIDS_NODISPOSE \
                  ST_SUBMIT_PAUSE_SUBMIT_SYNC ST_INPUT_FILE_FAILURE \
                  ST_OUTPUT_FILE_FAILURE ST_ERROR_FILE_FAILURE \
                  ST_SUBMIT_SUSPEND_RESUME_WAIT ST_SUBMIT_POLLING_WAIT_TIMEOUT \
                  ST_SUBMIT_POLLING_WAIT_ZEROTIMEOUT \
                  ST_SUBMIT_POLLING_SYNCHRONIZE_TIMEOUT \
                  ST_SUBMIT_POLLING_SYNCHRONIZE_ZEROTIMEOUT \
                  ST_BULK_SUBMIT_IN_HOLD_SESSION_RELEASE \
                  ST_BULK_SUBMIT_IN_HOLD_SINGLE_RELEASE \
                  ST_BULK_SUBMIT_IN_HOLD_SESSION_DELETE \
                  ST_BULK_SUBMIT_IN_HOLD_SINGLE_DELETE \
                  ST_SUBMIT_IN_HOLD_RELEASE ST_SUBMIT_IN_HOLD_DELETE \
                  ST_SYNCHRONIZE_NONEXISTANT ST_RECOVERABLE_SESSION" {
               puts "starting single threaded test $st_test"
               drmaa_test $host $binary_path $st_test $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/suspendable_sleeper.sh
            }

            # -- tests with a <sleeper_job> argument repeatedly 
            foreach st_test "ST_SUBMIT_NO_RUN_WAIT" {
               set n 100
               puts "starting single threaded test $st_test $n times each"
               for {set i 0} {$i < $n} {incr i} {
                  drmaa_test $host $binary_path $st_test $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/suspendable_sleeper.sh
               }
            }

            # -- tests with a <exit_arg_job> argument
            foreach ste_test "ST_EXIT_STATUS ST_USAGE_CHECK" {
               puts "starting single threaded test $ste_test"
               drmaa_test $host $binary_path $ste_test $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/exit.sh
            }


            # -- tests with <exit_arg_job> and <email_addr> arguments
            # need to add the entry "test.cat -N ExitTest -h" to qtask file
            # need to add "-m a" to sge_request file 
            # test assumes job do run at submission host
            # puts "starting single threaded test ST_ATTRIBUTE_CHECK"
            # drmaa_test $host $binary_path ST_ATTRIBUTE_CHECK $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/exit.sh "$CHECK_USER@localhost"
            # need to remove "-m a" from sge_request file 
            # need to move entry "test.cat -N ExitTest -h" to users .qtask file
            # -- 
         } 
         "201" { 
            # all MT tests need a sleeper job as argument
            foreach mt_test "MT_SUBMIT_WAIT MT_EXIT_DURING_SUBMIT \
                     MT_SUBMIT_MT_WAIT MT_EXIT_DURING_SUBMIT_OR_WAIT \
                     MT_SUBMIT_BEFORE_INIT_WAIT" {
               puts "starting multi threaded test $mt_test"
               drmaa_test $host $binary_path $mt_test $ts_config(product_root)/examples/jobs/sleeper.sh
            }
         } 
         "202" { 
            # shutdown qmaster
            shutdown_master_and_scheduler $ts_config(master_host) [get_qmaster_spool_dir] 

            # this test must fail when qmaster is down
            set test_output [start_remote_prog $host $CHECK_USER $binary_path/test_drmaa "ST_SUBMIT_WAIT $ts_config(product_root)/examples/jobs/sleeper.sh" prg_exit_state 500]

            puts $CHECK_OUTPUT "exit status was $prg_exit_state"
            puts $CHECK_OUTPUT "output was\n$test_output"

            if { $prg_exit_state == 0 } {
               add_proc_error drmaa_check -1 "test_drmaa ST_SUBMIT_WAIT failed at host $host"
            }
            # restart qmaster
            startup_qmaster 
         } 
      } 
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#
#****** drmaa_test/drmaa_test() ******
#  NAME
#     drmaa_test() -- generic drmaa test
#
#  SYNOPSIS
#     drmaa_test { test_name host binary_path arguments }
#
#  FUNCTION
#     This procedure starts test_drmaa with the corresponding arguemnts.
#     Exit status of test_drmaa must always be 0 otherwise test has failed.
#
#  INPUTS
#     host                       - The host where 'test_drmaa' is run
#     binary_path                - The path where 'test_drmaa' can be found
#     test_name                  - The name of a test. To get a complete list
#                                  of all test cases run 'test_drmaa' without args
#     arguments                  - Additional arguments needed for the test case.
#     user                       - Optional argument if test shall be run as user 
#                                  other than CHECK_USER
#
#  EXAMPLE
#     drmaa_test ST_SUBMIT_WAIT ori <source-path>/SOLARIS86/ $SGE_ROOT/examples/jobs/sleeper.sh
#*******************************
#
proc drmaa_test { host binary_path test_name arguments {user ""} } {
   global CHECK_OUTPUT CHECK_USER

   if {$user == ""} { 
      set user $CHECK_USER
   }

   puts $CHECK_OUTPUT "$binary_path/test_drmaa $test_name $arguments"
   set test_output [ start_remote_prog $host $user $binary_path/test_drmaa "$test_name $arguments" prg_exit_state 500 ]

   puts $CHECK_OUTPUT "exit status was $prg_exit_state"
   puts $CHECK_OUTPUT "output was\n$test_output"

   if { $prg_exit_state != 0 } {
      add_proc_error drmaa_check -1 "$binary_path/test_drmaa $test_name $arguments failed at host $host"
   }
}

#                                                             max. column:     |
#
#****** drmaa_test/drmaa_test_st_input_becomes_output() ******
#  NAME
#     drmaa_test_st_input_becomes_output() -- Test to ensure 
#      input/output is treated correctly by DRMAA
#
#  SYNOPSIS
#     drmaa_test_st_input_becomes_output { host binary_path }
#
#  FUNCTION
#     This test creates unique file names for job input/output. These
#     file names are passed to the test_drmaa ST_INPUT_BECOMES_OUTPUT.
#     After test_drmaa ST_INPUT_BECOMES_OUTPUT was run the files are deleted.
#
#  INPUTS
#     host                       - The host where 'test_drmaa' is run
#     binary_path                - The path where 'test_drmaa' can be found
#*******************************
#
proc drmaa_test_st_input_becomes_output { host binary_path } {
   global CHECK_OUTPUT CHECK_USER

   # prepare input file
   set input_file [get_tmp_file_name]
  
   # prepare output file name
   set output_file [get_tmp_file_name]

   puts $CHECK_OUTPUT "input_file:  $input_file"
   puts $CHECK_OUTPUT "output_file: $output_file"

   if { $input_file == $output_file } {
      add_proc_error drmaa_check -1 "input and output file are equal"
   }

   puts $CHECK_OUTPUT "$binary_path/test_drmaa ST_INPUT_BECOMES_OUTPUT $input_file $output_file"

   # run job
   set test_output [start_remote_prog $host $CHECK_USER $binary_path/test_drmaa "ST_INPUT_BECOMES_OUTPUT $input_file $output_file" prg_exit_state 500]

   puts $CHECK_OUTPUT "exit status was $prg_exit_state"
   puts $CHECK_OUTPUT "output was\n$test_output"

   # remove input and output file
   file delete "$input_file"
   file delete "$output_file"

   if { $prg_exit_state != 0 } {
      add_proc_error drmaa_check -1 "test_drmaa ST_INPUT_BECOMES_OUTPUT failed at host $host\nexit status was $prg_exit_state\noutput was $test_output"
   }
}

#                                                             max. column:     |
#
#****** drmaa_test/drmaa_test_failing_control_operations() ******
#  NAME
#     drmaa_test_failing_control_operations() -- Test to ensure 
#      DRMAA operations behave correctly when they operate on other 
#      users jobs trying input/output is treated correctly by DRMAA
#
#  SYNOPSIS
#     drmaa_test_failing_control_operations { host binary_path }
#
#  FUNCTION
#     This test creates unique file names for job input/output. These
#     file names are passed to the test_drmaa ST_INPUT_BECOMES_OUTPUT.
#     After test_drmaa ST_INPUT_BECOMES_OUTPUT was run the files are deleted.
#
#  INPUTS
#     host                       - The host where 'test_drmaa' is run
#     binary_path                - The path where 'test_drmaa' can be found
#*******************************
#
proc drmaa_test_failing_control_operations { host binary_path } {
   global ts_config
   global CHECK_OUTPUT CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 

   #
   # submit sequential job in hold state as user1 
   #

   puts "going to submit a job as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   set job_id [ submit_job "-o /dev/null -j y -h $ts_config(product_root)/examples/jobs/sleeper.sh 15" 1 60 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER ]
   puts "submitted job $job_id as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"

   # ensure control operations forbidden for user2 result in a DRMAA_ERRNO_AUTH_FAILURE 
   # test broken for DRMAA_CONTROL_TERMINATE operation due to #979
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD DRMAA_CONTROL_RELEASE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_AUTH_FAILURE"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_AUTH_FAILURE $job_id" $CHECK_SECOND_FOREIGN_SYSTEM_USER
   }

   # ensure suspend/unsuspend as user1 on job in hold state returns intended errno value
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_SUSPEND DRMAA_ERRNO_SUSPEND_INCONSISTENT_STATE $job_id" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_RESUME  DRMAA_ERRNO_RESUME_INCONSISTENT_STATE $job_id" $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete job as user1
   set result [start_sge_bin "qdel" $job_id "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result"
    
   # ensure control operation isused as user1 on no longer existing job results in a DRMAA_ERRNO_INVALID_JOB 
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
         DRMAA_CONTROL_RELEASE DRMAA_CONTROL_TERMINATE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_INVALID_JOB"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_INVALID_JOB $job_id" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }

   #
   # submit job array in hold state as user1 
   #

   puts "going to submit a job as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   set job_id [ submit_job "-t 1-2 -o /dev/null -j y -h $ts_config(product_root)/examples/jobs/sleeper.sh 15" 1 60 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER ]
   puts "submitted job $job_id as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"

   # ensure control operations forbidden for user2 result in a DRMAA_ERRNO_AUTH_FAILURE 
   # test broken for DRMAA_CONTROL_TERMINATE operation due to #979
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
         DRMAA_CONTROL_RELEASE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_AUTH_FAILURE"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_AUTH_FAILURE $job_id.1" $CHECK_SECOND_FOREIGN_SYSTEM_USER
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_AUTH_FAILURE $job_id.2" $CHECK_SECOND_FOREIGN_SYSTEM_USER
   }

   # ensure suspend/unsuspend as user1 on job in hold state returns intended errno value
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_SUSPEND DRMAA_ERRNO_SUSPEND_INCONSISTENT_STATE $job_id.1" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_SUSPEND DRMAA_ERRNO_SUSPEND_INCONSISTENT_STATE $job_id.2" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_RESUME  DRMAA_ERRNO_RESUME_INCONSISTENT_STATE $job_id.1" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_RESUME  DRMAA_ERRNO_RESUME_INCONSISTENT_STATE $job_id.2" $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete job as user1
   set result [start_sge_bin "qdel" $job_id "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "qdel_output = \n$result"
    
   # ensure control operation isused as user1 on no longer existing job results in a DRMAA_ERRNO_INVALID_JOB 
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
         DRMAA_CONTROL_RELEASE DRMAA_CONTROL_TERMINATE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_INVALID_JOB"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_INVALID_JOB $job_id.1" $CHECK_FIRST_FOREIGN_SYSTEM_USER
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_INVALID_JOB $job_id.2" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }
}

proc drmaa_redirect_lib {version {host CHECK_HOST}} {
   global ts_config CHECK_USER CHECK_HOST CHECK_OUTPUT

   puts $CHECK_OUTPUT "Using DRMAA version $version on $host"

   set compile_arch [resolve_build_arch_installed_libs $host]
   set install_arch [resolve_arch $host]

   start_remote_prog $CHECK_HOST "root" "/bin/rm" "$ts_config(product_root)/lib/$install_arch/libdrmaa.so"
   start_remote_prog $CHECK_HOST "root" "/bin/ln" "-s libdrmaa.so.$version $ts_config(product_root)/lib/$install_arch/libdrmaa.so"
   start_remote_prog $CHECK_HOST "root" "/bin/rm" "$ts_config(source_dir)/$compile_arch/test_drmaa"
   start_remote_prog $CHECK_HOST "root" "/bin/ln" "-s test_drmaa.$version $ts_config(source_dir)/$compile_arch/test_drmaa"
}

