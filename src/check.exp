#!/vol2/TCL_TK/glinux/bin/expect
# expect script 
# test SGE/SGEEE System
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__


#****** framework/setup_cleanup_functions ******
#  NAME
#     setup_cleanup_functions -- setup and cleanup for testsuite checks
#
#  FUNCTION
#     Before starting the actual testsuite test, usually some setup 
#     (e.g. creating queues, parallel environments etc.) has to be done.
#     After the check finished, these resources have to be deleted again.
#
#     In former versions of testsuite, the corresponding setup and cleanup 
#     functions were simply defined as check functions. But this approach has 
#     the disadvantage, that the cleanup function was not run, when a 
#     critical error (e.g. a TCL error) occured during the execution of the 
#     check functions.
#     Another disadvantage was, that setup and cleanup were done for each 
#     individual check level, but often the same setup is valid for all 
#     check levels.
#
#     Therefore special setup and cleanup functions were introduced into 
#     testsuite.
#
#     The following functions can be defined in the test procedure (check.exp):
#
#     check_setup_function
#        setup function that is called before the check is run.
#        NOTE: Do not use the check_setup_function to shutdown any Grid Engine 
#        components. Before checks are run in a certain level, testsuite checks
#        if the system is up and running. You can savely use the 
#        check_setup_level_function to shutdown Grid Engine.
#
#     check_cleanup_function
#        cleanup function that is called after the whole check (all runlevels) 
#        ran through. It is also called when the check_setup_function failed 
#        and the actual check cannot be run.
#
#     check_setup_level_function
#        per level setup function. It is called after the init_level_function 
#        and before the first check_function is called.
#        Use this function for configuration that only applies to a specific 
#        level, or if you have to shutdown Grid Engine for the test.
#
#     check_cleanup_level_function
#        per level cleanup function that is called after the check_functions 
#        have been run in a certain level. It is also called, when the 
#        check_setup_level_function failed and the check cannot be run in the 
#        actual level.
#
#     Both types of setup/cleanup functions can be combined in a single check.
#
#  EXAMPLE
#     1. per check setup/cleanup
#     #define a level initialization procedure:
#     set check_init_level_procedure "access_lists_init_level"
#     # define test's name and run level descriptions
#     set check_name            "access_lists"
#     set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
#     set check_highest_level   0
#     set check_description(0)  "Test (x)user_lists access for queue/cluster/pe"
#
#     # define test's dependencies
#     set check_needs           "init_core_system"
#
#     # setup and cleanup functions
#     set check_setup_function "access_lists_setup"
#     set check_cleanup_function "access_lists_cleanup"
#     
#     # define test's procedure order
#     set check_functions ""
#     lappend check_functions "access_lists_global_host"
#     lappend check_functions "access_lists_exec_host"
#     lappend check_functions "access_lists_queue"
#     lappend check_functions "access_lists_cluster_config"
#     lappend check_functions "access_lists_pe"
#     
#     
#     2. per level setup/cleanup
#     
#     
#     # define a level initialization procedure:
#     set check_init_level_procedure "usage_init_level"
#     
#     # define test's name and run level descriptions
#     set check_name            "usage"
#     set check_category        "COMPATIBILITY SYSTEM VERIFIED"
#     set check_highest_level   1
#     set check_description(0)  "check reserved usage of jobs submitted with qsub"
#     set check_description(1)  "check reserved usage of jobs submitted with qrsh"
#     
#     # define test's dependencies
#     set check_needs           "init_core_system"
#     
#     # setup and cleanup functions
#     set check_setup_level_function "usage_setup"
#     set check_cleanup_level_function "usage_cleanup"
#     
#     # define test's procedure order
#     set check_functions ""
#     lappend check_functions "usage_single"
#     lappend check_functions "usage_tight"
#     lappend check_functions "usage_loose1"
#     lappend check_functions "usage_loose2"
#     
#*******************************
#

#****** framework/solaris_zones ******
#  NAME
#     solaris_zones -- use of testsuite with Solaris zones
#
#  FUNCTION
#     Testsuite has some special handling for Solaris zones.
#
#     The testsuite host configuration allows to specify a
#     list of zones (zone hostnames) for each configured host.
#
#     If zones are configured on a host being part of a testsuite cluster,
#     testsuite will use the zones as execution hosts instead of the
#     real host (global zone).
#     qmaster and shadowd will run in the global zone (real hostname).
#
#     The testsuite configuration database (TCL array ts_config) contains
#     the following entries, that are affected by zone configuration:
#        - execd_hosts: The real hostnames configured as exec hosts
#        - execd_nodes: - for hosts having no zones: The real hostname.
#                       - for hosts having zones, execd_nodes will contain
#                         all zones of the host, but not the host itself.
#        - unique_execd_nodes: Similar to execd_nodes, but for hosts having
#                              zones, only the first zone is contained.
#        - unique_arch_nodes: For each architecture present in the cluster,
#                             one host or zone is contained, selected from 
#                             unique_execd_nodes.
#
#     Testsuite checks intending to run tests on all configured execution
#     hosts should use ts_config(execd_nodes).
#
#     Testsuite checks intending to run tests on all architectures available
#     in the cluster should use ts_config(unique_arch_nodes).
#
#  EXAMPLE
#     We have the hosts "host" and "zhost".
#     On host "zhost", 2 zones are installed: zone00 and zone01.
#
#     ts_config(execd_hosts): "host zhost"
#     ts_config(execd_nodes): "host zone00 zone01"
#     ts_config(unique_execd_nodes): host zone00"
#
#     If we run testsuite on "host",
#     qmaster will run on "host",
#     execution daemons will be running on "host", "zone00", and "zone01".
#
#     If we run testsuite on "zhost",
#     qmaster will run on "zhost",
#     execution daemons will be running on "host", "zone00", and "zone01".
#     
#*******************************
#

fconfigure stdin -blocking TRUE
global last_debug_msec
set last_debug_msec [clock clicks -milliseconds]
global daemon_debug 
set daemon_debug 0
global master_debug
set master_debug 0
global schedd_debug
set schedd_debug 0
global actual_user_system
set actual_user_system "admin user system" ;# system type installed at install core system test

global DISABLE_ADD_PROC_ERROR
set DISABLE_ADD_PROC_ERROR 0
global no_action                   ;# just used for testing/debug  procedures
set no_action 0
global be_quiet
set be_quiet 0
global write_mail_to_file
set write_mail_to_file 0
global do_close_rlogin
set do_close_rlogin 0

# if we know the config is ok, we don't want to check it, 
# e.g. we don't want to connect to all hosts during setup
#      or check the CVS version at every testsuite startup
global fast_setup
set fast_setup 0

global do_compile
global CHECK_TESTSUITE_LOCKFILE
set CHECK_TESTSUITE_LOCKFILE "testsuite_lockfile"
global CHECK_TESTSUITE_INSTALL_MODE
set CHECK_TESTSUITE_INSTALL_MODE "manual" ;# sets the install mode. allowed are: automatic and manual
 
# path/file variables
global CHECK_RESULT_DIR            ;# check result directory            
global CHECK_BAD_RESULT_DIR        ;# check rusult directory for failed checkes

# this is for new tests:
global CHECK_PROTOCOL_DIR          ;# directory for test protocols, logs etc.
global CHECK_JOB_OUTPUT_DIR        ;# directory for qsub job outputs
############################################################################

global CHECK_ACTUAL_TEST_PATH      ;# directory of current running test
global CHECK_OUTPUT                ;# output from testsuite 
global CHECK_CURRENT_WORKING_DIR   ;# current work directory
global CHECK_HTML_DIRECTORY        ;# directory for HTML output of testsuite 
set CHECK_HTML_DIRECTORY ""
# globals for source code specific staff
global CHECK_PACKAGE_DIRECTORY        ;# optional: no compile directory, use distribution (tar or sun packages)
global CHECK_PACKAGE_TYPE             ;# zip or tar
set CHECK_PACKAGE_TYPE "tar"
global CHECK_QMASTER_INSTALL_OPTIONS  ;# optional: qmaster install parameter
global CHECK_EXECD_INSTALL_OPTIONS    ;# optional: execd install parameter 
set CHECK_PACKAGE_DIRECTORY "none"
set CHECK_QMASTER_INSTALL_OPTIONS ""
set CHECK_EXECD_INSTALL_OPTIONS   ""

# test system specific 
global CHECK_L10N  ;# is sge/sgeee system l10n'ed ?
set CHECK_L10N 0
global CHECK_DNS_DOMAINNAME
set CHECK_DNS_DOMAINNAME ""
global CHECK_REMOTE_ENVIRONMENT
set CHECK_REMOTE_ENVIRONMENT ""
global CHECK_DISPLAY_OUTPUT 
if { [info exists env(DISPLAY)] } {
set CHECK_DISPLAY_OUTPUT [set env(DISPLAY)]
} else {
set CHECK_DISPLAY_OUTPUT "undefined"  
}
global CHECK_SETTINGS_VERSION    ;# settings file version number
set CHECK_SETTINGS_VERSION "undefined"
global CHECK_PRODUCT_VERSION_NUMBER ;# version string of qstat -help of tested system
set CHECK_PRODUCT_VERSION_NUMBER "unknown"
global CHECK_PRODUCT_TYPE           ;# "sgeee" or "sge" 
global CHECK_COMMD_PORT            ;# commd port
global CHECK_USER                  ;# user who start test
global CHECK_GROUP                 ;# group of user who start test
global CHECK_ACT_LEVEL             ;# actual check level ( value from 0 up to xxx )
global CHECK_SPOOL_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_SPOOL_DIR_CONFIG_FILE "local-spool.conf"
global CHECK_LOCAL_BINARY_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_LOCAL_BINARY_DIR_CONFIG_FILE "local-bin.conf"
global CHECK_BINARY_DIR_CONFIG_FILE ;# file for binary directories in $CHECK_CONFIG_DIR
set CHECK_BINARY_DIR_CONFIG_FILE "binary-path.conf"
global CHECK_LOADSENSOR_DIR_CONFIG_FILE ;# file for architecture specific loadsensor binaries in
set CHECK_LOADSENSOR_DIR_CONFIG_FILE "loadsensor.conf" ;# $CHECK_CONFIG_DIR
global CHECK_MAIL_OUTPUT_FILE
set CHECK_MAIL_OUTPUT_FILE "all_test_mails.txt"

global check_use_installed_system   ;# used only for install_core_system test (noinst parameter)
set check_use_installed_system 0    ;# set to 1 when installed system parameter is set

global check_do_not_use_spool_config_entries
set check_do_not_use_spool_config_entries 0

global check_do_clean_compile
set check_do_clean_compile 0

global check_reinit_on_tcl_error
set check_reinit_on_tcl_error 0

global CHECK_FIRST_FOREIGN_SYSTEM_USER       ;# other system user for e.g. submitting jobs 
set CHECK_FIRST_FOREIGN_SYSTEM_USER "nobody"

global CHECK_SECOND_FOREIGN_SYSTEM_USER      ;# other system user for e.g. submitting jobs 
set CHECK_SECOND_FOREIGN_SYSTEM_USER "nobody"

global CHECK_FIRST_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_FIRST_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_SECOND_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_SECOND_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_DEFAULT_DOMAIN                ;# default domain for install test
set CHECK_DEFAULT_DOMAIN "none"

global CHECK_MAILX_HOST                    ;# host where the mailx binary is available
set CHECK_MAILX_HOST "none"

global CHECK_REPORT_EMAIL_TO               ;# mail reports/errors to this email-account
set CHECK_REPORT_EMAIL_TO "none"

global CHECK_REPORT_EMAIL_CC               ;# cc reports/errors to this email-accounts
set CHECK_REPORT_EMAIL_CC "none"                 

global CHECK_SEND_ERROR_MAILS              ;# flag 0 off  1 on
set CHECK_SEND_ERROR_MAILS "1"

global CHECK_MAX_ERROR_MAILS              ;# max mails on run all test
set CHECK_MAX_ERROR_MAILS 400

global CHECK_EXPECT_MATCH_MAX_BUFFER   ;# read buffer for expect
set CHECK_EXPECT_MATCH_MAX_BUFFER 640000

global CHECK_COVERAGE
set CHECK_COVERAGE {} ;# list of code coverage methods (tcov, insure, or emma)

global CHECK_COVERAGE_DIR ;# directory for test coverage profiles
set CHECK_COVERAGE_DIR ""

global CHECK_PREFERRED_ARCHS ;# preferred architecture for testing
set CHECK_PREFERRED_ARCHS {}

global CHECK_HAVE_TDOM ;# do we have the tdom tcl package installed?
set CHECK_HAVE_TDOM 0

# to redefine in checks:
global check_name                  ;# name of actual check module 
global check_category              ;# check category name array (z.b. COMPATIBILITY, NONROOT, SYSTEM, PERFORMANCE)
global check_description           ;# description of actual check module (append more levels as list)
global check_needs                 ;# dependencies of this check (name of other check)
global check_functions             ;# functions to call (in order)
global check_init_level_procedure  ;# name of procedure to call before starting level run
global check_errno                 ;# list of errors that were raised for a certain test
global check_errstr                ;# short error descriptions in text form for check_errno
global check_highest_level         ;# here a check can define his check levels count 0 ...

# for global procedures
global check_cur_proc_error        ;# short error description in text form ( in public procedures )
global check_cur_proc_result       ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )    


# testsuite intern
global CHECK_INFORMATION_FILE      ;# filename of check information (check.exp)
global CHECK_INFORMATION_EXT       ;# fileextension of check information (check.exp)
global ts_checktree                ;# structure which contains checktree directory informations (see build_checktree)
global CHECK_REPORT_FILE           ;# filename (with path) for report
global CHECK_MAIN_RESULTS_DIR      ;# check result root directory for all RESULTS
global CHECK_CONFIG_DIR            ;# global configuration testsuite directory
global CHECK_DEFAULTS_FILE         ;# default settings save file
global CHECK_DO_SETUP              ;# flag: do setup option called ?
global CHECK_CUR_PROC_NAME         ;# name of current running test procedure
set    CHECK_CUR_PROC_NAME "initializing"

global CHECK_ENABLED_RUNLEVELS     ;# enabled runlevels
global CHECK_ENABLED_CATEGORIES    ;# enabled categories
global CHECK_ACT_PATH              ;# actual checkpath (while switching in menu mode)
global arch_cache                  ;# cache for architecture names (lower case) e.g. solaris64
global pe_for_version_check_result ;# cache for pe/checkpnt version
global build_arch_cache            ;# cache for architecture names (upper case) e.g. SOLARIS64
global l10n_raw_cache              ;# chche for l10n translation strings
global l10n_install_cache          ;# cache for l10n installation script strings
global have_ssh_access_state       ;# global variable for have_ssh_access procedure (remember state)
global check_timestamp             ;# for use in is_job_running
global CHECK_SGE_DEBUG_LEVEL       ;# SGE_DEBUG_LEVEL for starting qmaster and scheduler in debug mode
set CHECK_SGE_DEBUG_LEVEL "2 0 0 0 0 0 0 0"
global CHECK_MAILS_SENT            ;# counter for send mails
set CHECK_MAILS_SENT 0
global CHECK_ENABLE_MAIL           ;# is mail sending enabled
set CHECK_ENABLE_MAIL 1
global CHECK_ADMIN_USER_SYSTEM     ;# if no root account is possible
set CHECK_ADMIN_USER_SYSTEM 0
set check_timestamp [timestamp]
set have_ssh_access_state -1
set pe_for_version_check_result "undefined"
set CHECK_ENABLED_RUNLEVELS "0"
set CHECK_ENABLED_CATEGORIES {}
set CHECK_DO_SETUP         0
set CHECK_INFORMATION_FILE "check"   ;# this is the filename of each check in different
set CHECK_INFORMATION_EXT  "exp"     ;# default extension for check files
                                         ;# subdirectories of "checktree"
                                         ;# every file with this name is interpreded as check routine


# the following variables are used for handling user pressing CTRL-C
global CHECK_INTERRUPT              ;# user requests interrupt, value of CHECK_INTERRUPT defines when
                                     # the check will be interrupted:
                                     # 1: after the current check, including all active runlevels
                                     # 2: after the current check in the current runlevel
                                     # 3: after the current check_function
global CHECK_TEST_RUNNING           ;# we are currently running a check
global CHECK_TESTS_RUNNING          ;# we are currently running a whole part of checktree
set CHECK_INTERRUPT 0
set CHECK_TEST_RUNNING 0
set CHECK_TESTS_RUNNING 0

# debuglevel 0 - none
# debuglevel 1 - more output
# debuglevel 2 - wait for user response (sometimes!)

global CHECK_DEBUG_LEVEL
set CHECK_DEBUG_LEVEL 0 

#set CHECK_OUTPUT [open /dev/null "w"]
set CHECK_OUTPUT stdout

#
#                                                             max. column:     |
#****** check/debug_puts() ******
#  NAME
#     debug_puts -- ??? 
#
#  SYNOPSIS
#     debug_puts { args } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     args - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc debug_puts { args } {
   global CHECK_OUTPUT CHECK_DEBUG_LEVEL
   global CHECK_CUR_PROC_NAME last_debug_msec

   if { $CHECK_DEBUG_LEVEL == 0 } {
      return
   }

   if { [llength [info procs "gethostname"]] != 0 } {
      set local_host [gethostname 0]
   } else {
      set local_host "unknown"
   }
   set output ""
   foreach elem $args {
      set output "$output $elem"
   }   

   if { [info exists CHECK_CUR_PROC_NAME] == 0 } {
      set CHECK_CUR_PROC_NAME "unknown"
   }
   set time [clock clicks -milliseconds]
   set time [expr $time - $last_debug_msec]

   set last_debug_msec [clock clicks -milliseconds]

   puts $CHECK_OUTPUT "\[$time $local_host:$CHECK_CUR_PROC_NAME\] $output" 
}

#                                                             max. column:     |
#****** check/get_current_working_dir() ******
# 
#  NAME
#     get_current_working_dir -- ??? 
#
#  SYNOPSIS
#     get_current_working_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_current_working_dir { } {

  set work_dir [pwd]
  debug_puts "working dir is $work_dir"
  set help0 $work_dir
  while  { 1 } {
     set help [ split $help0 "/" ]
     set help2 [ lreplace $help 0 1 ]
     set new_work_dir "/[ join $help2 "/" ]"
     set help0 $new_work_dir
     set catch_return_1 [ catch { 
         eval exec "ls $work_dir"
     } result_1 ] 

     set catch_return_2 [ catch { 
         eval exec "ls $new_work_dir" 
     } result_2 ]
     if { $catch_return_1 == 0 && $catch_return_2 == 0} {
        if { [ string compare $result_1 $result_2 ] == 0 } {
           # possibly mounted directory try to create a file
           set f_name "testsuite_test_[timestamp]"
           set catch_return_3 [ catch { 
              eval exec "touch $work_dir/$f_name" 
           } result_3 ]
           if { [ file isfile "$new_work_dir/$f_name" ] } {
              puts "--> mount prefix found, using $new_work_dir"
              set work_dir $new_work_dir
           }
           set catch_return_4 [ catch { 
              eval exec "rm $work_dir/$f_name" 
           } result_4 ]
        }
     }
     if { [string compare $help0 "/" ] == 0 } {
        break;
     }
  }
  return $work_dir 
}


set CHECK_CURRENT_WORKING_DIR [get_current_working_dir]
set CHECK_DEFAULTS_FILE    "$CHECK_CURRENT_WORKING_DIR/defaults.sav"

set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"
set CHECK_TESTSUITE_LOCKFILE "$CHECK_CURRENT_WORKING_DIR/testsuite_lockfile"


# some useful functions for test implementation



# 
#                                                             max. column:     |
#****** check/add_proc_error() ******
# 
#  NAME
#     add_proc_error -- append testsuite error message
#
#  SYNOPSIS
#     add_proc_error { proc_name result text } 
#
#  FUNCTION
#     This procedure adds a new error to the global error arrays for the global 
#     procedures.  
#
#     So a test programmer doesn't have to set the error states after calling 
#     a global procedure which uses add_proc_error. Each global procedure 
#     set the error state by itself. 
#
#     The test run will report ALL global errors and doesn't set the test run 
#     to a correct state if such an error is reported. 
#
#     Some global procedures have an optional flag to switch off the global 
#     error report. For some cases it is necessary to turn off the error 
#     reporting. (e.g. forced timeout test)
#
#  INPUTS
#     proc_name   - name of the calling procedure
#     result      - error state (e.g. -1)
#     text        - error text (e.g. "open file xxx failed)
#     raise_error - raise an error condition (including sending mail)
#                   or just output the error message
#
#  RESULT
#     no result
#
#  SEE ALSO
#*******************************
proc add_proc_error {proc_name result text {raise_error 1}} {
   global CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name
   global add_proc_error_avoid_recursive_call
   global check_errno check_errstr
   global DISABLE_ADD_PROC_ERROR

   if { $DISABLE_ADD_PROC_ERROR == 1 } {
      return;
   }
   # trim text message
   set text [string trim $text]

   # There are cases where we intentionally make a command fail,
   # e.g. calling get_exechost for a non execution host.
   # We don't want the test to go into error state in this case,
   # but just see the error output.
   if {!$raise_error} {
      puts $CHECK_OUTPUT "----------------------------------------------------------------"
      puts $CHECK_OUTPUT "!!   The following message is an *expected* error condition   !!"
      puts $CHECK_OUTPUT $text  
      puts $CHECK_OUTPUT "----------------------------------------------------------------"
      return
   }

   # add_proc_error could be called recursively, for example, 
   # if errors occur while sending the error message as mail.
   # In this case, just output the error message - Otherwise we might 
   # end up in endless recursion.
   if {[info exists add_proc_error_avoid_recursive_call] && $add_proc_error_avoid_recursive_call == 1} {
      puts $CHECK_OUTPUT "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      puts $CHECK_OUTPUT "!!! recursive call of add_proc_error !!!"
      puts $CHECK_OUTPUT "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      puts $CHECK_OUTPUT "$proc_name|$result|$check_name|$CHECK_CUR_PROC_NAME"
      puts $CHECK_OUTPUT "$text"
      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT ""
      return
   }

   # result >= 0 means ok
   # lots of such calls come from (deprecated) set_error calls
   if {$result >= 0} {
      return
   }

   # avoid recursive call
   set add_proc_error_avoid_recursive_call 1

   set new_error "$proc_name|$check_name|$CHECK_CUR_PROC_NAME|$text"

   # store the list of errors that occured during the run of a test
   if {![info exists check_errno($CHECK_CUR_PROC_NAME)]} {
      set check_errno($CHECK_CUR_PROC_NAME) {}
      set check_errstr($CHECK_CUR_PROC_NAME) {}
   }
   lappend check_errno($CHECK_CUR_PROC_NAME) $result
   lappend check_errstr($CHECK_CUR_PROC_NAME) $new_error


   if {$check_name != "setup"} {
      show_proc_error $result $new_error
   } else {
      puts $CHECK_OUTPUT [create_error_message $new_error]
   }

   # now we are through, allow further calls of add_proc_error
   set add_proc_error_avoid_recursive_call 0
}

#****** check/print_errors() ***************************************************
#  NAME
#     print_errors() -- parse resent testsuite errors and print them out
#
#  SYNOPSIS
#     print_errors { } 
#
#  FUNCTION
#     This procedure analyses the current stored testsuite errors reported
#     via add_proc_error and prints them out in a error report section.
#     This section is parsed when a testsuite is controlling another testsuite
#     and the controller testsuite wants to find out what happens on the
#     remote testsuite. The function returns 0 when there where no errors.
#     Warnings are ignored.
#
#  INPUTS
#
#  RESULT
#     0 no errors found
#     1 there were errors 
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc print_errors {} {
   global check_errno check_errstr CHECK_OUTPUT
   set found_errors 0
   if { [info exists check_errno] } {
      set names [array names check_errno]
      foreach name $names {
         set max_error [llength $check_errno($name)]
         for {set index 0} {$index < $max_error} {incr index 1} {
            set error [lindex $check_errno($name) $index]
            if { $error == -1 || $error == -2 } {
               if { $found_errors == 0 } {
                  puts $CHECK_OUTPUT "ERROR REPORT - START"
                  set found_errors 1
               }
               set help [lindex $check_errstr($name) $index]
               set help [split $help "|"]
               set test_name [lindex $help 1]
               set test_proc [lindex $help 0]
               set test_error [lindex $help 3]
               puts $CHECK_OUTPUT "$test_name: procedure \"$test_proc\" - $test_error"
            }
         }
      }
      if { $found_errors != 0} {
         puts $CHECK_OUTPUT "ERROR REPORT - DONE"
      }
   }
   return $found_errors
}

#                                                             max. column:     |
#****** check/have_ssh_access() ******
# 
#  NAME
#     have_ssh_access -- is ssh accessable ?
#
#  SYNOPSIS
#     have_ssh_access { } 
#
#  FUNCTION
#     This procedure tries to get a ssh (secure shell) connection to each execd 
#     host from the cluster. The result of this test is stored in a global 
#     variable so the next call will not cause the connection test again.
#
#  INPUTS
#
#  RESULT
#     0: no ssh access
#     1: ok
#
#  SEE ALSO
#     ???/???
#*******************************
proc have_ssh_access {} {
  global CHECK_OUTPUT have_ssh_access_state ts_config

  if { $have_ssh_access_state != -1 } {
     return $have_ssh_access_state
  }

  if {$ts_config(connection_type) == "rlogin" ||  $ts_config(connection_type) == "ssh_with_password"} {
     set have_ssh_access_state 0
     return $have_ssh_access_state
  }

  set local_host [gethostname]
  set run_again 0
  if { [ info exists ts_config(execd_hosts) ] != 1 } {
     puts $CHECK_OUTPUT "no execd hosts defined, checking only local ssh connection"
     set run_again 1
     set host_array $local_host 
  } else {
     set host_array $ts_config(execd_hosts)
  }

  set ssh_binary [get_binary_path $local_host ssh]
  if { $ssh_binary == "" } {
     add_proc_error "have_ssh_access" "-1" "--> no ssh binary configured for host $local_host - please update your testsuite host configuration"
     return 0
  }

  log_user 0
  set have_complete_access 1
  
  foreach elem $host_array { 
     set catch_state [ catch {

        puts $CHECK_OUTPUT "trying $ssh_binary -l root $elem id"

        set id [ open_spawn_process "$ssh_binary" "-l" "root" "$elem" "id"]
        set sp_id [ lindex $id 1 ] 
 
        set timeout 30
        set end_val 0
        set have_access 0
        while { $end_val == 0} {
           log_user 0
           expect {
               -i $sp_id full_buffer {
                  add_proc_error "have_ssh_access" "-1" "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               }

               -i $sp_id "uid*0*root" {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> having ssh access to host $elem"
                  set end_val 1
                  set have_access 1
               }
               -i $sp_id "assword" {
                  set end_val 1
               }
               -i $sp_id timeout {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> timeout waiting to get root access"
                  set end_val 1
               }
               -i $sp_id eof {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> end of file dedected"
                  set end_val 1
               }
           }
        }
        set log_user 0
        close_spawn_process $id 1
        if { $have_access != 1 } {
            log_user 1
            set have_complete_access 0
            puts $CHECK_OUTPUT "--> no ssh access to host $elem"
            add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem"
        }
     } ] ;# end of chatch
     if { $catch_state != 0} {
        puts $CHECK_OUTPUT "--> no ssh access to host $elem (maybe no ssh installed)"
        add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem (maybe no ssh installed)"
        set have_complete_access 0
     }
  }
  log_user 1
  if { $run_again == 0 } {
     set have_ssh_access_state $have_complete_access
  }
  return $have_complete_access
}

proc init_stored_passwd {} {
   global stored_passwd

   set stored_passwd(root) ""
}

#****** check/set_root_passwd() ******
# 
#  NAME
#     set_root_passwd -- ask user for root password
#
#  SYNOPSIS
#     set_root_passwd { } 
#
#  FUNCTION
#     This procedure reads in the root password from stdin. If the root password 
#     is not used (ssh access garanted) the procedure returns immediately.
#     The root password is tested with an id call as root on the local machine.
#
#     If we have windows host(s) in our cluster, the procedure will also ask for 
#     the passwords of CHECK_USER, CHECK_FIRST_FOREIGN_SYSTEM_USER, and
#     CHECK_SECOND_FOREIGN_SYSTEM_USER.
#     This is required, as windows doesn't allow us to 
#        - access network filesystems
#        - switch to a certain target user
#     without the users password.
#
#  SEE ALSO
#     check/have_root_passwd
#     check/get_root_passwd
#*******************************
proc set_root_passwd {} {
   global CHECK_OUTPUT
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER
   global stored_passwd
   global ts_config

   # initialize stored password database
   if {![info exists stored_passwd]} {
      init_stored_passwd
   }

   set result "no password" 

   set passwd_required ""

   # if we don't have ssh access, we need the root passwd
   # and test it on the master host
   if {![have_ssh_access]} {
      lappend passwd_required "root"
   }

   # if we have a windows host in the cluster, we need passwords
   # of all users
   set windows_host ""
   if {[host_conf_have_windows]} {
      set passwd_required "$CHECK_USER root $CHECK_FIRST_FOREIGN_SYSTEM_USER $CHECK_SECOND_FOREIGN_SYSTEM_USER"
      puts "Our testsuite cluster contains (a) windows host(s)."
      puts "For both login into the windows host with full network access,"
      puts "and for executing jobs (which requires registering users with sgepasswd),"
      puts "we need the windows passwords of the following users:"
      foreach user $passwd_required {
         puts "  - $user"
      }

      # Test login on one of the windows hosts
      set windows_host [host_conf_get_windows_host]
   }

   # Enter and test passwords
   foreach user $passwd_required {
      set_passwd $user $ts_config(master_host) $windows_host
   }
   
   # Now check for additional password hooks from additional checktrees
   while { [get_user_passwd_hooks] != 0 } {
      puts "Error setting password hooks ..."
      wait_for_enter
   }
}

#****** check/get_user_passwd_hooks() ******************************************
#  NAME
#     get_user_passwd_hooks() -- check password hooks from add. checktrees
#
#  SYNOPSIS
#     get_user_passwd_hooks { } 
#
#  FUNCTION
#     If an additional checktree defines passwd_hook then this procedure
#     is calling the hook function.
#
#  RESULT
#     -1 => error
#     result of hook function ( should be 0 on success ) 
#
#*******************************************************************************
proc get_user_passwd_hooks {} {
   global ts_checktree CHECK_OUTPUT
   set res 0
   for {set i 0} { $i < $ts_checktree(act_nr)} {incr i 1 } {
      if { [info exists ts_checktree($i,passwd_hook) ] } {
         set prog $ts_checktree($i,passwd_hook)
         if { [info procs $prog ] != $prog } {
            add_proc_error "exec_install_binaries_hooks" -1 "Can not execute passwd hook $ts_checktree($i,passwd_hooks_${ii}), prog not found"
            return 0
         } else {
            set res [$prog]
            if { $res != 0} {
               break
            }
         }
      }
   }
   return $res
}  

#****** check/set_passwd() *****************************************************
#  NAME
#     set_passwd() -- query user for password
#
#  SYNOPSIS
#     set_passwd { user root_host win_host } 
#
#  FUNCTION
#     Interactively asks for the password of a certain user 
#     (required for windows) and stores it in a TCL data structure.
#
#  INPUTS
#     user      - user names whose password shall be set
#     root_host - host to be used for testing root password (usually a unix host)
#     win_host  - windows host to test user passwords
#
#  SEE ALSO
#     check/set_root_passwd()
#     check/get_passwd()
#     check/get_root_passwd()
#*******************************************************************************
proc set_passwd {user root_host win_host} {
   global CHECK_OUTPUT
   global CHECK_ADMIN_USER_SYSTEM
   global stored_passwd

   # repeat passwd question, until success, or 
   # user explicitly requested other options
   set error 1
   while {$error} {
      # enter passwd
      puts "\nhost access with password needed for user $user"
      if {$user == "root"} {
         puts "please enter the password, or \"noroot\" to start testsuite without root access"
      } else {
         puts "please enter the password, or \"none\" to skip passwd entry and risk errors later on"
      }
      puts "user $user's password: "
      stty -echo
      set passwd [wait_for_enter 1]
      stty echo

      # evaluate passwd
      if {$passwd == ""} {
         puts $CHECK_OUTPUT "--> password not set!"
         continue
      } else {
         # user explicitly requests not to have passwd?
         if {$user == "root" && $passwd == "noroot"} {
            set CHECK_ADMIN_USER_SYSTEM 1
            set error 0
         } else {
            if {$user != "root" && $passwd == "none"} {
               set error 0
            } else {
               # seems to be a real passwd - check it
               # temporarily set password database (for connection test)
               set stored_passwd($user) $passwd

               # choose host on which to test user's passwd
               if {$user == "root"} {
                  set host $root_host
               } else {
                  set host $win_host
               }

               # try to connect to host and execute "id"
               puts $CHECK_OUTPUT "--> testing $user access to host $host ..."
               set result [start_remote_prog $host $user "id" "" prg_exit_state 60 0 "" "" 1 1 0 0]
               puts $CHECK_OUTPUT "--> id as $user output:\n$result"

               # on error: allow reentering of passwd, or
               # switch to admin user system, or
               # do not reenter passwd and risk errors later on (windows non root users)
               if {[string first $user $result] >= 0} {
                  set error 0
               } else {
                  puts $CHECK_OUTPUT "--> no $user access"
                  set passwd ""
               }
            } ;# passwd check
         } ;# passwd or none has been entered
      } ;# passwd or noroot/none has been entered
   } ;# while loop entering passwd   

   # finally store the passwd
   set stored_passwd($user) $passwd
}

#****** check/get_passwd() *****************************************************
#  NAME
#     get_passwd() -- get the password of a given user
#
#  SYNOPSIS
#     get_passwd { user } 
#
#  FUNCTION
#     Returns the password of a given user (set ealier by set_passwd), or an
#     empty string, in case no password is available.
#
#  INPUTS
#     user - user whose password shall be returned
#
#  RESULT
#     the password or an empty string
#
#  SEE ALSO
#     check/set_passwd()
#*******************************************************************************
proc get_passwd {user {raise_error 1}} {
  global stored_passwd

   if {$user == "Administrator"} {
      set user "root"
   }

   if {![info exists stored_passwd($user)] || $stored_passwd($user) == ""} {
      add_proc_error "get_passwd" "-2" "$user's password not set" $raise_error
      return ""
   }

   return $stored_passwd($user)
}

# 0 no action
# 1 new pre_install
# 2 only shutdown system


#                                                             max. column:     |
#****** check/have_root_passwd() ******
# 
#  NAME
#     have_root_passwd -- is root password available ?
#
#  SYNOPSIS
#     have_root_passwd { } 
#
#  FUNCTION
#     test if root password was typed in 
#
#  INPUTS
#     0  : root password should be ok
#     -1 : no root access
#  RESULT
#     
#
#  SEE ALSO
#     check/set_root_passwd
#     check/get_root_passwd
#*******************************
proc have_root_passwd {} {
  global CHECK_OUTPUT
  global stored_passwd

  if {[have_ssh_access] == 1} {
     return 0
  }

  if {![info exists stored_passwd(root)] || $stored_passwd(root) == ""} {
     puts $CHECK_OUTPUT "you have no ssh access and no root password"
     return -1
  }

  return 0
}

#                                                             max. column:     |
#****** check/get_root_passwd() ******
# 
#  NAME
#     get_root_passwd -- return root password 
#
#  SYNOPSIS
#     get_root_passwd { } 
#
#  FUNCTION
#     This procedure returns the root password, typed in by the user.
#
#  INPUTS
#
#  RESULT
#     string with root password
#
#  SEE ALSO
#     check/have_root_passwd
#     check/set_root_passwd
#*******************************
proc get_root_passwd {} {
  global stored_passwd
  
  if {![info exists stored_passwd(root)] || $stored_passwd(root) == ""} {
     add_proc_error "get_root_passwd" "-2" "root password not set"
     return ""
  }

  return $stored_passwd(root)
}





#                                                  max. column:     |
#****** check/mail_report() ******
# 
#  NAME
#     mail_report -- send mail
#
#  SYNOPSIS
#     mail_report { subject body } 
#
#  FUNCTION
#     This procedure sends an e-mail to the e-mail-address configured
#     with the global variables CHECK_REPORT_EMAIL_CC  and 
#     CHECK_REPORT_EMAIL_TO. Subject and body of the mail is taken 
#     from the parameters subject and body.
#
#  INPUTS
#     subject - e-mail subject text
#     body    - e-mail body text
#
#  SEE ALSO
#     check/send_mail
#*******************************
proc mail_report { subject body } {
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC CHECK_OUTPUT
   global write_mail_to_file

   set mail_cc ""

   # needn't check mailto / cc if we are writing to mailfile
   if {$write_mail_to_file == 0} {
      if { [string compare $CHECK_REPORT_EMAIL_TO "none"] == 0 } {
         puts $CHECK_OUTPUT "--> mail_report - no mail address"
         return
      }
   
      if { [string compare $CHECK_REPORT_EMAIL_CC "none"] != 0 } {
         set mail_cc $CHECK_REPORT_EMAIL_CC
      }
   }

   send_mail $CHECK_REPORT_EMAIL_TO $mail_cc $subject $body 
}



#                                                             max. column:     |
#****** check/send_mail() ******
# 
#  NAME
#     send_mail -- send mail  
#
#  SYNOPSIS
#     send_mail { address cc subject body } 
#
#  FUNCTION
#     This procedure calls the mailx binary by using remote shell to 
#     send an e-mail. 
#
#  INPUTS
#     address - e-mail address
#     cc      - e-mail CC address
#     subject - e-mail subject text  
#     body    - e-mail body text 
#
#  SEE ALSO
#     check/mail_report
#*******************************
proc send_mail { address cc subject body } {
   global CHECK_MAILX_HOST CHECK_OUTPUT
   global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_USER CHECK_MAX_ERROR_MAILS
   global write_mail_to_file CHECK_MAIL_OUTPUT_FILE CHECK_ENABLE_MAIL
   global ts_config

   if { $write_mail_to_file != 0 } {
      set fd [ open $CHECK_MAIL_OUTPUT_FILE "a" ]
      puts $fd "-=*************************************************************=-"
      puts $fd "Grid Engine Version: [get_version_info]"
      puts $fd "Subject            : $subject"
      puts $fd "-=*************************************************************=-"
      puts $fd "$body"
      puts $fd "-=*=-"
      flush $fd
      close $fd 
      puts $CHECK_OUTPUT "Added entry in mail output file $CHECK_MAIL_OUTPUT_FILE"
      return
   }

   set erg [sendmail_wrapper $address $cc $subject $body]
   if { $erg == 0 } {
      return
   }

   set new_subject "[get_version_info] ($ts_config(cell)) - $subject"
  
   if { $CHECK_ENABLE_MAIL != 1 } {
      puts $CHECK_OUTPUT "mail sending disabled, mails sent: $CHECK_MAILS_SENT"
      puts $CHECK_OUTPUT "mail new_subject: $new_subject"
      puts $CHECK_OUTPUT "mail body:"
      puts $CHECK_OUTPUT "$body"
      return
   }
 
   set tmp_mailfile [get_tmp_file_name]

   set output_file [open $tmp_mailfile "w"]
   puts $output_file $body
   flush $output_file
   close $output_file
 
   set file_size 0
   while { $file_size == 0 } {
      catch { set file_size [file size $tmp_mailfile]}
      if { $file_size == 0 } { 
         puts $CHECK_OUTPUT "--> file size of \"$tmp_mailfile\": $file_size ; waiting for filesize > 0"
         sleep 1
      }
   }
 
 
 
   catch { exec "touch" $tmp_mailfile } result
   catch { exec "chmod" "0755" $tmp_mailfile } result
 
   if { [string compare $cc "none"] != 0 } {
      set mail_args "-s \"$new_subject\" -c \"$cc\" \"$address\" < \"$tmp_mailfile\""
   } else {
      set mail_args "-s \"$new_subject\" \"$address\" < \"$tmp_mailfile\""
   }
   set mail_output [start_remote_prog $CHECK_MAILX_HOST "ts_def_con_mail" "mailx" "$mail_args" prg_exit_state 60 0 "" "" 1 0]
 
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "--> send_mail - could not send mail:\n$mail_output"
   } else {
      puts $CHECK_OUTPUT "--> send_mail - mail sent to $address"
      incr CHECK_MAILS_SENT 1
      if { $CHECK_MAILS_SENT == $CHECK_MAX_ERROR_MAILS } {
         if { [string compare $cc "none"] != 0 } {
            set mail_args "-s \"max mail count reached\" -c \"$cc\" \"$address\" < \"$tmp_mailfile\""
         } else {
            set mail_args "-s \"max mail count reached\" \"$address\" < \"$tmp_mailfile\""
         }
         start_remote_prog $CHECK_MAILX_HOST "ts_def_con_mail" "mailx" "$mail_args" prg_exit_state 60 0 "" "" 1 0 
         set CHECK_ENABLE_MAIL 0
      }  
   }
 
   file delete $tmp_mailfile 
}




#                                                             max. column:     |
#****** check/set_error() ******
# 
#  NAME
#     set_error -- set error for current check 
#
#  SYNOPSIS
#     set_error { erno errtext } 
#
#  FUNCTION
#     *** deprecated ***
#
#     This procedure simply sets the global variables check_errno and 
#     check_errstr to the given parameters. Beyond it the procedure 
#     add_proc_error is called in order to append the errors to the global error 
#     list.
#
#  INPUTS
#     erno    - integer
#               0  = no error
#               -1 = error, but the check will run till end
#               -2 = error, the current check will stop (no further check function
#                    is called)
#               -3 = warning, (e.g. test can not run on this host)
#
#     errtext - short error description
#
#
#  EXAMPLE
#     set_error 0 "ok"  ;# Test is "OK"
#
#  SEE ALSO
#     check/add_proc_error
#*******************************
proc set_error {errno errtext} {
   global CHECK_OUTPUT CHECK_CUR_PROC_NAME

   puts $CHECK_OUTPUT "-------------------------------------------------------------------"
   puts $CHECK_OUTPUT "deprecated function set_error called from \"$CHECK_CUR_PROC_NAME\""
   puts $CHECK_OUTPUT "use add_proc_error to report errors, remove calls \"set_error 0 ...\""
   puts $CHECK_OUTPUT "-------------------------------------------------------------------"

   add_proc_error "set_error" $errno $errtext

   return $errno
}

#****** check/get_testsuite_root_dir_from_file() *******************************
#  NAME
#     get_testsuite_root_dir_from_file() -- get testsuite root directory
#
#  SYNOPSIS
#     get_testsuite_root_dir_from_file { filename } 
#
#  FUNCTION
#     This procedure greps for the testsuite configuration in the given file.
#     It only returns the testsuite root directory. This function is used
#     to setup the ts_config(testsuite_root_dir) variable before sourcing the
#     file procedures script in the tcl_directory.
#
#  INPUTS
#     filename - path to testsuite configuration file (defaults file)
#
#  RESULT
#     testsuite root directory path
#
#  SEE ALSO
#     check/setup2
#*******************************************************************************
proc get_testsuite_root_dir_from_file { filename } {

   if { [file isfile $filename] != 1 } {
      return "no_such_file" 
   }
   set file [open $filename "r"]
   set found_object 0
   set next 0
   while { [gets $file line] >= 0 } {
      if { $next == 1 } {
         break
      }
      if { [ string first "OBJ_START:testsuite configuration:" $line] >= 0 } { 
         set found_object 1
      }
      if { [ string first ":testsuite_root_dir:" $line] >= 0 && $found_object == 1 } {
         set next 1
      }
   }
   if { $next == 1 } {
      set start [ string first ":" $line ]
      set end   [ string last ":" $line ]   
      incr start 1
      incr end -1
      return [string range $line $start $end]
   } 
   close $file
   return "testsuite_root_dir_not_found"
}

#                                                             max. column:     |
#****** check/edit_defaults() ******
# 
#  NAME
#     edit_defaults -- ??? 
#
#  SYNOPSIS
#     edit_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc edit_defaults {} {
  global CHECK_OUTPUT CHECK_DEFAULTS_FILE CHECK_CONFIG_DIR
  global env

  load_defaults
  set return_value -1
  if { [ write_edit_defaults_file "/tmp/testsuite_tmp_defaults_file" ] != 0 } {
     puts $CHECK_OUTPUT "error open file \"$def_edit_file\" for writing"
     return -1
  }
  set local_host [gethostname]

  puts $def_edit_file
  set exit_edit_loop 0
  while { $exit_edit_loop == 0 } {
     if { $CHECK_CONFIG_DIR != "" } {
        set vim_binary [get_binary_path $local_host "vim"]
     } else {
        puts $CHECK_OUTPUT "config directory path not set ..."
        set env_variable "EDITOR"
        puts $CHECK_OUTPUT "checking for $env_variable environment setting..."
        if { [info exists env($env_variable)] } {
           puts $CHECK_OUTPUT "$env_variable=$env($env_variable)"
           set vim_binary $env($env_variable)
           puts $CHECK_OUTPUT "using environment $env_variable"
        } else {
           puts $CHECK_OUTPUT "environment $env_variable not set, using default"
           set vim_binary "vim"
        }
        set catch_return [ catch { eval exec which $vim_binary } catch_value ]
        puts $CHECK_OUTPUT "exec \"which $vim_binary\" returns: $catch_return"
        if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "error executing \"which $vim_binary\"!!!"
        } else {
           set vim_binary $catch_value
        }
        if { [file exists $vim_binary] != 1 } {
           puts $CHECK_OUTPUT "could not find binary"
           puts $CHECK_OUTPUT "$vim_binary"
           exit 1
        }
        puts $CHECK_OUTPUT "using \"$vim_binary\" as editor"
     }
     set env(EDITOR) $vim_binary
     set id [ open_spawn_process $vim_binary "$def_edit_file" ]
     interact -o -i [lindex $id 1]
     set exit_state [ close_spawn_process $id ]

     if { $exit_state == 0 } {
        set read_return [ read_edit_defaults_file "$def_edit_file" ] 
        if { $read_return >= 0 } { 
           if { $read_return == 0 } {
              puts $CHECK_OUTPUT "no changes"
              set return_value 1
              set exit_edit_loop 1
           } else {
              puts $CHECK_OUTPUT "$read_return changes in defaults file \"$CHECK_DEFAULTS_FILE\""
              set return_value 0
              set exit_edit_loop 1
           }
        } else {
           puts $CHECK_OUTPUT "error reading file \"$def_edit_file\""
           puts $CHECK_OUTPUT "\n>> press CTRL-C to abort setup configuration!"
           wait_for_enter
        }
     }
  }
  if { [ string first "/tmp/testsuite_tmp_defaults_file" $def_edit_file ] >= 0 } {
     file delete $def_edit_file
     puts $CHECK_OUTPUT "file \"$def_edit_file\" deleted!" 
  }
  return $return_value 
}

#                                                             max. column:     |
#****** check/calc_space() ******
# 
#  NAME
#     calc_space -- ??? 
#
#  SYNOPSIS
#     calc_space { space name } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     space - ??? 
#     name  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc calc_space {space name} {

  set length [ string length $name ]
  set spaces [ expr ( $space - $length )  ]
  set back ""
  for {set i 0} { $i < $spaces} { incr i 1} {
     set back "$back "
  }
  return $back
}

proc get_local_hostname {} {
   global env CHECK_OUTPUT 
   set catch_return [ catch { exec "hostname" } result ]
   if { $catch_return == 0 } {
      set result [split $result "."]
      set newname [lindex $result 0]
      puts $CHECK_OUTPUT "got hostname: \"$newname\""
      return $newname
   } else {
      puts $CHECK_OUTPUT "local hostname error or binary not found"
      puts $CHECK_OUTPUT "error: $result"
      puts $CHECK_OUTPUT "error: $catch_return"
      puts $CHECK_OUTPUT "trying local HOST environment variable ..."
      if { [ info exists env(HOST) ] } {
         set result [split $env(HOST) "."]
         set newname [lindex $result 0]
         if { [ string length $newname ] > 0 } {
             puts $CHECK_OUTPUT "got hostname_ \"$newname\""
             return $newname
         } 
      }
   }
   puts $CHECK_OUTPUT "tcl procedure get_local_hostname() can't get local hostname"
   puts $CHECK_OUTPUT "please set check if binary \"hostname\" is in path or"
   puts $CHECK_OUTPUT "set the environment variable \"HOST\" to the hostname value"
   exit 1
   return "unknown"
}

#****** check/check_executable_files() *****************************************
#  NAME
#     check_executable_files() -- check if testsuite files are executable
#
#  SYNOPSIS
#     check_executable_files { } 
#
#  FUNCTION
#     testsuite setup
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc check_executable_files {  } {
   global CHECK_OUTPUT
   global ts_config

   set scripts_dir "$ts_config(testsuite_root_dir)/scripts"
   set filelist ""
   set shell_filelist [get_file_names $scripts_dir "*.sh"]
   set cshell_filelist [get_file_names $scripts_dir "*.csh"]
   set tcl_filelist [get_file_names $scripts_dir "*.tcl"]
   
   foreach file $shell_filelist {
      lappend filelist "$scripts_dir/$file"
   }
   foreach file $cshell_filelist {
      lappend filelist "$scripts_dir/$file"
   }
   foreach file $tcl_filelist {
      lappend filelist "$scripts_dir/$file"
   }
   lappend filelist "$ts_config(checktree_root_dir)/api/drmaaj/sleeper.sh"
   lappend filelist "$ts_config(checktree_root_dir)/bugs/issuezilla/126/sleep.sh"
   lappend filelist "$ts_config(checktree_root_dir)/bugs/issuezilla/1334/jobstarter.sh"
   lappend filelist "$ts_config(checktree_root_dir)/bugs/issuezilla/1489/infinity.sh"
   lappend filelist "$ts_config(checktree_root_dir)/bugs/issuezilla/1489/termtest.sh"
   lappend filelist "$ts_config(checktree_root_dir)/bugs/issuezilla/1556/1556.sh"
   lappend filelist "$ts_config(checktree_root_dir)/functional/migration/checkpt_job.sh"
   lappend filelist "$ts_config(checktree_root_dir)/functional/migration/migrate.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qmake/echo_variable.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qmod/general/qmod_job.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qrsh/qsub_gid.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qrsh/sleep_pid.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qrsh/starter.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qrsh/terminate.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qrsh/trap.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qrsh/ulimit.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qsub/starter.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qsub/sleeper.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qtcsh/qtask_global.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/clients/qtcsh/qtask_local.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/qmaster/size/pminiworm.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/qmaster/size/flood_sleeper.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/qmaster/size/qstat.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/qmaster/size/redir_stderr.sh"
   lappend filelist "$ts_config(checktree_root_dir)/system_tests/qmaster/size/sge_start.sh"
   lappend filelist "$ts_config(source_dir)/aimk"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/array_submitter.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/env-tester.csh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/jobnet_submitter.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/pminiworm.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/simple.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/sleeper.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/step_A_array_submitter.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/step_B_array_submitter.sh"
   lappend filelist "$ts_config(source_dir)/dist/examples/jobs/worker.sh"
   
   set change_files ""


   set file_error 0
   foreach elem $filelist {
      set filename $elem
      if { [ file isfile $filename ] != 1  } {
         puts $CHECK_OUTPUT "file not found: $filename"
         set file_error 1
         continue
      }
      set attribs [ file attributes $filename -permissions] 
      if { [ string compare $attribs "00755" ] != 0 } {
         puts $CHECK_OUTPUT "file not executable (attributes: $attribs):\n $filename"
         lappend change_files $filename
         set file_error 1
         continue
      }
   }

   if { $file_error != 0 } {
      while { 1 } {
         puts $CHECK_OUTPUT "should I set the file permissions to 00755? (yes/no)"
         set answer [wait_for_enter 1]
         if { [ string compare $answer "yes" ] == 0 } {
            foreach elem $change_files {
                catch { file attributes $elem -permissions 00755 }
                set attribs [ file attributes $elem -permissions] 
                if { [ string compare $attribs "00755" ] != 0  } {
                   puts $CHECK_OUTPUT "check_executable_files - error setting file permissions: $elem"
                   exit -1
                }
            }  
            break
         } 
         if { [ string compare $answer "no" ] == 0 } {
            puts $CHECK_OUTPUT "check_executable_files - file errors. exit."
            exit -1
         } 
         puts $CHECK_OUTPUT "please enter \"yes\" or \"no\"!"
      }
   }
}

#****** check/set_users_environment() ******************************************
#  NAME
#     set_users_environment() -- setup user and l10n environment
#
#  SYNOPSIS
#     set_users_environment { host {variable_name env} { show_variables 0 } } 
#
#  FUNCTION
#     This procedure is used to generate the users environment for the
#     local environment and for the create_shell_script() procedure.
#
#  INPUTS
#     host                 - hostname (used for l10n)
#     {variable_name env}  - variable to store environment
#     { show_variables 0 } - if 1: print setting info
#
#  SEE ALSO
#     file_procedures/create_shell_script()
#*******************************************************************************
proc set_users_environment { node {variable_name env} { show_variables 0 } } {
   global CHECK_REMOTE_ENVIRONMENT CHECK_OUTPUT env 
   global CHECK_L10N ts_host_config
   global ts_config

   upvar $variable_name environment

   set host [node_get_host $node]

   set remote_environment $CHECK_REMOTE_ENVIRONMENT

   if { $CHECK_L10N == 0 && [llength $remote_environment] == 0 } {
      return 0
   }

   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   if { $CHECK_L10N != 0 } {
      set locale $ts_config(l10n_test_locale)
      if { [ info exist ts_host_config($host,${locale}_locale) ] != 1 } {
         if { [set pos [ string first $ts_config(dns_domain) $host]] >= 0 } {
            if { $ts_config(dns_for_install_script) == "none" } {
                incr pos -2
                set host [ string range $host 0 $pos ]
            }
         }
      }

      if { [ info exist ts_host_config($host,${locale}_locale) ] } {
         set locale_env $ts_host_config($host,${locale}_locale)
         if { $locale_env == "" } {
            debug_puts "no value for ${locale}_locale on host $host, please set LANG, LC_MESSAGES ..."
         }
         append locale_env " SGE_ENABLE_MSG_ID=2 SGE_INFOTEXT_MAX_COLUMN=5000"
         debug_puts "L10N enabled"
         debug_puts "locale = \"$locale\""
         debug_puts "environment on host $host: $locale_env"
         foreach u_env $locale_env {
            debug_puts "environment: $u_env"
            set help [split $u_env "="]
            set env_name  [lindex $help 0]
            set env_value [lindex $help 1]
            debug_puts "env_name: $env_name"
            if { [string compare $env_name ""] == 0 } {
               puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
               return -1
            }
            debug_puts "env_value: $env_value"
            if { [string compare $env_value ""] == 0 } {
               if { [info exists env($env_name)] } {
                  set env_value $env($env_name)
               } else {
                  puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
                  return -1
               }
            }
            if { [string compare $variable_name "env"] == 0 } {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting local l10n variable $env_name=\"$env_value\""
               }
            } else {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting remote l10n variable $env_name=\"$env_value\""
               }
            }
            set environment($env_name) $env_value 
            debug_puts "$env_name set to \"$env_value\""
         }
      } else {
         debug_puts "could not find l10n configuration for host $host"
      }
   }

   foreach u_env $remote_environment {
      debug_puts "environment: $u_env"
      set help [split $u_env "="]
      set env_name  [lindex $help 0]
      set env_value [lindex $help 1]
      debug_puts "env_name: $env_name"
      if { [string compare $env_name ""] == 0 } {
         puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
         return -1
      }
      debug_puts "env_value: $env_value"
      if { [string compare $env_value ""] == 0 } {
         if { [info exists env($env_name)] } {
            set env_value $env($env_name)
         } else {
            puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
            return -1
         }
      }
      if { [string compare $variable_name "env"] == 0 } {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting local variable $env_name=\"$env_value\""
         }
      } else {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting remote variable $env_name=\"$env_value\""
         }
      }
      set environment($env_name) $env_value 
      debug_puts "$env_name set to \"$env_value\""
   }
   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   return 0
}

proc show_setup_information { } {

   global CHECK_OUTPUT

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "If you are starting the testsuite for the first time you should read this short"
   puts $CHECK_OUTPUT "setup guide to make it easier for you to understand the setup questions."
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The testsuite needs 3 user accounts:\n"
   puts $CHECK_OUTPUT " a) testsuite user:   The user who is starting the testsuite\n"
   puts $CHECK_OUTPUT " b) first_foreign_system_username:  "
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of two system groups (use <SPACE>"
   puts $CHECK_OUTPUT "                      to seperate the groups)\n"
   puts $CHECK_OUTPUT " c) second_foreign_system_username:"
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of a system group where b) is not"
   puts $CHECK_OUTPUT "                      group member.\n"
 
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The 3 user accounts must have rlogin access to the cluster hosts. (.rhost file)\n"
   puts $CHECK_OUTPUT "Every output to stdout in\n"
   puts $CHECK_OUTPUT " /etc/csh.cshrc, /etc/csh.login, \$HOME/.cshrc, \$HOME/.login , ...\n"
   puts $CHECK_OUTPUT "is not allowed. The testsuite will use e.g. rlogin \$EXEC_HOST pwd to get the"
   puts $CHECK_OUTPUT "working directory on that host. Any output made in the files would influence"
   puts $CHECK_OUTPUT "the result of the call.\n" 

   puts $CHECK_OUTPUT "Each of the 3 user must have read access to\n"
   puts $CHECK_OUTPUT "   - testsuite directory"
   puts $CHECK_OUTPUT "   - source code directory"
   puts $CHECK_OUTPUT "   - installation directory (\$SGE_ROOT)"   
  
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "All path statements have to be absolute. The use of links may cause troubles."
    
   wait_for_enter
}


#****** check/save_host_configuration() ****************************************
#  NAME
#     save_host_configuration() -- save host configuration
#
#  SYNOPSIS
#     save_host_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual host configuration to the given
#     file. (ts_host_config array)
#
#  INPUTS
#     file - host configuration file
#
#  SEE ALSO
#     check/save_user_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_host_configuration { file } {
   global ts_host_config
   global CHECK_OUTPUT

   set conf_name "testsuite host configuration"

   if { [ info exists ts_host_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $file $conf_name old_host_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_host_config
   spool_array_to_file $file $conf_name ts_host_config  
   puts $CHECK_OUTPUT "new host configuration saved: version: $ts_host_config(version)"
   wait_for_enter
   return 0
}

#****** check/save_user_configuration() ****************************************
#  NAME
#     save_user_configuration() -- save user configuration file
#
#  SYNOPSIS
#     save_user_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual user configuration to the given
#     file. (ts_user_config array)
#
#  INPUTS
#     file - user configuration file
#
#  SEE ALSO
#     check/save_host_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_user_configuration { file } {
   global ts_user_config
   global CHECK_OUTPUT

   if { [ info exists ts_user_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }


   set conf_name "testsuite user configuration"
   # first get old configuration
   read_array_from_file  $file $conf_name old_user_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_user_config
   spool_array_to_file $file $conf_name ts_user_config  
   
   puts $CHECK_OUTPUT "new user configuration saved"
   wait_for_enter

   return 0
}


#****** check/save_configuration() *********************************************
#  NAME
#     save_configuration() -- save testsuite configuration (ts_config array)
#
#  SYNOPSIS
#     save_configuration { } 
#
#  FUNCTION
#     This procedure will save the actual ts_config array settings to the
#     testsuite setup file.
#
#  SEE ALSO
#     check/restore_configuration()
#*******************************************************************************
proc save_configuration {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE
   global pe_for_version_check_result

   set conf_name "testsuite configuration"

   if { [ info exists ts_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE $conf_name old_config
   # save old configuration 
   spool_array_to_file $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name ts_config  
   puts $CHECK_OUTPUT "new testsuite configuration saved"

   set pe_for_version_check_result "undefined"

   wait_for_enter

   return 0
}

#****** check/restore_configuration() ******************************************
#  NAME
#     restore_configuration() -- restore old testsuite configuration
#
#  SYNOPSIS
#     restore_configuration { } 
#
#  FUNCTION
#     This procedure can be used to get the previous testsuite configuration
#
#  SEE ALSO
#     check/save_configuration()
#*******************************************************************************
proc restore_configuration { } {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE

   set conf_name "testsuite configuration"

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   if { [ info exists old_config(version) ] } {
      puts $CHECK_OUTPUT "spooling previous configuration (Version: $old_config(version)"
      spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name old_config
   } else {
      puts $CHECK_OUTPUT "no previous configuration available!"
   }
   puts $CHECK_OUTPUT "reading latest configuration ..."
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name" ts_config

   return 0
}


#****** check/get_configuration_element_name_on_pos() **************************
#  NAME
#     get_configuration_element_name_on_pos() -- return config elem name on pos
#
#  SYNOPSIS
#     get_configuration_element_name_on_pos { config_array config_pos } 
#
#  FUNCTION
#     This procedure returns the name of the configuration element on the
#     given position.
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#     config_pos   - pos number
#
#  SEE ALSO
#     check/get_configuration_element_count()
#*******************************************************************************
proc get_configuration_element_name_on_pos { config_array config_pos } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) == $config_pos } {
         return $elem
      }
   }
   return ""
}



#****** check/get_configuration_element_count() ********************************
#  NAME
#     get_configuration_element_count() -- returns number of conig elements
#
#  SYNOPSIS
#     get_configuration_element_count { config_array } 
#
#  FUNCTION
#     This procedure returns the config parameter count for one of the testsuite
#     setup arrays (ts_config, ts_host_config, ts_user_config)
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#
#  SEE ALSO
#     check/get_configuration_element_name_on_pos()
#*******************************************************************************
proc get_configuration_element_count { config_array } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) > $max_pos } {
         set max_pos $config($elem,pos)
      }
   }
   return $max_pos
}


#****** check/update_ts_config_version() ***************************************
#  NAME
#     update_ts_config_version() -- used for version update of ts_config
#
#  SYNOPSIS
#     update_ts_config_version { } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite configuration
#     are not equal.
#
#  SEE ALSO
#     check/update_ts_host_config_version()
#*******************************************************************************
proc update_ts_config_version {} {
   global actual_ts_config_version 
   global ts_config
   global CHECK_OUTPUT

   if {[string compare $ts_config(version) "1.0"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.0 to 1.1 ..."
      config_build_ts_config_1_1
      show_config ts_config
      wait_for_enter
   }

   if {[string compare $ts_config(version) "1.1"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.1 to 1.2 ..."
      config_build_ts_config_1_2
      show_config ts_config
      wait_for_enter
   }

   if {[string compare $ts_config(version) "1.2"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.2 to 1.3 ..."
      config_build_ts_config_1_3
      show_config ts_config
      wait_for_enter
   }
   
   if {[string compare $ts_config(version) "1.3"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.3 to 1.4 ..."
      config_build_ts_config_1_4
      show_config ts_config
      wait_for_enter
   }
   
   if {[string compare $ts_config(version) "1.4"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.4 to 1.5 ..."
      config_build_ts_config_1_5
      show_config ts_config
      wait_for_enter
   }
   
   if {[string compare $ts_config(version) "1.5"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.5 to 1.6 ..."
      config_build_ts_config_1_6
      show_config ts_config
      wait_for_enter
   }
  
   if {[string compare $ts_config(version) "1.6"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.6 to 1.7 ..."
      config_build_ts_config_1_7
      show_config ts_config
      wait_for_enter
   }

   if {[string compare $ts_config(version) "1.7"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.7 to 1.8 ..."
      config_build_ts_config_1_8
      show_config ts_config
      wait_for_enter
   }

   if {[string compare $ts_config(version) "1.8"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.8 to 1.9 ..."
      config_build_ts_config_1_9
      show_config ts_config
      wait_for_enter
   }

   if {[string compare $ts_config(version) "1.9"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.9 to 1.91 ..."
      config_build_ts_config_1_91
      show_config ts_config
      wait_for_enter
   }
   
   if {[string compare $ts_config(version) "1.91"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.91 to 1.10 ..."
      config_build_ts_config_1_10
      show_config ts_config
      wait_for_enter
   }
   
   if {[string compare $ts_config(version) "1.10"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.10 to 1.11 ..."
      config_build_ts_config_1_11
      show_config ts_config
      wait_for_enter
   }

   if {[string compare $ts_config(version) "1.11"] == 0} {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.11 to 1.12 ..."
      config_build_ts_config_1_12
      show_config ts_config
      wait_for_enter
      return 0
   }
   
   puts $CHECK_OUTPUT "\nunexpected version $ts_config(version), need version $actual_ts_config_version"
   return -1
}

#****** check/get_spaces() *****************************************************
#  NAME
#     get_spaces() -- return string with given number of spaces 
#
#  SYNOPSIS
#     get_spaces { nr } 
#
#  FUNCTION
#     This procedure returns a string with the given number of spaces
#
#  INPUTS
#     nr - nr of spaces in string
#
#  RESULT
#     string with given number of spaces
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc get_spaces { nr } {
   set spaces ""
   for { set i 0 } { $i < $nr } { incr i 1 } {
      append spaces " "
   }
   return $spaces
}


#****** check/setup2() *********************************************************
#  NAME
#     setup2() -- testsuite initialization procedure
#
#  SYNOPSIS
#     setup2 { } 
#
#  FUNCTION
#     This procedure is used for testsuite initalization.
#
#  INPUTS
#
#  SEE ALSO
#     check/__setup()
#*******************************************************************************
proc setup2 { } {
   global sge_config
   global ts_config ts_host_config ts_user_config actual_ts_config_version
   global CHECK_OUTPUT CHECK_DO_SETUP
   global CHECK_DEFAULTS_FILE do_nomain
   global env be_quiet fast_setup
   global check_name CHECK_ACT_LEVEL have_defaults
   global CHECK_USER CHECK_CURRENT_WORKING_DIR
   global CHECK_PRODUCT_TYPE
   global CHECK_PRODUCT_VERSION_NUMBER
   global CHECK_COMMD_PORT
   global CHECK_CONFIG_DIR
   global CHECK_MAIN_RESULTS_DIR
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_PROTOCOL_DIR
   global CHECK_USER
   global CHECK_GROUP
   global CHECK_CURRENT_WORKING_DIR
   global CHECK_PACKAGE_DIRECTORY
   global CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS
   global CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME
   global CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST
   global CHECK_REPORT_EMAIL_TO
   global CHECK_REPORT_EMAIL_CC
   global CHECK_SEND_ERROR_MAILS 
   global CHECK_MAX_ERROR_MAILS
 

   # unset old system environment
   if { $be_quiet == 0 } { 
      puts "starting setup ..."
   }
   if { [info exists env(GRD_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting GRD_ROOT"
      }
      unset env(GRD_ROOT)
   }
   if { [info exists env(CODINE_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting CODINE_ROOT"
      }
      unset env(CODINE_ROOT)
   }
   
   # setup check information for error mails
   set check_name "setup"
   set CHECK_ACT_LEVEL "0"
   set have_defaults 0
   set configuration_updated 0

   if {[read_array_from_file $CHECK_DEFAULTS_FILE "testsuite configuration" ts_config ] == 0} {
      if {$ts_config(version) != $actual_ts_config_version} {
         puts $CHECK_OUTPUT "unknown configuration file version: $ts_config(version)"
         while {[update_ts_config_version] != 0} {
            wait_for_enter
         }

         # we have to store it later, after verifying the updated config
         set configuration_updated 1
      }
      # got config
     
      read_array_from_file $ts_config(host_config_file) "testsuite host configuration" ts_host_config
     
      if { [verify_config ts_config 1 err_list] != 0 } {
       
         # configuration problems

         foreach elem $err_list {
            puts "$elem"
         } 
         puts "Press enter to edit setup configurations"
         set answer [wait_for_enter 1]
         set not_ok 1
         while { $not_ok } {
            if { [verify_config ts_config 0 err_list ] != 0 } {
               wait_for_enter
               set not_ok 1
               foreach elem $err_list {
                  puts $CHECK_OUTPUT "error in: $elem"
               } 
               puts $CHECK_OUTPUT "Try again? (y/n)"
               set answer [wait_for_enter 1]
               if { $answer == "n" } {
                  # restore old config ?
                  puts $CHECK_OUTPUT "Do you want to restore previous configuration? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [restore_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error restoring configuration!"
                        exit 1
                     }
                     exit 0
                  }
                  # save anyway
                  puts $CHECK_OUTPUT "Do you want to save your changes? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [save_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error saving configuration!"
                        exit 1
                     }
                  }
                  exit 1
               } 
            } else {
               set not_ok 0
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      } else {
         if { $configuration_updated } {
            puts $CHECK_OUTPUT "Do you want to save the updated configuration? (y/n)"
            set answer [ wait_for_enter 1 ]
            if { $answer == "y" } {
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      }
      set CHECK_CONFIG_DIR "not supported in setup2 config file"
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\nstarting setup ... ok"
      }
      enhanced_setup
      
      if { $CHECK_DO_SETUP == 1 } {
         modify_setup2
      }
      
      unlock_testsuite
   } else {
      puts $CHECK_OUTPUT "could not open defaults file."
      if { [ file isfile $CHECK_DEFAULTS_FILE ] } {
         puts $CHECK_OUTPUT "file exists -> assuming old configuration file!"
         convert_old_defaults_file_to_new_format
         exit -1
      }
      puts $CHECK_OUTPUT "press return to create new configuration file \"$CHECK_DEFAULTS_FILE\""
      wait_for_enter 1 
      if { [save_configuration] != 0 } {
         exit -1
      }
      setup2
   }
}

#****** check/enhanced_setup() *************************************************
#  NAME
#     enhanced_setup() -- addition testsuite setup
#
#  SYNOPSIS
#     enhanced_setup { } 
#
#  FUNCTION
#     Procedure is called at the end of setup2(). Here some additional testsuite
#     setup calls are made.
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc enhanced_setup {} {
   global CHECK_ENABLED_RUNLEVELS
   global CHECK_ENABLED_CATEGORIES CHECK_OUTPUT check_name
   global be_quiet CHECK_PACKAGE_DIRECTORY
   global env CHECK_COMMD_PORT
   global ts_config

   if { $be_quiet == 0 } { 
      puts "   starting enhanced setup (SGE_ROOT=$ts_config(product_root)) ..."
   }
   set check_name "enhanced_setup"
   set local_host [gethostname]

   set env(COMMD_PORT) $CHECK_COMMD_PORT;
   set env(SGE_QMASTER_PORT) $CHECK_COMMD_PORT;
   set env(SGE_EXECD_PORT) [expr ( $CHECK_COMMD_PORT + 1 ) ];
   set env(SGE_ROOT) $ts_config(product_root);
   set env(SGE_CELL) $ts_config(cell)
   set env(SGE_SINGLE_LINE) 1
#   don't enable this without rework of qstat parsing
#   set env(SGE_LONG_QNAMES) 40

   set_users_environment $local_host

# now search for further checktree configurations
# ===============================================

   if { $ts_config(additional_checktree_dirs) != "none" } {
      if { $be_quiet == 0 } { 
         puts "   exploring other checktrees ..."
         foreach dir $ts_config(additional_checktree_dirs) {
            puts "   $dir ..."

         }
      }
   }

   puts "   setting up checktree ..."
   if {[build_checktree] != 0} {
      modify_setup2
      exit 1
   }


   set CHECK_ENABLED_RUNLEVELS "0" ;# 100 200 300 400" ;# max level is 400
   # JG: changed default categories to VERIFIED, reset to SYSTEM, once we get
   #     rid of the VERFIED category (when all tests are verified).
   set CHECK_ENABLED_CATEGORIES "VERIFIED"

   puts "   checking testsuite results directories ..."

   delete_tests "root" 1

   
   puts "   checking all shell scripts to be executable ..."
   check_executable_files
   
   if { $be_quiet == 0 } { 
      puts "   architecture: [resolve_arch $local_host]";
      puts "   local host:   $local_host";
   }

   puts "   reading message macros ..."
   update_macro_messages_list

#
# uncomment the following line, if the unused macros should be removed from source code
# ======================================================================================  
# 
# --   check_c_source_code_files_for_macros
}



proc build_checktree {} {
   global ts_checktree
   global CHECK_OUTPUT ACT_CHECKTREE
   global ts_config
   
   if { [info exists ts_checktree] } {
      unset ts_checktree
   }
   set ts_checktree(act_nr) 1             ;# contains the next free number for a checktree directory element
   
   set ts_checktree(0,dir_name) "root"    ;# set directory name of root element
   set ts_checktree(0,test_available) 0   ;# there is no test available for the directory entry 0
   set ts_checktree(0,upper_nrs) 0        ;# upper_nrs contains the directory number of the parent checktree
                                          ;# directory element
   set ts_checktree(root) 0               ;# maps the directory path to directory number

   # read_checktree_nodes is setting additional information in the checktree !!!
 
   puts $CHECK_OUTPUT "reading checktree nodes ..."  
   set error [read_checktree_nodes $ts_config(checktree_root_dir)] 
   if { $error != 0 } {
      return -1
   }
   puts $CHECK_OUTPUT "reading additional checktrees ..."
   if { $ts_config(additional_checktree_dirs) != "none" } {
      foreach dir $ts_config(additional_checktree_dirs) {
         set error [read_checktree_nodes $dir]
         if { $error != 0 } {
            return -1
         }
         if { [file isfile $dir/checktree.tcl] } {
            puts $CHECK_OUTPUT "source additional file $dir/checktree.tcl"
            set ACT_CHECKTREE $dir
            ts_source $dir/checktree
         } else {
            puts $CHECK_OUTPUT "checktree file $dir/checktree.tcl not found"
         }
      }
   }

   

   puts $CHECK_OUTPUT "verify checktree ..."
   
   for {set i 0} {$i< $ts_checktree(act_nr)} {incr i 1} {
#      puts $CHECK_OUTPUT "test $i $ts_checktree($i,dir_name) , up-dir=$ts_checktree($i,upper_nrs), subdir(s)=$ts_checktree($i,sub_nrs)"
      set ts_checktree($i,max_level_count) [get_max_level_count $ts_checktree($i,dir_name)]
#      puts $CHECK_OUTPUT "dir $ts_checktree($i,dir_name) has max level state: $ts_checktree($i,max_level_count)"
      if { $ts_checktree($i,test_available) == 1 } {
         set ts_checktree($i,check_levels) [get_check_levels $ts_checktree($i,dir_name)]
#         puts $CHECK_OUTPUT "test $ts_checktree($i,check_name) has checklevels: $ts_checktree($i,check_levels)"
#         puts $CHECK_OUTPUT "name $ts_checktree($i,check_name), $ts_checktree($i,check_category), $ts_checktree($i,check_highest_level)"
         for { set j [expr ( $i + 1 ) ] } {$j< $ts_checktree(act_nr)} {incr j 1} {
            if { $ts_checktree($j,test_available) == 1 } {
               if { $ts_checktree($i,check_name) == $ts_checktree($j,check_name) } {
                  set error_text ""
                  append error_text "check_name \"$ts_checktree($i,check_name)\" is not unique:\n"
                  append error_text "please check the following tests directories:\n"
                  append error_text "$ts_checktree($i,dir_name)\n"
                  append error_text "$ts_checktree($j,dir_name)\n" 
                  add_proc_error "build_checktree" -1 $error_text
                  wait_for_enter
                  return -1
               }
               if { $ts_checktree($i,check_init_level_procedure) != "--" && 
                    $ts_checktree($i,check_init_level_procedure) == $ts_checktree($j,check_init_level_procedure) } {
                  set error_text ""
                  append error_text "check_init_level_procedure \"$ts_checktree($i,check_init_level_procedure)\" is not unique:\n"
                  append error_text "please check the following tests directories:\n"
                  append error_text "$ts_checktree($i,dir_name)\n"
                  append error_text "$ts_checktree($j,dir_name)\n" 
                  add_proc_error "build_checktree" -1 $error_text
                  wait_for_enter
                  return -1
               }
            }
         }

      }
      
   }
   
   # read configurations of the checktree

   for {set i 0} { $i < $ts_checktree(act_nr)} {incr i 1 } {
      for {set ii 0} {[info exists ts_checktree($i,setup_hooks_${ii}_name)]} {incr ii 1} {
         
         if { [info exists ts_checktree($i,setup_hooks_${ii}_filename)] == 0 } {
            add_proc_error "build_checktree" -1 "field setup_hooks_${ii}_filename not defined for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
            wait_for_enter
            return -1
         }
         
         set filename $ts_checktree($i,setup_hooks_${ii}_filename)
         
         set config_array $ts_checktree($i,setup_hooks_${ii}_config_array)
         
         global $config_array

         if { [file exists $filename] == 0 } {
            
            puts $CHECK_OUTPUT "file \"$filename\" for \"$ts_checktree($i,setup_hooks_${ii}_name)\" not found."
            puts $CHECK_OUTPUT "creating new configuration ..."
            wait_for_enter
            
            $ts_checktree($i,setup_hooks_${ii}_init_func) $config_array
            
            while { 1 } {
               # initialize the config
               set error_list {}
               set res [$ts_checktree($i,setup_hooks_${ii}_verify_func) $config_array 0 error_list]
               if { $res == 0 } {
                  break
               } 
               if { $res < 0 } {
                  add_proc_error "build_checktree" -1 "Can not verify config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
                  wait_for_enter
                  return -1
               }
               puts $CHECK_OUTPUT "Errors in configuration => retry"
               wait_for_enter
            }
            spool_array_to_file $filename $ts_checktree($i,setup_hooks_${ii}_name) $config_array
         } else {
           
           # file exists => read it
            if { [read_array_from_file $filename $ts_checktree($i,setup_hooks_${ii}_name) $config_array] == 0 } {
               set res [$ts_checktree($i,setup_hooks_${ii}_verify_func) $config_array 1 error_list]
               if { $res < 0 } {
                  add_proc_error "build_checktree" -1 "Can not verify config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
                  wait_for_enter
                  return -1
               } 
               if { $res > 0 } {
                  puts $CHECK_OUTPUT "Configuration $ts_checktree($i,setup_hooks_${ii}_name) has errors => retry"
                  wait_for_enter
                  while { 1 } {
                     set error_list {}
                     set res [$ts_checktree($i,setup_hooks_${ii}_verify_func) $config_array 0 error_list]
                     if { $res == 0 } {
                        spool_array_to_file $filename $ts_checktree($i,setup_hooks_${ii}_name) $config_array
                        break
                     } 
                     if { $res < 0 } {
                        add_proc_error "build_checktree" -1 "Can not verify config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
                        wait_for_enter
                        return -1
                     }
                  }
               }
            } else {
               add_proc_error "build_checktree" -1 "Can't read config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
               wait_for_enter
               return -1
            }
         }
      }
   }
#   puts $CHECK_OUTPUT "roots: $ts_checktree(0,sub_nrs)"
   return 0
}


proc read_checktree_nodes { path } {
   global ts_checktree CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT
   global CHECK_OUTPUT
   global check_highest_level check_init_level_procedure check_name
   global check_category 
   global CHECK_ACT_LEVEL DISABLE_ADD_PROC_ERROR

   # remember last check name - we'll reset to it on function exit
   set old_check_name $check_name

   # every checktree directory gets an individual number
   set nr $ts_checktree(act_nr)
   incr ts_checktree(act_nr) 1

   # prepare for sourceing check.exp files
   set check_highest_level 0 
   set check_init_level_procedure "--"
   set check_category ""

   # try to find and source check files in this directory for the configured N1GE version
   set sourced_files [ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT]

   # if there is a check in this directory, remember some information
   if {$sourced_files > 0} {
      # here is a test file
      set ts_checktree($nr,test_available) 1

      for { set lt 0 } { $lt <= $check_highest_level } { incr lt 1 } {
         if { [info exists check_description($lt)] } {
            if { [string match "*\n*" $check_description($lt)] } {
               puts $CHECK_OUTPUT "--------------------------------------------------------------"
               puts $CHECK_OUTPUT "check directory: $path"
               puts $CHECK_OUTPUT "description($lt): \"$check_description($lt)\""
               puts $CHECK_OUTPUT "PANIC: check \"$check_name\" contains unexpected new line characters in check description!"
               puts $CHECK_OUTPUT "--------------------------------------------------------------"
               exit 1
            }
         }
      }

      set ts_checktree($nr,check_name) $check_name
      set ts_checktree($nr,check_init_level_procedure) $check_init_level_procedure
      set ts_checktree($nr,check_highest_level) $check_highest_level
      set ts_checktree($nr,check_category) $check_category
   } else {
      set ts_checktree($nr,test_available) 0
   }
   set ts_checktree($nr,dir_name) $path
   set ts_checktree($path)        $nr
   

   if {[info exists ts_checktree($nr,sub_nrs)] == 0} {   ;# ts_checktree($nr,sub_nrs) contains the 
      set ts_checktree($nr,sub_nrs) {}                   ;# list of numbers of subdirectories checktree elements
   }
   set upper_dir [file dirname $path]
   if { [info exists ts_checktree($upper_dir) ] } {
      set ts_checktree($nr,upper_nrs) $ts_checktree($upper_dir)
   } else {
      set ts_checktree($nr,upper_nrs) 0
      lappend ts_checktree(0,sub_nrs) $nr               ;# this is for the "root" element. Additional checktree
                                                        ;# directories are children of the "root" tree. The sub_nr
                                                        ;# can't be initalized by the directory list.
   }

   # recursive call on subdirectories
   set dirs [get_dir_names $path]
   foreach element $dirs {
      read_checktree_nodes "$path/$element"
      lappend ts_checktree($nr,sub_nrs) $ts_checktree($path/$element)
   }
  
   # stay in directory of former check
   set check_name $old_check_name
   return 0
}

proc get_tests_from_checktree { { path "root" } } {
   global ts_checktree CHECK_OUTPUT

   set selected_dirs ""

   if { [info exists ts_checktree($path)] } {
     set selected_dirs $ts_checktree($path)
   } else {
     add_proc_error "get_tests_from_checktree" -1 "path=$path not found in checktree"
   }


   set all_nrs {}
   foreach nr $selected_dirs {
      lappend all_nrs $nr

      set ret_val {}
      lappend_sub_nrs_from_checktree $nr ret_val
      foreach sub_nr $ret_val {
         lappend all_nrs $sub_nr
      }
   }
   
   # now we have all directory numbers, generate path list
   set path_list {}
   foreach nr $all_nrs {
      if { $ts_checktree($nr,test_available) == 1 } {
         lappend path_list $ts_checktree($nr,dir_name)
      }
   }
   return $path_list
}

proc lappend_sub_nrs_from_checktree { dir_nr result } {
   global ts_checktree CHECK_OUTPUT
   upvar $result res
 
   foreach nr $ts_checktree($dir_nr,sub_nrs) {
      lappend res $nr
      lappend_sub_nrs_from_checktree $nr res
   }
}


proc get_checktree_dir_names { path { only_basename 0 } } {
   global ts_checktree CHECK_OUTPUT

   # first find entry directory numbers
   set selected_dirs {}
   if { [info exists ts_checktree($path)] } {
     set nr $ts_checktree($path)
     set selected_dirs $ts_checktree($nr,sub_nrs)
   } else {
     add_proc_error "get_tests_from_checktree" -1 "path=$path not found in checktree"
   }

   # now we have all directory numbers, generate path list
   set path_list {}
   foreach nr $selected_dirs {
      if { $only_basename == 0 } {
         lappend path_list $ts_checktree($nr,dir_name)
      } else {
         lappend path_list [file tail $ts_checktree($nr,dir_name)]
      }
   }
   return $path_list

}




# check dependencies
#                                                             max. column:     |
#****** check/validate_needs() ******
# 
#  NAME
#     validate_needs -- ??? 
#
#  SYNOPSIS
#     validate_needs { needs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     needs - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc validate_needs {needs} {
  global CHECK_RESULT_DIR CHECK_OUTPUT

  if {$needs == ""} {
     return 0;
  } 

  set uncomplete 0;

  foreach elem $needs {

    set result_files ""
    set core_result_files ""
    catch { set result_files [glob "$CHECK_RESULT_DIR/$elem.res.*"] }

    debug_puts $result_files

    debug_puts " validate_needs: matching files in $CHECK_RESULT_DIR: $result_files"

    if {![file isfile [lindex $result_files 0]]} {
       debug_puts " validate_needs: need to run check $elem.";
       incr uncomplete 1; 
    }
  }

  if {$uncomplete == 0} {
    return 0;
  }
  return -1;
}

#                                                             max. column:     |
#****** check/delete_result() ******
# 
#  NAME
#     delete_result -- ??? 
#
#  SYNOPSIS
#     delete_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_result {path runtime level} {
   save_result $path $runtime $level 0
}

#****** check/clear_all_check_errors() *****************************************
#  NAME
#     clear_all_check_errors() -- clear errors for one specific check
#
#  SYNOPSIS
#     clear_all_check_errors { check_name } 
#
#  FUNCTION
#     The testsuite framework stores all errors showing up while running 
#     a specific test.
#     Before starting a test, the error information will be cleared 
#     with this function.
#
#  INPUTS
#     check_name - name of the current check
#*******************************************************************************
proc clear_all_check_errors {check_name} {
   global CHECK_OUTPUT
   global check_errno check_errstr

   if {[info exists check_errno]} {
      unset check_errno
      unset check_errstr
   }

   set functions [get_all_check_functions]
   foreach function $functions {
      set check_errno($function) {}
      set check_errstr($function) {}
      lappend check_errno($function) 0
      lappend check_errstr($function) "any|$check_name|any|was never running"
   }
}

#****** check/get_all_check_functions() ****************************************
#  NAME
#     get_all_check_functions() -- get list of all check functions
#
#  SYNOPSIS
#     get_all_check_functions { } 
#
#  FUNCTION
#     Returns a list of all functions being part of a specific test.
#     This is:
#        - the setup and cleanup functions
#        - the setup and cleanup per level functions
#        - the check functions
#
#  RESULT
#     List of function names.
#*******************************************************************************
proc get_all_check_functions {} {
   global check_functions
   global check_setup_function check_cleanup_function 
   global check_setup_level_function check_cleanup_level_function

   set functions {}

   if {[info exists check_setup_function] && $check_setup_function != ""} {
      lappend functions $check_setup_function
   }
   if {[info exists check_setup_level_function] && $check_setup_level_function != ""} {
      lappend functions $check_setup_level_function
   }

   if {[info exists check_functions]} {
      foreach function $check_functions {
         lappend functions $function
      }
   }

   if {[info exists check_cleanup_level_function] && $check_cleanup_level_function != ""} {
      lappend functions $check_cleanup_level_function
   }
   if {[info exists check_cleanup_function] && $check_cleanup_function != ""} {
      lappend functions $check_cleanup_function
   }

   return $functions
}

#                                                             max. column:     |
#****** check/save_result() ******
#  NAME
#     save_result -- save result of a check run
#
#  SYNOPSIS
#     save_result { path runtime level } 
#
#  FUNCTION
#     Saves the result of a run of a certain check in a certain runlevel
#     to a file.
#     Results of finished checks are stored in the directory 
#     <results_dir>/<host>.completed, unfinished (failed or not yet run) in
#     <results_dir>/<host>.uncompleted.
#
#  INPUTS
#     path    - path of the check to save
#     runtime - runtime of check
#     level   - the runlevel
#     save_finished - has the check finished, or not?
#*******************************
proc save_result {path runtime level {save_finished 1}} {
   global check_name check_description check_needs check_errno check_errstr 
   global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
   global CHECK_OUTPUT check_highest_level

   # only for supported levels
   if {[is_level_enabled $level] == -1} {
      debug_puts "\n--> save_result - info: test level $level not activated, aborting\n"
      return
   }

   # only for activated categories
   if {[is_category_enabled $path] == -1} {
     debug_puts "\n--> save_result - info: category not activated, aborting\n"
     return
   }
  
   set good_dir $CHECK_RESULT_DIR
   set bad_dir  $CHECK_BAD_RESULT_DIR

   debug_puts "saving results for $check_name (level $level)..."
   debug_puts $good_dir
   debug_puts $bad_dir

   # decide, which in which directory to store, in which to delete
   if {$save_finished} {
      set save_dir   $good_dir
      set delete_dir $bad_dir
   } else {
      set save_dir   $bad_dir
      set delete_dir $good_dir
   }

   # build a test description
   set data {}
   lappend data $path
   lappend data $check_name;
   lappend data $check_description($level)
   lappend data $check_needs

   # dump data per check_function
   set functions [get_all_check_functions]
   set errno_list {}
   set errstr_list {}
   foreach function $functions {
      if {[info exists check_errno($function)]} {
         lappend errno_list $check_errno($function)
         lappend errstr_list $check_errstr($function)
      } else {
         lappend errno_list {}
         lappend errstr_list {}
      }
   }

   lappend data $functions
   lappend data $errno_list
   lappend data $errstr_list

   lappend data $runtime
   lappend data [clock format [clock seconds]]
   lappend data $check_highest_level

   # dump test description to result file
   set output [open "$save_dir/$check_name.res.$level" "w"]  
   puts $output "$data"
   close $output

   # delete the other one
   if {[file isfile "$delete_dir/$check_name.res.$level"] == 1} {
      delete_file "$delete_dir/$check_name.res.$level"
   }
} 

proc get_check_name {path} {
   global ts_checktree
   
   set name ""
   if {[info exists ts_checktree($path)]} {
      set nr $ts_checktree($path)
      if {$ts_checktree($nr,test_available) == 1} {
         set name $ts_checktree($nr,check_name)
      }
   }

   return $name
}


proc get_check_levels { path } {
   global CHECK_ACT_LEVEL
   global ts_checktree
   global DISABLE_ADD_PROC_ERROR

   set saved_level $CHECK_ACT_LEVEL
   set levels {}
   if {[info exists ts_checktree($path)]} {
      set nr $ts_checktree($path)
      if {$ts_checktree($nr,check_highest_level) > 0 && $ts_checktree($nr,check_init_level_procedure) != "--"} {
         for {set i 0} {$i <= $ts_checktree($nr,check_highest_level)} {incr i 1} {
            set CHECK_ACT_LEVEL $i
            set DISABLE_ADD_PROC_ERROR 1
            if {[$ts_checktree($nr,check_init_level_procedure)] != 0} { 
               continue 
            }
            set DISABLE_ADD_PROC_ERROR 0
            lappend levels $CHECK_ACT_LEVEL
         }
      } else {
         lappend levels 0
      }
   }
   set CHECK_ACT_LEVEL $saved_level
   return $levels
}


proc get_checktree_levels { path } {
   global CHECK_ACT_LEVEL
   global ts_checktree

   set levels {}
   if {[info exists ts_checktree($path)]} {
      set nr $ts_checktree($path)
      set levels $ts_checktree($nr,check_levels)
   }

   return $levels
}


# get test result
#                                                             max. column:     |
#****** check/get_test_result() ******
# 
#  NAME
#     get_test_result -- ??? 
#
#  SYNOPSIS
#     get_test_result { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_test_result {filename} {
   if {[file isfile $filename] != 1} {
      return {"file not found"}
   }
   if {[file readable $filename] != 1} {
      return {"file not readable"}
   }
   set input [open $filename "r"]
   gets $input data
   close $input
   return $data
}

# create report
#                                                             max. column:     |
#****** check/create_report() ******
# 
#  NAME
#     create_report -- ??? 
#
#  SYNOPSIS
#     create_report { file goodbad } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     file    - ??? 
#     goodbad - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_report {file goodbad} {
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
  global CHECK_PRODUCT_VERSION_NUMBER ts_config

  set output [open $file "WRONLY APPEND CREAT"]
  puts $output "\n checksystem report"
  puts $output " ==================\n"
  puts $output " Date: [exec date]\n\n"
  puts $output " Version: $CHECK_PRODUCT_VERSION_NUMBER"
  puts $output " Installed in: $ts_config(product_root)"
  if {$goodbad == 0} { 
     set total [print_results $CHECK_RESULT_DIR $output]
     puts $output "\nTotal number of test functions: $total"
  } else {
     print_results $CHECK_BAD_RESULT_DIR $output
  }

  flush $output  
  close $output
 
  puts "report was written to $file"
}

# formatted output
#                                                             max. column:     |
#****** check/format_output() ******
# 
#  NAME
#     format_output -- ??? 
#
#  SYNOPSIS
#     format_output { prefix size text } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     prefix - ??? 
#     size   - ??? 
#     text   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc format_output { prefix size text} {

  if {[string length $text] <= $size } {
     return $text;
  }

  set otext $text
  set buffer ""

  while { 1 == 1 } {
     set buffer "$buffer[string range $otext 0 $size]"
     set otext [string range $otext [expr ($size+1)] [string length $otext] ]
     set buffer "$buffer\n$prefix"
     if {[string length $otext] <= $size} {
        set buffer "$buffer$otext"
        return $buffer
     }
  }

}

# print results
#                                                             max. column:     |
#****** check/print_results() ******
# 
#  NAME
#     print_results -- ??? 
#
#  SYNOPSIS
#     print_results { ckpath where } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     ckpath - ??? 
#     where  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_results {ckpath where} {
   global CHECK_OUTPUT
   set numb_of_check_functions 0 
   set filenames [get_file_names $ckpath]
   set catch_return [ catch {
      foreach elem $filenames {
         clear_screen
         puts $CHECK_OUTPUT "file: $elem"
         set data [get_test_result "$ckpath/$elem"]
   
         set path [lindex $data 0]
         set check_name [lindex $data 1]
         set check_descrip [lindex $data 2]
         set check_needs [lindex $data 3]
         set check_functions [lindex $data 4]
         set check_errno [lindex $data 5]
         set check_errstr [lindex $data 6]
         set check_clock [lindex $data 7]
         set check_date  [lindex $data 8]
         set high_level [lindex $data 9]
         set file_level [split $elem "."]
         set file_level [lindex $file_level 2]
   
         set check_description($file_level) $check_descrip
   
         puts $where "############################################################################"
         puts $where "check: $check_name (level $file_level)"
         puts $where "############################################################################"
         puts $where "----------------------------------------------------------------------------"
         puts $where "results:"
      
         set index 0
         puts $where "----------------------------------------------------------------------------"
         puts $where "run time:       [format_output "                " 59 $check_clock]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "date (end):     [format_output "                " 59 $check_date]" 
         puts $where "----------------------------------------------------------------------------"
         set leveltext $check_description($file_level)
         puts $where "description:    [format_output "                " 59 $leveltext]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "dependencies:   [format_output "                " 59 $check_needs]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "functions:      [format_output "                " 59 $check_functions]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "function count: [format_output "                " 59 [llength $check_functions]]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "directory:      [format_output "                " 59 $path]"
         puts $where "----------------------------------------------------------------------------\n"
   
         set numb_of_check_functions [ expr ($numb_of_check_functions + [llength $check_functions]) ]
         if {[string compare $where "stdout" ] == 0 } {
            puts $where "please press RETURN"
            set pressed [wait_for_enter 1]
         }
      }
   } my_error ]
   if { $catch_return != 0 } {
       add_proc_error "print_results" -1 "error creating test report:\n$my_error"
   }
   


   puts $where "\nTotal number of check functions in\n\"$ckpath\":\n$numb_of_check_functions\n"
   return $numb_of_check_functions
}
#                                                             max. column:     |
#****** check/is_level_enabled() ******
# 
#  NAME
#     is_level_enabled -- ??? 
#
#  SYNOPSIS
#     is_level_enabled { level_nr } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level_nr - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc is_level_enabled { level_nr } {

    global CHECK_ENABLED_RUNLEVELS

    foreach level_start $CHECK_ENABLED_RUNLEVELS {
       set level_end [ expr ( $level_start + 99 ) ]

       if { ( $level_start <= $level_nr ) && ( $level_nr <= $level_end ) } {
          return 0
       }
    }

    return -1
}


proc is_category_enabled { path } {
   global CHECK_ENABLED_CATEGORIES ts_checktree
   set checks_cat ""
   if { [info exists ts_checktree($path)] } {
      set nr $ts_checktree($path)
      set checks_cat $ts_checktree($nr,check_category)
   }
   foreach elem $checks_cat {
      if { [ lsearch $CHECK_ENABLED_CATEGORIES $elem] != -1 } {
         return 0
      }
   }
   return -1
}

proc delete_tests {path {only_if_not_there 0}} {
   global check_errno check_errstr check_functions validate_needs check_name
   global CHECK_OUTPUT check_highest_level check_name check_description
   global check_init_level_procedure CHECK_ACT_LEVEL CHECK_OUTPUT
   global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT
   global check_setup_function check_cleanup_function 
   global check_setup_level_function check_cleanup_level_function
   global DISABLE_ADD_PROC_ERROR

   set old_check_name $check_name
   set selected_tests [get_tests_from_checktree $path]

   foreach elem $selected_tests {
      flush $CHECK_OUTPUT
      set check_highest_level 0
      set check_name ""
      set check_init_level_procedure "--"

      if {[ts_source $elem/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT]} {
         debug_puts "sourced \"$elem/$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT\""

         # clear all errno/errstr per check_function
         clear_all_check_errors $check_name

         set do_delete 1
         if {$only_if_not_there == 1} {
            set result [validate_needs $check_name]
            if {$result == 0} {
               set do_delete 0
            }
         }

         if {$do_delete == 1} {
            for {set i 0} {$i <= $check_highest_level} {incr i 1} {
               if {[string compare $check_init_level_procedure "--"] != 0} {
                  set CHECK_ACT_LEVEL $i
                  set DISABLE_ADD_PROC_ERROR 1
                  if {[$check_init_level_procedure] == 0} {
                     delete_result $elem 0 $i
                  }
                  set DISABLE_ADD_PROC_ERROR 0
               } else {
                  delete_result $elem 0 $i
               }
            }
         }
      }
   }

   set check_name $old_check_name
}


#                                                             max. column:     |
#****** check/run_tests() ******
# 
#  NAME
#     run_tests -- ??? 
#
#  SYNOPSIS
#     run_tests { path runcompleted } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ???
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_tests {path runcompleted} {
   global CHECK_OUTPUT check_errstr CHECK_RESULT_DIR
   global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_MAX_ERROR_MAILS
   global CHECK_ACT_PATH check_use_installed_system
   global check_reinit_on_tcl_error
   global ts_config
   global CHECK_TESTS_RUNNING
   global CHECK_INTERRUPT

   set CHECK_TESTS_RUNNING 1

   set local_host [gethostname]
   set CHECK_MAILS_SENT 0  ;# clear mail counter
 
   set check_directories [get_tests_from_checktree $path]

   if {$runcompleted == 1} {
      delete_tests $path
   }

   # create list of checks to run
   set checks_to_do {}
   foreach elem $check_directories {
      if {[is_category_enabled $elem] == 0} {
         set test_name [get_check_name $elem] 
         set tests_runlevels [get_checktree_levels $elem]
         foreach tests_runlevel $tests_runlevels {
            if {$runcompleted == 0} {
               if {[file isfile "$CHECK_RESULT_DIR/$test_name.res.$tests_runlevel"]} {
                  continue
               }
            }
            lappend checks_to_do $elem
            break
         }
      }
   }
   set checks_to_do [lsort -dictionary $checks_to_do]
   if {[llength $checks_to_do] == 0} {
      set CHECK_TESTS_RUNNING 0
      return
   }

   # check if root password is needed
   foreach elem $checks_to_do {
      debug_puts "checking whether test in directory $elem needs root access ..."
      if {[check_root_access $elem] == 0 && [have_root_passwd] == -1} {
         puts $CHECK_OUTPUT "test in directory $elem needs root access ..."
         set_root_passwd
      }
   }

   # now run the checks
   set stop 0
   set pass_no 1
   set last_to_do -1
   set check_ok_name     ""
   set check_ok_state    "" 
   set check_ok_date     ""
   set check_ok_pass     ""
   set check_error_name  ""
   set check_error_state ""
   set check_error_date  ""
   set check_error_pass  ""
   set check_missing_dep ""
   set check_warning_name ""
   set check_warning_state ""
   set check_warning_date ""
   set check_warning_pass ""
   set check_missing_dep ""

   # we'll probably need multiple passes due to dependencies
   while {$stop == 0} {
      set todo [llength $checks_to_do]
      puts $CHECK_OUTPUT "---PASS${pass_no}----------------------------------------"
      puts $CHECK_OUTPUT "   Nr. of tests remaining: $todo"
      puts $CHECK_OUTPUT "------------------------------------------------" 

      # run all checks
      foreach check $checks_to_do {
         # running all tests can be interrupted by pressing CTRL-C
         if {$CHECK_INTERRUPT > 0} {
            set stop 1
            break
         }

         # run an individual check
         set test_result [run_test $check $runcompleted]

         switch -- $test_result {
            0 {
               # test OK
               lappend check_ok_name  $check
               lappend check_ok_state $test_result
               lappend check_ok_date  [clock format [clock seconds]]
               lappend check_ok_pass  $pass_no
            }
            -2 {
               # dependencies - try again
               lappend check_missing_dep $check
            }
            -3 {
               # impossible / unusefull to run this test
               lappend check_warning_name  $check
               lappend check_warning_state $test_result
               lappend check_warning_date  [clock format [clock seconds]]
               lappend check_warning_pass  $pass_no
            }
            1 {
               # test was already done in an earlier run
               # no action
               puts $CHECK_OUTPUT "run_tests - check already done"
            }

            2 {
               # test has no valid test in this run level
               # no action
               puts $CHECK_OUTPUT "test does not support actual runlevel"
            }
            -101 - 
            default {
               # -101: check failed due to tcl error
               # default: check failed for other reasons (e.g. add_proc_error)
               lappend check_error_name  $check
               lappend check_error_state $test_result
               lappend check_error_date  [clock format [clock seconds]]
               lappend check_error_pass  $pass_no
 
               if {$check_reinit_on_tcl_error == 1} {
                  # reinit system
                  puts $CHECK_OUTPUT "deleting all jobs"
                  delete_all_jobs
                  wait_for_end_of_all_jobs 15

                  set save_installed_value $check_use_installed_system
                  set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                  set check_use_installed_system 1
                  set CHECK_ACT_PATH "$ts_config(checktree_root_dir)/install_core_system"  
                  close_open_rlogin_sessions 1  ;# session reset (if defect)
                  set init_ret [run_test $CHECK_ACT_PATH 1]
                  if {$init_ret != 0 && $init_ret != -3} {
                     set check_use_installed_system 0
                     set CHECK_ACT_PATH "$ts_config(checktree_root_dir)/install_core_system" 
                     run_test $CHECK_ACT_PATH 1
                  }
                  set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                  set check_use_installed_system $save_installed_value
               }
            }
         }
      }

      # if stop was requested, e.g. by CTRL-C, stop now
      if {$stop} {
         break
      }

      # try to rerun checks that failed due to dependencies errors
      if {[llength $check_missing_dep] > 0} {
         # missing dependencies, run again
         set checks_to_do $check_missing_dep
         incr pass_no
         if {$todo == $last_to_do} {
            set stop 1
         } else {
            puts $CHECK_OUTPUT "restarting test with missing dependencies ..."
            set check_missing_dep ""
         }
         set last_to_do $todo
      } else {
         # all done
         set stop 1
      }
   }  ;# while stop == 0

   puts $CHECK_OUTPUT "Number of completed tests     : [llength $check_ok_name]"
   puts $CHECK_OUTPUT "Number of failed tests        : [llength $check_error_name]"
   puts $CHECK_OUTPUT "Number of unsupported tests   : [llength $check_warning_name]"
   puts $CHECK_OUTPUT "Number of dependencies errors : [llength $check_missing_dep]"

   set mail_body "Testsuite run on host $local_host complete\n\n"

   # dependencies errors
   if {[llength $check_missing_dep] > 0} {
      append mail_body "missing dependencies:\n"
      append mail_body "=====================\n\n"
      foreach elem $check_missing_dep {
         append mail_body "check [get_check_name $elem] in directory\n$elem\n"
      }
      append mail_body "\n"
   }

   # tests ok
   append mail_body "completed tests:\n"
   append mail_body "================\n\n"
   for {set index 0} {$index < [llength $check_ok_name]} {incr index 1} {
      append mail_body "Date: [lindex $check_ok_date $index]\n"
      append mail_body "Test: [lindex $check_ok_name $index]\n"
      append mail_body "Info: Pass[lindex $check_ok_pass $index], State: [lindex $check_ok_state $index]\n\n"
   }
   set nr_complete [llength $check_ok_name]
   append mail_body "Number of completed tests: $nr_complete"

   # tests failed
   append mail_body "\n\nfailed tests:\n"
   append mail_body "=============\n"
   for {set index 0} {$index < [llength $check_error_name]} {incr index 1} {
      append mail_body "Date: [lindex $check_error_date $index]\n"
      append mail_body "Test: [lindex $check_error_name $index]\n"
      append mail_body "Info: Pass[lindex $check_error_pass $index], State: [lindex $check_error_state $index]\n\n"
   }
   set nr_failed [llength $check_error_name]
   append mail_body "Number of failed tests: $nr_failed"

   # test run not usefull (warning)
   append mail_body "\n\nunsupported tests:\n"
   append mail_body "==================\n"
   for {set index 0} {$index < [llength $check_warning_name]} {incr index 1} {
      append mail_body "Date: [lindex $check_warning_date $index]\n"
      append mail_body "Test: [lindex $check_warning_name $index]\n"
      append mail_body "Info: Pass[lindex $check_warning_pass $index], State: [lindex $check_warning_state $index]\n\n"
   }
   set nr_unsupported [llength $check_warning_name]
   append mail_body "Number of unsupported tests: $nr_unsupported"

   # mail subject
   if {[llength $check_missing_dep ] > 0} {
      set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported;depend:[llength $check_missing_dep]"
   } else {
      set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported"
   }

   # do send mail
   mail_report "$mail_subject" $mail_body

   set CHECK_TESTS_RUNNING 0
}


#                                                             max. column:     |
#****** check/lock_testsuite() ******
# 
#  NAME
#     lock_testsuite -- ??? 
#
#  SYNOPSIS
#     lock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc lock_testsuite {} {
   global CHECK_OUTPUT CHECK_USER
   global CHECK_MAIN_RESULTS_DIR
   global CHECK_TESTSUITE_LOCKFILE
   global ts_config

   set local_host [gethostname]
    set pid [getpid]
    
    debug_puts "-> lock_testsuite: pid=$pid host=$local_host user=$CHECK_USER"

    set result 1
    set time [expr [timestamp] + 60]
    while {$result != 0} {
       puts $CHECK_OUTPUT "waiting for lock ..."
       set result [catch {
          exec -- $ts_config(testsuite_root_dir)/scripts/lock.sh $CHECK_TESTSUITE_LOCKFILE $pid $local_host $CHECK_USER
       } catch_output]
       debug_puts "======================================="
       debug_puts "lock.sh returned $result:\n$catch_output"
       debug_puts "======================================="
       set file_size 0
       catch {set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       if {$file_size == 0} {
           puts $CHECK_OUTPUT "file size is 0, deleting lockfile..."
           sleep 60  ;# wait for NFS to update file
           unlock_testsuite
           sleep 60  ;# wait for NFS to update file
           return [lock_testsuite]  
       }
       if {$result != 0} {
          puts $CHECK_OUTPUT "checking lockfile owner process ..."
          set data ""
          catch {
              set input [open "$CHECK_TESTSUITE_LOCKFILE" "r"]
              gets $input data
              close $input
          }
          set owner_pid  [lindex $data 0]
          set owner_host [lindex $data 1]
          set owner_user [lindex $data 2]

          debug_puts "testsuite is locked by user $owner_user, process $owner_pid on host $owner_host!"
          if {[lindex $data 0] == $pid && [lindex $data 1] == $local_host && [lindex $data 2] == $CHECK_USER} {
              debug_puts "thats me, so we have the lock"
              set result 0
              continue
          }
          debug_puts "checking whether process is still alive ..."
           
          get_ps_info $owner_pid $owner_host
          if { $ps_info($owner_pid,error) == 0 } {
             puts $CHECK_OUTPUT "process exists, command is \n-----\n\"$ps_info($owner_pid,string)\"\n-----"
          } else {
             puts $CHECK_OUTPUT "process doesn't exist -> unlock_testsuite ..."
             unlock_testsuite
          }
       }
    }
    debug_puts "new lockfile written! Testing for correct lock ..."

    set time [expr [timestamp] + 60]
    set tries 0
    set ok 0
    set failed 0
    set file_size 0
    while {$ok != 1} {
       sleep 1
       catch { set input [ open $CHECK_TESTSUITE_LOCKFILE "r" ]
               gets $input data
               close $input }
 
       debug_puts "pid  [lindex $data 0] == $pid"
       debug_puts "host [lindex $data 1] == $local_host"
       debug_puts "user [lindex $data 2] == $CHECK_USER"
 
       if {[lindex $data 0] == $pid && [lindex $data 1] == $local_host && [lindex $data 2] == $CHECK_USER} {
          incr tries 1
          if {$tries >= 2} {
             set ok 1
          }
       }
       debug_puts "waiting to get lock"

       catch {set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       debug_puts "file size is: $file_size"

       if {[timestamp] > $time} {
          set failed 1
          set ok 1
       }
    }

    if {$failed == 1} {
        puts $CHECK_OUTPUT "no success! Try again ..."
        if { $file_size == 0 } {
           debug_puts "file size is zero, deleting lockfile..."
           unlock_testsuite
        }
        return [lock_testsuite]
    }

    debug_puts "lock success!"
}

#                                                             max. column:     |
#****** check/unlock_testsuite() ******
# 
#  NAME
#     unlock_testsuite -- ??? 
#
#  SYNOPSIS
#     unlock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc unlock_testsuite {} {
    global CHECK_OUTPUT CHECK_MAIN_RESULTS_DIR CHECK_TESTSUITE_LOCKFILE

    if {[file isfile $CHECK_TESTSUITE_LOCKFILE] == 1 } {
        puts $CHECK_OUTPUT "removing lockfile \"$CHECK_TESTSUITE_LOCKFILE\"" 

       set catch_return [ catch {exec rm "$CHECK_TESTSUITE_LOCKFILE"} ]
       if { $catch_return != 0 } {
          puts $CHECK_OUTPUT "unlock_testsuite - could not unlock testsuite"
          return
       } 
       while { [ file isfile $CHECK_TESTSUITE_LOCKFILE ] == 1 } {
          puts $CHECK_OUTPUT "file still existing" 
          sleep 1
       }
    }
    puts $CHECK_OUTPUT "testsuite unlocked!" 
}


# run_test_level: returns
# -1 on error, 
# -2 check can not run
#  0 if ok, 
#  1 already done
#
#                                                             max. column:     |
#****** check/run_test_level() ******
# 
#  NAME
#     run_test_level -- ??? 
#
#  SYNOPSIS
#     run_test_level { path runcompleted level {do_save 1} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#     level        - ??? 
#     {do_save 1}  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#*******************************
proc run_test_level {path runcompleted level {do_save 1}} {
   global check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
   global check_errstr CHECK_OUTPUT check_description check_functions check_errno 
   global CHECK_CUR_PROC_NAME
   global CHECK_CURRENT_WORKING_DIR check_init_level_procedure CHECK_ACT_LEVEL
   global errorInfo
   global check_setup_level_function check_cleanup_level_function
   global ts_config
   global CHECK_INTERRUPT
   
   # do not run already completed tests
   debug_puts "runcompleted is $runcompleted"
   if {$runcompleted == 0} {
      if {[file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"]} {
         return 1
      }
   }

   # get lock  
   delete_temp_script_files
   lock_testsuite
 
   set CHECK_ACT_LEVEL $level
   puts $CHECK_OUTPUT "starting test functions (runlevel is $CHECK_ACT_LEVEL)..."
 
   # call init_check_level procedure!
   # JG:       init_check_level is run twice (already in run_test.
   #           do we really have to call it twice?
   #           or call it here and return if it doesn't return 0
   # CR:       This must be done, because a test can be started for a
   #           specified runlevel
   if {[info exists check_init_level_procedure]} {
      if {[string compare $check_init_level_procedure "--"] != 0} {
         puts $CHECK_OUTPUT "\ncalling init level function \"$check_init_level_procedure\" ..."
         $check_init_level_procedure
      }
   }
 
   # call all check functions 
   clear_all_check_errors $check_name
   set start_time [clock seconds]
   set catch_return 0

   # unless we are in install - check if system is running
   if {[string compare $check_name "init_core_system"] != 0 &&
       [string compare $check_needs "" ] != 0} {
      if {[is_scheduler_alive $ts_config(master_host) [get_qmaster_spool_dir]] != 1} {
         add_proc_error "run_test_level" -1 "scheduler is not alive"
      }
      wait_for_load_from_all_queues 60
   }

   # only continue, if we have check_functions at all
   if {![info exists check_functions] || [llength $check_functions] == 0} {
      add_proc_error "run_test_level" -1 "check $check_name doesn't have any check_functions"
   } else {
      # if we have a level specific setup function: execute it
      set setup_ret [execute_setup_cleanup_function $check_setup_level_function "setup_level"]

      # if we had a setup error, don't execute the test,
      # but continue with the cleanup function
      if {$setup_ret} {
         foreach elem $check_functions {
            # running all check_functions can be interrupted by pressing CTRL-C
            if {$CHECK_INTERRUPT >= 3} {
               break
            }
            puts $CHECK_OUTPUT "\n>>>>>>>>>>>>>>>>>>>>>>"
            puts $CHECK_OUTPUT "$elem"    
            puts $CHECK_OUTPUT "runlevel: [get_run_level_name $level]($level)"
            puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>"

            # set public procedure error state to "no error"
            set check_cur_proc_result "0"
            set check_cur_proc_error "ok"
            set CHECK_CUR_PROC_NAME $elem

            # this starts the test procedure
            set catch_return [catch {$elem} errMsg]
            if {$catch_return != 0} {
               puts $CHECK_OUTPUT $errMsg
               add_proc_error "run_test_level" "-2" "TCL Error\n${errMsg}\n${errorInfo}" 
            } 
            
            # shall we stop testing due to error conditions?
            # for some reason, we stop at error code -2 (warning);
            # on -1, we continue
            if {[info exists check_errno($elem)] && [lsearch -exact $check_errno($elem) "-2"] >= 0} {
               break;
            }
         };# foreach check_function
      }

      # if we have a level specific cleanup function: execute it
      execute_setup_cleanup_function $check_cleanup_level_function "cleanup_level"
   }

   # examine public procedure error states
   set was_error 0
   set was_unsupported 0
   if {[info exists check_errno]} {
      foreach function [array names check_errno] {
         if {[info exists check_errno($function)]} {
            foreach error $check_errno($function) {
               if {$error != 0} {
                  if {$error == -1} {
                     incr was_error
                  } elseif {$error == -2} {
                     incr was_error
                  } elseif {$error == -3} {
                     incr was_unsupported
                  }
               }
            }
         }
      }
   }

   set end_time [clock seconds]
   set duration [expr $end_time - $start_time]

   # evaluate check status
   set finished 1
   if {$catch_return != 0} {
      puts $CHECK_OUTPUT "T C L   E R R O R   running test \"$check_name\" in run level $level !"
      set finished 0
      set ret -101 
   } elseif {$was_error > 0} {
      puts $CHECK_OUTPUT "\ncheck \"$check_name\" F A I L E D  in run level $level !"
      set finished 0
      set ret -1
   } elseif {$was_unsupported > 0} {
      puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level !"
      set ret -2
   } else {
      puts $CHECK_OUTPUT "S U C C E S S F U L L Y performed \"$check_name\" in run level $level !"
      set ret 0
   }

   if {$do_save} {
      save_result $path $duration $level $finished
   }

   unlock_testsuite

   return $ret
}


#                                                             max. column:     |
#****** check/check_root_access() ******
# 
#  NAME
#     check_root_access -- ??? 
#
#  SYNOPSIS
#     check_root_access { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_root_access {path} {
  global check_root_access_needs 
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT

  set check_root_access_needs "no"  
  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT

  if { [string compare -nocase "yes" $check_root_access_needs] == 0 } {
     return 0
  } 

  return -1
}

proc delete_temp_script_files { } {
  global CHECK_OUTPUT
  global ts_config

  puts -nonewline $CHECK_OUTPUT "deleting temporary used files ..."
  set del_file_name "$ts_config(testsuite_root_dir)/.testsuite_delete"
  if { [ file isfile $del_file_name ] == 1 } {
     set del_file [ open $del_file_name "r" ]
     while { [gets $del_file line] >= 0 } {
        if { [ file isfile $line ] == 1 } {
           file delete $line
           puts -nonewline $CHECK_OUTPUT "."
           flush $CHECK_OUTPUT
        }
     }
     close $del_file
     file delete $del_file_name
     puts -nonewline $CHECK_OUTPUT "."
     flush $CHECK_OUTPUT
  } 
  puts $CHECK_OUTPUT ""
}

#****** check/execute_setup_cleanup_function() *********************************
#  NAME
#     execute_setup_cleanup_function() -- execute a setup/cleanup function
#
#  SYNOPSIS
#     execute_setup_cleanup_function { func_name type } 
#
#  FUNCTION
#     execute_setup_cleanup_function is used to execute a setup/cleanup
#     function for a check and/or a check level.
#
#  INPUTS
#     func_name - name of the procedure to execute
#     type      - descriptive text (e.g. "setup_level", or "cleanup")
#
#  RESULT
#     0 - failure
#     1 - ok
#     2 - empty function name
#
#*******************************************************************************
proc execute_setup_cleanup_function {func_name type} {
   global CHECK_OUTPUT CHECK_ACT_LEVEL
   global CHECK_CUR_PROC_NAME

   set ret 1

   # if no setup/cleanup function is set, func_name will be ""
   if { $func_name == "" } {
      set ret 2
   }

   if {$ret == 1} {
      # register the function for error handling
      set CHECK_CUR_PROC_NAME $func_name
   
      # check, if the function exists
      if { [info procs $func_name] != $func_name } {
         set ret 0
         add_proc_error "execute_setup_cleanup_function" -2 "$type procedure \"$func_name\" doesn't exist"
      }
   }

   # execute the setup/cleanup function
   if {$ret == 1} {
      puts $CHECK_OUTPUT "starting $type function $func_name"
      set CHECK_CUR_PROC_NAME $func_name

      set act_level_value $CHECK_ACT_LEVEL

      if { $type == "setup" || $type == "cleanup" } {
         set act_level_value $CHECK_ACT_LEVEL
         set CHECK_ACT_LEVEL "global $type procedure \"$func_name\""
      }
      set catch_return [ catch { $func_name } catch_message ]

      set CHECK_ACT_LEVEL $act_level_value

      # catch returnes an error - may be a TCL error
      if {$catch_return != 0} {
         add_proc_error "run_test" "-2" "$type function \"$func_name\" failed:\n$catch_message" 
         set ret 0
      }
   }

   # check if error occured during execution of the setup/cleanup function
   if {$ret == 1} {
      # check_errno contains error codes as well as OK status (0)
      # search for entries != 0, if found, treat as error
      if {[info exists check_errno($func_name)]} {
         foreach elem $check_errno($func_name) {
            if {$elem != 0} {
               set ret 0
               break
            }
         }
      }
   }

   return $ret
}

# run test
#                                                             max. column:     |
#****** check/run_test() ******
# 
#  NAME
#     run_test -- ??? 
#
#  SYNOPSIS
#     run_test { path runcompleted {run_single_test "all"} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     runcompleted            - ??? 
#     {run_single_test "all"} - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test {path runcompleted {run_single_test "all"} { send_mail_report 1 } } {
   global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
   global check_errstr CHECK_OUTPUT check_description check_functions check_errno 
   global CHECK_CUR_PROC_NAME check_root_access_needs
   global CHECK_CURRENT_WORKING_DIR check_highest_level check_init_level_procedure CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE CHECK_PRODUCT_VERSION_NUMBER
   global check_category CHECK_GROUP DISABLE_ADD_PROC_ERROR
   global check_setup_function check_cleanup_function check_setup_level_function check_cleanup_level_function
   global ts_config
   global CHECK_TEST_RUNNING
   global CHECK_INTERRUPT

   # monitor, that we are currently running a test
   set CHECK_TEST_RUNNING 1

   cd $CHECK_CURRENT_WORKING_DIR

   set do_only_one_test 0

   set CHECK_ACTUAL_TEST_PATH $path

   set check_name          ""
   set check_category      ""
   set check_needs         ""
   set check_functions     ""
   set check_setup_function ""
   set check_cleanup_function ""
   set check_setup_level_function ""
   set check_cleanup_level_function ""
   set check_highest_level 0
   set check_init_level_procedure "--"
   set check_root_access_needs   "no" 

   ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
   if {[string compare $run_single_test "all"] != 0} {
      set do_only_one_test 1
      puts $CHECK_OUTPUT "running only test \"$run_single_test\""
      set check_functions "$run_single_test"
   }

   if {[string compare -nocase "yes" $check_root_access_needs] == 0 && [have_root_passwd] == -1} {
      puts $CHECK_OUTPUT "test needs root access ..."
      set_root_passwd
   }

   puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
   puts $CHECK_OUTPUT ">>> $check_name"
   puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
   debug_puts "file: $path/check.exp"

   # first check the dependencies
   # if dependencies are not fulfilled, we mark the test as not yet run
   set result [validate_needs $check_needs]
   debug_puts "needs returned $result"
   debug_puts "highest level of test is $check_highest_level"
   if {$result != 0} {
      puts $CHECK_OUTPUT "dependencies ($check_needs) not fulfilled! Stop!"
      clear_all_check_errors $check_name
      for {set level 0} {$level <= $check_highest_level} {incr level 1} {
         if {[string compare $check_init_level_procedure "--"] != 0} { 
            set DISABLE_ADD_PROC_ERROR 1
            set CHECK_ACT_LEVEL $level
            if {[$check_init_level_procedure ] == 0} { 
               delete_result $path 0 $level
            }
            set DISABLE_ADD_PROC_ERROR 0
         } else {
            delete_result $path 0 $level
         }
      }
      set CHECK_TEST_RUNNING 0
      return -2  ;# dependencies not fulfilled
   }

   set nr_errors 0
   set nr_warnings 0
   set nr_already_done 0
   set nr_new_done 0
   set my_current_runlevel 0
   set do_send_mail 0
   set no_level_calls 0 
   set no_of_test_runs 0
   set immediate_return 0

   set possible_test_levels 0
   for {set level 0} {$level <= $check_highest_level} {incr level 1} {
      if {[string compare $check_init_level_procedure "--"] != 0} {
         set CHECK_ACT_LEVEL $level
         if {[$check_init_level_procedure] == 0} {
            incr possible_test_levels 1 
         }
      } else {
         # we have an old test which has no check level defined,
         # assume at least 1 test level (0)
         incr possible_test_levels 1
         break  
      }
   }

   if { $possible_test_levels == 0 } {
      # the test doesn't support any check level - store it as done unsupported
      save_result $path 0 0 1
      set CHECK_TEST_RUNNING 0
      return -3
   }

   # check if this test is enabled for the actual runlevel, test is already done, ...
   for {set level 0} {$level <= $check_highest_level} {incr level 1} {
      # check if this is a global enabled level
      if {[is_level_enabled $level] == -1} {
         continue
      }

      # check test's init level procedure return value
      if {[string compare $check_init_level_procedure "--"] != 0} {
         set CHECK_ACT_LEVEL $level
         if {[$check_init_level_procedure] != 0} {
            continue 
         }
      }

      # check if test was already running
      if {$runcompleted == 0} {
         if {[file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"]} {
            continue 
         }
      }
      incr no_of_test_runs 1
   }

   if { $no_of_test_runs == 0 } {
      # no active runlevel for this check, return 2
      set CHECK_TEST_RUNNING 0
      return 2
   }

   # check the number of busy rlogin sessions
   # it should be 0
   set num_busy_sessions_before_check [get_busy_spawn_rlogin_sessions]
   if {$num_busy_sessions_before_check > 0} {
      set session_info [dump_spawn_rlogin_sessions 0]
      add_proc_error "run_test" -3 "We have $num_busy_sessions_before_check busy rlogin sessions before starting test $check_name ($path).\nThis may indicate a problem (missing close_spawn_session call in previous check).\n\n$session_info"
   }

   # start a setup function for this check - should it exist
   set setup_ret [execute_setup_cleanup_function $check_setup_function "setup"]
   if {!$setup_ret} {
      set immediate_return -1
   }

   if {$immediate_return == 0} {
      for {set level 0} {$level <= $check_highest_level} {incr level 1} {
         # check for interrupt
         if {$CHECK_INTERRUPT >= 2} {
            break
         }

         if {[is_level_enabled $level] == -1} {
            continue
         }
         set my_current_runlevel $level
         if {[string compare $check_init_level_procedure "--"] != 0} {
            set CHECK_ACT_LEVEL $level
            if {[$check_init_level_procedure] != 0} {
               continue
            }
         }
         puts $CHECK_OUTPUT "\n----------------------------------------------"
         puts $CHECK_OUTPUT "-> enter check level $level"

         if {$do_only_one_test == 0} {
            set back [run_test_level $path $runcompleted $level]
            debug_puts "level $level return value: $back"
            incr no_level_calls 1
         } else {
            set back [run_test_level $path $runcompleted $level 0]
            debug_puts "level $level return value of test $run_single_test: $back"
            incr no_level_calls 1
         }

         if {[string first "unknown" $CHECK_GROUP] >= 0} {
            add_proc_error "run_test" -1 "CHECK_GROUP set to unknown, test was $path in level $level"
         }
        
         # now we are back from executing one runlevel - evaluate the result
         if {$back == -101} {
            incr nr_errors 1
            debug_puts "--> TCL ERROR in check $path in level $level <--"
            set immediate_return -101
            break
         }

         # there were errors
         if {$back == -1} {
            incr nr_errors 1
            debug_puts "--> ERROR in check $path in level $level <--"
            set immediate_return -1
            break
         }

         # there were warnings
         if {$back == -2} {
            incr nr_warnings 1
            debug_puts "--> check $path in level $level: can't start test <--"
         }

         # test succeeded
         if {$back == 0} {
            set do_send_mail 1
            incr nr_new_done 1
            debug_puts "no errors"
         }

         # test had already run
         if {$back == 1} {
            debug_puts "check already done"
            incr nr_already_done 1
         }
         debug_puts "calls=$no_level_calls, already done=$nr_already_done"
      }
   }

   # if we have a specific cleanup function: execute it
   set cleanup_ret [execute_setup_cleanup_function $check_cleanup_function "cleanup"]
   if {!$cleanup_ret} {
      set immediate_return -1
   }

   # check the number of busy rlogin sessions
   # it should be 0, or at least not higher than before starting test
   set num_busy_sessions_after_check [get_busy_spawn_rlogin_sessions]
   if {$num_busy_sessions_before_check < $num_busy_sessions_after_check} {
      set session_info [dump_spawn_rlogin_sessions 0]
      close_open_rlogin_sessions
      add_proc_error "run_test" -1 "Session leak in check $check_name ($path)!\nWe have $num_busy_sessions_after_check busy rlogin sessions after starting the test.\nBefore the test, we had $num_busy_sessions_before_check busy sessions.\nMake sure the test closes all opened sessions again!\n\n$session_info\nClosing all sessions now to prepare clean reconnect."
      incr nr_errors
   }

   if {$immediate_return != 0} {
      set CHECK_TEST_RUNNING 0
      return $immediate_return
   }

   if {$nr_already_done == $no_level_calls} {
      set CHECK_TEST_RUNNING 0
      return 1  ;# was done time before
   }
  
   if {$send_mail_report != 1} {
      set do_send_mail 0
   }

   # when the tests succeeded, we usually send a mail
   if {$nr_errors == 0 && $nr_warnings == 0} {
      if {$do_send_mail == 1} {
         set mail_body "Successfully performed check $check_name in directory\n$path\n"
         append mail_body "Date: [ exec date ]\n\n"
         append mail_body "product type:     $CHECK_PRODUCT_TYPE\n"
         append mail_body "product feature:  $ts_config(product_feature)\n"
         append mail_body "product version:  $CHECK_PRODUCT_VERSION_NUMBER\n"
         append mail_body "product root:     $ts_config(product_root)\n"
         append mail_body "cell:             $ts_config(cell)\n"
         append mail_body "runlevel:         [get_run_level_name $my_current_runlevel]\n"
         append mail_body "max. runlevel:    [get_run_level_name $check_highest_level]\n"
         append mail_body "dependencies:     $check_needs\n"
         append mail_body "check functions:  \n"
         foreach elem $check_functions {
            append mail_body "                   $elem\n"
         }
         append mail_body "init level proc:  $check_init_level_procedure\n"
         mail_report "testsuite success - $check_name" $mail_body
      }
      set CHECK_TEST_RUNNING 0
      return 0
   } else {
      set CHECK_TEST_RUNNING 0
      if {$nr_errors == 0} {
         return -3 ;# we had warnings
      }
      return -1
   }
}

#                                                             max. column:     |
#****** check/clean_up_globals() ******
# 
#  NAME
#     clean_up_globals -- ??? 
#
#  SYNOPSIS
#     clean_up_globals { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_globals {} {
  global check_init_level_procedure check_name check_description check_highest_level
  global check_needs check_functions check_category
 
  if { [ info exists check_category ] } {
     unset check_category 
  }

  if { [ info exists check_description] } {
     unset check_description 
  }


  set check_name        ""                 ;# name of actual check module 
  set check_needs       ""          ;# dependencies of this check (name of other check)
  set check_functions   ""          ;# functions to call (in order)
  set check_init_level_procedure "--"   ;# name of procedure to call before starting level run
  set check_highest_level 0        ;# here a check can define his check levels count 0 ... 
}

# show test description
#                                                             max. column:     |
#****** check/show_test() ******
# 
#  NAME
#     show_test -- ??? 
#
#  SYNOPSIS
#     show_test { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_test {path full} {
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_needs check_highest_level 
  global check_init_level_procedure CHECK_ACT_LEVEL check_category
  global DISABLE_ADD_PROC_ERROR

  clean_up_globals  

  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
  puts "===============================================================================" 
  puts "name:         | $check_name"
  puts -nonewline "categories:   | "
  foreach cat $check_category {
     puts -nonewline "$cat "
  }
  puts ""
  puts "===============================================================================" 

  if { $full == 1} {
    puts "filename:     | [ format_output "              | " 61 $path/$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT ]"

    puts "===============================================================================" 
    for {set i 0} {$i <= $check_highest_level} {incr i 1} {
       set blank ""
       if { $i <= 99} {
         set blank " "
       }
       if { $i <= 9 } {
         set blank "  "
       } 

       set do_print 0
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
          set CHECK_ACT_LEVEL $i
          set DISABLE_ADD_PROC_ERROR 1
          if { [$check_init_level_procedure ]  == 0 } { 
             set do_print 1
          } 
          set DISABLE_ADD_PROC_ERROR 0
       } else {
          set do_print 1
       }
       if { $do_print == 1 } { 
          puts "run level ${blank}$i |"
          puts "description:  | [ format_output "              | " 61 $check_description($i)]"
          puts "==============================================================================="
       }
      

    }

    puts "dependencies: |"
    foreach element $check_needs {
      puts "              | [ format_output "              | " 61 $element]"
    }
    puts "==============================================================================="
  }
}

#                                                             max. column:     |
#****** check/select_runlevel() ******
# 
#  NAME
#     select_runlevel -- ??? 
#
#  SYNOPSIS
#     select_runlevel { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc select_runlevel {} {
     global CHECK_ENABLED_RUNLEVELS CHECK_ENABLED_CATEGORIES

     set data ""
     set my_cats [get_checktree_categories "root"]

     while { $data != 0 } {
       
        clear_screen
        print_menu_header
        set selected_levels ""
        foreach elem $CHECK_ENABLED_RUNLEVELS {
           set a_level [ get_run_level_name $elem ] 
  
           if { [string first $a_level $selected_levels ] < 0 } {
              set selected_levels "$selected_levels $a_level"
           } 
        }

        puts "\nplease select/unselect new runlevels/categories: \n"
        puts "(0) return to previous menu\n"

        puts "runlevels:\n"
        puts "(1) short  (   0 min - 15 min / run level   0 -  99 )"
        puts "(2) medium (  16 min -  1 h   / run level 100 - 199 )"
        puts "(3) long   (   1 h   -  4 h   / run level 200 - 299 )"
        puts "(4) day    ( > 4 h   - 24 h   / run level 300 - 399 )"
        puts "(5) week   ( >24 h            / run level 400 - 499 )\n"
        puts "categories:\n"
        set numbs 6
        foreach elem $my_cats {
           puts "($numbs) $elem"
           incr numbs 1
        }

        set data [wait_for_enter 1]
        if { $data <= 5 && $data > 0 } {
           incr data -1
           set in 0
           if { $data <= 4 && $data >= 0 } {
              foreach x $CHECK_ENABLED_RUNLEVELS {
                 if { $x == [ expr ( $data * 100 ) ] } {
                    set in 1
                 }      
              }
           }
   
           if { $data <= 4 && $data >= 0 } {
             if {$in == 0} {
               lappend CHECK_ENABLED_RUNLEVELS [ expr ( $data * 100 )] 
             } else {
               set new_enabled_runlevels ""
               foreach x $CHECK_ENABLED_RUNLEVELS {
                  if { $x != [ expr ( $data * 100 ) ] } { 
                     lappend new_enabled_runlevels $x
                  }
               }
               set CHECK_ENABLED_RUNLEVELS $new_enabled_runlevels
             } 
           }
           incr data 1
        } else {
           # categories
           set max_number [llength $my_cats]
           incr max_number 5
           if { $data > $max_number || $data <= 5  } {
              continue
           }   
           set my_cat [ expr ( $data - 6 ) ]   
           set new_cat [ lindex $my_cats $my_cat ]
           set cat_pos [ lsearch $CHECK_ENABLED_CATEGORIES  $new_cat ]
           if { $cat_pos != -1 } {
              set CHECK_ENABLED_CATEGORIES [ lreplace $CHECK_ENABLED_CATEGORIES $cat_pos $cat_pos ]
           } else {
              lappend CHECK_ENABLED_CATEGORIES $new_cat
           }
        }
     } 
}
proc check_display {} {
     global CHECK_DISPLAY_OUTPUT CHECK_USER CHECK_OUTPUT

     if { [ string compare $CHECK_DISPLAY_OUTPUT "undefined" ] == 0 } {
        puts "no debug x display set"
        return -1
     } 

     if { [ have_root_passwd ] != 0 } {
         set_root_passwd
     }

     puts $CHECK_OUTPUT "using display: $CHECK_DISPLAY_OUTPUT"
   
     set local_host [gethostname]
     set xterm_path [get_xterm_path $local_host]

     start_remote_prog $local_host "$CHECK_USER" $xterm_path "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user $CHECK_USER from host $local_host"    
         return -1
     }

     if { [ have_root_passwd ] != 0 } {
         set_root_passwd
     }
     start_remote_prog "$local_host" "root" $xterm_path "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user root from host $local_host"    
         return -1
     }
     return 0
}


proc set_command_line_options {} {
     global CHECK_ENABLED_RUNLEVELS CHECK_ENABLED_CATEGORIES
     global CHECK_SGE_DEBUG_LEVEL check_use_installed_system
     global master_debug schedd_debug do_not_update CHECK_DISPLAY_OUTPUT daemon_debug
     set data ""
     while { $data != 0 } {
        clear_screen
        print_menu_header
        puts "\nplease select/unselect command line options: \n"
        puts "(0) return to previous menu\n"

        puts "options:\n"


        if { $master_debug == 0 } {
           set md_flag "off"
        } else {
           set md_flag "on"
        }
        if { $schedd_debug == 0 } {
           set sd_flag "off"
        } else {
           set sd_flag "on"
        }
        if { $do_not_update == 0 } {
           set nu_flag "off"
        } else {
           set nu_flag "on"
        }

        if { $check_use_installed_system == 0 } {
           set re_init_flag "off"
        } else {
           set re_init_flag "on"
        }

        puts "(1) master_debug    : $md_flag"
        puts "(2) schedd_debug    : $sd_flag"
        puts "(3) SGE_DEBUG_LEVEL : $CHECK_SGE_DEBUG_LEVEL"
        puts "(4) no_update       : $nu_flag"
        puts "(5) re_init         : $re_init_flag"

        set data [wait_for_enter 1]
        if { $data <= 2 && $data > 0 } {
        }
        switch $data {
           "1" { 
              puts "master_debug" 
              if { $master_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set master_debug 1
              } else {
                 set master_debug 0
              }
           }
           "2" {
              puts "schedd_debug" 
              if { $schedd_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set schedd_debug 1
              } else {
                 set schedd_debug 0
              }
           }
           "3" {
               puts "enter new SGE_DEBUG_LEVEL: "
               set CHECK_SGE_DEBUG_LEVEL [wait_for_enter 1]
           }
           "4" {
               if { $do_not_update == 0 } {
                  set do_not_update 1
               } else { 
                  set do_not_update 0
               }
           }
           "5" {
              if { $check_use_installed_system == 0 } {
                 set check_use_installed_system 1
              } else {
                 set check_use_installed_system 0
              }
           }
        }

        if { $schedd_debug == 0 && $master_debug == 0 } {
           set daemon_debug 1
        } else {
           set daemon_debug 0
        }
     } 
}

#****** check/get_max_level_count() ********************************************
#  NAME
#     get_max_level_count() -- get runleves of check
#
#  SYNOPSIS
#     get_max_level_count { path } 
#
#  FUNCTION
#     This function returns all runlevel numbers for the check specified by
#     its testsuite path.
#
#  INPUTS
#     path - full path name of check
#
#  RESULT
#     a list of runlevel numbers
#
#*******************************************************************************
proc get_max_level_count {path} {
  global CHECK_ACT_LEVEL
  global ts_checktree DISABLE_ADD_PROC_ERROR
 
  set check_directories [get_tests_from_checktree $path]
  set max_level {}
  foreach elem $check_directories {
     set nr $ts_checktree($elem)
     if { [string compare $ts_checktree($nr,check_init_level_procedure) "--" ] != 0 } {
        set DISABLE_ADD_PROC_ERROR 1
        for {set x 0 } {$x <= $ts_checktree($nr,check_highest_level)} {incr x 1 } {
           set CHECK_ACT_LEVEL $x
           if { [$ts_checktree($nr,check_init_level_procedure)]  == 0 } {
              if { [lsearch $max_level $x] < 0 } {
                 lappend max_level $x
              }
           }
        } 
        set DISABLE_ADD_PROC_ERROR 0
     }
  }  
  return $max_level
}

proc get_checktree_max_level_count {path} {
  global CHECK_ACT_LEVEL
  global ts_checktree
 
  if { [info exists ts_checktree($path)] }  {
     set nr $ts_checktree($path)
     return $ts_checktree($nr,max_level_count)
  }
  return ""
}






proc get_checktree_categories {path} {
  global ts_checktree
 
  set check_directories [get_tests_from_checktree $path]
  set back {}
  foreach elem $check_directories {
     set nr $ts_checktree($elem)
     if { [info exists ts_checktree($nr,check_category)] } {
        foreach elem $ts_checktree($nr,check_category) {
           if { [ lsearch -exact $back $elem ] == -1 } {
              lappend back $elem
           }
        }
     }
  }
  set back [lsort $back]
  return $back
}




# show test descriptons (of all subtests)
#                                                             max. column:     |
#****** check/show_tests() ******
# 
#  NAME
#     show_tests -- ??? 
#
#  SYNOPSIS
#     show_tests { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_tests {path full} {
  global ts_checktree

  set check_directories [get_tests_from_checktree $path]

  foreach elem $check_directories {
     clear_screen
     show_test $elem $full
     wait_for_enter
  }  
}

proc change_dir { { have_input "" } } {
  global CHECK_ACT_PATH ts_checktree CHECK_OUTPUT

  set index_start 1

  if { $have_input == "" } {
     print_menu_header
  }

  set dirs [ get_checktree_dir_names $CHECK_ACT_PATH 0]

  set count 1 

  if {[string compare $CHECK_ACT_PATH "root"] != 0 } {
    if { $have_input == "" } {
       puts "($count) - up"
    }
    incr count 1
    incr index_start 1
  }
  if { $have_input == "" } {
     puts "($count) - stay"
  }
  incr count 1
  incr index_start 1

  foreach elem $dirs {
     # puts "($count) - go to \"$elem\""
     set newdir($count) $elem
     incr count 1
  }

  if { $have_input == "" } {
     puts -nonewline "\nEnter number or a subdirectory name:\n> "
     set input [wait_for_enter 1] 
  } else {
     set input $have_input
  }


  # here we have an input
  for { set i 0 } { $i < [llength $dirs] } { incr i 1 } {
     if { [file tail [lindex $dirs $i]] == $input || [lindex $dirs $i] == $input } {
        set input $i 
        incr input $index_start
     }
  }

  # here input contains the number (switch to newdir($input)
  if { $input == ".." }  {
     if { $have_input == "" } {
        puts "go to upper dir ..."
     }
     if { [info exists ts_checktree($CHECK_ACT_PATH)] } {
        set nr $ts_checktree($CHECK_ACT_PATH)
        set updir $ts_checktree($nr,upper_nrs); 
        set CHECK_ACT_PATH $ts_checktree($updir,dir_name)
     }
     return
  }

  if { [info exists newdir($input)] == 1 } {
     if { $have_input == "" } {
        puts "go to dir $newdir($input) ..."
     }
     set CHECK_ACT_PATH "$newdir($input)"
     return
  }

  if { [info exists ts_checktree($input)] == 1 } {
     set CHECK_ACT_PATH $ts_checktree($ts_checktree($input),dir_name)
     return
  }

  # here we try to find check names and dir names
  set matches {}
  # here we try to find a test name
  for {set i 0} {$i< $ts_checktree(act_nr)} {incr i 1} {
     if { $ts_checktree($i,test_available) == 1 } {
        if { $ts_checktree($i,check_name) == $input } {
           set found 0
           foreach elem $matches {
              if { $elem == $i } {
                 set found 1
              }
           }
           if { $found == 0 } {
              lappend matches $i
           }
        }
     }
     if { [file tail $ts_checktree($i,dir_name)] == $input } {
        set found 0
        foreach elem $matches {
           if { $elem == $i } {
              set found 1
           }
        }
        if { $found == 0 } {
           lappend matches $i
        }
     }
  }

  if { [llength $matches] == 1 } {
     set CHECK_ACT_PATH $ts_checktree($matches,dir_name)
     return
  } 

  if { $matches > 1 } {
     puts "found [llength $matches] matches for \"$input\" ..."
     if {[info exists selection]} {
        unset selection
     }
     for {set i 0} {$i< [llength $matches]} {incr i 1} {
        set text ""
        if { $ts_checktree($i,test_available) == 1 } {
           if { $ts_checktree($i,check_name) == $input} {
              set text "check name"
           }
        }
        if { $text == "" } {
           set text "directory name"
        }
        puts " ([expr ( $i + 1 )]) => via $text: $ts_checktree([lindex $matches $i],dir_name)"
        set selection([expr ( $i + 1 )]) $ts_checktree([lindex $matches $i],dir_name)
     }

     puts -nonewline "\nEnter number:\n> "
     set input [wait_for_enter 1] 
     if { [info exists selection($input)] } {
        set CHECK_ACT_PATH $selection($input)
        return
     }
  }
  puts "no match!"
  wait_for_enter
}


#                                                             max. column:     |
#****** check/get_run_level_name() ******
# 
#  NAME
#     get_run_level_name -- ??? 
#
#  SYNOPSIS
#     get_run_level_name { level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_run_level_name { level } {
  
  if { $level >= 400 } {
     return "week"
  }

  if { $level >= 300 } {
     return "day"
  }

  if { $level >= 200 } {
     return "long"
  }

  if { $level >= 100 } {
     return "medium"
  }

  if { $level >= 00 } {
     return "short"
  }
  return ""
}
# time in minutes
proc get_run_level_time { level } {
  
  if { $level >= 400 } {
     return [expr (48 * 60)]
  }

  if { $level >= 300 } {
     return [expr (14 * 60)]
  }

  if { $level >= 200 } {
     return [expr (2 * 60)]
  }

  if { $level >= 100 } {
     return 30
  }

  if { $level >= 00 } {
     return 10
  }
  return 0
}


#                                                             max. column:     |
#****** check/clear_screen() ******
# 
#  NAME
#     clear_screen -- ??? 
#
#  SYNOPSIS
#     clear_screen { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clear_screen {} {
   global CHECK_DEBUG_LEVEL
   if { $CHECK_DEBUG_LEVEL == 0 } {
      set clear_sequence [ format "%c%c%c%c%c%c%c" 0x1b 0x5b 0x48 0x1b 0x5b 0x32 0x4a 0x00 ]
      puts -nonewline $clear_sequence
   } else {
      debug_puts "ignoring clear_screen() call! We are in debug mode!"
   }
}

#                                                             max. column:     |
#****** check/print_menu_header() ******
# 
#  NAME
#     print_menu_header -- ??? 
#
#  SYNOPSIS
#     print_menu_header { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_menu_header {} {
  global CHECK_ACT_PATH CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_BAD_RESULT_DIR 
  global CHECK_MAIN_RESULTS_DIR 
  global CHECK_ENABLED_RUNLEVELS CHECK_PRODUCT_VERSION_NUMBER
  global CHECK_ENABLED_CATEGORIES CHECK_USER CHECK_GROUP
  global ts_checktree
  global ts_config

  set local_host [gethostname]
  clear_screen
  set_users_environment $local_host env 1
  get_version_info
  puts "===============================================================================" 

  puts " system version     :  $CHECK_PRODUCT_VERSION_NUMBER ($ts_config(gridengine_version))"
  puts " feature            :  $ts_config(product_feature)"
  puts " current dir        :  [ format_output "                       " 54 $CHECK_ACT_PATH ]"

  set dirs [ get_checktree_dir_names $CHECK_ACT_PATH ]
  lappend dirs $CHECK_ACT_PATH
  set test_counts ""
  set test_text ""
  set time_count 0
  foreach elem $dirs {
     set test_name ""
     set check_directories [get_tests_from_checktree $elem]
     set count 0
     foreach test $check_directories {
        if { [is_category_enabled $test] == 0 } {
           set run_test_ok 0
           set tests_runlevels [get_checktree_levels $test]
            
           # test if the check was already successful
           set test_name [get_check_name $test]
           set global_test_name $test_name
           foreach tests_runlevel $tests_runlevels {
              if { [ is_level_enabled $tests_runlevel ] == 0 } {
                 set state_text "done"
                 if {![file isfile "$CHECK_RESULT_DIR/$global_test_name.res.$tests_runlevel"]} {
                    set run_test_ok 1
                    incr time_count [get_run_level_time $tests_runlevel] 
                    set state_text "on"
                 }
              } else {
                 set state_text "off"
              }
              if { [string first [get_run_level_name $tests_runlevel] $test_name] < 0 } {
                 append test_name " [get_run_level_name $tests_runlevel]=$state_text"
              }
           }
           if { $run_test_ok == 1 } {
              # we have to run this check
              incr count 1  
           }
        } else {
           set test_name [get_check_name $test]
           append test_name " (category not enabled)"  
        }
     }
     if { $count > 9 } {
        set blank " "
     } else {
        set blank "  "
     }
     lappend test_counts "$count"

     # do we have a test in local directory?
     set we_have_a_test 0
     if { [info exists ts_checktree($CHECK_ACT_PATH)] } {
        set nr $ts_checktree($CHECK_ACT_PATH)
        if { $ts_checktree($nr,test_available) == 1 } {
           set we_have_a_test 1
        }
     }

     if { $elem == $CHECK_ACT_PATH } {
        if { $we_have_a_test == 1 } {
           lappend test_text   " test name: $test_name"
        }
     } else {
        if { $elem != $CHECK_ACT_PATH } {
           lappend test_text   "${blank}${count} test(s) available in subdir: [file tail $elem]"
        }
     }
  }

  set test_count [llength $test_counts]
  puts "==============================================================================="


  set possible_levels ""

  foreach elem [get_checktree_max_level_count $CHECK_ACT_PATH] {
     set a_level [ get_run_level_name $elem ] 
     if { [string first $a_level $possible_levels ] < 0 } {
        set possible_levels "$possible_levels $a_level"
     } 
  }
  set possible_levels [lsort $possible_levels]
  puts " max. runlevel      :  $possible_levels"  

  set selected_levels ""
  set CHECK_ENABLED_RUNLEVELS [ lsort $CHECK_ENABLED_RUNLEVELS  ]
  foreach elem $CHECK_ENABLED_RUNLEVELS {
     set a_level [ get_run_level_name $elem ] 

     if { [string first $a_level $selected_levels ] < 0 } {
        set selected_levels "$selected_levels $a_level"
     } 
  } 

  set selected_levels [ lsort $selected_levels ]
  puts " selected runlevels :  $selected_levels"
  set my_cats [get_checktree_categories $CHECK_ACT_PATH]
  puts -nonewline " categories         :  "
  foreach elem $my_cats {
     puts -nonewline "$elem "
  }
  puts ""

  puts -nonewline " selected categories:  "
  set CHECK_ENABLED_CATEGORIES [ lsort $CHECK_ENABLED_CATEGORIES]
  foreach elem $CHECK_ENABLED_CATEGORIES {
     puts -nonewline "$elem "
  }
  puts ""
  set hours [ expr ( $time_count / 60 ) ]
  set minutes [ expr (  $time_count % 60 ) ]
  puts " est. run time      :  $hours h $minutes m"
  puts "===============================================================================" 
  foreach elem $test_text {
     puts $elem
  }
  puts "===============================================================================" 
}

#                                                             max. column:     |
#****** check/wait_for_enter() ******
# 
#  NAME
#     wait_for_enter -- wait for the user to press any keys
#
#  SYNOPSIS
#     wait_for_enter {{no_text 0} {second_try 0}} 
#
#  FUNCTION
#     Wait for the user to press enter.
#     If the user entered text before enter, this text will be returned.
#
#  INPUTS
#      {no_text 0} - 0: will output "press enter" before waiting
#                    1: output nothing
#
#  RESULT
#     The string the user entered, or "", if he just pressed enter.
#*******************************
proc wait_for_enter {{no_text 0} {second_try 0}} {
   global CHECK_OUTPUT
   global ts_config
   flush $CHECK_OUTPUT

   set have_config 1
   if { [info exists ts_config(testsuite_root_dir)] == 0 } {
      set have_config 0
   }

   # output some message
   if {$no_text == 0} {
      puts "\npress enter..."
   }

   # wait for the user to press enter
   if { $have_config == 0 || $ts_config(testsuite_root_dir) == "" } {
      set current_dir [pwd]
      debug_puts "ts config not set, using current directory ($current_dir) for testsuite_root_dir"
      set wait_script "$current_dir/scripts/wait_for_enter.sh"
   } else {
      set wait_script "$ts_config(testsuite_root_dir)/scripts/wait_for_enter.sh"
   }


   set output ""
   set en_result [catch { set output [eval exec $wait_script] } catch_output]

   # if wait_for_enter.sh cannot be executed (e.g. due to incorrect file permissions),
   # exit testsuite.
   # For example netbeans checkout will not set the correct file permissions (strip the x flag).
   if {$en_result != 0} {
      if {$second_try} {
         # if we already tried to fix the problem, but it still fails: exit
         puts "error executing $wait_script"
         exit 1
      } else {
         # try to fix file permissions and retry wait_for_enter
         file attributes $wait_script -permissions 00755
         return [wait_for_enter $no_text 1]
      }
   }

   return [string trim $output]
}

#                                                             max. column:     |
#****** check/wait_for_start_time() ******
# 
#  NAME
#     wait_for_start_time -- ??? 
#
#  SYNOPSIS
#     wait_for_start_time { substring } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     substring - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_start_time { substring } {
   puts "wait for start time: \"$substring\""
   while { 1 } {
      set date_output [ exec date "+%D %H:%M" ]
      puts -nonewline "\r$date_output"
      flush stdout
      if { [string compare $date_output $substring] == 0 } {
         break; 
      }
      sleep 30
   }
   puts ""
}

# returns -1: error
# returns 0 : no error
proc prepare_packages { } {
   global CHECK_PACKAGE_DIRECTORY CHECK_OUTPUT CHECK_DEFAULTS_FILE
   global CHECK_JOB_OUTPUT_DIR CHECK_PACKAGE_TYPE
   global CHECK_USER CHECK_PRODUCT_TYPE CHECK_PROTOCOL_DIR
   global CHECK_GROUP check_name CHECK_CUR_PROC_NAME
   global ts_config

   set check_name "prepare_packages"
   set CHECK_CUR_PROC_NAME "prepare_packages"
   set local_host [gethostname]


   #do pre checks like in compile
   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           return -1
      } 
   }

   set have_tar 0
   set have_zip 0
   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_tar ] == 0 } {
      puts $CHECK_OUTPUT "found tar files"
      set have_tar 1
   }

   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_zip ] == 0 } {
      puts $CHECK_OUTPUT "found zip files"
      set have_zip 1
   }

   if { $have_tar == 0 && $CHECK_PACKAGE_TYPE == "tar" } {
      add_proc_error "prepare_packages" -1 "not all tar files available"
      return -1
   }

   if { $have_zip == 0 && $CHECK_PACKAGE_TYPE == "zip" } {
      add_proc_error "prepare_packages" -1 "not all zip files available"
      return -1
   }


   if { $have_tar == 1 && $CHECK_PACKAGE_TYPE == "tar" } {

      # shutdown eventually running system
      shutdown_core_system

      set tar_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both tar ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$ts_config(product_root)/$ts_config(cell)/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$ts_config(product_root)/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$ts_config(product_root)\" to testsuite_trash"
      if { [delete_directory "$ts_config(product_root)"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $ts_config(product_root) directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$ts_config(product_root)"  } result
      puts $result
      catch { exec "chmod" "755" "$ts_config(product_root)"  } result
      puts $result

      catch { file mkdir "$ts_config(product_root)/$ts_config(cell)" } 
      catch { file mkdir "$ts_config(product_root)/$ts_config(cell)/common" } 

      # copy pos. host_aliases file to new product root /cell/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$ts_config(product_root)/$ts_config(cell)/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $ts_config(product_root)
      } 
      puts $CHECK_OUTPUT ""

      # gunzip package files
      puts $CHECK_OUTPUT "gunzip package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "gunzip" "$ts_config(product_root)/$file"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # extract package files
      puts $CHECK_OUTPUT "extract package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         set result [start_remote_prog $local_host $CHECK_USER "tar" "-xvf $file_no_gz" prg_exit_state 60 0 $ts_config(product_root)]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""
     
      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $tar_files { 
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         delete_file $ts_config(product_root)/$file_no_gz
      } 
      puts $CHECK_OUTPUT ""

      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $ts_config(product_root)/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $ts_config(product_root)/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $ts_config(product_root)/utilbin ]
      
      set local_host_arch [ resolve_arch $local_host ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $local_host not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $ts_config(execd_hosts) {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in tar files, please add tar file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for tar architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   if { $have_zip == 1 && $CHECK_PACKAGE_TYPE == "zip" } {

      # shutdown eventually running system
      shutdown_core_system

      set zip_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both zip ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$ts_config(product_root)/$ts_config(cell)/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$ts_config(product_root)/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$ts_config(product_root)\" to testsuite_trash"
      if { [delete_directory "$ts_config(product_root)"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $ts_config(product_root) directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$ts_config(product_root)"  } result
      puts $result
      catch { exec "chmod" "755" "$ts_config(product_root)"  } result
      puts $result

      catch { file mkdir "$ts_config(product_root)/$ts_config(cell)" } 
      catch { file mkdir "$ts_config(product_root)/$ts_config(cell)/common" } 

      # copy pos. host_aliases file to new product root /$SGE_CELL/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$ts_config(product_root)/$ts_config(cell)/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      if { [catch { file mkdir "$ts_config(product_root)/tmp_zip_copy" }] != 0 } {
         puts $CHECK_OUTPUT "could not create directory \"$ts_config(product_root)/tmp_zip_copy\""
         return -1    
      }
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $ts_config(product_root)/tmp_zip_copy
      } 
      puts $CHECK_OUTPUT ""

      
      # unzip package files
      puts $CHECK_OUTPUT "unzip package files ..."
      set i 0
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "unzip" "$ts_config(product_root)/tmp_zip_copy/$file" "-d" "$ts_config(product_root)/tmp_zip_copy"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $zip_files { 
         delete_file $ts_config(product_root)/tmp_zip_copy/$file
      } 
      puts $CHECK_OUTPUT ""


      # now check if packages are already installed and remove installed ones
      set package_names [ get_dir_names $ts_config(product_root)/tmp_zip_copy ]
      puts -nonewline $CHECK_OUTPUT "Found following packages:"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT " $pkg" 
      }
      puts $CHECK_OUTPUT "\n"
      set user_key "unknown"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT "Checking if package \"$pkg\" is already installed on host \"$local_host\" ... "
         set output [start_remote_prog $local_host "root" "pkginfo" "$pkg"]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT "not installed"
         } else {
            puts $CHECK_OUTPUT "already installed."
            puts $CHECK_OUTPUT "\n$output\n"
            puts $CHECK_OUTPUT "Press \"yes\" to uninstall ALL packages listed above or \"no\" to continue ..."
            if { $user_key == "unknown" } {
               set user_key [ wait_for_enter 1 ]
            }
            if { $user_key == "yes" } {
               puts $CHECK_OUTPUT "removing package \"$pkg\" ..."
               set output [start_remote_prog $local_host "root" "pkgrm" "-n $pkg"]
               puts $CHECK_OUTPUT $output
               if { $prg_exit_state != 0 } {
                  puts $CHECK_OUTPUT "error uninstalling package \"$pkg\""
                   puts $CHECK_OUTPUT "stop package installation"
                   return -1
               }
            } else {
               puts $CHECK_OUTPUT "will NOT remove package \"\""
               puts $CHECK_OUTPUT "stop package installation"
               return -1
            }
         }
      }
      
      # now install the packages ...
      set send_speed .1
      set send_slow "1 $send_speed"
      foreach pkg $package_names {
         set id [open_remote_spawn_process "$local_host" "root" "pkgadd" "-d $ts_config(product_root)/tmp_zip_copy $pkg" ]
         log_user 1
         set sp_id [ lindex $id 1 ]
         set timeout 60
         set do_stop 0
         set exit_state 1
         while { $do_stop == 0 } {
            flush $CHECK_OUTPUT
            expect {
               -i $sp_id full_buffer { 
                  add_proc_error "prepare_packages" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id timeout {
                  add_proc_error "prepare_packages" -1 "unexpected timeout"
                  close_spawn_process $id
                  return -1
               } 
               -i $sp_id eof {
                  set exit_state [close_spawn_process $id]
                  set do_stop 1
               } 
               -i $sp_id "_exit_status_:*\n" {
                  set buf $expect_out(buffer)
                  set s_start [ string first "(" $buf ]
                  set s_end [ string first ")" $buf ]
                  incr s_start 1
                  incr s_end -1
                  set exit_state [ string range $buf $s_start $s_end ]
                  puts $CHECK_OUTPUT "exit state is: \"$exit_state\""
                  close_spawn_process $id
                  set do_stop 1
               }
               -i $sp_id "default /gridware/sge*]" {
                  flush $CHECK_OUTPUT
                  if { [ string length $ts_config(product_root) ] >= 5  } {
                     send -s -i $sp_id "$ts_config(product_root)\n"
                  } else {
                     add_proc_error "prepare_packages" -1 "can't use product root directory (shorter than 5 chars)"
                     close_spawn_process $id
                     return -1
                  }
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "default sgeadmin*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "$CHECK_USER\n"   
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Do you want to install these as setuid/setgid files*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "y\n"   
                  flush $CHECK_OUTPUT
               }


               -i $sp_id "default adm*]" {
                  send -s -i $sp_id "$CHECK_GROUP\n"
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Waiting for pkgadd of*" {
                  add_proc_error "prepare_packages" -1 "$local_host: another pkgadd session is running...\n$expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id "*\n" { 
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id default {
                  add_proc_error "prepare_packages" -1 "undefined behaviour: $expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               } 
            }
         }
         if { $exit_state != 0 } {
            add_proc_error "prepare_packages" -1 "exit state of pgkadd \"$pkg\" is $exit_state -> error"
            return -1
         }
      }
           



      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $ts_config(product_root)/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $ts_config(product_root)/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $ts_config(product_root)/utilbin ]
      
      set local_host_arch [ resolve_arch $local_host ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $local_host not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $ts_config(execd_hosts) {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in zip files, please add zip file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for zip architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   return -1
}
# mode : check_both, check_tar, check_zip
# get_files : no, tar, zip
proc check_packages_directory { path { mode "check_both" } { get_files "no" } } {

   global CHECK_OUTPUT CHECK_PACKAGE_TYPE

   set tar_bin_files [ get_file_names $path "sge*-bin-*.tar.gz" ] 
   set zip_bin_files [ get_file_names $path "sge*-bin-*.zip" ]      
   set tar_common_files [ get_file_names $path "sge*-common*.tar.gz" ] 
   set zip_common_files [ get_file_names $path "sge*-common*.zip" ]   
   set tar_doc_files [ get_file_names $path "sge*-doc*.tar.gz" ] 
   set zip_doc_files [ get_file_names $path "sge*-doc*.zip" ]    

   set tar_list "$tar_bin_files $tar_common_files $tar_doc_files"
   set zip_list "$zip_bin_files $zip_common_files $zip_doc_files"
     

   set nr_tar_bin_files [ llength $tar_bin_files ]
   set nr_zip_bin_files [ llength $zip_bin_files ] 
   set nr_tar_common_files [ llength $tar_common_files ]
   set nr_zip_common_files [ llength $zip_common_files ] 
   set nr_tar_doc_files [ llength $tar_doc_files ]
   set nr_zip_doc_files [ llength $zip_doc_files ] 

   set tar_complete 0
   set zip_complete 0

   if { $tar_bin_files  > 0 && $tar_common_files > 0 && $tar_doc_files > 0 } {
      set tar_complete 1
   }
   if { $zip_bin_files  > 0 && $zip_common_files > 0 && $zip_doc_files > 0 } {
      set zip_complete 1
   }

   if { $get_files == "no" } {
      puts $CHECK_OUTPUT "nr. of binary tar files: $nr_tar_bin_files"
      puts $CHECK_OUTPUT "nr. of binary zip files: $nr_zip_bin_files"
      puts $CHECK_OUTPUT "nr. of common tar files: $nr_tar_common_files"
      puts $CHECK_OUTPUT "nr. of common zip files: $nr_zip_common_files"
      puts $CHECK_OUTPUT "nr. of doc tar files: $nr_tar_doc_files"
      puts $CHECK_OUTPUT "nr. of doc zip files: $nr_zip_doc_files"
      if { $tar_complete == 1 } {
         puts $CHECK_OUTPUT "tar files complete"
      } else {
         puts $CHECK_OUTPUT "tar files INCOMPLETE"
      }
      if { $zip_complete == 1 } {
         puts $CHECK_OUTPUT "zip files complete"
      } else {
         puts $CHECK_OUTPUT "zip files INCOMPLETE"
      }
      
      if { $tar_complete == 1 && $zip_complete == 1 && $mode == "check_both" } {
         return 0
      }
      if { $tar_complete == 1 && $mode == "check_tar" } {
         return 0
      }
      if { $zip_complete == 1 && $mode == "check_zip" } {
         return 0
      }
      return -1
   } else {
      switch -- $get_files {
         "tar" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "tar files incomplete error"
                return ""
             }
             return $tar_list
         }
         "zip" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "zip files incomplete error"
                return ""
             }
             return $zip_list
         } 
      }
   }
   return -1
}

proc build_distribution { arch_list } {
   global CHECK_OUTPUT CHECK_USER
   global ts_config

   set local_host [gethostname]
   if { $ts_config(package_type) == "create_tar" &&
        $ts_config(package_directory) != "none" } {
      
      
      puts $CHECK_OUTPUT "creating tar packages"  
      # distribution will be created using mk_dist
      # figure out which commandline options to use
      set args ""
      append args "-vdir $ts_config(product_root)"             ;# find the distrib here
      append args " -version $ts_config(source_cvs_release)"   ;# for package names
      append args " -basedir $ts_config(package_directory)"    ;# destination dir
      append args " -bin -common"                              ;# which packages

      if { $ts_config(gridengine_version) == 53 } {
         if { $ts_config(product_type) == "sgeee" } {
            append args " -sgeee"
         }
      }

      if { ! [file isdirectory $ts_config(package_directory)] } {
         file mkdir $ts_config(package_directory)
      }

      puts $CHECK_OUTPUT "starting mk_dist $args $arch_list"
      # start mk_dist
      set open_spawn [open_remote_spawn_process $local_host $CHECK_USER "./scripts/mk_dist" "$args $arch_list" 0 $ts_config(source_dir)]
      set sp_id [ lindex $open_spawn 1 ]
      set timeout -1
      set done 0
      while { $done != 1 } {
         expect_user {
            -i $sp_id full_buffer {
               puts $CHECK_OUTPUT "testsuite - compile source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id "_exit_status_" {
               set done 1
            }
            -i $sp_id eof {
               set done 1
            }
            -i $sp_id "*\n" {
               puts $CHECK_OUTPUT $expect_out(0,string)
            }
         }
      }
      close_spawn_process $open_spawn
      puts $CHECK_OUTPUT ""
   }
}

proc install_binaries { arch_list a_report } {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_USER ts_config
   upvar $a_report report

   set local_host [gethostname]
   set was_error 0

   set task_nr [ report_create_task report "install_binaries" $local_host ]
   
   # install to ts_config(product_root)
   if { $ts_config(gridengine_version) == 53 } {
      if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0 } {
         set link_name "myinst"
         set sgeee_param "-sgeee"
      } else {
         set link_name "myinst"
         set sgeee_param ""
      }
   }

   # copy pos. host_aliases file to trash_
   if { [ file isfile "$ts_config(product_root)/$ts_config(cell)/common/host_aliases"] == 1 } {
      report_task_add_message report $task_nr "saving host_aliases file ..."
      catch { exec "cp" "$ts_config(product_root)/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
      puts $result
      report_task_add_message report $task_nr $result
   } 

   # now delete install directory
   report_task_add_message report $task_nr "moving directory \"$ts_config(product_root)\" to testsuite_trash"
   if { [delete_directory "$ts_config(product_root)"] != 0 } {
      add_proc_error "compile_source" -2 "could not delete $ts_config(product_root) directory, critical error - stop"
      report_task_add_message report $task_nr "could not delete $ts_config(product_root) directory, critical error - stop"
      report_finish_task report $task_nr -1
      return -1
   }
 
   # wait for nfs updates
   puts $CHECK_OUTPUT "waiting for nfs ..."
   after 5000
   puts $CHECK_OUTPUT "starting installation ..."
   

   catch { exec "mkdir" "$ts_config(product_root)"  } result
   report_task_add_message report $task_nr $result
   catch { exec "touch" "$ts_config(product_root)"  } result
   report_task_add_message report $task_nr $result
   catch { exec "chmod" "755" "$ts_config(product_root)"  } result
   report_task_add_message report $task_nr $result
 
   if { $ts_config(gridengine_version) == 53 } {
      report_task_add_message report $task_nr "\ncreating link \"$link_name\""
      set return_state [ catch { eval exec ln -s $ts_config(source_dir)/scripts/distinst $ts_config(source_dir)/$link_name } output ]
   }

 
   report_task_add_message report $task_nr "\ninstalling product binaries"
  
   set inst_env(SGE_ROOT) $ts_config(product_root)

   if { [ string compare "none" $ts_config(dist_install_options) ] == 0  } {
      set dist_inst_options ""
   } else {
      set dist_inst_options $ts_config(dist_install_options)
   }

   if { $ts_config(gridengine_version) == 53 } {
      set open_spawn [open_remote_spawn_process $local_host $CHECK_USER "./$link_name" "$sgeee_param $dist_inst_options $arch_list" 0 $ts_config(source_dir) inst_env]
   } else {
      set open_spawn [open_remote_spawn_process $local_host $CHECK_USER "./scripts/distinst" "-local -noexit $dist_inst_options $arch_list" 0 $ts_config(source_dir) inst_env]
   }
   set sp_id [ lindex $open_spawn 1 ]
   set timeout -1
   set done 0
   puts -nonewline $CHECK_OUTPUT "installing "
   while { $done != 1 } {
      expect_user {
         -i $sp_id full_buffer {
            report_task_add_message report $task_nr "testsuite - compile source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "Base directory:" {
             ts_send $sp_id "y\n"
         }
         -i $sp_id "overriding mode" {
             ts_send $sp_id "y\n"
         }
         -i $sp_id "_exit_status_" {
            set done 1
         }
         -i $sp_id eof {
            set done 1
         }
         -i $sp_id "*\n" {
            report_task_add_message report $task_nr $expect_out(0,string)
            puts -nonewline $CHECK_OUTPUT "."
            flush $CHECK_OUTPUT
         }
      }
   }
   close_spawn_process $open_spawn
   puts $CHECK_OUTPUT " done"
   puts $CHECK_OUTPUT ""

   foreach elem $ts_config(execd_hosts) {
      set host_arch [ resolve_arch $elem 1]
      if { ([string compare $host_arch ""] != 0) && ([string compare $host_arch "unknown" ] != 0) } {
         report_task_add_message report $task_nr " arch on host $elem is $host_arch - successfully installed binaries"
      } else {
         report_task_add_message report $task_nr " error installing binaries for host $elem"
         set was_error 1
      }
   }

   catch { file mkdir "$ts_config(product_root)/man" } 
   catch { file mkdir "$ts_config(product_root)/catman" } 
   catch { file mkdir "$ts_config(product_root)/$ts_config(cell)" } 
   catch { file mkdir "$ts_config(product_root)/$ts_config(cell)/common" } 

  
   # copy pos. host_aliases file to new product root /$SGE_CELL/common
   if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 } {
        report_task_add_message report $task_nr "restoring host_aliases file ..."
        catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$ts_config(product_root)/$ts_config(cell)/common/host_aliases" } result
        report_task_add_message report $task_nr $result
   }
  
   # copy source/dist/util/arch to $SGE_ROOT/util.
   # When we compiled our own binaries (including non distributed architectures like 
   # lx26-x86 or hp11-64, source/dist/util/arch will give us the correct arch strings.
   set arch_script_src "$ts_config(source_dir)/dist/util/arch"
   set arch_script_dst "$ts_config(product_root)/util/arch"
   report_task_add_message report $task_nr "installing $arch_script_src ..."
   catch { exec cp $arch_script_src $arch_script_dst} result
 
   # done - final error handling
   if { $was_error } {
      report_finish_task report $task_nr -1
   } else {
      report_finish_task report $task_nr 0
   }
   return $was_error
}

#****** check/update_source() ******************************************************
#  NAME
#    update_source()
#
#  SYNOPSIS
#    update_source { a_html_body } 
#
#  FUNCTION
#     Updates the sources at ts_config(source_dir)
#     The cvs commands is executed at $ts_config(source_cvs_hostname)
#     For the result a report is emailed
#  INPUTS
#    a_html_body   -- html body where error messages will be appended
#    a_mail_body   -- mail body where error messages will be appended
#  RESULT
#     0  --  no update has been executed
#     1  --  update has been executed 
#     <0 --  failure 
#  EXAMPLE
#
#
#  NOTES
#     calls exit if the sources of the testsuite are updated
#
#  BUGS
#
#  SEE ALSO
#     check/compile_source
#******
proc update_source { a_report do_only_hooks } {
   global do_not_update 
   global ts_config
   global CHECK_OUTPUT 
   global CHECK_USER
   upvar $a_report report
   
   if { $do_not_update == 0 } {
      if { $do_only_hooks == 0 } {
         set tries 1
         set output ""
         set update_ok 0
         set prg_exit_state 0
         set conflict_files {}
         
         set task_nr [report_create_task report "cvs_update" $ts_config(source_cvs_hostname)]

         puts $CHECK_OUTPUT "updating sources (-q -z 9 update -dP) ..."
         
         while { $tries <= 3 && $update_ok == 0 } {
            
            report_task_add_message report $task_nr "------------------------------------------"
            report_task_add_message report $task_nr "$tries. cvs update try ..."
            report_task_add_message report $task_nr "updating gridengine directory $ts_config(source_dir)/.. on host $ts_config(source_cvs_hostname) ..."
            
            set open_spawn [open_remote_spawn_process $ts_config(source_cvs_hostname) $CHECK_USER "cvs" "-q -z 9 update -dP" 0 "$ts_config(source_dir)/.."]
            set spawn_list [lindex $open_spawn 1]
            
            set frame_work_script_update 0
            set testsuite_update 0
            set cvs_change_log ""
            
            set cvs_output [ open "$ts_config(source_dir)/cvs_update.log.[timestamp]" "w" ]
            
            set use_output 0
            set timeout 600

            expect {
               -i $spawn_list full_buffer {
                  report_task_add_message report $task_nr "full_buffer error on cvs update"
               }
               -i $spawn_list timeout {
                  report_task_add_message report $task_nr "got timeout on cvs update"
               }
               -i $spawn_list eof {
                  report_task_add_message report $task_nr "got eof on cvs update"
               }
               -i $spawn_list "_exit_status_:(*)" {  
                  set use_output 0
                  set prg_exit_state [get_string_value_between "_exit_status_:(" ")" $expect_out(0,string)]
                  report_task_add_message report $task_nr "cvs update exited with status $prg_exit_state"
                  if { $prg_exit_state != 0 } {
                     set update_ok 0
                  } else {
                     set update_ok 1
                  }
               }
               -i $spawn_list "_start_mark_:(0)" {
                  set use_output 1
                  report_task_add_message report $task_nr "cd $ts_config(source_dir)/.. ; cvs -q -z 9 update -dP"
                  exp_continue
               }
               -i $spawn_list -re {^C .*?\n} { ;# conflict files
                  if { $use_output == 1 } {
                     set elem [string trimright $expect_out(buffer) "\n\r"]
                     report_task_add_message report $task_nr "$elem"
                     
                     set len [string length $elem]
                     set confict_file [string range $elem 2 $len]
                     lappend conflict_files $confict_file
                  }
                  exp_continue
               }
               -i $spawn_list -re {^.*?\n} {
                  if { $use_output } {
                     set elem [string trimright $expect_out(buffer) "\n\r"]
                     report_task_add_message report $task_nr "$elem"
                     puts $cvs_output "$elem"

                     if { ([string range $elem 0 2 ] != "cvs") && ([string range $elem 0 0] != "?") } {
                        report_task_add_message report $task_nr "$elem"
                        append cvs_change_log "$elem\n"
                        if { [ string first "testsuite/check.exp" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
                           set frame_work_script_update 1
                        }
                        if { [ string first "testsuite/tcl_files" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
                           set testsuite_update 1
                        }
                     }
                  }
                  exp_continue
               }
            }

            flush $cvs_output
            close $cvs_output
            close_spawn_process $open_spawn
            incr tries 1
            if { [ llength $conflict_files ] > 0 } {
               # we have conflict do not continue
               break
            }
            if { $update_ok == 0 } {
               sleep 60
            }
         }

         if { [llength $conflict_files] > 0 } {
            report_add_message report "CVS Update Error: The following files contains conflicts:\n"
            foreach elem $conflict_files {
               report_add_message report "   $elem"
            }
            report_add_message report "\n Please resolve these conflicts!!!\n"
            report_finish_task report $task_nr -1
            return -1
         }
         
         if { $update_ok != 1 } {
            report_add_message report "CVS Update Error: cvs update failed three times!!!\n"
            report_finish_task report $task_nr -1
            return -1
         }

         # if the testsuite itself has been update, require restart
         if { $frame_work_script_update == 1 } {
            report_add_message report "CVS Update: TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!\n"
            report_finish_task report $task_nr 0
            report_finish report 0
            exit 1 
         }
         if { $testsuite_update == 1 } {
            report_add_message report "CVS Update Warning: testsuite source procedures were updated!!!"
            report_add_message report "                    Resourcing it !!!\n"
         }
         report_finish_task report $task_nr 0

         # TODO: next task is update additional checktree sources (see issue#82 issue#141)
         return 1
      } else {
         puts $CHECK_OUTPUT "Skip GE cvs update , I am on do_only_hooks mode"
         
         # TODO: only update additional checktree sources (see issue#82 issue#141)
         return 1
      }
   } else {
      return 0
   }
}

#                                                             max. column:     |
#****** check/run_all_at_starttime() ******
# 
#  NAME
#     run_all_at_starttime -- ??? 
#
#  SYNOPSIS
#     run_all_at_starttime { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_all_at_starttime {} {
   global CHECK_ACT_PATH CHECK_REPORT_FILE ts_config

   set start_time 0
   set should_we_compile 0

   print_menu_header
   if { [ ask_user_yes_or_no " Do you want to enter a special starttime (y/N) ? " ] } {
      puts "\n now it is: [exec date "+%D %H:%M" ]"
      set start_time [ get_user_input "    Please enter start time : " ]
      puts "\n testsuite will start at \"$start_time\""
   } else {
      
      puts "\n testsuite will run continuously"
   }

   if { [ ask_user_yes_or_no "\n\n Should the testsuite update, compile and install before testing (y/N) ? " ] } {
      set should_we_compile 1
      puts "\n testsuite will update, compile and install the latest source code"
   } else {
      puts "\n testsuite will use the current installation"
   }

   if { [ ask_user_yes_or_no "\n\n Are this settings correct (y/N) ? " ] == 0 } {
      puts "\n testsuite will return to the main menue, please"
      return
   }

   set_root_passwd
 

   if { $start_time != 0 } {
      wait_for_start_time $start_time
   }
   delete_tests $CHECK_ACT_PATH
   if { $should_we_compile == 1 } {
#     remove_old_cvs_tree
      set back [ compile_source ]
      if { $back != 0 } {
         puts "error in compile source - stop"
         exit -1
      }
      set saved_path $CHECK_ACT_PATH
      set CHECK_ACT_PATH "$ts_config(checktree_root_dir)/install_core_system"
      set back [ run_test $CHECK_ACT_PATH 1 ]
      if { $back != 0 } {
         puts "error in test install_core_system - stop"
         exit -1
      }
      set CHECK_ACT_PATH $saved_path
   }
   run_tests $CHECK_ACT_PATH 0
   create_report ${CHECK_REPORT_FILE}.ok 0
   create_report ${CHECK_REPORT_FILE}.failed 1

   wait_for_enter
}

#****** check/do_wait() ********************************************************
#  NAME
#     do_wait() -- wait for x seconds (and print .)
#
#  SYNOPSIS
#     do_wait { time } 
#
#  INPUTS
#     time - time in seconds
#
#*******************************************************************************
proc do_wait { time } {

   set timestart [ timestamp ]
   while { 1 } {
       if { [ expr ( [ timestamp  ] - $timestart ) ] >= $time } {
         puts ""
         return
       }
       puts -nonewline "."
       flush stdout
       sleep 1
   }
}

#                                                             max. column:     |
#****** check/get_user_input() ******
# 
#  NAME
#     get_user_input -- ??? 
#
#  SYNOPSIS
#     get_user_input { what } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     what - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_user_input { what } {
   puts -nonewline $what
   flush stdout 
   set myinput [wait_for_enter 1]
   return $myinput
}


#****** check/restart_debug_daemons() ******************************************
#  NAME
#     restart_debug_daemons() -- used for menu point 20/21
#
#  SYNOPSIS
#     restart_debug_daemons { { shutdown 0 } } 
#
#  FUNCTION
#     This procedure will shutdown and restart the qmaster and scheduler
#
#  INPUTS
#     { shutdown 0 } - 0 -> do shutdown (otherwise only do starup)
#
#*******************************************************************************
proc restart_debug_daemons { { shutdown 0 } } {
   global daemon_debug master_debug schedd_debug
   global ts_config

   if { [ have_root_passwd ] != 0 } {
      set_root_passwd
   }
   if { $shutdown == 0 } {
      set spooldir [get_qmaster_spool_dir]
      shutdown_master_and_scheduler $ts_config(master_host) $spooldir
   }
   startup_qmaster 
   wait_for_load_from_all_queues 300 
}

#                                                             max. column:     |
#****** check/ask_user_yes_or_no() ******
# 
#  NAME
#     ask_user_yes_or_no -- ??? 
#
#  SYNOPSIS
#     ask_user_yes_or_no { question } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     question - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc ask_user_yes_or_no { question } {
  
   puts -nonewline $question
   flush stdout 
   set myinput [wait_for_enter 1]

   if { [ string compare -nocase $myinput "yes" ] == 0 } {
       return 1
   }
   if { [ string compare -nocase $myinput "y" ] == 0 } {
       return 1
   }
   return 0
}

# select action
#                                                             max. column:     |
#****** check/menu() ******
# 
#  NAME
#     menu -- ??? 
#
#  SYNOPSIS
#     menu { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc menu {} {
  global CHECK_ACT_PATH CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_BAD_RESULT_DIR 
  global CHECK_MAIN_RESULTS_DIR 
  global CHECK_ENABLED_RUNLEVELS CHECK_PRODUCT_VERSION_NUMBER CHECK_SETUP_NAMES
  global daemon_debug CHECK_DEBUG_LEVEL CHECK_DEFAULTS_FILE CHECK_DO_SETUP
  global CHECK_PACKAGE_DIRECTORY CHECK_SETUP_CHANGES CHECK_PACKAGE_TYPE
  global check_reinit_on_tcl_error ts_checktree CHECK_ENABLED_CATEGORIES ts_config
   global CHECK_INTERRUPT

  set local_host [gethostname]
  delete_temp_script_files

   while {1} {

  print_menu_header
 
  puts "  (0) select runlevels/categories"
  puts "  (2) run not completed tests (including subdirectories)"
  puts "  (3) show test descriptions"
  puts "  (4) exit (press ^C to exit without shutdown of the cluster)"
  puts "  (5) show completed test list"
  puts "  (6) show not completed test list"
  puts "  (7) reset completed test list (for all subdirectories)"
  puts "  (8) create check report"
  puts "  (9) run all tests at a special starttime"
  if {[string compare "stdout" $CHECK_OUTPUT] == 0} {
     puts " (10) use file \"${local_host}.checklog\" for output" 
  } else {
     puts " (10) use \"stdout\" for output"
  }

  set localtest -1
  if {[info exists ts_checktree($CHECK_ACT_PATH)]} {
     set local_dir_nr $ts_checktree($CHECK_ACT_PATH)
     if {$ts_checktree($local_dir_nr,test_available) == 1} {
        set localtest 0
     }
  }

  if { $localtest >= 0 } {
    puts " (11) show test descriptions of local test"
    puts " (12) run local test"
    puts " (13) run local test continously"
  }
    puts "===============================================================================" 
    puts " (19) install system"
    puts " (20) shutdown and restart master and scheduler"
    puts " (21) only start master and scheduler daemons"
    puts " (22) check messages files of execds and qmaster"
    if { $CHECK_PACKAGE_DIRECTORY == "none" } {
       puts " (23) compile source code and pre install binaries"
    } else {
       puts " (23) install product packages"
    }
    puts " (24) do (23), then (2)"
    puts " (25) set testsuite debug level (current value: $CHECK_DEBUG_LEVEL)"
    puts " (26) enter testsuite setup" 
    puts " (27) set command line options"
    puts " (28) restart cluster"
    puts " (29) check spool directory content"
    puts " (30) re-read checktree and re-source tcl-files"
    puts " (31) search for old sge_processes on configured hosts"
    puts " (32) dump status of all rlogin connections"
    puts " (33) close all rlogin connections"
    puts " (40) initialize code coverage checking"
    puts " (41) delete code coverage data"
    puts " (42) dump code coverage analysis"
    puts " (50) only compile hooks and pre install"
    puts " (51) run shutdown hooks"

   puts "\nYou can select a menu number,"
   puts "enter a relative/absolute path or \"..\" to switch the directory."
   puts "You can also enter a test name to switch directly to the test directory."
   puts -nonewline "\n> "

  set input [wait_for_enter 1]; 

#  clear_screen

  switch -- $input {
     "19" {
           if { [have_root_passwd] == -1 } {
              puts $CHECK_OUTPUT "need root access ..."
              set_root_passwd
           }

           # first install additional clusters
           operate_additional_clusters install

           # now start all checks with INSTALL category
           set org_categories $CHECK_ENABLED_CATEGORIES
           set CHECK_ENABLED_CATEGORIES "INSTALL"
           set runcompleted 1
           run_tests "root" $runcompleted
           set CHECK_ENABLED_CATEGORIES $org_categories
           wait_for_enter
         }
    "20" { restart_debug_daemons } 
    "21" { restart_debug_daemons 1 }
    "22" { set output [check_messages_files]
           puts $CHECK_OUTPUT $output
           wait_for_enter
         }
    "23" { 
            if {[have_root_passwd] == -1} {
               puts $CHECK_OUTPUT "need root access ..."
               set_root_passwd
            }

            if {$ts_config(package_directory) == "none" ||
                $ts_config(package_type) == "create_tar"} {
               # we compile the source and do a scripts/distinst
               set back [compile_source]
                
                if {$back != 0} {
                   puts "--> error compiling and pre installing source code"
                } else {
                   puts "--> source code compiled and pre installed"
                }
                wait_for_enter
                
            } else {
               # we have product packages
                set back [prepare_packages]
                if { $back != 0 } {
                   puts "--> error installing product packages"
                } else {
                   puts "--> product packages pre installed"
                }
                wait_for_enter
            }
            
         }
    "24" {
          if { [have_root_passwd] == -1 } {
                puts $CHECK_OUTPUT "need root access ..."
                set_root_passwd
           }
           set back [compile_source]
           if { $back != 0 } {
              puts "--> error compiling and pre installing source code"
              wait_for_enter
           } else {
              puts "--> source code compiled and pre installed"
              run_tests $CHECK_ACT_PATH 0
              wait_for_enter
           }
         }
    "25" {  incr CHECK_DEBUG_LEVEL 1 
            if  { $CHECK_DEBUG_LEVEL > 2 } {
               set CHECK_DEBUG_LEVEL 0
            }
         }
    "26" {
            modify_setup2
            source_tcl_files
            build_checktree
            wait_for_enter
         }
    "27" {
         set_command_line_options
    }
    "28" {
         startup_core_system 0 1
         wait_for_enter
    }
    "29" {
         check_local_spool_directories 1
         wait_for_enter
    }
    "30" {
         source_tcl_files
         build_checktree
         wait_for_enter
    }
    "31" {
         seek_and_destroy_sge_processes
    }
    "32" {
         dump_spawn_rlogin_sessions
         wait_for_enter
    }
    "33" {
         close_open_rlogin_sessions
         wait_for_enter
    }
    "40" {
         coverage_initialize
         wait_for_enter
    }
    "41" {
         coverage_initialize 1
         wait_for_enter
    }
    "42" {
         coverage_analyis
         wait_for_enter
    }
    "50" {
         if { [have_root_passwd] == -1 } {
            puts $CHECK_OUTPUT "need root access ..."
            set_root_passwd
         }
         set back [compile_source 1]
          
         if { $back != 0 } {
            puts "--> error compiling and pre installing source code"
         } else {
            puts "--> source code compiled and pre installed"
         }
         wait_for_enter
    }
    "51" {
         if { [have_root_passwd] == -1 } {
               puts $CHECK_OUTPUT "need root access ..."
               set_root_passwd
         }
         shutdown_core_system 1 0
         wait_for_enter
    }
    "0" { select_runlevel }
    "2" { set saved_check_reinit_on_tcl_error $check_reinit_on_tcl_error 
          set check_reinit_on_tcl_error 1
          run_tests $CHECK_ACT_PATH 0
          set check_reinit_on_tcl_error $saved_check_reinit_on_tcl_error
          set CHECK_INTERRUPT 0
          wait_for_enter
        }
    "3" { show_tests $CHECK_ACT_PATH 1
        }
    "4" { puts "bye!\n"
          shutdown_core_system 0 1
          if {[string compare "stdout" $CHECK_OUTPUT] != 0} {
             close $CHECK_OUTPUT
          }
          exit 0
        }
    "5" {
          set total [print_results $CHECK_RESULT_DIR stdout]
          puts stdout "Total number of test functions: $total"
          wait_for_enter
        }
    "6" {
          set total [print_results $CHECK_BAD_RESULT_DIR stdout]
          puts stdout "Total number of test functions: $total"
          wait_for_enter
        }
    "7" { delete_tests $CHECK_ACT_PATH
          wait_for_enter
        }
    "8" {
          if {[file isfile "${CHECK_REPORT_FILE}.ok"] == 1} {
             delete_file "${CHECK_REPORT_FILE}.ok"
          }
          if {[file isfile "${CHECK_REPORT_FILE}.failed"] == 1} {
             delete_file "${CHECK_REPORT_FILE}.failed"
          }
          create_report "${CHECK_REPORT_FILE}.ok" 0
          create_report "${CHECK_REPORT_FILE}.failed"  1
          wait_for_enter
        }
    "9" {
          run_all_at_starttime
          set CHECK_INTERRUPT 0
          wait_for_enter
        }
    "10" {
           if {[string compare "stdout" $CHECK_OUTPUT] == 0} {
              set CHECK_OUTPUT [open "$CHECK_MAIN_RESULTS_DIR/$local_host.checklog" "w"]  
           } else {
              close $CHECK_OUTPUT
              set CHECK_OUTPUT stdout
           }
         }
    "11" {
          if {$localtest >= 0} {
             puts "local test description ..."
             show_test $CHECK_ACT_PATH 1
             wait_for_enter
          }
        }
    "12" {
          if {$localtest >= 0} {
            puts "running local test ..."
            run_test $CHECK_ACT_PATH 1
            set CHECK_INTERRUPT 0
            wait_for_enter
          }
         }
    "13" {
            if {$localtest >= 0} {
               while {$CHECK_INTERRUPT == 0} {
                  puts "running local test ..."
                  run_test $CHECK_ACT_PATH 1
                  create_report ${CHECK_REPORT_FILE}.ok 0
                  create_report ${CHECK_REPORT_FILE}.failed 1
               }
               set CHECK_INTERRUPT 0
            }
         }
     default {
        if { $input != "" } {
           change_dir $input
        }
     }
   }
   }
}

proc update_compile_html_output { content } {
   global CHECK_HTML_DIRECTORY CHECK_OUTPUT
   if { $CHECK_HTML_DIRECTORY != "" } { 
      puts $CHECK_OUTPUT "-> UPDATING HTML FILES IN DIRECTORY: \"$CHECK_HTML_DIRECTORY\""
      puts $CHECK_OUTPUT "-> UPDATING file index.html"
      generate_html_file "$CHECK_HTML_DIRECTORY/index.html" "Nightly Build Compile Results" $content
   }
}

proc get_shared_lib_path { host name path } {

   upvar $name var_name
   upvar $path var_value

   get_current_cluster_config_array ts_config

   set host_arch [resolve_arch $host ]
   set var_name [get_shared_lib_path_variable_name $host_arch]
   if { [info exists ts_config(product_root) ] } {
      set var_value $ts_config(product_root)/lib/$host_arch
   } else {
      set var_value ""
   }
}


proc get_shared_lib_path_variable_name { arch } {
   set name ""
   switch -exact $arch {
      aix41 -
      aix42 -
      aix43 {
         set name LIBPATH
      }
      hp10 -
      hp11 {
         set name SHLIB_PATH
      }
      darwin -
      darwin-x86 -
      darwin-ppc {
         set name DYLD_LIBRARY_PATH
      }
      default {
         set name LD_LIBRARY_PATH
      }
   }
   return $name
}

proc setup_shared_lib_path {} {
   global env CHECK_OUTPUT
   global be_quiet
   get_current_cluster_config_array ts_config

   set local_arch [resolve_arch [gethostname]]
   set name [get_shared_lib_path_variable_name $local_arch]
   if { [info exists env($name)] } {
      set env($name) "$env($name):$ts_config(product_root)/lib/$local_arch"
   } else {
      set env($name) "$ts_config(product_root)/lib/$local_arch"
   }
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT "   set environment variable $name to $env($name)"
   }
}

proc source_tcl_files {} {
   global CHECK_OUTPUT
   global ts_config

   if [info exists ts_config] {
      set libdir "$ts_config(testsuite_root_dir)/tcl_files"
   } else {
      set libdir "tcl_files"
   }

   # these files have to be version independent
   source $libdir/version.tcl
   source $libdir/config.tcl

   # now we have a ts_config (before reading config file with "" as version)
   # and can use the ts_source command
   # all the following library files may be version dependent
   ts_source $libdir/config_user
   ts_source $libdir/config_host

   ts_source $libdir/compile
   ts_source $libdir/file_procedures
   ts_source $libdir/gettext_procedures
   ts_source $libdir/jgdi_shell
   ts_source $libdir/remote_procedures
   ts_source $libdir/control_procedures
   ts_source $libdir/cluster_procedures
   ts_source $libdir/coverage
   ts_source $libdir/parser
   ts_source $libdir/parser_xml
   ts_source $libdir/sge_config
   ts_source $libdir/sge_procedures
   ts_source $libdir/sge_job
   ts_source $libdir/sge_queue
   ts_source $libdir/sge_project
   ts_source $libdir/sge_sched_conf
   ts_source $libdir/sge_checkpoint
   ts_source $libdir/sge_pe	
   ts_source $libdir/sge_host
   ts_source $libdir/sge_hostgroup
   ts_source $libdir/sge_calendar
   ts_source $libdir/sge_qconf_config
   ts_source $libdir/sge_users	
   ts_source $libdir/sge_userset	
   ts_source $libdir/sge_sharetree	
   ts_source $libdir/sge_event_client	
   ts_source $libdir/sge_resource_quota
   ts_source $libdir/sge_ar
    
   ts_source $libdir/checktree_helper
   ts_source $libdir/report_procedures
   
   # source a user private tcl file, e.g. to contain a 
   # inhouse_cluster_post_install function
   ts_source $libdir/private
}

#                                                             max. column:     |
#****** check/build_java_env_list() ******
# 
#  NAME
#     build_java_env_list -- Build a list of CHECK_* variables into jvm switches
#
#  SYNOPSIS
#     build_java_env_list {} 
#
#  FUNCTION
#     This function builds a list of JVM switches which will set system
#     properties corresponding to various bits of information that only the test
#     suite knows.  These system properties are read by the
#     com.sun.grid.Settings class in the classes/test directory.
#
#  RESULT
#     A string containing -D switches for relevant system properties
#
#  SEE ALSO
#     classes/test/com/sun/grid/Settings.java
#*******************************
proc build_java_env_list {} {
   global CHECK_USER CHECK_ACTUAL_TEST_PATH
   global CHECK_CURRENT_WORKING_DIR
   global CHECK_PRODUCT_VERSION_NUMBER
   global env

   get_current_cluster_config_array ts_config

   set local_host [gethostname]
   set local_arch [resolve_arch $local_host]

   set env_list "-Dgets.user=\"$CHECK_USER\""
   set env_list "$env_list -Dgets.test_path=\"$CHECK_ACTUAL_TEST_PATH\""
   set env_list "$env_list -Dgets.sge_root=\"$ts_config(product_root)\""
   set env_list "$env_list -Dgets.arch=\"$local_arch\""
   set env_list "$env_list -Dgets.hostname=\"$local_host\""
   set env_list "$env_list -Dgets.gets_root=\"$ts_config(testsuite_root_dir)\""
   set env_list "$env_list -Dgets.cwd=\"$CHECK_CURRENT_WORKING_DIR\""
   set env_list "$env_list -Dgets.scripts_dir=\"$ts_config(testsuite_root_dir)/scripts\""
   set env_list "$env_list -Dgets.checktree_root=\"$ts_config(checktree_root_dir)\""
   set env_list "$env_list -Dgets.pid=\"[getpid]\""
   set env_list "$env_list -Dgets.home_dir=\"$env(HOME)\""
   set env_list "$env_list -Dgets.version=\"$CHECK_PRODUCT_VERSION_NUMBER\""

   return $env_list
}

proc load_additional_packages {} {
   global CHECK_HAVE_TDOM CHECK_OUTPUT

   set ret [catch {package require tdom} output]
   if {$ret == 0} {
      set CHECK_HAVE_TDOM 1
      puts $CHECK_OUTPUT "successfully loaded tdom package version $output"
   }
}


#****** check/operate_additional_clusters() ************************************
#  NAME
#     operate_additional_clusters() -- perform remote testsuite actions
#
#  SYNOPSIS
#     operate_additional_clusters { operation } 
#
#  FUNCTION
#     This procedure is used to startup remote testsuite with additional_config
#     and perform startup, kill, compile, install ... commands. The command
#     is stared on all configured additional configurations. 
#
#  INPUTS
#     operation - command line parameter for remote testsuite
#
#  RESULT
#     0 on success or the exit value of the remote testsuite run
#  SEE ALSO
#     check/operate_add_cluster()
#*******************************************************************************
proc operate_additional_clusters {operation} {
   global CHECK_OUTPUT CHECK_USER
   global check_use_installed_system
   global ts_config

   if {$ts_config(additional_config) != "none"} {
      foreach filename $ts_config(additional_config) {
         operate_add_cluster $filename $operation
      }
   } else {
      puts $CHECK_OUTPUT "no additional clusters defined"
   }
}

#****** check/operate_add_cluster() ********************************************
#  NAME
#     operate_add_cluster() -- perform single remote testsuite action
#
#  SYNOPSIS
#     operate_add_cluster { filename operation {atimeout 120} } 
#
#  FUNCTION
#     This procedure is used to startup remote testsuite with additional_config
#     and perform startup, kill, compile, install ... commands
#
#  INPUTS
#     filename       - filename of the remote testsuite configuration
#     operation      - startup: startup system which was killed
#                      kill: kill system which was started
#                      compile: compile sources
#                      install: install system (basic installation)
#                      execute_func: start remote tcl function call with command specified in arguments
#                      procedure return values are stored in execute_func_return
#     {atimeout 120} - timeout for operation outputs
#     {execute_func_return rpc_retval} - remote procedure return values
#                                        when execute_func is used
#
#  SEE ALSO
#     check/operate_additional_clusters()
#*******************************************************************************
proc operate_add_cluster {filename operation {atimeout 120} {execute_func ""} {execute_func_return rpc_retval} } {
   global CHECK_OUTPUT CHECK_USER CHECK_HTML_DIRECTORY
   global check_use_installed_system
   global check_do_clean_compile do_not_update ts_config
   upvar $execute_func_return rpcret


   set rpcret ""
   set return_value 0
   if {$ts_config(additional_config) != "none"} {
      # clear previously read config
      if {[info exists add_config]} {
         unset add_config
      }
      # read additional config file
      if {[read_array_from_file $filename "testsuite configuration" add_config] != 0} {
         add_proc_error "operate_add_cluster $operation" -1 "cannot read additonal configuration file $filename"
         continue
      }

      # start testsuite with install option on the cluster's master host
      puts $CHECK_OUTPUT "\n${operation}ing cluster of additional configuration $filename"
      puts $CHECK_OUTPUT "on host $add_config(master_host) as user $CHECK_USER"

      set args "check.exp file $filename fast_setup quiet"
      if {$operation == "install" && $check_use_installed_system} {
         append args " re_init"
      }

      if {$operation == "compile" && $check_do_clean_compile } {
         append args " compile_clean"
      }

      if {$operation == "compile" && $do_not_update } {
         append args " no_update"
      }

      if {$CHECK_HTML_DIRECTORY != ""} {
         remote_file_mkdir $add_config(master_host) $CHECK_HTML_DIRECTORY/$add_config(master_host)
         wait_for_remote_dir $add_config(master_host) $CHECK_USER $CHECK_HTML_DIRECTORY/$add_config(master_host)
         wait_for_remote_dir $ts_config(master_host) $CHECK_USER $CHECK_HTML_DIRECTORY/$add_config(master_host)
         append args " html_dir $CHECK_HTML_DIRECTORY/$add_config(master_host)" 
      }
  
      # The "execute_func" has to be the last argument!!!
      append args " $operation"
      if {$operation == "execute_func" } {
         append args " $execute_func"
      }

      puts $CHECK_OUTPUT "starting expect $args in $add_config(testsuite_root_dir) as user $CHECK_USER on host $add_config(master_host) ..."
      set id [open_remote_spawn_process $add_config(master_host) $CHECK_USER "expect" $args 0 $add_config(testsuite_root_dir)]
      set script_tail_name [file tail $shell_script_name]
      set script_tail_name [file rootname $script_tail_name] ;# remove dot (.) because of glob switch
      puts $CHECK_OUTPUT "script file tail name is \"$script_tail_name\""

      if {$id == ""} {
         add_proc_error "operate_add_cluster $args" -1 "$operation in additional config $filename failed:\ngot no spawn id"
         continue
      }
      
      set spawn_id [lindex $id 1]
#      log_user 1
      set timeout $atimeout
      set found_end 0
      set error_found 0
      set proc_found 0
      set error_text ""

      expect {
         -i $spawn_id timeout {
            add_proc_error "operate_add_cluster $args" -1 "$operation in additional config $filename failed:\ntimeout"
         }
         -i $spawn_id full_buffer {
            add_proc_error "operate_add_cluster $args" -1 "$operation in additional config $filename failed:\nbuffer overflow"
         }
         -i $spawn_id eof {
            add_proc_error "operate_add_cluster $args" -1 "$operation in additional config $filename failed:\nunexpected eof"
         }

         -i $spawn_id -- "*\n" {
            set stop 0
            foreach line [split $expect_out(0,string) "\n"] {
               set line [string trim $line]
               if {$line != ""} {
                  puts $CHECK_OUTPUT "\[remote ts [file tail $filename]\]$line"
                  switch -glob -- $line {
                     "host access with password needed for user*" {
                        set user [lindex $line 7]
                        set passwd [get_passwd $user]
                        if {$passwd == ""} {
                           set_passwd $user $add_config(master_host) [host_conf_get_windows_host]
                           set passwd [get_passwd $user]
                           # the set_passwd switches off log_user
                           log_user 1
                        }

                        if {$passwd == ""} {
                           add_proc_error "operate_add_cluster $args" -1 "$operation in additional config $filename failed:\ndon't know passwd of user $user required to operate the cluster"
                           set stop 1
                        } else {
                           ts_send $spawn_id "$passwd\n" 1 1
                        }
                     }
                     "_exit_status_:(*)*" {
                        if { [string match "*$script_tail_name*" $line] } {
                            set remote_exit_state [get_string_value_between "(" ")" $line]
                            if { $remote_exit_state != 0 } {
                               append error_text "remote testsuite terminated with exit state $remote_exit_state\n"
                               set return_value $remote_exit_state
                            }
                            puts $CHECK_OUTPUT "got _exit_status - stopping"
                            set found_end 1
                        } else {
                           debug_puts $CHECK_OUTPUT "found an exit status"
                        }
                     }
                     "*_END_OF_FILE_*" {
                        if { $found_end == 1 } {
                           puts $CHECK_OUTPUT "exit status found - last line parsed - finished"
                           set stop 1
                        } else {
                           debug_puts $CHECK_OUTPUT "this is not end of my script file"
                        }
                     }
                     "ERROR REPORT - START" {
                        puts $CHECK_OUTPUT "found error report start"
                        set error_found 1
                     }
                     "ERROR REPORT - DONE" {
                        puts $CHECK_OUTPUT "found error report end"
                        set error_found 0
                     }
                     "PROCEDURE REPORT - START" {
                        puts $CHECK_OUTPUT "found procedure report start"
                        set proc_found 1
                     }
                     "PROCEDURE REPORT - DONE" {
                        puts $CHECK_OUTPUT "found procedure report end"
                        set proc_found 0
                     }

                  }
                  if { $error_found == 2 } {
                     append error_text "$line\n"
                  }
                  if { $error_found == 1 } {
                     incr error_found 1
                  }
                  if { $proc_found == 2 } {
                     append rpcret $line
                  }
                  if { $proc_found == 1 } {
                     incr proc_found 1
                  }


               }
            }
           
            if {!$stop} {
               exp_continue
            }
         }
      }
      close_spawn_process $id
      if { $error_text != "" } {
         puts $CHECK_OUTPUT "remote operation \"$args\" in remote testsuite [file tail $filename] failed:"
         puts $CHECK_OUTPUT $error_text
         set proc_error_text ""
         append proc_error_text "remote operation \"$args\" in testsuite [file tail $filename] failed:\n"
         append proc_error_text $error_text
         add_proc_error "operate_add_cluster" -1 "$proc_error_text"
      } else {
         puts $CHECK_OUTPUT "remote operation \"$args\" in remote testsuite [file tail $filename] finished successfully"
      }
   } else {
      puts $CHECK_OUTPUT "no additional clusters defined"
   }
   return $return_value
}




# Main programm:

set do_kill           0
set do_install        0
set do_start          0
set do_compile        0
set do_not_update     0
set do_all            0
set do_one_test       0
set do_category       0
set do_nomain         0
set do_prog_start     0
set do_only_reset_config 0
set do_only_diff_macros 0
set be_quiet          0
set fast_setup        0
set CHECK_CUR_PROC_NAME "main"
set check_name "main"
set CHECK_ACTUAL_TEST_PATH "not in testmode"
set mail_subject "testsuite error - main"
set mail_body    "date: [exec date]\n:\n"

# for some reason, we need this with SuSE 10 expect 5.43.0
fconfigure stdin -blocking TRUE

for { set i 0 } { $i < $argc } { incr i } {
   if {([string compare [lindex $argv $i] "--setup"] == 0) || ([string compare [lindex $argv $i] "setup"] == 0) } {
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return == 0 } { 
        set CHECK_DO_SETUP 1 
      } else {
        puts "could not copy defaults file"
      }
      continue
   }
   
   if {([string compare [lindex $argv $i] "--quiet"] == 0) || ([string compare [lindex $argv $i] "quiet"] == 0) } {
      set be_quiet 1
      continue
   }

   if {([string compare [lindex $argv $i] "--fast_setup"] == 0) || ([string compare [lindex $argv $i] "fast_setup"] == 0) } {
      set fast_setup 1
      continue
   }

   if {([string compare [lindex $argv $i] "--close_rlogin"] == 0) || ([string compare [lindex $argv $i] "close_rlogin"] == 0) } {
      set do_close_rlogin 1
      continue
   }
   

   if {([string compare [lindex $argv $i] "--help"] == 0) || ([string compare [lindex $argv $i] "help"] == 0) } {
      puts "usage: expect check.exp \[options\]"
      puts "\noptions are:"
      puts "help                  show this"
      puts ""
      puts "setup_help            show setup informations"
      puts ""
      puts "check_macros DUMPFILE_A DUMPFILE_B IGNORE_BACKSLASH"
      puts "                      check if all message macros from DUMPFILE_A are in DUMPFILE_B and compare"
      puts "                      the messages. If IGNORE_BACKSLASH is set to 0 backslashes at the end of"
      puts "                      a message macro not ignored. If set to 1 the backslashes are removed before"
      puts "                      comparing the messages."
      puts ""
      puts "install               just install core system and exit"
      puts ""
      puts "kill                  shutdown cluster"
      puts ""
      puts "start                 startup cluster"
      puts ""
      puts "setup                 run setup"
      puts ""
      puts "file FILE             use FILE as defaults file"
      puts ""
      puts "re_init               use already installed system (will only shutdown/reconfigure the cluster!)"
      puts "                      when test install_core_system is called or install option is set"
      puts ""
      puts "re_init_on_tcl_error  reinitialize cluster when tcl error occurs"
      puts ""
      puts "compile               checkout source code and recompile"
      puts ""
      puts "no_update             do not update source when compile option is used"
      puts ""
      puts "all RUNLEVEL          run every test automatically up to runlevel RUNLEVEL"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "check PATH RUNLEVEL   run test in checktree sub-path automatically up to runlevel"
      puts "                      RUNLEVEL. PATH is as check sub-path, relative to checktree."
      puts "                      If PATH begins with \"/\" then the path is used absolute"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "execute_func ARGS     just run this procedure with given arguments"
      puts "                      (all arguments after this keyword are used as function call)"
      puts "                      e.g.: .. no_update execute_func compare_dump_data_file arg1 arg2"
      puts ""
      puts "category CAT_LIST     set users category list (COMPATIBILITY SYSTEM \[...\])"
      puts "                      (CAT_LIST must be 1 single parameter, must be quoted"
      puts "                       when using more than one category)"
      puts "" 
      puts "no_main               don't run main part (usefull for sourceing this file)"
      puts ""
      puts "no_main2              don't run main part and don't do setup"
      puts "                      (usefull for sourceing this file)"
      puts ""
      puts "reset_conf            reset test cluster"
      puts ""
      puts "debug LEVEL           run testsuite in debuglevel 0,1 or 2"
      puts "                      0=no debug, 1=more output, 2=1+user response"
      puts ""
      puts "quiet                 no output on setup"
      puts ""
      puts "fast_setup            suppress configuration checks at startup (setup phase)"
      puts ""
      puts "no_local_spool        ignore local spool directories from host configuration file"
      puts ""
      puts "compile_clean         force aimk clean when no_update option is set at compile time"
      puts ""
      puts "mfile FILE            write all mails into file FILE (when mail is enabled)"
      puts ""
      puts "html_dir              write testsuite html files into that directory"
      puts ""
      puts "close_rlogin          don't let rlogin connections open for next command (per default the testsuite"
      puts "                      not close a rlogin connection. The testsuite will reuse the open connection"
      puts "                      for a later remote command. Use close_rlogin if the number of open file "
      puts "                      descriptors is low on your system)"
      puts ""
      puts "master_debug          procedure startup_qmaster will startup qmaster"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "schedd_debug          procedure startup_qmaster will startup schedduler"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "display DISPLAY       set display for daemon debug windows"
      puts ""
      puts "coverage <type(s)>    with code coverage analysis, type =\"tcov|insure|emma\""
      puts "coverage_dir <dir>    directory for test coverage profiles"
      puts ""
      puts "preferred_archs <archs> specify architectures, that shall be used whenever possible"
      puts "                      please use quotes, when specifying multiple architectures, e.g."
      puts "                      preferred_archs sol-sparc64, or preferred_archs \"hp11 hp11-64\""
      puts ""
      puts "send_speed <value>    specify the used testsuite send speed. This value overwrites"
      puts "                      the settings from the host configurations. A send_speed value of"
      puts "                      0.0 disables sending out expect strings slow."
      puts "                      A really slow send_speed would be \"0.01\"."
      puts "                      The testsuite test \"testsuite\" can be started to get information"
      puts "                      about current remote script execution times."
      puts "                      If some hosts have unexpected connection errors the send_speed"
      puts "                      value can be used to prevent errors."
      puts ""
      exit 1
   }

   if {([string compare [lindex $argv $i] "--setup_help"] == 0) || ([string compare [lindex $argv $i] "setup_help"] == 0) } {
      show_setup_information
      exit 1
   }

   if {([string compare [lindex $argv $i] "--check_macros"] == 0) || ([string compare [lindex $argv $i] "check_macros"] == 0) } {
      incr i
      set global_macro_file1 [lindex $argv $i]
      incr i
      set global_macro_file2 [lindex $argv $i]
      incr i
      set global_macro_ignore_flag [lindex $argv $i]
      if { $global_macro_ignore_flag == ""  } {
         set global_macro_ignore_flag 0
      }
      puts $CHECK_OUTPUT "checking difference for \n\"$global_macro_file1\"\n and \n\"$global_macro_file2\""
      if { $global_macro_ignore_flag != 0 } {
         puts $CHECK_OUTPUT "ignoring backslashes at the end of macros"
      } else {
         puts $CHECK_OUTPUT "don't ignore backslashes at the end of macros"
      }

      set do_only_diff_macros 1
   }

   
   if { ( [string compare [lindex $argv $i] "--no_local_spool"] == 0 ) || ([string compare [lindex $argv $i] "no_local_spool"] == 0) } {
      set check_do_not_use_spool_config_entries 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile_clean"] == 0 ) || ([string compare [lindex $argv $i] "compile_clean"] == 0) } {
      set check_do_clean_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init"] == 0 ) || ([string compare [lindex $argv $i] "re_init"] == 0) } {
      set check_use_installed_system 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init_on_tcl_error"] == 0 ) || ([string compare [lindex $argv $i] "re_init_on_tcl_error"] == 0) } {
      set check_reinit_on_tcl_error 1
      continue
   }


   if { ( [string compare [lindex $argv $i] "--master_debug"] == 0 ) || ([string compare [lindex $argv $i] "master_debug"] == 0) } {
      set master_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--schedd_debug"] == 0 ) || ([string compare [lindex $argv $i] "schedd_debug"] == 0) } {
      set schedd_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--display"] == 0 ) || ([string compare [lindex $argv $i] "display"] == 0) } {
      incr i
      set CHECK_DISPLAY_OUTPUT [lindex $argv $i]
      continue
   }

   


   if { ( [string compare [lindex $argv $i] "--kill"] == 0 ) || ([string compare [lindex $argv $i] "kill"] == 0) } {
      set do_kill 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--start"] == 0 ) || ([string compare [lindex $argv $i] "start"] == 0) } {
      set do_start 1
      continue
   }

   
   if { ( [string compare [lindex $argv $i] "--mfile"] == 0 ) || ([string compare [lindex $argv $i] "mfile"] == 0) } {
      incr i
      set CHECK_MAIL_OUTPUT_FILE [lindex $argv $i]
      if { [llength $CHECK_MAIL_OUTPUT_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"mfile\" option without filename!"
         exit -1 
      }
      if { ([ string first "/" $CHECK_MAIL_OUTPUT_FILE ] < 0) && ([ string first "\/" $CHECK_MAIL_OUTPUT_FILE ] < 0)} {
          set CHECK_MAIL_OUTPUT_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_MAIL_OUTPUT_FILE"
      }
      set write_mail_to_file 1
      puts $CHECK_OUTPUT " ---> writing all mails into \"$CHECK_MAIL_OUTPUT_FILE\" ! <---"
      if {[file exists $CHECK_MAIL_OUTPUT_FILE]} {
         file rename -force $CHECK_MAIL_OUTPUT_FILE "$CHECK_MAIL_OUTPUT_FILE.bak"
      }
      set mf [open $CHECK_MAIL_OUTPUT_FILE "w"]
      puts $mf "This file contains testsuite mail contents"
      close $mf
      continue
   }
 
   if { ( [string compare [lindex $argv $i] "--file"] == 0 ) || ([string compare [lindex $argv $i] "file"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_DEFAULTS_FILE [ string trim $help_var ]

      if { [llength $CHECK_DEFAULTS_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"file\" option without filename!"
         exit -1 
      }

      if { ([ string first "/" $CHECK_DEFAULTS_FILE ] != 0) } {
          set CHECK_DEFAULTS_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_DEFAULTS_FILE"
      }
      
      puts $CHECK_OUTPUT "using configuration file \"$CHECK_DEFAULTS_FILE\""
      continue
   }

   if { ( [string compare [lindex $argv $i] "--html_dir"] == 0 ) || ([string compare [lindex $argv $i] "html_dir"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_HTML_DIRECTORY [ string trim $help_var ]
      if { [llength $CHECK_HTML_DIRECTORY] != 1 } {
         puts $CHECK_OUTPUT "can't use \"html_dir\" option without filename!"
         exit -1 
      }

      if { [string first "/" $CHECK_HTML_DIRECTORY] != 0 } {
         puts $CHECK_OUTPUT "your specified HTML directory \"$CHECK_HTML_DIRECTORY\" seems not to be an absolute path"
         puts $CHECK_OUTPUT "please enter the full path to your HTML directory."
         exit -1 
      }

      if {[file isdirectory $CHECK_HTML_DIRECTORY] == 0} {
         puts $CHECK_OUTPUT "HTML directory $CHECK_HTML_DIRECTORY not existing. Creating ..."
         catch {file mkdir $CHECK_HTML_DIRECTORY} blub
         puts $CHECK_OUTPUT "file mkdir $CHECK_HTML_DIRECTORY returned:\n$blub"
         if {[file isdirectory $CHECK_HTML_DIRECTORY] == 0} {
            puts $CHECK_OUTPUT "cannot create HTML directory: \"$CHECK_HTML_DIRECTORY\""
            exit -1 
         }
      }

      puts $CHECK_OUTPUT " ---> using \"$CHECK_HTML_DIRECTORY\" for HTML output <---"
      continue
   }

  
   

   if { ( [string compare [lindex $argv $i] "--install"] == 0 ) || ([string compare [lindex $argv $i] "install"] == 0 ) } {
      set do_install 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile"] == 0 ) || ([string compare [lindex $argv $i] "compile"] == 0 ) } {
      set do_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_update"] == 0 ) || ([string compare [lindex $argv $i] "no_update"] == 0 ) } {
      set do_not_update 1
      continue
   }

   
   
   if { ( [string compare [lindex $argv $i] "--reset_conf"] == 0 ) || ([string compare [lindex $argv $i] "reset_conf"] == 0 ) } {
      set do_only_reset_config 1
      set check_use_installed_system 1
      continue
   }
  
   if { ( [string compare [lindex $argv $i] "--coverage"] == 0 ) || ([string compare [lindex $argv $i] "coverage"] == 0 ) } {
      incr i
      set help_var [lindex $argv $i]
      set help_var [string trim $help_var]
      foreach cov $help_var {
         if {$cov == "tcov" || $cov == "insure" || $cov == "emma"} {
            lappend CHECK_COVERAGE $cov
            puts $CHECK_OUTPUT " ---> doing code coverage analysis with \"$cov\" <---"
         } else {
            puts $CHECK_OUTPUT "invalid coverage method $cov"
         }
      }
      continue
   }

   if { ( [string compare [lindex $argv $i] "--coverage_dir"] == 0 ) || ([string compare [lindex $argv $i] "coverage_dir"] == 0 ) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_COVERAGE_DIR [ string trim $help_var ]

      if { [llength $CHECK_COVERAGE_DIR] != 1 } {
         puts $CHECK_OUTPUT "can't use \"profile_dir\" option without filename!"
         exit -1 
      }

      puts $CHECK_OUTPUT " ---> using \"$CHECK_COVERAGE_DIR\" for coverage profiles <---"
      continue
   }

   if { ( [string compare [lindex $argv $i] "--send_speed"] == 0 ) || ([string compare [lindex $argv $i] "send_speed"] == 0 ) } {
      incr i
      set help_var [lindex $argv $i]
      set GLOBAL_SEND_SPEED [ string trim $help_var ]

      if { [llength $GLOBAL_SEND_SPEED] != 1 } {
         puts $CHECK_OUTPUT "can't use \"send_speed\" option without value!"
         exit -1 
      }

      if { $GLOBAL_SEND_SPEED <= 0.0 } {
         set GLOBAL_SEND_SPEED 0.0
      }
      puts $CHECK_OUTPUT " ---> using \"$GLOBAL_SEND_SPEED\" for send_speed <---"
      continue
   }


   if { ( [string compare [lindex $argv $i] "--check"] == 0 ) || ([string compare [lindex $argv $i] "check"] == 0 ) } {
      set do_one_test 1
      set ru_lev [ expr ( 1 + $i ) ]
      set do_one_test_name [ lindex $argv $ru_lev ]
      set ru_lev [ expr ( 2 + $i ) ] 
      set do_one_test_level [lindex $argv $ru_lev]
      puts $CHECK_OUTPUT "path: $do_one_test_name"
      puts $CHECK_OUTPUT "level: $do_one_test_level"
      if { [ llength $do_one_test_level ] != 1 || [ llength $do_one_test_name ] != 1} {
         puts $CHECK_OUTPUT "used check parameter without runlevel or checkname"
         setup2
         set local_host [gethostname]
         set local_arch [resolve_arch $local_host]
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$ts_config(testsuite_root_dir)\"\n"
         set mail_body "$mail_body check is running on host \"$local_host\" architecture is \"$local_arch\"\n"
         set mail_body "$mail_body product root directory is \"$ts_config(product_root)\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used check parameter without runlevel or checkname" 
         exit -1
      }
      incr i
      continue
   }
 
   if { ( [string compare [lindex $argv $i] "--all"] == 0 ) || ([string compare [lindex $argv $i] "all"] == 0 ) } {
      set do_all 1
      set ru_lev [ expr (1 + $i) ] 
      set do_all_runlevel [lindex $argv $ru_lev]
      if { [ llength $do_all_runlevel ] != 1 } {
         puts $CHECK_OUTPUT "used all parameter without runlevel"
         setup2
         set local_host [gethostname]
         set local_arch [resolve_arch $local_host]
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$ts_config(testsuite_root_dir)\"\n"
         set mail_body "$mail_body check is running on host \"$local_host\" architecture is \"$local_arch\"\n"
         set mail_body "$mail_body product root directory is \"$ts_config(testsuite_root_dir)\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used all parameter without runlevel" 
         exit -1
      }
      incr i
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--category"] == 0 ) || ([string compare [lindex $argv $i] "category"] == 0 ) } {
      set do_category 1
      set ru_lev [ expr (1 + $i) ] 
      set do_category_list [lindex $argv $ru_lev]
      if { [ llength $do_category_list ] == 0 } {
         puts $CHECK_OUTPUT "used category parameter without category list"
         setup2
         set local_host [gethostname]
         set local_arch [resolve_arch $local_host]
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$ts_config(testsuite_root_dir)\"\n"
         set mail_body "$mail_body check is running on host \"$local_host\" architecture is \"$local_arch\"\n"
         set mail_body "$mail_body product root directory is \"$ts_config(testsuite_root_dir)\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used category parameter without category list" 
         exit -1
      }
      incr i
      continue
   }


   if { ( [string compare [lindex $argv $i] "--debug"] == 0 ) || ([string compare [lindex $argv $i] "debug"] == 0 ) } {
      set deb_lev [ expr (1 + $i) ] 
      set CHECK_DEBUG_LEVEL [lindex $argv $deb_lev]

      debug_puts "debuglevel is $CHECK_DEBUG_LEVEL"
      incr i
      continue
   }
   if { ( [string compare [lindex $argv $i] "--execute_func"] == 0 ) || ([string compare [lindex $argv $i] "execute_func"] == 0 ) } {
      set exec_args ""
      for { incr i 1 } { $i < $argc } { incr i } {
         lappend exec_args [lindex $argv $i]
      }
      set do_prog_start 1
      break
   }

   if { ( [string compare [lindex $argv $i] "--no_main"] == 0 ) || ([string compare [lindex $argv $i] "no_main"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_main2"] == 0 ) || ([string compare [lindex $argv $i] "no_main2"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      puts "no_main2 active"
      return
   }

   if {[string compare [lindex $argv $i] "--preferred_archs"] == 0 || [string compare [lindex $argv $i] "preferred_archs"] == 0} {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_PREFERRED_ARCHS [string trim $help_var]

      if {[llength $CHECK_PREFERRED_ARCHS] < 1} {
         puts $CHECK_OUTPUT "please specify an architecture name together with the preferred_archs switch"
         exit -1 
      }

      puts $CHECK_OUTPUT " ---> using \"$CHECK_PREFERRED_ARCHS\" as preferred architectures <---"
      continue
   }
}

if {$CHECK_COVERAGE != {} && $CHECK_COVERAGE_DIR == ""} {
   puts $CHECK_OUTPUT "please specify a coverage profile directory with the option coverage_dir"
   exit -1
}

# load defaults file
#__setup   ;# old setup
source_tcl_files

if { $do_only_diff_macros == 1 } {
   exit [diff_macro_files $global_macro_file1 $global_macro_file2 $global_macro_ignore_flag]
}

setup2

# clear the arch cache, only after the setup2 we have the path to SGE_ROOT,
# and can call the correct arch script
resolve_arch_clear_cache

# resource the tcl_files - we now know the gridengine_version
source_tcl_files

# try load TCL packages like TDOM
load_additional_packages

# fill sge_config array with minimal information
bootstrap_sge_config

if { $do_category == 1 } {
   set CHECK_ENABLED_CATEGORIES $do_category_list
}
set CHECK_ACT_PATH "root"

set local_host [gethostname]
set local_arch [resolve_arch $local_host]

set mail_body "$mail_body product version is [get_version_info]\n"
set mail_body "$mail_body testsuite root directory is \"$ts_config(testsuite_root_dir)\"\n"
set mail_body "$mail_body check is running on host \"$local_host\" architecture is \"$local_arch\"\n"
set mail_body "$mail_body product root directory is \"$ts_config(product_root)\"\n-------\n"
set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"


if { $no_action == 1 } {
  puts $CHECK_OUTPUT "CHECK_GROUP=$CHECK_GROUP"
  puts "No action flag is set -> exit 1"
  exit 1
}

if { $do_prog_start == 1 } {
   puts $CHECK_OUTPUT "starting $exec_args ..."
   set exit_value [eval $exec_args]
   puts $CHECK_OUTPUT "PROCEDURE REPORT - START"
   puts $exit_value
   puts $CHECK_OUTPUT "PROCEDURE REPORT - DONE"
   exit 0
}

if { $check_reinit_on_tcl_error == 1 } {
   set_root_passwd   
}

if { $do_compile } {
   if { [have_root_passwd] == -1 } {
         puts $CHECK_OUTPUT "need root access ..."
         set_root_passwd
   }

   if { [ compile_source ] != 0 } {
      exit -1
   } else {
      exit 0
   }
}

if { $do_one_test } {
   # ts_checktree ok
   if { [string first "/" $do_one_test_name] == 0 || [string first "\\" $do_one_test_name] == 0 } {
      set CHECK_ACT_PATH "$do_one_test_name"
   } else {
      set CHECK_ACT_PATH "$ts_config(checktree_root_dir)/$do_one_test_name"
   }
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   set selected_levels ""
   set CHECK_ENABLED_RUNLEVELS ""
   for {set i 0} {$i<= $do_one_test_level} {incr i 1} {
      lappend CHECK_ENABLED_RUNLEVELS [ expr ( $i * 100 )  ]
   }
 
   delete_tests $CHECK_ACT_PATH
   # print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0
}

if { $do_all } {
   # ts_checktree ok
   set CHECK_ACT_PATH "root"
   delete_tests $CHECK_ACT_PATH
   set CHECK_ACT_PATH "root"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   set selected_levels ""
   set CHECK_ENABLED_RUNLEVELS ""
   for {set i 0} {$i<= $do_all_runlevel} {incr i 1} {
      lappend CHECK_ENABLED_RUNLEVELS [ expr ( $i * 100 )  ]
   }

   print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0
} 

if { $do_install } {
   # ts_checktree ok
   puts "installing core system on host [gethostname] ..."
   set CHECK_ACT_PATH "$ts_config(checktree_root_dir)/install_core_system"  
   run_test $CHECK_ACT_PATH 1
   operate_additional_clusters install

   set exit_value [print_errors]
   exit $exit_value
}

if { $do_kill } {
   set check_name "command line"

   shutdown_core_system 0 1

   set exit_value [print_errors]
   exit $exit_value

}

if { $do_start } {
   set check_name "command line"

   startup_core_system 0 1

   set exit_value [print_errors]
   exit $exit_value
}


if { $do_only_reset_config == 1 } {
  set result 1
  # ts_checktree ok
  set CHECK_ACT_PATH "$ts_config(checktree_root_dir)/install_core_system"
  run_test $CHECK_ACT_PATH 1 "setup_queues" 0
  run_test $CHECK_ACT_PATH 1 "setup_testcheckpointobject" 0
  run_test $CHECK_ACT_PATH 1 "setup_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_execd_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestproject" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestpe" 0
  run_test $CHECK_ACT_PATH 1 "setup_deadlineuser" 0
  run_test $CHECK_ACT_PATH 1 "setup_schedconf" 0
  run_test $CHECK_ACT_PATH 1 "setup_default_calendars" 0
  run_test $CHECK_ACT_PATH 1 "setup_inhouse_cluster" 0
 
  puts "configuration reset done" 
  exit $result
}

proc ctrlc {} {
   global CHECK_INTERRUPT
   global CHECK_TEST_RUNNING CHECK_TESTS_RUNNING

   puts "\nInterrupt requested\n"

   # if we are not running any tests (in menu), exit immediately
   if {$CHECK_TEST_RUNNING == 0 && $CHECK_TESTS_RUNNING == 0} {
      close_open_rlogin_sessions
      exit 1
   }

   # offer a menu to let user decide what to do
   puts "(1) exit immediately"
   if {$CHECK_TEST_RUNNING} {
      puts "(2) stop after current check_function"
      puts "(3) stop after current check completed the current runlevel"
   }
   if {$CHECK_TESTS_RUNNING} {
      puts "(4) stop after current check completed (all runlevels)"
   }
  
   # read user input 
   set input [wait_for_enter 1]
   switch -exact [string trim $input] {
      1 {
         close_open_rlogin_sessions
         exit 1
      }
      2 {
         set CHECK_INTERRUPT 3
      }
      3 {
         set CHECK_INTERRUPT 2
      }
      4 {
         set CHECK_INTERRUPT 1
      }
   }
}

trap ctrlc { SIGINT }
 
if {$do_nomain == 0} {
  if { $daemon_debug != 0 } {
     if { [check_display] != 0 } {
        exit 1
     }
  }
#  puts "please press <RETURN>"
#  wait_for_enter 1
  menu 
}
