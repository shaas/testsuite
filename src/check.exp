#!/vol2/TCL_TK/glinux/bin/expect
# expect script 
# test SGE/SGEEE System
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__


#****** framework/setup_cleanup_functions ******
#  NAME
#     setup_cleanup_functions -- setup and cleanup for testsuite checks
#
#  FUNCTION
#     Before starting the actual testsuite test, usually some setup 
#     (e.g. creating queues, parallel environments etc.) has to be done.
#     After the check finished, these resources have to be deleted again.
#
#     In former versions of testsuite, the corresponding setup and cleanup 
#     functions were simply defined as check functions. But this approach has 
#     the disadvantage, that the cleanup function was not run, when a 
#     critical error (e.g. a TCL error) occured during the execution of the 
#     check functions.
#     Another disadvantage was, that setup and cleanup were done for each 
#     individual check level, but often the same setup is valid for all 
#     check levels.
#
#     Therefore special setup and cleanup functions were introduced into 
#     testsuite.
#
#     The following functions can be defined in the test procedure (check.exp):
#
#     check_setup_function
#        setup function that is called before the check is run.
#        NOTE: Do not use the check_setup_function to shutdown any Grid Engine 
#        components. Before checks are run in a certain level, testsuite checks
#        if the system is up and running. You can savely use the 
#        check_setup_level_function to shutdown Grid Engine.
#
#     check_cleanup_function
#        cleanup function that is called after the whole check (all runlevels) 
#        ran through. It is also called when the check_setup_function failed 
#        and the actual check cannot be run.
#
#     check_setup_level_function
#        per level setup function. It is called after the init_level_function 
#        and before the first check_function is called.
#        Use this function for configuration that only applies to a specific 
#        level, or if you have to shutdown Grid Engine for the test.
#
#     check_cleanup_level_function
#        per level cleanup function that is called after the check_functions 
#        have been run in a certain level. It is also called, when the 
#        check_setup_level_function failed and the check cannot be run in the 
#        actual level.
#
#     Both types of setup/cleanup functions can be combined in a single check.
#
#  EXAMPLE
#     1. per check setup/cleanup
#     #define a level initialization procedure:
#     set check_init_level_procedure "access_lists_init_level"
#     # define test's name and run level descriptions
#     set check_name            "access_lists"
#     set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
#     set check_highest_level   0
#     set check_description(0)  "Test (x)user_lists access for queue/cluster/pe"
#
#     # define test's dependencies
#     set check_needs           "init_core_system"
#
#     # setup and cleanup functions
#     set check_setup_function "access_lists_setup"
#     set check_cleanup_function "access_lists_cleanup"
#     
#     # define test's procedure order
#     set check_functions ""
#     lappend check_functions "access_lists_global_host"
#     lappend check_functions "access_lists_exec_host"
#     lappend check_functions "access_lists_queue"
#     lappend check_functions "access_lists_cluster_config"
#     lappend check_functions "access_lists_pe"
#     
#     
#     2. per level setup/cleanup
#     
#     
#     # define a level initialization procedure:
#     set check_init_level_procedure "usage_init_level"
#     
#     # define test's name and run level descriptions
#     set check_name            "usage"
#     set check_category        "COMPATIBILITY SYSTEM VERIFIED"
#     set check_highest_level   1
#     set check_description(0)  "check reserved usage of jobs submitted with qsub"
#     set check_description(1)  "check reserved usage of jobs submitted with qrsh"
#     
#     # define test's dependencies
#     set check_needs           "init_core_system"
#     
#     # setup and cleanup functions
#     set check_setup_level_function "usage_setup"
#     set check_cleanup_level_function "usage_cleanup"
#     
#     # define test's procedure order
#     set check_functions ""
#     lappend check_functions "usage_single"
#     lappend check_functions "usage_tight"
#     lappend check_functions "usage_loose1"
#     lappend check_functions "usage_loose2"
#     
#*******************************
#

#****** framework/solaris_zones ******
#  NAME
#     solaris_zones -- use of testsuite with Solaris zones
#
#  FUNCTION
#     Testsuite has some special handling for Solaris zones.
#
#     The testsuite host configuration allows to specify a
#     list of zones (zone hostnames) for each configured host.
#
#     If zones are configured on a host being part of a testsuite cluster,
#     testsuite will use the zones as execution hosts instead of the
#     real host (global zone).
#     qmaster and shadowd will run in the global zone (real hostname).
#
#     The testsuite configuration database (TCL array ts_config) contains
#     the following entries, that are affected by zone configuration:
#        - execd_hosts: The real hostnames configured as exec hosts
#        - execd_nodes: - for hosts having no zones: The real hostname.
#                       - for hosts having zones, execd_nodes will contain
#                         all zones of the host, but not the host itself.
#        - unique_execd_nodes: Similar to execd_nodes, but for hosts having
#                              zones, only the first zone is contained.
#        - unique_arch_nodes: For each architecture present in the cluster,
#                             one host or zone is contained, selected from 
#                             unique_execd_nodes.
#
#     Testsuite checks intending to run tests on all configured execution
#     hosts should use ts_config(execd_nodes).
#
#     Testsuite checks intending to run tests on all architectures available
#     in the cluster should use ts_config(unique_arch_nodes).
#
#  EXAMPLE
#     We have the hosts "host" and "zhost".
#     On host "zhost", 2 zones are installed: zone00 and zone01.
#
#     ts_config(execd_hosts): "host zhost"
#     ts_config(execd_nodes): "host zone00 zone01"
#     ts_config(unique_execd_nodes): host zone00"
#
#     If we run testsuite on "host",
#     qmaster will run on "host",
#     execution daemons will be running on "host", "zone00", and "zone01".
#
#     If we run testsuite on "zhost",
#     qmaster will run on "zhost",
#     execution daemons will be running on "host", "zone00", and "zone01".
#     
#*******************************
#

fconfigure stdin -blocking TRUE
global last_debug_msec
set last_debug_msec [clock clicks -milliseconds]
global daemon_debug 
set daemon_debug 0
global master_debug
set master_debug 0
global schedd_debug
set schedd_debug 0
global actual_user_system
set actual_user_system "admin user system" ;# system type installed at install core system test

global no_action                   ;# just used for testing/debug  procedures
set no_action 0
global be_quiet
set be_quiet 0
global write_mail_to_file
set write_mail_to_file 0
global do_close_rlogin
set do_close_rlogin 0

# if we know the config is ok, we don't want to check it, 
# e.g. we don't want to connect to all hosts during setup
#      or check the CVS version at every testsuite startup
global fast_setup
set fast_setup 0

global do_compile
global CHECK_TESTSUITE_LOCKFILE
set CHECK_TESTSUITE_LOCKFILE "testsuite_lockfile"
global CHECK_TESTSUITE_INSTALL_MODE
set CHECK_TESTSUITE_INSTALL_MODE "manual" ;# sets the install mode. allowed are: automatic and manual
 
# path/file variables
global CHECK_TESTSUITE_ROOT        ;# path to TESTSUITE directory
global CHECK_CHECKTREE_ROOT        ;# path where checktree lies

# never touch these dirs: begin
global CHECK_RESULT_DIR            ;# check result directory            
global CHECK_BAD_RESULT_DIR        ;# check rusult directory for failed checkes
global CHECK_CORE_RESULT_DIR       ;# check result core system directory
global CHECK_CORE_BAD_RESULT_DIR   ;# check result directory for failed core system checkes
# never touch these dirs : end

# this is for new tests:
global CHECK_PROTOCOL_DIR          ;# directory for test protocols, logs etc.
global CHECK_JOB_OUTPUT_DIR        ;# directory for qsub job outputs
############################################################################

global CHECK_ACTUAL_TEST_PATH      ;# directory of current running test
global CHECK_PRODUCT_ROOT          ;# path to sge system
global CHECK_OUTPUT                ;# output from testsuite 
global CHECK_CURRENT_WORKING_DIR   ;# current work directory
global CHECK_HTML_DIRECTORY        ;# directory for HTML output of testsuite 
set CHECK_HTML_DIRECTORY ""
# globals for source code specific staff
global CHECK_SOURCE_DIR            ;# path to source code directory (c4)
global CHECK_SOURCE_CVS_RELEASE    ;# release name to check out e.g. V52_BRANCH
set CHECK_SOURCE_CVS_RELEASE "maintrunk"    ;# default is "maintrunk"
global CHECK_SOURCE_HOSTNAME       ;# name of host with cvs installed on (e.g. fangorn)
global CHECK_DIST_INSTALL_OPTIONS     ;# optional: mydistinst options
global CHECK_PACKAGE_DIRECTORY        ;# optional: no compile directory, use distribution (tar or sun packages)
global CHECK_PACKAGE_TYPE             ;# zip or tar
set CHECK_PACKAGE_TYPE "tar"
global CHECK_QMASTER_INSTALL_OPTIONS  ;# optional: qmaster install parameter
global CHECK_EXECD_INSTALL_OPTIONS    ;# optional: execd install parameter 
set CHECK_DIST_INSTALL_OPTIONS "-allall"
set CHECK_PACKAGE_DIRECTORY "none"
set CHECK_QMASTER_INSTALL_OPTIONS ""
set CHECK_EXECD_INSTALL_OPTIONS   ""

# test system specific 
global CHECK_L10N  ;# is sge/sgeee system l10n'ed ?
set CHECK_L10N 0
global CHECK_DNS_DOMAINNAME
set CHECK_DNS_DOMAINNAME ""
global CHECK_REMOTE_ENVIRONMENT
set CHECK_REMOTE_ENVIRONMENT ""
global CHECK_DISPLAY_OUTPUT 
if { [info exists env(DISPLAY)] } {
set CHECK_DISPLAY_OUTPUT [set env(DISPLAY)]
} else {
set CHECK_DISPLAY_OUTPUT "undefined"  
}
global CHECK_SETTINGS_VERSION    ;# settings file version number
set CHECK_SETTINGS_VERSION "undefined"
global CHECK_PRODUCT_VERSION_NUMBER ;# version string of qstat -help of tested system
set CHECK_PRODUCT_VERSION_NUMBER "unknown"
global CHECK_PRODUCT_TYPE           ;# "sgeee" or "sge" 
global CHECK_COMMD_PORT            ;# commd port
global CHECK_ARCH                  ;# architecture of this system (e.g. irix6)
set CHECK_ARCH "unknown"
global CHECK_USER                  ;# user who start test
global CHECK_GROUP                 ;# group of user who start test
global CHECK_HOST                  ;# hostname of this system (e.g. DWAIN)
global CHECK_CORE_EXECD            ;# known execd hostnames
set CHECK_CORE_EXECD ""
global CHECK_SUBMIT_ONLY_HOSTS     ;# list of submithosts (no execd/commd running)
set CHECK_SUBMIT_ONLY_HOSTS ""
global CHECK_CORE_MASTER           ;# qmaster hostname
set CHECK_CORE_MASTER ""
global CHECK_ACT_LEVEL             ;# actual check level ( value from 0 up to xxx )
global CHECK_SPOOL_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_SPOOL_DIR_CONFIG_FILE "local-spool.conf"
global CHECK_LOCAL_BINARY_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_LOCAL_BINARY_DIR_CONFIG_FILE "local-bin.conf"
global CHECK_BINARY_DIR_CONFIG_FILE ;# file for binary directories in $CHECK_CONFIG_DIR
set CHECK_BINARY_DIR_CONFIG_FILE "binary-path.conf"
global CHECK_LOADSENSOR_DIR_CONFIG_FILE ;# file for architecture specific loadsensor binaries in
set CHECK_LOADSENSOR_DIR_CONFIG_FILE "loadsensor.conf" ;# $CHECK_CONFIG_DIR
global CHECK_MAIL_OUTPUT_FILE
set CHECK_MAIL_OUTPUT_FILE "all_test_mails.txt"

global check_use_installed_system   ;# used only for install_core_system test (noinst parameter)
set check_use_installed_system 0    ;# set to 1 when installed system parameter is set

global check_do_not_use_spool_config_entries
set check_do_not_use_spool_config_entries 0

global check_do_clean_compile
set check_do_clean_compile 0

global check_reinit_on_tcl_error
set check_reinit_on_tcl_error 0

global CHECK_FIRST_FOREIGN_SYSTEM_USER       ;# other system user for e.g. submitting jobs 
set CHECK_FIRST_FOREIGN_SYSTEM_USER "nobody"

global CHECK_SECOND_FOREIGN_SYSTEM_USER      ;# other system user for e.g. submitting jobs 
set CHECK_SECOND_FOREIGN_SYSTEM_USER "nobody"

global CHECK_FIRST_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_FIRST_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_SECOND_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_SECOND_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_DEFAULT_DOMAIN                ;# default domain for install test
set CHECK_DEFAULT_DOMAIN "none"

global CHECK_MAILX_HOST                    ;# host where the mailx binary is available
set CHECK_MAILX_HOST "none"

global CHECK_REPORT_EMAIL_TO               ;# mail reports/errors to this email-account
set CHECK_REPORT_EMAIL_TO "none"

global CHECK_REPORT_EMAIL_CC               ;# cc reports/errors to this email-accounts
set CHECK_REPORT_EMAIL_CC "none"                 

global CHECK_SEND_ERROR_MAILS              ;# flag 0 off  1 on
set CHECK_SEND_ERROR_MAILS "1"

global CHECK_MAX_ERROR_MAILS              ;# max mails on run all test
set CHECK_MAX_ERROR_MAILS 400

global CHECK_USE_SSH                             ;# enable/disable use of ssh (o means disable)     
set CHECK_USE_SSH 0

global CHECK_TCL_SCRIPTFILE_DIR   ;# testsuite's subdir for tcl files
set CHECK_TCL_SCRIPTFILE_DIR "tcl_files"

global CHECK_SCRIPT_FILE_DIR  ;# testsuite's subdir for script files
set CHECK_SCRIPT_FILE_DIR "scripts"

global CHECK_EXPECT_MATCH_MAX_BUFFER   ;# read buffer for expect
set CHECK_EXPECT_MATCH_MAX_BUFFER 640000

global CHECK_COVERAGE
set CHECK_COVERAGE {} ;# list of code coverage methods (tcov, insure, or emma)

global CHECK_COVERAGE_DIR ;# directory for test coverage profiles
set CHECK_COVERAGE_DIR ""

# to redefine in checks:
global check_name                  ;# name of actual check module 
global check_category              ;# check category name array (z.b. COMPATIBILITY, NONROOT, SYSTEM, PERFORMANCE)
global check_description           ;# description of actual check module (append more levels as list)
global check_needs                 ;# dependencies of this check (name of other check)
global check_functions             ;# functions to call (in order)
global check_init_level_procedure   ;# name of procedure to call before starting level run
global check_errno                ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
global check_errstr                 ;# short error description in text form   
global check_highest_level         ;# here a check can define his check levels count 0 ...

# for global procedures
global check_cur_proc_error        ;# short error description in text form ( in public procedures )
global check_cur_proc_result       ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )    


# testsuite intern
global CHECK_INFORMATION_FILE      ;# filename of check information (check.exp)
global CHECK_INFORMATION_EXT       ;# fileextension of check information (check.exp)
global ts_checktree                ;# structure which contains checktree directory informations (see build_checktree)
global CHECK_REPORT_FILE           ;# filename (with path) for report
global CHECK_MAIN_RESULTS_DIR      ;# check result root directory for all RESULTS
global CHECK_CONFIG_DIR            ;# global configuration testsuite directory
global CHECK_DEFAULTS_FILE         ;# default settings save file
global CHECK_DO_SETUP              ;# flag: do setup option called ?
global CHECK_CUR_PROC_NAME         ;# name of current running test procedure
global CHECK_CUR_PROC_ERRORS       ;# list of procedure errors   ({error text} {error text} ... )
global CHECK_CUR_PROC_RESULTS      ;# list of procedure results  (0 -1 -2 0 ...)
global CHECK_ENABLED_RUNLEVELS      ;# enabled runlevels
global CHECK_ENABLED_CATEGORIES     ;# enabled categories
global CHECK_ACT_PATH              ;# actual checkpath (while switching in menu mode)
global arch_cache                  ;# cache for architecture names (lower case) e.g. solaris64
global pe_for_version_check_result ;# cache for pe/checkpnt version
global build_arch_cache            ;# cache for architecture names (upper case) e.g. SOLARIS64
global l10n_raw_cache              ;# chche for l10n translation strings
global l10n_install_cache          ;# cache for l10n installation script strings
global set_error_proc_called       ;# flag
global have_ssh_access_state       ;# global variable for have_ssh_access procedure (remember state)
global check_timestamp             ;# for use in is_job_running
global CHECK_SGE_DEBUG_LEVEL       ;# SGE_DEBUG_LEVEL for starting qmaster and scheduler in debug mode
set CHECK_SGE_DEBUG_LEVEL "2 0 0 0 0 0 0 0"
global CHECK_MAILS_SENT            ;# counter for send mails
set CHECK_MAILS_SENT 0
global CHECK_ENABLE_MAIL           ;# is mail sending enabled
set CHECK_ENABLE_MAIL 1
global CHECK_ADMIN_USER_SYSTEM     ;# if no root account is possible
set CHECK_ADMIN_USER_SYSTEM 0
set check_timestamp [timestamp]
set have_ssh_access_state -1
set pe_for_version_check_result "undefined"
set CHECK_ENABLED_RUNLEVELS "0"
set CHECK_ENABLED_CATEGORIES {}
set CHECK_DO_SETUP         0
set CHECK_INFORMATION_FILE "check"   ;# this is the filename of each check in different
set CHECK_INFORMATION_EXT  "exp"     ;# default extension for check files
                                         ;# subdirectories of "checktree"
                                         ;# every file with this name is interpreded as check routine


# debuglevel 0 - none
# debuglevel 1 - more output
# debuglevel 2 - wait for user response (sometimes!)

global CHECK_DEBUG_LEVEL
set CHECK_DEBUG_LEVEL 0 

#set CHECK_OUTPUT [open /dev/null "w"]
set CHECK_OUTPUT stdout

#
#                                                             max. column:     |
#****** check/debug_puts() ******
#  NAME
#     debug_puts -- ??? 
#
#  SYNOPSIS
#     debug_puts { args } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     args - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc debug_puts { args } {
   global CHECK_OUTPUT CHECK_DEBUG_LEVEL
   global CHECK_CUR_PROC_NAME CHECK_HOST last_debug_msec

   if { $CHECK_DEBUG_LEVEL == 0 } {
      return
   }

   set output ""
   foreach elem $args {
      set output "$output $elem"
   }   

   if { [info exists CHECK_HOST ] == 0 } {
      set CHECK_HOST "unknown"
   }
   if { [info exists CHECK_CUR_PROC_NAME] == 0 } {
      set CHECK_CUR_PROC_NAME "unknown"
   }
   set time [clock clicks -milliseconds]
   set time [expr $time - $last_debug_msec]

   set last_debug_msec [clock clicks -milliseconds]

   puts $CHECK_OUTPUT "\[$time $CHECK_HOST:$CHECK_CUR_PROC_NAME\] $output" 
}

#
#                                                             max. column:     |
#****** check/dump_ts_config() ******
#  NAME
#     dump_ts_config -- dump the testsuite configuration
#
#  SYNOPSIS
#     dump_ts_config { outputfile } 
#
#  FUNCTION
#     Dumps the contents of the ts_config array holding the testsuite 
#     configuration.
#     It is written to a file with the given outputfile name in a 
#     TAB separated ASCII file format:
#     The fields Name, Value and Description are written where
#     - Name is the name of the parameter
#     - Value is the value of the parameter in the current configuration
#     - Description is the testsuite internal description of the parameter
#
#  INPUTS
#     outputfile - name of the output file 
#
#  EXAMPLE
#     A call of
#     expect check.exp execute_func dump_ts_config ts_config.txt
#
#     will generate a file as follows:
#
#     Name    Value   Description
#     add_compile_archs       none    Forced compilation for architectures
#     aimk_compile_options    -secure Aimk compile options
#     checktree_root_dir   ...
#
#*******************************
#
proc dump_ts_config {outputfile} {
   global ts_config
  
   set output [open "$outputfile" w]
  
   set names {}
   
   foreach name [array names ts_config] {
      if {[string first "," $name] == -1} {
         lappend names $name
      }
   }

   puts $output "Name\tValue\tDescription\t"
   foreach name [lsort -dictionary $names] {
      puts $output [format "%s\t%s\t%s" "$name" "$ts_config($name)" "$ts_config($name,desc)"]
   }

   close $output
}



#                                                             max. column:     |
#****** check/get_current_working_dir() ******
# 
#  NAME
#     get_current_working_dir -- ??? 
#
#  SYNOPSIS
#     get_current_working_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_current_working_dir { } {

  set work_dir [pwd]
  debug_puts "working dir is $work_dir"
  set help0 $work_dir
  while  { 1 } {
     set help [ split $help0 "/" ]
     set help2 [ lreplace $help 0 1 ]
     set new_work_dir "/[ join $help2 "/" ]"
     set help0 $new_work_dir
     set catch_return_1 [ catch { 
         eval exec "ls $work_dir"
     } result_1 ] 

     set catch_return_2 [ catch { 
         eval exec "ls $new_work_dir" 
     } result_2 ]
     if { $catch_return_1 == 0 && $catch_return_2 == 0} {
        if { [ string compare $result_1 $result_2 ] == 0 } {
           # possibly mounted directory try to create a file
           set f_name "testsuite_test_[timestamp]"
           set catch_return_3 [ catch { 
              eval exec "touch $work_dir/$f_name" 
           } result_3 ]
           if { [ file isfile "$new_work_dir/$f_name" ] } {
              puts "--> mount prefix found, using $new_work_dir"
              set work_dir $new_work_dir
           }
           set catch_return_4 [ catch { 
              eval exec "rm $work_dir/$f_name" 
           } result_4 ]
        }
     }
     if { [string compare $help0 "/" ] == 0 } {
        break;
     }
  }
  return $work_dir 
}


set CHECK_CURRENT_WORKING_DIR [get_current_working_dir]
set CHECK_DEFAULTS_FILE    "$CHECK_CURRENT_WORKING_DIR/defaults.sav"

set CHECK_TESTSUITE_ROOT "$CHECK_CURRENT_WORKING_DIR"
set CHECK_CHECKTREE_ROOT "$CHECK_CURRENT_WORKING_DIR/checktree"
set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"
set CHECK_TESTSUITE_LOCKFILE "$CHECK_CURRENT_WORKING_DIR/testsuite_lockfile"


# some useful functions for test implementation



# 
#                                                             max. column:     |
#****** check/add_proc_error() ******
# 
#  NAME
#     add_proc_error -- append testsuite error message
#
#  SYNOPSIS
#     add_proc_error { proc_name result text } 
#
#  FUNCTION
#     This procedure adds a new error to the global error arrays for the global 
#     procedures.  
#
#     So a test programmer doesn't have to set the error states after calling 
#     a global procedure which uses add_proc_error. Each global procedure 
#     set the error state by itself. 
#
#     The test run will report ALL global errors and doesn't set the test run 
#     to a correct state if such an error is reported. 
#
#     Some global procedures have an optional flag to switch off the global 
#     error report. For some cases it is necessary to turn off the error 
#     reporting. (e.g. forced timeout test)
#
#  INPUTS
#     proc_name   - name of the calling procedure
#     result      - error state (e.g. -1)
#     text        - error text (e.g. "open file xxx failed)
#     raise_error - raise an error condition (including sending mail)
#                   or just output the error message
#
#  RESULT
#     no result
#
#  SEE ALSO
#     check/set_error
#*******************************
proc add_proc_error { proc_name result text {raise_error 1}} {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name
   global add_proc_error_avoid_recursive_call

   # There are cases where we intentionally make a command fail,
   # e.g. calling get_exechost for a non execution host.
   # We don't want the test to go into error state in this case,
   # but just see the error output.
   if {!$raise_error} {
      puts $CHECK_OUTPUT "----------------------------------------------------------------"
      puts $CHECK_OUTPUT $text  
      puts $CHECK_OUTPUT "----------------------------------------------------------------"
      return
   }

   # add_proc_error could be called recursively, for example, 
   # if errors occur while sending the error message as mail.
   # In this case, just output the error message - Otherwise we might 
   # end up in endless recursion.
   if {[info exists add_proc_error_avoid_recursive_call] && $add_proc_error_avoid_recursive_call == 1} {
      puts $CHECK_OUTPUT "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      puts $CHECK_OUTPUT "!!! recursive call of add_proc_error !!!"
      puts $CHECK_OUTPUT "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      puts $CHECK_OUTPUT "$proc_name|$result|$check_name|$CHECK_CUR_PROC_NAME"
      puts $CHECK_OUTPUT "$text"
      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT ""
      return
   }

   # avoid recursive call
   set add_proc_error_avoid_recursive_call 1

   lappend CHECK_CUR_PROC_RESULTS $result
   set new_error ""
   lappend new_error "$proc_name|$check_name|$CHECK_CUR_PROC_NAME|$text"
   lappend CHECK_CUR_PROC_ERRORS $new_error

   if { $check_name != "setup" } {
      show_proc_error $result $new_error
   } else {
      puts $CHECK_OUTPUT [ create_error_message $new_error ]
   }

   # now we are through, allow further calls of add_proc_error
   set add_proc_error_avoid_recursive_call 0
}


#                                                             max. column:     |
#****** check/have_ssh_access() ******
# 
#  NAME
#     have_ssh_access -- is ssh accessable ?
#
#  SYNOPSIS
#     have_ssh_access { } 
#
#  FUNCTION
#     This procedure tries to get a ssh (secure shell) connection to each execd 
#     host from the cluster. The result of this test is stored in a global 
#     variable so the next call will not cause the connection test again.
#
#  INPUTS
#
#  RESULT
#     0: no ssh access
#     1: ok
#
#  SEE ALSO
#     ???/???
#*******************************
proc have_ssh_access {} {
  global CHECK_CORE_EXECD CHECK_OUTPUT have_ssh_access_state CHECK_USE_SSH CHECK_HOST

  if { $have_ssh_access_state != -1 } {
     return $have_ssh_access_state
  }

  if { $CHECK_USE_SSH == 0 } {
     set have_ssh_access_state 0
     return $have_ssh_access_state
  }

  set run_again 0
  if { [ info exists CHECK_CORE_EXECD ] != 1 } {
     puts $CHECK_OUTPUT "no execd hosts defined, checking only local ssh connection"
     set run_again 1
     set host_array $CHECK_HOST 
  } else {
     set host_array $CHECK_CORE_EXECD
  }

  set ssh_binary [get_binary_path $CHECK_HOST ssh]
  if { $ssh_binary == "" } {
     add_proc_error "have_ssh_access" "-1" "--> no ssh binary configured for host $CHECK_HOST - please update your testsuite host configuration"
     return 0
  }

  log_user 0
  set have_complete_access 1
  
  foreach elem $host_array { 
     set catch_state [ catch {

        puts $CHECK_OUTPUT "trying $ssh_binary -l root $elem id"

        set id [ open_spawn_process "$ssh_binary" "-l" "root" "$elem" "id"]
        set sp_id [ lindex $id 1 ] 
 
        set timeout 30
        set end_val 0
        set have_access 0
        while { $end_val == 0} {
           log_user 0
           expect {
               -i $sp_id full_buffer {
                  add_proc_error "have_ssh_access" "-1" "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               }

               -i $sp_id "uid*0*root" {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> having ssh access to host $elem"
                  set end_val 1
                  set have_access 1
               }
               -i $sp_id "assword" {
                  set end_val 1
               }
               -i $sp_id timeout {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> timeout waiting to get root access"
                  set end_val 1
               }
               -i $sp_id eof {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> end of file dedected"
                  set end_val 1
               }
           }
        }
        set log_user 0
        close_spawn_process $id 1
        if { $have_access != 1 } {
            log_user 1
            set have_complete_access 0
            puts $CHECK_OUTPUT "--> no ssh access to host $elem"
            add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem"
        }
     } ] ;# end of chatch
     if { $catch_state != 0} {
        puts $CHECK_OUTPUT "--> no ssh access to host $elem (maybe no ssh installed)"
        add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem (maybe no ssh installed)"
        set have_complete_access 0
     }
  }
  log_user 1
  if { $run_again == 0 } {
     set have_ssh_access_state $have_complete_access
  }
  return $have_complete_access
}

proc init_stored_passwd {} {
   global stored_passwd

   set stored_passwd(root) ""
}

#****** check/set_root_passwd() ******
# 
#  NAME
#     set_root_passwd -- ask user for root password
#
#  SYNOPSIS
#     set_root_passwd { } 
#
#  FUNCTION
#     This procedure reads in the root password from stdin. If the root password 
#     is not used (ssh access garanted) the procedure returns immediately.
#     The root password is tested with an id call as root on the local machine.
#
#     If we have windows host(s) in our cluster, the procedure will also ask for 
#     the passwords of CHECK_USER, CHECK_FIRST_FOREIGN_SYSTEM_USER, and
#     CHECK_SECOND_FOREIGN_SYSTEM_USER.
#     This is required, as windows doesn't allow us to 
#        - access network filesystems
#        - switch to a certain target user
#     without the users password.
#
#  SEE ALSO
#     check/have_root_passwd
#     check/get_root_passwd
#*******************************
proc set_root_passwd {} {
   global global ts_config CHECK_OUTPUT
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER
   global stored_passwd

   # initialize stored password database
   if {![info exists stored_passwd]} {
      init_stored_passwd
   }

   set result "no password" 

   set passwd_required ""

   # if we don't have ssh access, we need the root passwd
   # and test it on the master host
   if {![have_ssh_access]} {
      lappend passwd_required "root"
   }

   # if we have a windows host in the cluster, we need passwords
   # of all users
   set windows_host ""
   if {[host_conf_have_windows]} {
      set passwd_required "$CHECK_USER root $CHECK_FIRST_FOREIGN_SYSTEM_USER $CHECK_SECOND_FOREIGN_SYSTEM_USER"
      puts "Our testsuite cluster contains (a) windows host(s)."
      puts "For both login into the windows host with full network access,"
      puts "and for executing jobs (which requires registering users with sgepasswd),"
      puts "we need the windows passwords of the following users:"
      foreach user $passwd_required {
         puts "  - $user"
      }

      # Test login on one of the windows hosts
      set windows_host [host_conf_get_windows_host]
   }

   # Enter and test passwords
   foreach user $passwd_required {
      set_passwd $user $ts_config(master_host) $windows_host
   }
   
   # Now check for additional password hooks from additional checktrees
   while { [get_user_passwd_hooks] != 0 } {
      puts "Error setting password hooks ..."
      wait_for_enter
   }
}

#****** check/get_user_passwd_hooks() ******************************************
#  NAME
#     get_user_passwd_hooks() -- check password hooks from add. checktrees
#
#  SYNOPSIS
#     get_user_passwd_hooks { } 
#
#  FUNCTION
#     If an additional checktree defines passwd_hook then this procedure
#     is calling the hook function.
#
#  RESULT
#     -1 => error
#     result of hook function ( should be 0 on success ) 
#
#*******************************************************************************
proc get_user_passwd_hooks {} {
   global ts_checktree CHECK_OUTPUT
   set res 0
   for {set i 0} { $i < $ts_checktree(act_nr)} {incr i 1 } {
      if { [info exists ts_checktree($i,passwd_hook) ] } {
         set prog $ts_checktree($i,passwd_hook)
         if { [info procs $prog ] != $prog } {
            add_proc_error "exec_install_binaries_hooks" -1 "Can not execute passwd hook $ts_checktree($i,passwd_hooks_${ii}), prog not found"
            return 0
         } else {
            set res [$prog]
            if { $res != 0} {
               break
            }
         }
      }
   }
   return $res
}  

#****** check/set_passwd() *****************************************************
#  NAME
#     set_passwd() -- query user for password
#
#  SYNOPSIS
#     set_passwd { user root_host win_host } 
#
#  FUNCTION
#     Interactively asks for the password of a certain user 
#     (required for windows) and stores it in a TCL data structure.
#
#  INPUTS
#     user      - user names whose password shall be set
#     root_host - host to be used for testing root password (usually a unix host)
#     win_host  - windows host to test user passwords
#
#  SEE ALSO
#     check/set_root_passwd()
#     check/get_passwd()
#     check/get_root_passwd()
#*******************************************************************************
proc set_passwd {user root_host win_host} {
   global ts_config CHECK_OUTPUT
   global CHECK_ADMIN_USER_SYSTEM
   global stored_passwd

   # repeat passwd question, until success, or 
   # user explicitly requested other options
   set error 1
   while {$error} {
      # enter passwd
      puts "\nhost access with password needed for user $user"
      if {$user == "root"} {
         puts "please enter the password, or \"noroot\" to start testsuite without root access"
      } else {
         puts "please enter the password, or \"none\" to skip passwd entry and risk errors later on"
      }
      puts "user $user's password: "
      stty -echo
      set passwd [wait_for_enter 1]
      stty echo

      # evaluate passwd
      if {$passwd == ""} {
         puts $CHECK_OUTPUT "--> password not set!"
         continue
      } else {
         # user explicitly requests not to have passwd?
         if {$user == "root" && $passwd == "noroot"} {
            set CHECK_ADMIN_USER_SYSTEM 1
            set error 0
         } else {
            if {$user != "root" && $passwd == "none"} {
               set error 0
            } else {
               # seems to be a real passwd - check it
               # temporarily set password database (for connection test)
               set stored_passwd($user) $passwd

               # choose host on which to test user's passwd
               if {$user == "root"} {
                  set host $root_host
               } else {
                  set host $win_host
               }

               # try to connect to host and execute "id"
               puts $CHECK_OUTPUT "--> testing $user access to host $host ..."
               set result [start_remote_prog $host $user "id" "" prg_exit_state 60 0 "" 1 1 1 0]
               puts $CHECK_OUTPUT "--> id as $user output:\n$result"

               # on error: allow reentering of passwd, or
               # switch to admin user system, or
               # do not reenter passwd and risk errors later on (windows non root users)
               if {[string first $user $result] >= 0} {
                  set error 0
               } else {
                  puts $CHECK_OUTPUT "--> no $user access"
                  set passwd ""
               }
            } ;# passwd check
         } ;# passwd or none has been entered
      } ;# passwd or noroot/none has been entered
   } ;# while loop entering passwd   

   # finally store the passwd
   set stored_passwd($user) $passwd
}

#****** check/get_passwd() *****************************************************
#  NAME
#     get_passwd() -- get the password of a given user
#
#  SYNOPSIS
#     get_passwd { user } 
#
#  FUNCTION
#     Returns the password of a given user (set ealier by set_passwd), or an
#     empty string, in case no password is available.
#
#  INPUTS
#     user - user whose password shall be returned
#
#  RESULT
#     the password or an empty string
#
#  SEE ALSO
#     check/set_passwd()
#*******************************************************************************
proc get_passwd {user} {
  global stored_passwd

   if {$user == "Administrator"} {
      set user "root"
   }

   if {![info exists stored_passwd($user)] || $stored_passwd($user) == ""} {
      add_proc_error "get_passwd" "-2" "$user's password not set"
      return ""
   }

   return $stored_passwd($user)
}

# 0 no action
# 1 new pre_install
# 2 only shutdown system
proc get_setup_change_state {} {
   global CHECK_OUTPUT CHECK_SETUP_CHANGES CHECK_SETUP_NAMES
   global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION
   global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
   global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
   global CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
   global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME
   global CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST 
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
   global CHECK_OUTPUT CHECK_SETUP_NAMES CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS
   global CHECK_MAX_ERROR_MAILS CHECK_HOST CHECK_USER
   global CHECK_SETUP_CHANGES

   set restart 0
   set pre_install 0

   foreach change $CHECK_SETUP_CHANGES {
      puts $CHECK_OUTPUT "cange of $change"
      puts $CHECK_OUTPUT "  old value: \"$CHECK_SETUP_NAMES($change,old)\""
      puts $CHECK_OUTPUT "  new value: \"[ set $CHECK_SETUP_NAMES($change)]\""

      switch -- $change {
         "qmaster_host" { 
            set help $CHECK_CORE_MASTER
            set  CHECK_CORE_MASTER $CHECK_SETUP_NAMES($change,old)
            puts $CHECK_OUTPUT "shutting down old system ..."  
            shutdown_core_system
            set CHECK_CORE_MASTER $help
         }
         "list_of_execution_hosts" {
            set help $CHECK_CORE_EXECD
            set  CHECK_CORE_EXECD  $CHECK_SETUP_NAMES($change,old)
            puts $CHECK_OUTPUT "shutting down old system ..."
            shutdown_core_system
            set CHECK_CORE_EXECD $help
         }
      }
 
      switch -- $CHECK_SETUP_NAMES($change,reinstall) {
         1 { incr pre_install  }
         2 { incr restart }
      }
   }
   set CHECK_SETUP_CHANGES ""
   if { $restart == 0 && $pre_install == 0 } { return 0 }
   if { $pre_install > 0 } { return 1 }
   if { $restart > 0 } { return 2 }

}


#                                                             max. column:     |
#****** check/have_root_passwd() ******
# 
#  NAME
#     have_root_passwd -- is root password available ?
#
#  SYNOPSIS
#     have_root_passwd { } 
#
#  FUNCTION
#     test if root password was typed in 
#
#  INPUTS
#     0  : root password should be ok
#     -1 : no root access
#  RESULT
#     
#
#  SEE ALSO
#     check/set_root_passwd
#     check/get_root_passwd
#*******************************
proc have_root_passwd {} {
  global CHECK_OUTPUT
  global stored_passwd

  if {[have_ssh_access] == 1} {
     return 0
  }

  if {![info exists stored_passwd(root)] || $stored_passwd(root) == ""} {
     puts $CHECK_OUTPUT "you have no ssh access and no root password"
     return -1
  }

  return 0
}

#                                                             max. column:     |
#****** check/get_root_passwd() ******
# 
#  NAME
#     get_root_passwd -- return root password 
#
#  SYNOPSIS
#     get_root_passwd { } 
#
#  FUNCTION
#     This procedure returns the root password, typed in by the user.
#
#  INPUTS
#
#  RESULT
#     string with root password
#
#  SEE ALSO
#     check/have_root_passwd
#     check/set_root_passwd
#*******************************
proc get_root_passwd {} {
  global stored_passwd
  
  if {![info exists stored_passwd(root)] || $stored_passwd(root) == ""} {
     add_proc_error "get_root_passwd" "-2" "root password not set"
     return ""
  }

  return $stored_passwd(root)
}





#                                                  max. column:     |
#****** check/mail_report() ******
# 
#  NAME
#     mail_report -- send mail
#
#  SYNOPSIS
#     mail_report { subject body } 
#
#  FUNCTION
#     This procedure sends an e-mail to the e-mail-address configured
#     with the global variables CHECK_REPORT_EMAIL_CC  and 
#     CHECK_REPORT_EMAIL_TO. Subject and body of the mail is taken 
#     from the parameters subject and body.
#
#  INPUTS
#     subject - e-mail subject text
#     body    - e-mail body text
#
#  SEE ALSO
#     check/send_mail
#*******************************
proc mail_report { subject body } {
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC CHECK_OUTPUT
   global write_mail_to_file

   set mail_cc ""

   # needn't check mailto / cc if we are writing to mailfile
   if {$write_mail_to_file == 0} {
      if { [string compare $CHECK_REPORT_EMAIL_TO "none"] == 0 } {
         puts $CHECK_OUTPUT "--> mail_report - no mail address"
         return
      }
   
      if { [string compare $CHECK_REPORT_EMAIL_CC "none"] != 0 } {
         set mail_cc $CHECK_REPORT_EMAIL_CC
      }
   }

   send_mail $CHECK_REPORT_EMAIL_TO $mail_cc $subject $body 
}



#                                                             max. column:     |
#****** check/send_mail() ******
# 
#  NAME
#     send_mail -- send mail  
#
#  SYNOPSIS
#     send_mail { address cc subject body } 
#
#  FUNCTION
#     This procedure calls the mailx binary by using remote shell to 
#     send an e-mail. 
#
#  INPUTS
#     address - e-mail address
#     cc      - e-mail CC address
#     subject - e-mail subject text  
#     body    - e-mail body text 
#
#  SEE ALSO
#     check/mail_report
#*******************************
proc send_mail { address cc subject body } {
   global ts_config
  global CHECK_TESTSUITE_ROOT CHECK_MAILX_HOST CHECK_OUTPUT
  global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_USER CHECK_MAX_ERROR_MAILS
  global write_mail_to_file CHECK_MAIL_OUTPUT_FILE CHECK_ENABLE_MAIL

  if { $write_mail_to_file != 0 } {
     set fd [ open $CHECK_MAIL_OUTPUT_FILE "a" ]
     puts $fd "-=*************************************************************=-"
     puts $fd "Grid Engine Version: [get_version_info]"
     puts $fd "Subject            : $subject"
     puts $fd "-=*************************************************************=-"
     puts $fd "$body"
     puts $fd "-=*=-"
     flush $fd
     close $fd 
     puts $CHECK_OUTPUT "Added entry in mail output file $CHECK_MAIL_OUTPUT_FILE"
     return
  }

  set erg [sendmail_wrapper $address $cc $subject $body]
  if { $erg == 0 } {
     return
  }

  set new_subject "[get_version_info] ($ts_config(cell)) - $subject"

  if { $CHECK_ENABLE_MAIL != 1 } {
     puts $CHECK_OUTPUT "mail sending disabled, mails sent: $CHECK_MAILS_SENT"
     puts $CHECK_OUTPUT "mail new_subject: $new_subject"
     puts $CHECK_OUTPUT "mail body:"
     puts $CHECK_OUTPUT "$body"
     return
  }


  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 

  set output_file [ open "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" "w"]
  puts $output_file $body
  flush $output_file
  close $output_file

  set file_size 0
   while { $file_size == 0 } {
      catch { set file_size [file size "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp"]}
      if { $file_size == 0 } { 
         puts $CHECK_OUTPUT "--> file size of \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\": $file_size ; waiting for filesize > 0"
         sleep 1
      }
   }



  catch { exec "touch" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result
  catch { exec "chmod" "0755" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result

  if { [string compare $cc "none"] != 0 } {
     set mail_args "-s \"$new_subject\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  } else {
     set mail_args "-s \"$new_subject\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  }
  set mail_output [ start_remote_prog $CHECK_MAILX_HOST $CHECK_USER "mailx" "$mail_args" prg_exit_state 60 0 "" 1 0 ]

  if { $prg_exit_state != 0 } {
     puts $CHECK_OUTPUT "--> send_mail - could not send mail:\n$mail_output"
  } else {
     puts $CHECK_OUTPUT "--> send_mail - mail sent to $address"
     incr CHECK_MAILS_SENT 1
     if { $CHECK_MAILS_SENT == $CHECK_MAX_ERROR_MAILS } {
        if { [string compare $cc "none"] != 0 } {
           set mail_args "-s \"max mail count reached\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
        } else {
           set mail_args "-s \"max mail count reached\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
        }
        start_remote_prog $CHECK_MAILX_HOST $CHECK_USER "mailx" "$mail_args" prg_exit_state 60 0 "" 1 0 
        set CHECK_ENABLE_MAIL 0
     }  
  }
  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 
}




# This procedure simply sets the global variables check_errno 
# and check_errstr to the given parameters. It 
#                                                             max. column:     |
#****** check/set_error() ******
# 
#  NAME
#     set_error -- set error for current check 
#
#  SYNOPSIS
#     set_error { erno errtext } 
#
#  FUNCTION
#     This procedure simply sets the global variables check_errno and 
#     check_errstr to the given parameters. Beyond it the procedure 
#     add_proc_error is called in order to append the errors to the global error 
#     list.
#
#  INPUTS
#     erno    - integer
#               0  = no error
#               -1 = error, but the check will run till end
#               -2 = error, the current check will stop (no further check function
#                    is called)
#               -3 = warning, (e.g. test can not run on this host)
#
#     errtext - short error description
#
#
#  EXAMPLE
#     set_error 0 "ok"  ;# Test is "OK"
#
#  SEE ALSO
#     check/add_proc_error
#*******************************
proc set_error {erno errtext} {
  global check_errno 
  global check_errstr CHECK_CUR_PROC_RESULTS
  global set_error_proc_called

  set set_error_proc_called 1
  set check_errno $erno
  set check_errstr $errtext

  add_proc_error "set_error" $erno $errtext

  if { $check_errno == 0 } {
    foreach element $CHECK_CUR_PROC_RESULTS {
      if { $element != 0 && $element != -3 } {   ;# there was a former error in this test !!
         set check_errno -1
         set check_errstr "error!"
      }
    }
  }

  return $erno
}

#****** check/get_testsuite_root_dir_from_file() *******************************
#  NAME
#     get_testsuite_root_dir_from_file() -- get testsuite root directory
#
#  SYNOPSIS
#     get_testsuite_root_dir_from_file { filename } 
#
#  FUNCTION
#     This procedure greps for the testsuite configuration in the given file.
#     It only returns the testsuite root directory. This function is used
#     to setup the CHECK_TESTSUITE_ROOT variable before sourcing the
#     file procedures script in the tcl_directory.
#
#  INPUTS
#     filename - path to testsuite configuration file (defaults file)
#
#  RESULT
#     testsuite root directory path
#
#  SEE ALSO
#     check/setup2
#*******************************************************************************
proc get_testsuite_root_dir_from_file { filename } {

   if { [file isfile $filename] != 1 } {
      return "no_such_file" 
   }
   set file [open $filename "r"]
   set found_object 0
   set next 0
   while { [gets $file line] >= 0 } {
      if { $next == 1 } {
         break
      }
      if { [ string first "OBJ_START:testsuite configuration:" $line] >= 0 } { 
         set found_object 1
      }
      if { [ string first ":testsuite_root_dir:" $line] >= 0 && $found_object == 1 } {
         set next 1
      }
   }
   if { $next == 1 } {
      set start [ string first ":" $line ]
      set end   [ string last ":" $line ]   
      incr start 1
      incr end -1
      return [string range $line $start $end]
   } 
   close $file
   return "testsuite_root_dir_not_found"
}

#                                                             max. column:     |
#****** check/edit_defaults() ******
# 
#  NAME
#     edit_defaults -- ??? 
#
#  SYNOPSIS
#     edit_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc edit_defaults {} {
  global CHECK_OUTPUT CHECK_DEFAULTS_FILE CHECK_HOST CHECK_CONFIG_DIR
  global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
  global env

  load_defaults
  set return_value -1
  if { [ write_edit_defaults_file "/tmp/testsuite_tmp_defaults_file" ] != 0 } {
     puts $CHECK_OUTPUT "error open file \"$def_edit_file\" for writing"
     return -1
  }

  puts $def_edit_file
  set exit_edit_loop 0
  while { $exit_edit_loop == 0 } {
     if { $CHECK_CONFIG_DIR != "" } {
        set vim_binary [get_binary_path "$CHECK_HOST" "vim"]
     } else {
        puts $CHECK_OUTPUT "config directory path not set ..."
        set env_variable "EDITOR"
        puts $CHECK_OUTPUT "checking for $env_variable environment setting..."
        if { [info exists env($env_variable)] } {
           puts $CHECK_OUTPUT "$env_variable=$env($env_variable)"
           set vim_binary $env($env_variable)
           puts $CHECK_OUTPUT "using environment $env_variable"
        } else {
           puts $CHECK_OUTPUT "environment $env_variable not set, using default"
           set vim_binary "vim"
        }
        set catch_return [ catch { eval exec which $vim_binary } catch_value ]
        puts $CHECK_OUTPUT "exec \"which $vim_binary\" returns: $catch_return"
        if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "error executing \"which $vim_binary\"!!!"
        } else {
           set vim_binary $catch_value
        }
        if { [file exists $vim_binary] != 1 } {
           puts $CHECK_OUTPUT "could not find binary"
           puts $CHECK_OUTPUT "$vim_binary"
           exit 1
        }
        puts $CHECK_OUTPUT "using \"$vim_binary\" as editor"
     }
     set env(EDITOR) $vim_binary
     set id [ open_spawn_process $vim_binary "$def_edit_file" ]
     interact -o -i [lindex $id 1]
     set exit_state [ close_spawn_process $id ]

     if { $exit_state == 0 } {
        set read_return [ read_edit_defaults_file "$def_edit_file" ] 
        if { $read_return >= 0 } { 
           if { $read_return == 0 } {
              puts $CHECK_OUTPUT "no changes"
              set return_value 1
              set exit_edit_loop 1
           } else {
              puts $CHECK_OUTPUT "$read_return changes in defaults file \"$CHECK_DEFAULTS_FILE\""
              set return_value 0
              set exit_edit_loop 1
           }
        } else {
           puts $CHECK_OUTPUT "error reading file \"$def_edit_file\""
           puts $CHECK_OUTPUT "\n>> press CTRL-C to abort setup configuration!"
           wait_for_enter
        }
     }
  }
  if { [ string first "/tmp/testsuite_tmp_defaults_file" $def_edit_file ] >= 0 } {
     file delete $def_edit_file
     puts $CHECK_OUTPUT "file \"$def_edit_file\" deleted!" 
  }
  return $return_value 
}

#                                                             max. column:     |
#****** check/calc_space() ******
# 
#  NAME
#     calc_space -- ??? 
#
#  SYNOPSIS
#     calc_space { space name } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     space - ??? 
#     name  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc calc_space {space name} {

  set length [ string length $name ]
  set spaces [ expr ( $space - $length )  ]
  set back ""
  for {set i 0} { $i < $spaces} { incr i 1} {
     set back "$back "
  }
  return $back
}

proc get_local_hostname {} {
   global env CHECK_OUTPUT 
   set catch_return [ catch { exec "hostname" } result ]
   if { $catch_return == 0 } {
      set result [split $result "."]
      set newname [lindex $result 0]
      puts $CHECK_OUTPUT "got hostname: \"$newname\""
      return $newname
   } else {
      puts $CHECK_OUTPUT "local hostname error or binary not found"
      puts $CHECK_OUTPUT "error: $result"
      puts $CHECK_OUTPUT "error: $catch_return"
      puts $CHECK_OUTPUT "trying local HOST environment variable ..."
      if { [ info exists env(HOST) ] } {
         set result [split $env(HOST) "."]
         set newname [lindex $result 0]
         if { [ string length $newname ] > 0 } {
             puts $CHECK_OUTPUT "got hostname_ \"$newname\""
             return $newname
         } 
      }
   }
   puts $CHECK_OUTPUT "tcl procedure get_local_hostname() can't get local hostname"
   puts $CHECK_OUTPUT "please set check if binary \"hostname\" is in path or"
   puts $CHECK_OUTPUT "set the environment variable \"HOST\" to the hostname value"
   exit 1
   return "unknown"
}

#****** check/check_executable_files() *****************************************
#  NAME
#     check_executable_files() -- check if testsuite files are executable
#
#  SYNOPSIS
#     check_executable_files { } 
#
#  FUNCTION
#     testsuite setup
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc check_executable_files {  } {

   global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_SOURCE_DIR

   set filelist ""
   set shell_filelist [get_file_names "$CHECK_TESTSUITE_ROOT/scripts" "*.sh"]
   set cshell_filelist [get_file_names "$CHECK_TESTSUITE_ROOT/scripts" "*.csh"]
   set tcl_filelist [get_file_names "$CHECK_TESTSUITE_ROOT/scripts" "*.tcl"]
   
   foreach file $shell_filelist {
      lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/$file"
   }
   foreach file $cshell_filelist {
      lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/$file"
   }
   foreach file $tcl_filelist {
      lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/$file"
   }
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/bugs/issuezilla/126/sleep.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/bugs/issuezilla/1334/jobstarter.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/bugs/issuezilla/1489/infinity.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/bugs/issuezilla/1489/termtest.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/bugs/issuezilla/1556/1556.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/checkpt_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/migrate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qmake/echo_variable.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qmod/general/qmod_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/qsub_gid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/sleep_pid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/starter.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/terminate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/trap.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/ulimit.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qsub/starter.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qsub/sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qtcsh/qtask_global.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qtcsh/qtask_local.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/pminiworm.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/flood_sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/qstat.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/redir_stderr.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/sge_start.sh"
   lappend filelist "$CHECK_SOURCE_DIR/aimk"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/env-tester.csh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/jobnet_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/pminiworm.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/simple.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/sleeper.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_A_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_B_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/worker.sh"
   
   set change_files ""


   set file_error 0
   foreach elem $filelist {
      set filename $elem
      if { [ file isfile $filename ] != 1  } {
         puts $CHECK_OUTPUT "file not found: $filename"
         set file_error 1
         continue
      }
      set attribs [ file attributes $filename -permissions] 
      if { [ string compare $attribs "00755" ] != 0 } {
         puts $CHECK_OUTPUT "file not executable (attributes: $attribs):\n $filename"
         lappend change_files $filename
         set file_error 1
         continue
      }
   }

   if { $file_error != 0 } {
      while { 1 } {
         puts $CHECK_OUTPUT "should I set the file permissions to 00755? (yes/no)"
         set answer [wait_for_enter 1]
         if { [ string compare $answer "yes" ] == 0 } {
            foreach elem $change_files {
                catch { file attributes $elem -permissions 00755 }
                set attribs [ file attributes $elem -permissions] 
                if { [ string compare $attribs "00755" ] != 0  } {
                   puts $CHECK_OUTPUT "check_executable_files - error setting file permissions: $elem"
                   exit -1
                }
            }  
            break
         } 
         if { [ string compare $answer "no" ] == 0 } {
            puts $CHECK_OUTPUT "check_executable_files - file errors. exit."
            exit -1
         } 
         puts $CHECK_OUTPUT "please enter \"yes\" or \"no\"!"
      }
   }
}

#****** check/set_users_environment() ******************************************
#  NAME
#     set_users_environment() -- setup user and l10n environment
#
#  SYNOPSIS
#     set_users_environment { host {variable_name env} { show_variables 0 } } 
#
#  FUNCTION
#     This procedure is used to generate the users environment for the
#     local environment and for the create_shell_script() procedure.
#
#  INPUTS
#     host                 - hostname (used for l10n)
#     {variable_name env}  - variable to store environment
#     { show_variables 0 } - if 1: print setting info
#
#  SEE ALSO
#     file_procedures/create_shell_script()
#*******************************************************************************
proc set_users_environment { node {variable_name env} { show_variables 0 } } {
   global CHECK_REMOTE_ENVIRONMENT CHECK_OUTPUT env 
   global CHECK_L10N ts_host_config ts_config

   upvar $variable_name environment

   set host [node_get_host $node]

   set remote_environment $CHECK_REMOTE_ENVIRONMENT

   if { $CHECK_L10N == 0 && [llength $remote_environment] == 0 } {
      return 0
   }

   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   if { $CHECK_L10N != 0 } {
      set locale $ts_config(l10n_test_locale)
      if { [ info exist ts_host_config($host,${locale}_locale) ] != 1 } {
         if { [set pos [ string first $ts_config(dns_domain) $host]] >= 0 } {
            if { $ts_config(dns_for_install_script) == "none" } {
                incr pos -2
                set host [ string range $host 0 $pos ]
            }
         }
      }

      if { [ info exist ts_host_config($host,${locale}_locale) ] } {
         set locale_env $ts_host_config($host,${locale}_locale)
         if { $locale_env == "" } {
            debug_puts "no value for ${locale}_locale on host $host, please set LANG, LC_MESSAGES ..."
         }
         append locale_env " SGE_ENABLE_MSG_ID=2 SGE_INFOTEXT_MAX_COLUMN=5000"
         debug_puts "L10N enabled"
         debug_puts "locale = \"$locale\""
         debug_puts "environment on host $host: $locale_env"
         foreach u_env $locale_env {
            debug_puts "environment: $u_env"
            set help [split $u_env "="]
            set env_name  [lindex $help 0]
            set env_value [lindex $help 1]
            debug_puts "env_name: $env_name"
            if { [string compare $env_name ""] == 0 } {
               puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
               return -1
            }
            debug_puts "env_value: $env_value"
            if { [string compare $env_value ""] == 0 } {
               if { [info exists env($env_name)] } {
                  set env_value $env($env_name)
               } else {
                  puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
                  return -1
               }
            }
            if { [string compare $variable_name "env"] == 0 } {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting local l10n variable $env_name=\"$env_value\""
               }
            } else {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting remote l10n variable $env_name=\"$env_value\""
               }
            }
            set environment($env_name) $env_value 
            debug_puts "$env_name set to \"$env_value\""
         }
      } else {
         debug_puts "could not find l10n configuration for host $host"
      }
   }

   foreach u_env $remote_environment {
      debug_puts "environment: $u_env"
      set help [split $u_env "="]
      set env_name  [lindex $help 0]
      set env_value [lindex $help 1]
      debug_puts "env_name: $env_name"
      if { [string compare $env_name ""] == 0 } {
         puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
         return -1
      }
      debug_puts "env_value: $env_value"
      if { [string compare $env_value ""] == 0 } {
         if { [info exists env($env_name)] } {
            set env_value $env($env_name)
         } else {
            puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
            return -1
         }
      }
      if { [string compare $variable_name "env"] == 0 } {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting local variable $env_name=\"$env_value\""
         }
      } else {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting remote variable $env_name=\"$env_value\""
         }
      }
      set environment($env_name) $env_value 
      debug_puts "$env_name set to \"$env_value\""
   }
   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   return 0
}

proc show_setup_information { } {

   global CHECK_OUTPUT

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "If you are starting the testsuite for the first time you should read this short"
   puts $CHECK_OUTPUT "setup guide to make it easier for you to understand the setup questions."
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The testsuite needs 3 user accounts:\n"
   puts $CHECK_OUTPUT " a) testsuite user:   The user who is starting the testsuite\n"
   puts $CHECK_OUTPUT " b) first_foreign_system_username:  "
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of two system groups (use <SPACE>"
   puts $CHECK_OUTPUT "                      to seperate the groups)\n"
   puts $CHECK_OUTPUT " c) second_foreign_system_username:"
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of a system group where b) is not"
   puts $CHECK_OUTPUT "                      group member.\n"
 
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The 3 user accounts must have rlogin access to the cluster hosts. (.rhost file)\n"
   puts $CHECK_OUTPUT "Every output to stdout in\n"
   puts $CHECK_OUTPUT " /etc/csh.cshrc, /etc/csh.login, \$HOME/.cshrc, \$HOME/.login , ...\n"
   puts $CHECK_OUTPUT "is not allowed. The testsuite will use e.g. rlogin \$EXEC_HOST pwd to get the"
   puts $CHECK_OUTPUT "working directory on that host. Any output made in the files would influence"
   puts $CHECK_OUTPUT "the result of the call.\n" 

   puts $CHECK_OUTPUT "Each of the 3 user must have read access to\n"
   puts $CHECK_OUTPUT "   - testsuite directory"
   puts $CHECK_OUTPUT "   - source code directory"
   puts $CHECK_OUTPUT "   - installation directory (\$SGE_ROOT)"   
  
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "All path statements have to be absolute. The use of links may cause troubles."
    
   wait_for_enter
}


#****** check/save_host_configuration() ****************************************
#  NAME
#     save_host_configuration() -- save host configuration
#
#  SYNOPSIS
#     save_host_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual host configuration to the given
#     file. (ts_host_config array)
#
#  INPUTS
#     file - host configuration file
#
#  SEE ALSO
#     check/save_user_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_host_configuration { file } {
   global ts_host_config
   global CHECK_OUTPUT

   set conf_name "testsuite host configuration"

   if { [ info exists ts_host_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $file $conf_name old_host_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_host_config
   spool_array_to_file $file $conf_name ts_host_config  
   puts $CHECK_OUTPUT "new host configuration saved: version: $ts_host_config(version)"
   wait_for_enter
   return 0
}

#****** check/save_user_configuration() ****************************************
#  NAME
#     save_user_configuration() -- save user configuration file
#
#  SYNOPSIS
#     save_user_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual user configuration to the given
#     file. (ts_user_config array)
#
#  INPUTS
#     file - user configuration file
#
#  SEE ALSO
#     check/save_host_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_user_configuration { file } {
   global ts_user_config
   global CHECK_OUTPUT

   if { [ info exists ts_user_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }


   set conf_name "testsuite user configuration"
   # first get old configuration
   read_array_from_file  $file $conf_name old_user_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_user_config
   spool_array_to_file $file $conf_name ts_user_config  
   
   puts $CHECK_OUTPUT "new user configuration saved"
   wait_for_enter

   return 0
}


#****** check/save_configuration() *********************************************
#  NAME
#     save_configuration() -- save testsuite configuration (ts_config array)
#
#  SYNOPSIS
#     save_configuration { } 
#
#  FUNCTION
#     This procedure will save the actual ts_config array settings to the
#     testsuite setup file.
#
#  SEE ALSO
#     check/restore_configuration()
#*******************************************************************************
proc save_configuration {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE
   global pe_for_version_check_result

   set conf_name "testsuite configuration"

   if { [ info exists ts_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE $conf_name old_config
   # save old configuration 
   spool_array_to_file $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name ts_config  
   puts $CHECK_OUTPUT "new testsuite configuration saved"

   set pe_for_version_check_result "undefined"

   wait_for_enter

   return 0
}

#****** check/restore_configuration() ******************************************
#  NAME
#     restore_configuration() -- restore old testsuite configuration
#
#  SYNOPSIS
#     restore_configuration { } 
#
#  FUNCTION
#     This procedure can be used to get the previous testsuite configuration
#
#  SEE ALSO
#     check/save_configuration()
#*******************************************************************************
proc restore_configuration { } {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE

   set conf_name "testsuite configuration"

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   if { [ info exists old_config(version) ] } {
      puts $CHECK_OUTPUT "spooling previous configuration (Version: $old_config(version)"
      spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name old_config
   } else {
      puts $CHECK_OUTPUT "no previous configuration available!"
   }
   puts $CHECK_OUTPUT "reading latest configuration ..."
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name" ts_config

   return 0
}


#****** check/get_configuration_element_name_on_pos() **************************
#  NAME
#     get_configuration_element_name_on_pos() -- return config elem name on pos
#
#  SYNOPSIS
#     get_configuration_element_name_on_pos { config_array config_pos } 
#
#  FUNCTION
#     This procedure returns the name of the configuration element on the
#     given position.
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#     config_pos   - pos number
#
#  SEE ALSO
#     check/get_configuration_element_count()
#*******************************************************************************
proc get_configuration_element_name_on_pos { config_array config_pos } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) == $config_pos } {
         return $elem
      }
   }
   return ""
}



#****** check/get_configuration_element_count() ********************************
#  NAME
#     get_configuration_element_count() -- returns number of conig elements
#
#  SYNOPSIS
#     get_configuration_element_count { config_array } 
#
#  FUNCTION
#     This procedure returns the config parameter count for one of the testsuite
#     setup arrays (ts_config, ts_host_config, ts_user_config)
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#
#  SEE ALSO
#     check/get_configuration_element_name_on_pos()
#*******************************************************************************
proc get_configuration_element_count { config_array } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) > $max_pos } {
         set max_pos $config($elem,pos)
      }
   }
   return $max_pos
}



#****** check/update_ts_host_config_version() **********************************
#  NAME
#     update_ts_host_config_version() -- used for version update of ts_host_config
#
#  SYNOPSIS
#     update_ts_host_config_version { filename } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite host configuration
#     are not equal.
#
#  INPUTS
#     filename - host configuration file
#
#  SEE ALSO
#     check/update_ts_config_version()
#*******************************************************************************
proc update_ts_host_config_version { filename } {
   global actual_ts_host_config_version
   global ts_host_config ts_config
   global CHECK_OUTPUT CHECK_USER

   if {$ts_host_config(version) == "1.0"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.0 to 1.1 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,fr_locale) ""
         set ts_host_config($host,ja_locale) ""
         set ts_host_config($host,zh_locale) ""
      }
      set ts_host_config(version) "1.1"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
   }

   if {$ts_host_config(version) == "1.1"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.1 to 1.2 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,ssh) ""
      }
      set ts_host_config(version) "1.2"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
   }

   if {$ts_host_config(version) == "1.2"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.2 to 1.3 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,java) ""
      }
      set ts_host_config(version) "1.3"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   if {$ts_host_config(version) == "1.3"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.3 to 1.4 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,zones) ""
      }
      set ts_host_config(version) "1.4"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   if {$ts_host_config(version) == "1.4"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.4 to 1.5 ..."

      # insert new parameter after version parameter
      set insert_pos $ts_host_config(version,pos)
      incr insert_pos 1

      # move positions of following parameters for 2 steps
      set new_parameter_cont 2
      set names [array names ts_host_config "*,pos"]
      foreach name $names {
         if { $ts_host_config($name) >= $insert_pos } {
            set ts_host_config($name) [ expr ( $ts_host_config($name) + $new_parameter_cont ) ]
         }
      }

      # parameter 1
      set parameter "NFS-ROOT2NOBODY"
      set ts_host_config($parameter)            ""
      set ts_host_config($parameter,desc)       "NFS shared directory with root to nobody mapping"
      set ts_host_config($parameter,default)    ""
      set ts_host_config($parameter,setup_func) "host_config_$parameter"
      set ts_host_config($parameter,onchange)   "install"
      set ts_host_config($parameter,pos)        $insert_pos

       
      # increment position for the second parameter 
      incr insert_pos 1

      # parameter 2
      set parameter "NFS-ROOT2ROOT"
      set ts_host_config($parameter)            ""
      set ts_host_config($parameter,desc)       "NFS shared directory with root read/write rights"
      set ts_host_config($parameter,default)    ""
      set ts_host_config($parameter,setup_func) "host_config_$parameter"
      set ts_host_config($parameter,onchange)   "install"
      set ts_host_config($parameter,pos)        $insert_pos

 
      # now we have version 1.5
      set ts_host_config(version) "1.5"

      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   if {$ts_host_config(version) == "1.5"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.5 to 1.6 ..."

      foreach host $ts_host_config(hostlist) {
         # convert the one architecture string to a version dependent one
         set arch $ts_host_config($host,arch)
         unset ts_host_config($host,arch)
         set ts_host_config($host,arch,53) [host_conf_53_arch $arch]
         set ts_host_config($host,arch,60) [host_conf_60_arch $arch]
         set ts_host_config($host,arch,65) [host_conf_65_arch $arch]

         # we now store compile host property depending on gridengine version
         # assume our current compile hosts compile for 53, 60, and 65
         if {$ts_host_config($host,compile) == 1} {
            set ts_host_config($host,compile,53) 1
            set ts_host_config($host,compile,60) 1
            set ts_host_config($host,compile,65) 1
         } else {
            set ts_host_config($host,compile,53) 0
            set ts_host_config($host,compile,60) 0
            set ts_host_config($host,compile,65) 0
         }
         unset ts_host_config($host,compile)
      }
      set ts_host_config(version) "1.6"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   if {$ts_host_config(version) == "1.6"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.6 to 1.7 ..."

      foreach host $ts_host_config(hostlist) {
         # convert the java home string to a version dependent one
         puts -nonewline " ... "
         set myenv(EN_QUIET) "1"
         set java15_bin [ start_remote_prog $host $CHECK_USER "/bin/csh" "-c \"source /vol2/resources/en_jdk15 ; which java\"" prg_exit_state 12 0 myenv 1 0 ]
         if { $prg_exit_state != 0 } {
            set java15_bin "" 
         }
         set java15_bin [string trim $java15_bin]
         if { ![file isfile $java15_bin] } {
            puts $CHECK_OUTPUT "file not found"
            set java15_bin ""
         }
         puts $CHECK_OUTPUT "setting java15 for host $host to \"$java15_bin\""
         set ts_host_config($host,java15) $java15_bin
      }
      set ts_host_config(version) "1.7"
     
      show_config ts_host_config
      wait_for_enter
      if {[save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   if {$ts_host_config(version) == "1.7" && $actual_ts_host_config_version == "1.8"} {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.7 to 1.8 ..."

      foreach host $ts_host_config(hostlist) {
         # we now store java compile host property depending on gridengine version
         set ts_host_config($host,java_compile,53) 0
         set ts_host_config($host,java_compile,60) 0
         set ts_host_config($host,java_compile,65) 0
      }
      set ts_host_config(version) "1.8"
     
      show_config ts_host_config
      wait_for_enter
      if {[save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   puts $CHECK_OUTPUT "\nunexpected version"
   return -1
}

#****** check/update_ts_config_version() ***************************************
#  NAME
#     update_ts_config_version() -- used for version update of ts_config
#
#  SYNOPSIS
#     update_ts_config_version { } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite configuration
#     are not equal.
#
#  SEE ALSO
#     check/update_ts_host_config_version()
#*******************************************************************************
proc update_ts_config_version {} {
   global actual_ts_config_version 
   global ts_config
   global CHECK_OUTPUT

   if { $ts_config(version) == "1.0" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.0 to 1.1 ..."
      config_build_ts_config_1_1
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.1" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.1 to 1.2 ..."
      config_build_ts_config_1_2
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.2" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.2 to 1.3 ..."
      config_build_ts_config_1_3
      show_config ts_config
      wait_for_enter
   }
   
   if { $ts_config(version) == "1.3" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.3 to 1.4 ..."
      config_build_ts_config_1_4
      show_config ts_config
      wait_for_enter
   }
   
   if { $ts_config(version) == "1.4" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.4 to 1.5 ..."
      config_build_ts_config_1_5
      show_config ts_config
      wait_for_enter
   }
   
   if { $ts_config(version) == "1.5" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.5 to 1.6 ..."
      config_build_ts_config_1_6
      show_config ts_config
      wait_for_enter
   }
  
   if { $ts_config(version) == "1.6" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.6 to 1.7 ..."
      config_build_ts_config_1_7
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.7" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.7 to 1.8 ..."
      config_build_ts_config_1_8
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.8" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.8 to 1.9 ..."
      config_build_ts_config_1_9
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.9" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.9 to 1.91 ..."
      config_build_ts_config_1_91
      show_config ts_config
      wait_for_enter
      return 0
   }
   
   puts $CHECK_OUTPUT "\nunexpected version $ts_config(version), need version $actual_ts_config_version"
   return -1
}

#****** check/get_spaces() *****************************************************
#  NAME
#     get_spaces() -- return string with given number of spaces 
#
#  SYNOPSIS
#     get_spaces { nr } 
#
#  FUNCTION
#     This procedure returns a string with the given number of spaces
#
#  INPUTS
#     nr - nr of spaces in string
#
#  RESULT
#     string with given number of spaces
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc get_spaces { nr } {
   set spaces ""
   for { set i 0 } { $i < $nr } { incr i 1 } {
      append spaces " "
   }
   return $spaces
}


#****** check/setup2() *********************************************************
#  NAME
#     setup2() -- testsuite initialization procedure
#
#  SYNOPSIS
#     setup2 { } 
#
#  FUNCTION
#     This procedure is used for testsuite initalization.
#
#  INPUTS
#
#  SEE ALSO
#     check/__setup()
#*******************************************************************************
proc setup2 { } {
   global sge_config
   global ts_config ts_host_config ts_user_config actual_ts_config_version
   global CHECK_OUTPUT CHECK_DO_SETUP
   global CHECK_DEFAULTS_FILE do_nomain
   global env be_quiet fast_setup
   global check_name CHECK_ACT_LEVEL have_defaults
   global CHECK_USER CHECK_CURRENT_WORKING_DIR
   global CHECK_PRODUCT_TYPE
   global CHECK_PRODUCT_VERSION_NUMBER
   global CHECK_PRODUCT_ROOT
   global CHECK_COMMD_PORT
   global CHECK_TESTSUITE_ROOT
   global CHECK_CONFIG_DIR
   global CHECK_CHECKTREE_ROOT
   global CHECK_MAIN_RESULTS_DIR
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_PROTOCOL_DIR
   global CHECK_CORE_MASTER
   global CHECK_CORE_EXECD
   global CHECK_SUBMIT_ONLY_HOSTS
   global CHECK_USER
   global CHECK_GROUP
   global CHECK_CURRENT_WORKING_DIR
   global CHECK_SOURCE_DIR
   global CHECK_SOURCE_CVS_RELEASE
   global CHECK_SOURCE_HOSTNAME
   global CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY
   global CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS
   global CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME
   global CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST
   global CHECK_REPORT_EMAIL_TO
   global CHECK_REPORT_EMAIL_CC
   global CHECK_SEND_ERROR_MAILS 
   global CHECK_MAX_ERROR_MAILS
   global CHECK_USE_SSH 
 

   # unset old system environment
   if { $be_quiet == 0 } { 
      puts "starting setup ..."
   }
   if { [info exists env(GRD_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting GRD_ROOT"
      }
      unset env(GRD_ROOT)
   }
   if { [info exists env(CODINE_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting CODINE_ROOT"
      }
      unset env(CODINE_ROOT)
   }
   
   # setup check information for error mails
   set check_name "setup"
   set CHECK_ACT_LEVEL "0"
   set have_defaults 0
   set configuration_updated 0

   if { [read_array_from_file $CHECK_DEFAULTS_FILE "testsuite configuration" ts_config ] == 0 } {
      if { $ts_config(version) != $actual_ts_config_version } {
         puts $CHECK_OUTPUT "unkown configuration file version: $ts_config(version)"
         while { [update_ts_config_version] != 0 } {
            wait_for_enter
         }

         # we have to store it later, after verifying the updated config
         set configuration_updated 1
      }
      # got config
     
      read_array_from_file $ts_config(host_config_file) "testsuite host configuration" ts_host_config
     
      if { [verify_config ts_config 1 err_list] != 0 } {
       
         # configuration problems

         foreach elem $err_list {
            puts "$elem"
         } 
         puts "Press enter to edit setup configurations"
         set answer [wait_for_enter 1]
         set not_ok 1
         while { $not_ok } {
            if { [verify_config ts_config 0 err_list ] != 0 } {
               wait_for_enter
               set not_ok 1
               foreach elem $err_list {
                  puts $CHECK_OUTPUT "error in: $elem"
               } 
               puts $CHECK_OUTPUT "Try again? (y/n)"
               set answer [wait_for_enter 1]
               if { $answer == "n" } {
                  # restore old config ?
                  puts $CHECK_OUTPUT "Do you want to restore previous configuration? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [restore_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error restoring configuration!"
                        exit 1
                     }
                     exit 0
                  }
                  # save anyway
                  puts $CHECK_OUTPUT "Do you want to save your changes? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [save_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error saving configuration!"
                        exit 1
                     }
                  }
                  exit 1
               } 
            } else {
               set not_ok 0
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      } else {
         if { $configuration_updated } {
            puts $CHECK_OUTPUT "Do you want to save the updated configuration? (y/n)"
            set answer [ wait_for_enter 1 ]
            if { $answer == "y" } {
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      }
      set CHECK_CONFIG_DIR "not supported in setup2 config file"
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\nstarting setup ... ok"
      }
      enhanced_setup
      
      if { $CHECK_DO_SETUP == 1 } {
         modify_setup2
      }
      
      unlock_testsuite
   } else {
      puts $CHECK_OUTPUT "could not open defaults file."
      if { [ file isfile $CHECK_DEFAULTS_FILE ] } {
         puts $CHECK_OUTPUT "file exists -> assuming old configuration file!"
         convert_old_defaults_file_to_new_format
         exit -1
      }
      puts $CHECK_OUTPUT "press return to create new configuration file \"$CHECK_DEFAULTS_FILE\""
      wait_for_enter 1 
      if { [save_configuration] != 0 } {
         exit -1
      }
      setup2
   }

}

#****** check/enhanced_setup() *************************************************
#  NAME
#     enhanced_setup() -- addition testsuite setup
#
#  SYNOPSIS
#     enhanced_setup { } 
#
#  FUNCTION
#     Procedure is called at the end of setup2(). Here some additional testsuite
#     setup calls are made.
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc enhanced_setup {} {
   global ts_config
   global CHECK_CHECKTREE_ROOT CHECK_ENABLED_RUNLEVELS
   global CHECK_ENABLED_CATEGORIES CHECK_OUTPUT check_name
   global be_quiet CHECK_PACKAGE_DIRECTORY
   global env CHECK_COMMD_PORT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST

   if { $be_quiet == 0 } { 
      puts "   starting enhanced setup ..."
   }
   set check_name "enhanced_setup"

   set env(COMMD_PORT) $CHECK_COMMD_PORT;
   set env(SGE_QMASTER_PORT) $CHECK_COMMD_PORT;
   set env(SGE_EXECD_PORT) [expr ( $CHECK_COMMD_PORT + 1 ) ];
   set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;
   set env(SGE_CELL) $ts_config(cell)
   set env(SGE_SINGLE_LINE) 1
#   don't enable this without rework of qstat parsing
#   set env(SGE_LONG_QNAMES) 40

   set_users_environment $CHECK_HOST

# now search for further checktree configurations
# ===============================================

   if { $ts_config(additional_checktree_dirs) != "none" } {
      if { $be_quiet == 0 } { 
         puts "   exploring other checktrees ..."
         foreach dir $ts_config(additional_checktree_dirs) {
            puts "   $dir ..."

         }
      }
   }

   puts "   setting up checktree ..."
   if {[build_checktree] != 0} {
      exit 1
   }


   set CHECK_ENABLED_RUNLEVELS "0" ;# 100 200 300 400" ;# max level is 400
   # JG: changed default categories to VERIFIED, reset to SYSTEM, once we get
   #     rid of the VERFIED category (when all tests are verified).
   set CHECK_ENABLED_CATEGORIES "VERIFIED" ;# [get_categories $CHECK_CHECKTREE_ROOT ]

   puts "   checking testsuite results directories ..."

   delete_tests "root" 1

   puts "   setting up shared library path ..."
   setup_shared_lib_path
   
   puts "   checking all shell scripts to be executable ..."
   check_executable_files
   
   if { $be_quiet == 0 } { 
      puts "   architecture: $CHECK_ARCH";
      puts "   local host:   $CHECK_HOST";
   }

   puts "   reading message macros ..."
   update_macro_messages_list
#
# uncomment the following line, if the unused macros should be removed from source code
# ======================================================================================  
# 
# --   check_c_source_code_files_for_macros
}



proc build_checktree {} {
   global ts_config ts_checktree
   global CHECK_OUTPUT ACT_CHECKTREE
   
   if { [info exists ts_checktree] } {
      unset ts_checktree
   }
   set ts_checktree(act_nr) 1             ;# contains the next free number for a checktree directory element
   
   set ts_checktree(0,dir_name) "root"    ;# set directory name of root element
   set ts_checktree(0,test_available) 0   ;# there is no test available for the directory entry 0
   set ts_checktree(0,upper_nrs) 0        ;# upper_nrs contains the directory number of the parent checktree
                                          ;# directory element
   set ts_checktree(root) 0               ;# maps the directory path to directory number

   # read_checktree_nodes is setting additional information in the checktree !!!
 
   puts $CHECK_OUTPUT "reading checktree nodes ..."  
   set error [read_checktree_nodes $ts_config(checktree_root_dir)] 
   if { $error != 0 } {
      return -1
   }
   puts $CHECK_OUTPUT "reading additional checktrees ..."
   if { $ts_config(additional_checktree_dirs) != "none" } {
      foreach dir $ts_config(additional_checktree_dirs) {
         set error [read_checktree_nodes $dir]
         if { $error != 0 } {
            return -1
         }
         if { [file isfile $dir/checktree.tcl] } {
            puts $CHECK_OUTPUT "source additional file $dir/checktree.tcl"
            set ACT_CHECKTREE $dir
            ts_source $dir/checktree
         } else {
            puts $CHECK_OUTPUT "checktree file $dir/checktree.tcl not found"
         }
      }
   }

   

   puts $CHECK_OUTPUT "verify checktree ..."
   
   for {set i 0} {$i< $ts_checktree(act_nr)} {incr i 1} {
#      puts $CHECK_OUTPUT "test $i $ts_checktree($i,dir_name) , up-dir=$ts_checktree($i,upper_nrs), subdir(s)=$ts_checktree($i,sub_nrs)"
      set ts_checktree($i,max_level_count) [get_max_level_count $ts_checktree($i,dir_name)]
#      puts $CHECK_OUTPUT "dir $ts_checktree($i,dir_name) has max level state: $ts_checktree($i,max_level_count)"
      if { $ts_checktree($i,test_available) == 1 } {
         set ts_checktree($i,check_levels) [get_check_levels $ts_checktree($i,dir_name)]
#         puts $CHECK_OUTPUT "test $ts_checktree($i,check_name) has checklevels: $ts_checktree($i,check_levels)"
#         puts $CHECK_OUTPUT "name $ts_checktree($i,check_name), $ts_checktree($i,check_category), $ts_checktree($i,check_highest_level)"
         for { set j [expr ( $i + 1 ) ] } {$j< $ts_checktree(act_nr)} {incr j 1} {
            if { $ts_checktree($j,test_available) == 1 } {
               if { $ts_checktree($i,check_name) == $ts_checktree($j,check_name) } {
                  set error_text ""
                  append error_text "check_name \"$ts_checktree($i,check_name)\" is not unique:\n"
                  append error_text "please check the following tests directories:\n"
                  append error_text "$ts_checktree($i,dir_name)\n"
                  append error_text "$ts_checktree($j,dir_name)\n" 
                  add_proc_error "build_checktree" -1 $error_text
                  wait_for_enter
                  return -1
               }
               if { $ts_checktree($i,check_init_level_procedure) != "--" && 
                    $ts_checktree($i,check_init_level_procedure) == $ts_checktree($j,check_init_level_procedure) } {
                  set error_text ""
                  append error_text "check_init_level_procedure \"$ts_checktree($i,check_init_level_procedure)\" is not unique:\n"
                  append error_text "please check the following tests directories:\n"
                  append error_text "$ts_checktree($i,dir_name)\n"
                  append error_text "$ts_checktree($j,dir_name)\n" 
                  add_proc_error "build_checktree" -1 $error_text
                  wait_for_enter
                  return -1
               }
            }
         }

      }
      
   }
   
   # read configurations of the checktree

   for {set i 0} { $i < $ts_checktree(act_nr)} {incr i 1 } {
      for {set ii 0} {[info exists ts_checktree($i,setup_hooks_${ii}_name)]} {incr ii 1} {
         
         if { [info exists ts_checktree($i,setup_hooks_${ii}_filename)] == 0 } {
            add_proc_error "build_checktree" -1 "field setup_hooks_${ii}_filename not defined for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
            wait_for_enter
            return -1
         }
         
         set filename $ts_checktree($i,setup_hooks_${ii}_filename)
         
         set config_array $ts_checktree($i,setup_hooks_${ii}_config_array)
         
         global $config_array

         if { [file exists $filename] == 0 } {
            
            puts $CHECK_OUTPUT "file $ts_checktree($i,setup_hooks_${ii}_name) not found, create new configuration"
            wait_for_enter
            
            $ts_checktree($i,setup_hooks_${ii}_init_func) $config_array
            
            while { 1 } {
               # initialize the config
               set error_list {}
               set res [$ts_checktree($i,setup_hooks_${ii}_verify_func) $config_array 0 error_list]
               if { $res == 0 } {
                  break
               } 
               if { $res < 0 } {
                  add_proc_error "build_checktree" -1 "Can not verify config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
                  wait_for_enter
                  return -1
               }
               puts $CHECK_OUTPUT "Errors in configuration => retry"
               wait_for_enter
            }
            spool_array_to_file $filename $ts_checktree($i,setup_hooks_${ii}_name) $config_array
         } else {
           
           # file exists => read it
            if { [read_array_from_file $filename $ts_checktree($i,setup_hooks_${ii}_name) $config_array] == 0 } {
               set res [$ts_checktree($i,setup_hooks_${ii}_verify_func) $config_array 1 error_list]
               if { $res < 0 } {
                  add_proc_error "build_checktree" -1 "Can not verify config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
                  wait_for_enter
                  return -1
               } 
               if { $res > 0 } {
                  puts $CHECK_OUTPUT "Configuration $ts_checktree($i,setup_hooks_${ii}_name) has errors => retry"
                  wait_for_enter
                  while { 1 } {
                     set error_list {}
                     set res [$ts_checktree($i,setup_hooks_${ii}_verify_func) $config_array 0 error_list]
                     if { $res == 0 } {
                        spool_array_to_file $filename $ts_checktree($i,setup_hooks_${ii}_name) $config_array
                        break
                     } 
                     if { $res < 0 } {
                        add_proc_error "build_checktree" -1 "Can not verify config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
                        wait_for_enter
                        return -1
                     }
                  }
               }
            } else {
               add_proc_error "build_checktree" -1 "Can't read config for setup hook $ts_checktree($i,setup_hooks_${ii}_name)"
               wait_for_enter
               return -1
            }
         }
      }
   }
#   puts $CHECK_OUTPUT "roots: $ts_checktree(0,sub_nrs)"
   return 0
}


proc read_checktree_nodes { path } {
   global ts_checktree CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT
   global CHECK_OUTPUT
   global ts_config
   global check_highest_level check_init_level_procedure check_name
   global check_category 
   global CHECK_ACT_LEVEL

   # remember last check name - we'll reset to it on function exit
   set old_check_name $check_name

   # every checktree directory gets an individual number
   set nr $ts_checktree(act_nr)
   incr ts_checktree(act_nr) 1

   # prepare for sourceing check.exp files
   set check_highest_level 0 
   set check_init_level_procedure "--"
   set check_category ""

   # try to find and source check files in this directory for the configured N1GE version
   set sourced_files [ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT]

   # if there is a check in this directory, remember some information
   if {$sourced_files > 0} {
      # here is a test file
      set ts_checktree($nr,test_available) 1

      for { set lt 0 } { $lt <= $check_highest_level } { incr lt 1 } {
         if { [info exists check_description($lt)] } {
            if { [string match "*\n*" $check_description($lt)] } {
               puts $CHECK_OUTPUT "--------------------------------------------------------------"
               puts $CHECK_OUTPUT "check directory: $path"
               puts $CHECK_OUTPUT "description($lt): \"$check_description($lt)\""
               puts $CHECK_OUTPUT "PANIC: check \"$check_name\" contains unexpected new line characters in check description!"
               puts $CHECK_OUTPUT "--------------------------------------------------------------"
               exit 1
            }
         }
      }

      set ts_checktree($nr,check_name) $check_name
      set ts_checktree($nr,check_init_level_procedure) $check_init_level_procedure
      set ts_checktree($nr,check_highest_level) $check_highest_level
      set ts_checktree($nr,check_category) $check_category
   } else {
      set ts_checktree($nr,test_available) 0
   }
   set ts_checktree($nr,dir_name) $path
   set ts_checktree($path)        $nr
   

   if {[info exists ts_checktree($nr,sub_nrs)] == 0} {   ;# ts_checktree($nr,sub_nrs) contains the 
      set ts_checktree($nr,sub_nrs) {}                   ;# list of numbers of subdirectories checktree elements
   }
   set upper_dir [file dirname $path]
   if { [info exists ts_checktree($upper_dir) ] } {
      set ts_checktree($nr,upper_nrs) $ts_checktree($upper_dir)
   } else {
      set ts_checktree($nr,upper_nrs) 0
      lappend ts_checktree(0,sub_nrs) $nr               ;# this is for the "root" element. Additional checktree
                                                        ;# directories are children of the "root" tree. The sub_nr
                                                        ;# can't be initalized by the directory list.
   }

   # recursive call on subdirectories
   set dirs [get_dir_names $path]
   foreach element $dirs {
      read_checktree_nodes "$path/$element"
      lappend ts_checktree($nr,sub_nrs) $ts_checktree($path/$element)
   }
  
   # stay in directory of former check
   set check_name $old_check_name
   return 0
}

proc get_tests_from_checktree { { path "root" } } {
   global ts_checktree CHECK_OUTPUT

   set selected_dirs ""

   if { [info exists ts_checktree($path)] } {
     set selected_dirs $ts_checktree($path)
   } else {
     add_proc_error "get_tests_from_checktree" -1 "path=$path not found in checktree"
   }


   set all_nrs {}
   foreach nr $selected_dirs {
      lappend all_nrs $nr

      set ret_val {}
      lappend_sub_nrs_from_checktree $nr ret_val
      foreach sub_nr $ret_val {
         lappend all_nrs $sub_nr
      }
   }
   
   # now we have all directory numbers, generate path list
   set path_list {}
   foreach nr $all_nrs {
      if { $ts_checktree($nr,test_available) == 1 } {
         lappend path_list $ts_checktree($nr,dir_name)
      }
   }
   return $path_list
}

proc lappend_sub_nrs_from_checktree { dir_nr result } {
   global ts_checktree CHECK_OUTPUT
   upvar $result res
 
   foreach nr $ts_checktree($dir_nr,sub_nrs) {
      lappend res $nr
      lappend_sub_nrs_from_checktree $nr res
   }
}


proc get_checktree_dir_names { path { only_basename 0 } } {
   global ts_checktree CHECK_OUTPUT

   # first find entry directory numbers
   set selected_dirs {}
   if { [info exists ts_checktree($path)] } {
     set nr $ts_checktree($path)
     set selected_dirs $ts_checktree($nr,sub_nrs)
   } else {
     add_proc_error "get_tests_from_checktree" -1 "path=$path not found in checktree"
   }

   # now we have all directory numbers, generate path list
   set path_list {}
   foreach nr $selected_dirs {
      if { $only_basename == 0 } {
         lappend path_list $ts_checktree($nr,dir_name)
      } else {
         lappend path_list [file tail $ts_checktree($nr,dir_name)]
      }
   }
   return $path_list

}




# check dependencies
#                                                             max. column:     |
#****** check/validate_needs() ******
# 
#  NAME
#     validate_needs -- ??? 
#
#  SYNOPSIS
#     validate_needs { needs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     needs - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc validate_needs {needs} {
  global CHECK_RESULT_DIR CHECK_CORE_RESULT_DIR CHECK_OUTPUT

  if {$needs == ""} {
     return 0;
  } 

  set uncomplete 0;

  foreach elem $needs {

    set result_files ""
    set core_result_files ""
    catch { set result_files [glob "$CHECK_RESULT_DIR/$elem.res.*"] }
    catch { set core_result_files [glob "$CHECK_CORE_RESULT_DIR/$elem.res.*"] }

    debug_puts $result_files $core_result_files

    debug_puts " validate_needs: matching files in $CHECK_RESULT_DIR: $result_files"
    debug_puts " validate_needs: matching files in $CHECK_CORE_RESULT_DIR: $core_result_files"

    if {([file isfile [lindex $result_files 0]] != 1) && ([file isfile [lindex $core_result_files 0]] != 1 )} {
       debug_puts " validate_needs: need to run check $elem.";
       incr uncomplete 1; 
    }
  }

  if {$uncomplete == 0} {
    return 0;
  }
  return -1;
}

# delete result in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/delete_result() ******
# 
#  NAME
#     delete_result -- ??? 
#
#  SYNOPSIS
#     delete_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     debug_puts "\n--> delete_result - info: test level $level not activated, aborting\n"
     return   ;# level not enabled
  }

  if { [is_category_enabled $path] == -1 } { 
     debug_puts "\n--> delete_result - info: category not activated, aborting\n"
     return  
  }
  
  

  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  }

  debug_puts "saving results for $check_name (level $level)..."
  debug_puts $good_dir
  debug_puts $bad_dir

  set myfile "$good_dir/$check_name.res.$level" 
  if {[file isfile $myfile] == 1} {
    delete_file $myfile
  }

  set data ""

  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs



  if { [ info exists check_functions ] } {
     if { [ string length $check_functions ] < 1 } {
        lappend data "{-> no check_function name <-}"
     } else {
        lappend data $check_functions
     } 
  } else {
     lappend data "{-> no check_function name <-}"
  }
  

  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$bad_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output 
}



# save results in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/save_result() ******
# 
#  NAME
#     save_result -- ??? 
#
#  SYNOPSIS
#     save_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc save_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     puts $CHECK_OUTPUT "\n--> save_result - error: test level $level not activated\n"
     return   ;# level not enabled
  }


  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  } 

  puts "saving results for $check_name (level $level) ..."
  puts $good_dir
  puts $bad_dir
  
  set data ""
  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs
  lappend data $check_functions
  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$good_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output

  if {[file isfile "$bad_dir/$check_name.res.$level"] == 1} {
    delete_file "$bad_dir/$check_name.res.$level"
    puts $CHECK_OUTPUT "\nset state of \"$check_name\" for level $level to completed !"
  }

} 

proc get_check_name {path} {
   global ts_checktree
   
   set name ""
   if { [info exists ts_checktree($path)] } {
      set nr $ts_checktree($path)
      if { $ts_checktree($nr,test_available) == 1 } {
         set name $ts_checktree($nr,check_name)
      }
   }
   return $name
}


proc get_check_levels { path } {
   global CHECK_ACT_LEVEL
   global ts_checktree

   set saved_level $CHECK_ACT_LEVEL
   set levels {}
   if { [info exists ts_checktree($path)] } {
      set nr $ts_checktree($path)
      if { $ts_checktree($nr,check_highest_level) > 0 && $ts_checktree($nr,check_init_level_procedure) != "--" } {
         for {set i 0} {$i <= $ts_checktree($nr,check_highest_level)} {incr i 1} {
            set CHECK_ACT_LEVEL $i
            if { [$ts_checktree($nr,check_init_level_procedure)] != 0 } { 
               continue 
            }
            lappend levels $CHECK_ACT_LEVEL
         }
      } else {
         lappend levels 0
      }
   }
   set CHECK_ACT_LEVEL $saved_level
   return $levels
}


proc get_checktree_levels { path } {
   global CHECK_ACT_LEVEL
   global ts_checktree

   set levels {}
   if { [info exists ts_checktree($path)] } {
      set nr $ts_checktree($path)
      return $ts_checktree($nr,check_levels)
   }
   return $levels
}


# get test result
#                                                             max. column:     |
#****** check/get_test_result() ******
# 
#  NAME
#     get_test_result -- ??? 
#
#  SYNOPSIS
#     get_test_result { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_test_result {filename} {
   if {[file isfile $filename] != 1} {
      return {"file not found"}
   }
   if {[file readable $filename] != 1} {
      return {"file not readable"}
   }
   set input [open $filename "r"]
   gets $input data
   close $input
   return $data
}

# create report
#                                                             max. column:     |
#****** check/create_report() ******
# 
#  NAME
#     create_report -- ??? 
#
#  SYNOPSIS
#     create_report { file goodbad } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     file    - ??? 
#     goodbad - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_report {file goodbad} {
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_CORE_RESULT_DIR
  global CHECK_CORE_BAD_RESULT_DIR CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT


  set output [open $file "WRONLY APPEND CREAT"]
  puts $output "\n checksystem report"
  puts $output " ==================\n"
  puts $output " Date: [exec date]\n\n"
  puts $output " Version: $CHECK_PRODUCT_VERSION_NUMBER"
  puts $output " Installed in: $CHECK_PRODUCT_ROOT"
  if {$goodbad == 0} { 
     set total1 [ print_results $CHECK_CORE_RESULT_DIR $output ]
     set total2 [ print_results $CHECK_RESULT_DIR $output ]
     puts $output "\nTotal number of test functions: [expr ($total1 + $total2) ]"
  } else {
     print_results $CHECK_CORE_BAD_RESULT_DIR $output
     print_results $CHECK_BAD_RESULT_DIR $output
  }

  flush $output  
  close $output
 
  puts "report was written to $file"
}

# formatted output
#                                                             max. column:     |
#****** check/format_output() ******
# 
#  NAME
#     format_output -- ??? 
#
#  SYNOPSIS
#     format_output { prefix size text } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     prefix - ??? 
#     size   - ??? 
#     text   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc format_output { prefix size text} {

  if {[string length $text] <= $size } {
     return $text;
  }

  set otext $text
  set buffer ""

  while { 1 == 1 } {
     set buffer "$buffer[string range $otext 0 $size]"
     set otext [string range $otext [expr ($size+1)] [string length $otext] ]
     set buffer "$buffer\n$prefix"
     if {[string length $otext] <= $size} {
        set buffer "$buffer$otext"
        return $buffer
     }
  }

}

# print results
#                                                             max. column:     |
#****** check/print_results() ******
# 
#  NAME
#     print_results -- ??? 
#
#  SYNOPSIS
#     print_results { ckpath where } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     ckpath - ??? 
#     where  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_results {ckpath where} {
   global CHECK_OUTPUT
   set numb_of_check_functions 0 
   set filenames [get_file_names $ckpath]
   set catch_return [ catch {
      foreach elem $filenames {
         clear_screen
         puts $CHECK_OUTPUT "file: $elem"
         set data [get_test_result "$ckpath/$elem"]
   
         set path [lindex $data 0]
         set check_name [lindex $data 1]
         set check_descrip [lindex $data 2]
         set check_needs [lindex $data 3]
         set check_functions [lindex $data 4]
         set check_errno [lindex $data 5]
         set check_errstr [lindex $data 6]
         set check_clock [lindex $data 7]
         set check_date  [lindex $data 8]
         set high_level [lindex $data 9]
         set file_level [split $elem "."]
         set file_level [lindex $file_level 2]
   
         set check_description($file_level) $check_descrip
   
         puts $where "############################################################################"
         puts $where "check: $check_name (level $file_level)"
         puts $where "############################################################################"
         puts $where "----------------------------------------------------------------------------"
         puts $where "results:"
      
         set index 0
         puts $where "----------------------------------------------------------------------------"
         puts $where "run time:       [format_output "                " 59 $check_clock]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "date (end):     [format_output "                " 59 $check_date]" 
         puts $where "----------------------------------------------------------------------------"
         set leveltext $check_description($file_level)
         puts $where "description:    [format_output "                " 59 $leveltext]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "dependencies:   [format_output "                " 59 $check_needs]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "functions:      [format_output "                " 59 $check_functions]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "function count: [format_output "                " 59 [llength $check_functions]]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "directory:      [format_output "                " 59 $path]"
         puts $where "----------------------------------------------------------------------------\n"
   
         set numb_of_check_functions [ expr ($numb_of_check_functions + [llength $check_functions]) ]
         if {[string compare $where "stdout" ] == 0 } {
            puts $where "please press RETURN"
            set pressed [wait_for_enter 1]
         }
      }
   } my_error ]
   if { $catch_return != 0 } {
       add_proc_error "print_results" -1 "error creating test report:\n$my_error"
   }
   


   puts $where "\nTotal number of check functions in\n\"$ckpath\":\n$numb_of_check_functions\n"
   return $numb_of_check_functions
}
#                                                             max. column:     |
#****** check/is_level_enabled() ******
# 
#  NAME
#     is_level_enabled -- ??? 
#
#  SYNOPSIS
#     is_level_enabled { level_nr } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level_nr - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc is_level_enabled { level_nr } {

    global CHECK_ENABLED_RUNLEVELS

    foreach level_start $CHECK_ENABLED_RUNLEVELS {
       set level_end [ expr ( $level_start + 99 ) ]

       if { ( $level_start <= $level_nr ) && ( $level_nr <= $level_end ) } {
          return 0
       }
    }

    return -1
}


proc is_category_enabled { path } {
   global CHECK_ENABLED_CATEGORIES ts_checktree
   set checks_cat ""
   if { [info exists ts_checktree($path)] } {
      set nr $ts_checktree($path)
      set checks_cat $ts_checktree($nr,check_category)
   }
   foreach elem $checks_cat {
      if { [ lsearch $CHECK_ENABLED_CATEGORIES $elem] != -1 } {
         return 0
      }
   }
   return -1
}

proc delete_tests {path { only_if_not_there 0 } } {
  global check_errno check_errstr check_functions validate_needs check_name
  global CHECK_OUTPUT check_highest_level check_name check_description
  global check_init_level_procedure CHECK_ACT_LEVEL CHECK_OUTPUT
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT


  set old_check_name $check_name
  set selected_tests [get_tests_from_checktree $path]
  foreach elem $selected_tests {
       set check_highest_level 0
       set check_errstr ""
       set check_errno ""
       set check_name ""
       set check_init_level_procedure "--"

       if {[ts_source $elem/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT]} {
          set check_errstr ""
          set check_errno ""
          if { [ info exists check_functions ] } {
             foreach element $check_functions {
                lappend check_errstr "was never running" 
                lappend check_errno "-1"
             }
          } else {
             puts $CHECK_OUTPUT "no check_functions variable available!!"
             sleep 5
          }
          debug_puts "sourced \"$elem/$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT\""

          set do_delete 1
          if {$only_if_not_there == 1 } { 
             set result [ validate_needs $check_name ]
             if { $result == 0 } {
                set do_delete 0
             }
          }

          if {$do_delete == 1} {
             for {set i 0} {$i <= $check_highest_level} {incr i 1} {
                if { [string compare $check_init_level_procedure "--" ] != 0 } {
                   set CHECK_ACT_LEVEL $i
                   if { [$check_init_level_procedure]  == 0 } { 
                      delete_result $elem 0 $i
                   } 
                } else {
                   delete_result $elem 0 $i
                }
             }
          }
       }
  }
  set check_name $old_check_name
}


#                                                             max. column:     |
#****** check/run_tests() ******
# 
#  NAME
#     run_tests -- ??? 
#
#  SYNOPSIS
#     run_tests { path runcompleted } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ???
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_tests { path runcompleted } {
    global CHECK_OUTPUT CHECK_HOST check_errstr CHECK_RESULT_DIR
    global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_MAX_ERROR_MAILS CHECK_CORE_RESULT_DIR
    global CHECK_CHECKTREE_ROOT CHECK_ACT_PATH check_use_installed_system ts_config
    global check_reinit_on_tcl_error CHECK_CORE_MASTER CHECK_PRODUCT_ROOT CHECK_ARCH

    set CHECK_MAILS_SENT 0  ;# clear mail counter
 
    set check_directories [get_tests_from_checktree $path]

    if { $runcompleted == 1 } {
       delete_tests $path
    }
    set checks_to_do ""
    foreach elem $check_directories {
       if { [is_category_enabled $elem ] == 0 } {
           set test_name [get_check_name $elem] 
           set tests_runlevels [get_checktree_levels $elem]
           foreach tests_runlevel $tests_runlevels {
              if { $runcompleted == 0 } {
                 if { ( [file isfile "$CHECK_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                    continue
                 }
                 if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                    continue
                 }
              }
              lappend checks_to_do $elem
              break
           }
       }
    }
    set checks_to_do [lsort -dictionary $checks_to_do]
    if {[llength $checks_to_do] == 0} {
       return
    }

    # check if root password is needed
    foreach elem $checks_to_do {
        debug_puts "checking whether test in directory $elem needs root access ..."
        if { ([check_root_access $elem ] == 0) && ([have_root_passwd] == -1 ) } {
            puts $CHECK_OUTPUT "test in directory $elem needs root access ..."
            set_root_passwd
        }
    }

    set stop 0
    set pass_no 1
    set last_to_do -1
    set check_ok_name     ""
    set check_ok_state    "" 
    set check_ok_date     ""
    set check_ok_pass     ""
#        set check_ok_text     ""
    set check_error_name  ""
    set check_error_state ""
    set check_error_date  ""
    set check_error_pass  ""
#        set check_error_text  ""
    set check_missing_dep ""
    set check_warning_name ""
    set check_warning_state ""
    set check_warning_date ""
    set check_warning_pass ""
    set check_missing_dep ""
#        set check_warning_text ""

    while { $stop == 0 } {
       set todo [ llength $checks_to_do ]
       puts $CHECK_OUTPUT "---PASS${pass_no}----------------------------------------"
       puts $CHECK_OUTPUT "   Nr. of tests remaining: $todo"
       puts $CHECK_OUTPUT "------------------------------------------------" 

       # start tests
       foreach check $checks_to_do {
          set test_result [ run_test $check $runcompleted ]

          switch -- $test_result {
                   0 { 
                        # test OK
                        lappend check_ok_name  $check
                        lappend check_ok_state $test_result
                        lappend check_ok_date  [ exec date ]
                        lappend check_ok_pass  $pass_no 
#                            foreach err_message $check_errstr {
#                               lappend check_ok_text("$check") "{$err_message}"
#                            }

                     }
                  -2 { 
                        # dependencies - try again
                        lappend check_missing_dep  $check
                     }
                  -3 {
                        # impossible / unusefull to run this test
                        lappend check_warning_name $check 
                        lappend check_warning_state $test_result
                        lappend check_warning_date [ exec date ]
                        lappend check_warning_pass  $pass_no 
                        foreach err_message $check_errstr {
                           if { [info exists check_warning_text("$check") ] } {
                              lappend check_warning_text("$check") "{$err_message}"
                           } else {
                              set check_warning_text("$check") "{$err_message}"
                           }
                        }
                     }
                   1 { 
                        # test was already done in an earlier run
                        # no action
                        puts $CHECK_OUTPUT "run_tests - check already done"
                     }

                   2 {  
                        # test has no valid test in this run level
                        # no action
                        puts $CHECK_OUTPUT "test does not support actual runlevel"
                     }
                -101 {
                        # check failed due to tcl error
                        lappend check_error_name  $check
                        lappend check_error_state $test_result
                        lappend check_error_date  [ exec date ]
                        lappend check_error_pass  $pass_no 
                                
                        foreach err_message $check_errstr {
                           if { [info exists check_error_text("$check") ] } {
                              lappend check_error_text("$check") "{$err_message}"
                           } else {
                              set check_error_text("$check") "{$err_message}"
                           }
                        }
 
                        if { $check_reinit_on_tcl_error == 1 } {
                           # reinit system
                           puts $CHECK_OUTPUT "deleting all jobs"
                           delete_all_jobs
                           wait_for_end_of_all_jobs 15

                           set save_installed_value $check_use_installed_system
                           set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                           set check_use_installed_system 1
                           set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                           close_open_rlogin_sessions 1  ;# session reset (if defect)
                           if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                              set check_use_installed_system 0
                              set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                              run_test $CHECK_ACT_PATH 1
                           }
                           set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                           set check_use_installed_system $save_installed_value
                        }
                     }

             default {
                        # check failed
                        lappend check_error_name  $check
                        lappend check_error_state $test_result
                        lappend check_error_date  [ exec date ]
                        lappend check_error_pass  $pass_no 
                                
                        foreach err_message $check_errstr {
                           if { [info exists check_error_text("$check") ] } {
                              lappend check_error_text("$check") "{$err_message}"
                           } else {
                              set check_error_text("$check") "{$err_message}"
                           }
                        }
                        if { $check_reinit_on_tcl_error == 1 } {
                           # reinit system
                           # reinit system
                           puts $CHECK_OUTPUT "deleting all jobs"
                           delete_all_jobs
                           wait_for_end_of_all_jobs 15

                           set save_installed_value $check_use_installed_system
                           set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                           set check_use_installed_system 1
                           set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                           close_open_rlogin_sessions 1  ;# session reset (if defect)
                           if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                              set check_use_installed_system 0
                              set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                              run_test $CHECK_ACT_PATH 1
                           }
                           set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                           set check_use_installed_system $save_installed_value
                       }
                     }
          }
       }

       if { [llength $check_missing_dep] > 0 } {
          # missing dependencies , run again
          set checks_to_do $check_missing_dep
          incr pass_no 1
          if { $todo == $last_to_do } {
             set stop 1
          } else {
             puts $CHECK_OUTPUT "restarting test with missing dependencies ..."
             set check_missing_dep ""
          } 
          set last_to_do $todo
       } else {
          # all done
          set stop 1
       } 
    }  ;# while stop == 0

    puts $CHECK_OUTPUT "Number of completed tests     : [llength $check_ok_name]"  
    puts $CHECK_OUTPUT "Number of failed tests        : [llength $check_error_name]"  
    puts $CHECK_OUTPUT "Number of unsupported tests   : [llength $check_warning_name]"
    puts $CHECK_OUTPUT "Number of dependencies errors : [llength $check_missing_dep]"


    set mail_body "Testsuite run on host $CHECK_HOST complete\n\n"


    # dependencies errors
    if { [llength $check_missing_dep ] > 0 } { 
       append mail_body "missing dependencies:\n"
       append mail_body "=====================\n\n"
       foreach elem $check_missing_dep {
          append mail_body "check [get_check_name $elem] in directory\n$elem\n" 
       } 
       append mail_body "\n"
    }
    # tests ok

    append mail_body "completed tests:\n"
    append mail_body "================\n\n"
    for {set index 0} {$index < [llength $check_ok_name]} {incr index 1} {
        append mail_body "Date: [ lindex $check_ok_date $index ]\n" 
        append mail_body "Test: [ lindex $check_ok_name $index ]\n"
        append mail_body "Info: Pass[lindex $check_ok_pass $index], State: [lindex $check_ok_state $index]\n\n"
    }
    set nr_complete [llength $check_ok_name] 
    append mail_body "Number of completed tests: $nr_complete"        

    # tests failed
    append mail_body "\n\nfailed tests:\n"
    append mail_body "=============\n"
    for {set index 0} {$index < [llength $check_error_name]} {incr index 1} {
        append mail_body "Date: [ lindex $check_error_date $index ]\n" 
        append mail_body "Test: [ lindex $check_error_name $index ]\n"
        append mail_body "Info: Pass[lindex $check_error_pass $index], State: [lindex $check_error_state $index]\n\n"
        foreach err_message $check_error_text("[ lindex $check_error_name $index ]") {
            foreach sm $err_message {
               set error_output [ create_error_message $sm ]
               append mail_body $error_output
            }
        }
    }
    set nr_failed [llength $check_error_name]
    append mail_body "Number of failed tests: $nr_failed"  

    # test run not usefull (warning)
    append mail_body "\n\nunsupported tests:\n"
    append mail_body "==================\n"
    for {set index 0} {$index < [llength $check_warning_name]} {incr index 1} {
        append mail_body "Date: [ lindex $check_warning_date $index ]\n" 
        append mail_body "Test: [ lindex $check_warning_name $index ]\n"
        append mail_body "Info: Pass[lindex $check_warning_pass $index], State: [lindex $check_warning_state $index]\n\n"
        if { [info exists check_warning_text("[ lindex $check_warning_name $index ]")] } {
           foreach err_message $check_warning_text("[ lindex $check_warning_name $index ]") {
              foreach sm $err_message {
                 set error_output [ create_error_message $sm ]
                 append mail_body $error_output
              }
           }
        }
    }
    set nr_unsupported [llength $check_warning_name]
    append mail_body "Number of unsupported tests: $nr_unsupported"  
    if { [llength $check_missing_dep ] > 0 } {
       set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported;depend:[llength $check_missing_dep]"
    } else {
       set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported"
    }
    mail_report "$mail_subject" $mail_body
  

}


#                                                             max. column:     |
#****** check/lock_testsuite() ******
# 
#  NAME
#     lock_testsuite -- ??? 
#
#  SYNOPSIS
#     lock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc lock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_HOST CHECK_USER CHECK_MAIN_RESULTS_DIR
    global CHECK_SCRIPT_FILE_DIR CHECK_TESTSUITE_LOCKFILE

    set pid [getpid]
    
    debug_puts "-> lock_testsuite: pid=$pid host=$CHECK_HOST user=$CHECK_USER"

    set result 0
    set time [ expr ( [timestamp] + 60 ) ] 
    while { $result  != 10 } {
       puts $CHECK_OUTPUT "waiting for lock ..."
       set result [ catch {  
           eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/lock.sh $CHECK_TESTSUITE_LOCKFILE $pid $CHECK_HOST $CHECK_USER"
       } ]
       puts $CHECK_OUTPUT "lock.sh returned $result"
       set file_size 0
       catch { set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       if { $file_size == 0 } {
           puts $CHECK_OUTPUT "file size is 0, deleteing lockfile..."
           sleep 60  ;# wait for NFS to update file
           unlock_testsuite
           sleep 60  ;# wait for NFS to update file
           return [ lock_testsuite ]  
       }
       if { $result != 10 } {
          puts $CHECK_OUTPUT "checking lockfile owner process ..."
          set data ""
          catch {
              set input [ open "$CHECK_TESTSUITE_LOCKFILE" "r" ]
              gets $input data 
              close $input
          }
          set owner_pid  [lindex $data 0]
          set owner_host [lindex $data 1]
          set owner_user [lindex $data 2]

          debug_puts "testsuite is locked by user $owner_user, process $owner_pid on host $owner_host!"
          if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
              debug_puts "thats me, so we have the lock"
              set result 10
              continue
          }
          debug_puts "checking whether process is still alive ..."
           
          get_ps_info $owner_pid $owner_host
          if { $ps_info($owner_pid,error) == 0 } {
             puts $CHECK_OUTPUT "process exists, command is \n-----\n\"$ps_info($owner_pid,string)\"\n-----"
          } else {
             puts $CHECK_OUTPUT "process doesn't exist -> unlock_testsuite ..." 
             unlock_testsuite 
          }
       }
    }
    debug_puts "new lockfile written! Testing for correct lock ..."

    set time [ expr ( [timestamp] + 60 ) ] 
    set tries 0 
    set ok 0
    set failed 0
    set file_size 0
    while {$ok != 1} {
       sleep 1
       catch { set input [ open $CHECK_TESTSUITE_LOCKFILE "r" ]
               gets $input data 
               close $input } 
 
       debug_puts "pid  [lindex $data 0] == $pid"
       debug_puts "host [lindex $data 1] == $CHECK_HOST"
       debug_puts "user [lindex $data 2] == $CHECK_USER"
 
       if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
          incr tries 1
          if {$tries >= 2} {
             set ok 1
          }
       }
       debug_puts "waiting to get lock"

       catch { set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       debug_puts "file size is: $file_size"

       if { [timestamp] > $time } {
          set failed 1
          set ok 1
       }      
    }

    if {$failed == 1} {
        puts $CHECK_OUTPUT "no success! Try again ..."
        if { $file_size == 0 } {
           debug_puts "file size is zero, deleteing lockfile..."
           unlock_testsuite
        }
        return [ lock_testsuite ] 
    } 

    debug_puts "lock success!" 

}

#                                                             max. column:     |
#****** check/unlock_testsuite() ******
# 
#  NAME
#     unlock_testsuite -- ??? 
#
#  SYNOPSIS
#     unlock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc unlock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_MAIN_RESULTS_DIR CHECK_TESTSUITE_LOCKFILE

    if {[file isfile $CHECK_TESTSUITE_LOCKFILE] == 1 } {
        puts $CHECK_OUTPUT "removing lockfile \"$CHECK_TESTSUITE_LOCKFILE\"" 

       set catch_return [ catch {exec rm "$CHECK_TESTSUITE_LOCKFILE"} ]
       if { $catch_return != 0 } {
          puts $CHECK_OUTPUT "unlock_testsuite - could not unlock testsuite"
          return
       } 
       while { [ file isfile $CHECK_TESTSUITE_LOCKFILE ] == 1 } {
          puts $CHECK_OUTPUT "file still existing" 
          sleep 1
       }
    }
    puts $CHECK_OUTPUT "testsuite unlocked!" 
}


# run_test_level: returns
# -1 on error, 
# -2 check can not run
#  0 if ok, 
#  1 already done
#
#                                                             max. column:     |
#****** check/run_test_level() ******
# 
#  NAME
#     run_test_level -- ??? 
#
#  SYNOPSIS
#     run_test_level { path runcompleted level {do_save 1} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#     level        - ??? 
#     {do_save 1}  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#*******************************
proc run_test_level {path runcompleted level {do_save 1}} {
   global check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
   global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
   global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS
   global CHECK_CURRENT_WORKING_DIR check_init_level_procedure CHECK_ACT_LEVEL
   global set_error_proc_called errorInfo CHECK_CORE_MASTER
   global check_setup_level_function check_cleanup_level_function
   
   # do not run already completed tests
   debug_puts "runcompleted is $runcompleted"
   if { $runcompleted == 0 } {
     if { ( [file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
     if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
   }  


   # get lock  
   delete_temp_script_files
   lock_testsuite

 
   set CHECK_ACT_LEVEL $level
   puts $CHECK_OUTPUT "starting test functions (runlevel is $CHECK_ACT_LEVEL)..."
 
   # call init_check_level procedure!
   # JG:       init_check_level is run twice (already in run_test.
   #           do we really have to call it twice?
   #           or call it here and return if it doesn't return 0
   # CR:       This must be done, because a test can be started for a
   #           specified runlevel
   if {[info exists check_init_level_procedure] == 1 } {
       if {[ string compare $check_init_level_procedure "--"] != 0 } {
          puts $CHECK_OUTPUT "\ncalling init level function \"$check_init_level_procedure\" ..."
          $check_init_level_procedure
       }
   }

 
   # call all check functions 
   set check_errno "-1"
   set check_errstr "was never running"
   set start_time [clock seconds]
   set was_error 0
   set was_unsupported 0
   set complete_errstr ""
   set complete_errno ""
   set catch_return 0

   # unless we are in install - check if system is running
   if { [ string compare $check_name "init_core_system" ] != 0 && 
        [ string compare $check_needs "" ] != 0 } {
      if { [is_scheduler_alive $CHECK_CORE_MASTER [get_qmaster_spool_dir]] != 1 } {
         add_proc_error "run_test_level" -1 "scheduler is not alive"
      }
      wait_for_load_from_all_queues 60
   }

   if { [info exists check_functions] } {
      # if we have a level specific setup function: execute it
      set setup_error 0
      set setup_ret [execute_setup_cleanup_function $check_setup_level_function "setup_level"]
      if {!$setup_ret} {
         set setup_error 1
      }

      if { ! $setup_error } {
      foreach elem $check_functions {
         puts $CHECK_OUTPUT "\n>>>>>>>>>>>>>>>>>>>>>>"
         puts $CHECK_OUTPUT "$elem"    
         puts $CHECK_OUTPUT "runlevel: [get_run_level_name $level]($level)"
         puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>"

         set check_errno "-1"
         set check_errstr "was never running"
         set was_empty 0
 
         # set public procedure error state to "no error"
         set check_cur_proc_result "0"
         set check_cur_proc_error "ok"
         set CHECK_CUR_PROC_ERRORS ""
         set CHECK_CUR_PROC_RESULTS "" 
         set CHECK_CUR_PROC_NAME $elem
         set set_error_proc_called 0  

         # this starts the test procedure
         set catch_return [ catch { $elem } errMsg ]
         if { $catch_return != 0 } {
            puts $CHECK_OUTPUT $errMsg
            add_proc_error "run_test_level" "-2" "catch returns not 0\n${errMsg}\n${errorInfo}" 
            set_error -2 "tcl error"
         } 
         
         # examine public procedure error states
         set myindex 0
         set procedure_error_text ""
         set procedure_errno ""
         foreach element $CHECK_CUR_PROC_RESULTS {
            if { $element != 0 } {
               # we got an error: append it to the check_xxx lists
               lappend procedure_error_text [lindex $CHECK_CUR_PROC_ERRORS $myindex]
               lappend procedure_errno $element 
            }
            incr myindex 1
         }        

         if { $set_error_proc_called == 0 } {
             lappend procedure_error_text "{$elem|no \"set_error\" call on procedure return|$check_name|run_test_level}"
             lappend procedure_errno "-1"
             set was_empty 1
         }
 
         flush $CHECK_OUTPUT  
      
         set stop 0 
         if { [ llength $procedure_errno ] == 0 } {
            lappend procedure_error_text "{$elem|$check_errstr|$check_name|run_test_level}"
            lappend procedure_errno $check_errno
            set was_empty 1
         }
         set cur_check_errno [ lindex $procedure_errno [ expr ( [ llength $procedure_errno] - 1 ) ] ]
         debug_puts "cur_check_errno = \"$cur_check_errno\""
         set cur_check_err_text  [ lindex $procedure_error_text [ expr ( [ llength $procedure_error_text] - 1 ) ] ]


         if {$cur_check_errno != 0} {
            incr was_error 1

            debug_puts "DEBUG: cur_errno = $cur_check_errno"           
 
            if { $was_empty == 1  } { 
               show_proc_error $cur_check_errno $cur_check_err_text
            }

            if {$cur_check_errno == -2 } {    ;# hard error dedected run no more test functions
              set stop 1   ;# stop with this test or not ?
            }

            if {$cur_check_errno == -3 } {    ;# test not possible for this host (no error)
              set was_unsupported 1
              incr was_error -1

              puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level, procedure $elem !"
            }
         } else {
            debug_puts "status: $check_errstr"
         }

         set myindex 0
         foreach element $procedure_errno {
            if { $element != 0 } {
               lappend complete_errstr [lindex $procedure_error_text $myindex]
               lappend complete_errno  $element
            }
            incr myindex 1
         }
         if {$stop == 1} {
           break;
         }
      }
      
      if { [llength $check_functions] == 0 } {   
         set no_func_error "{none|check_functions list has length 0 ( level: $level)|$check_name|run_test_level}"
         lappend complete_errstr "$no_func_error"
         lappend complete_errno -1
         show_proc_error -1 "$no_func_error"
         set was_error 1
      }
      }

      # if we have a level specific cleanup function: execute it
      set cleanup_ret [execute_setup_cleanup_function $check_cleanup_level_function "cleanup_level"]
      if {!$cleanup_ret} {
         set was_error 1
      }

      if { $setup_error } {
         set was_error 1
      }

      if { $catch_return != 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "T C L   E R R O R   running test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         unlock_testsuite
         return -101 
      }

      if { $was_unsupported == 1 && $was_error == 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {  
             save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return -2
      }

      if {$was_error == 0} {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "S U C C E S S F U L L Y performed \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {      
            save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return 0
      } 
   } else {
     set no_func_error "{none|check_functions variable not found (level: $level)|$check_name|run_test_level}"
     lappend complete_errstr "$no_func_error"
     lappend complete_errno -1
     show_proc_error -1 "$no_func_error"
   }
 
   # check function does not exist or had an error
   
   set check_errstr $complete_errstr
   set check_errno $complete_errno


   set end_time [clock seconds]
   if { $do_save == 1 } {   
      delete_result $path [expr ($end_time - $start_time)] $level
   }
   puts $CHECK_OUTPUT "\ncheck \"$check_name\" F A I L E D  in run level $level !"
   unlock_testsuite
   return -1
}


#                                                             max. column:     |
#****** check/check_root_access() ******
# 
#  NAME
#     check_root_access -- ??? 
#
#  SYNOPSIS
#     check_root_access { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_root_access {path} {
  global check_root_access_needs 
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT

  set check_root_access_needs "no"  
  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT

  if { [string compare -nocase "yes" $check_root_access_needs] == 0 } {
     return 0
  } 

  return -1
}

proc delete_temp_script_files { } {
  global CHECK_TESTSUITE_ROOT CHECK_OUTPUT

  set del_file_name "$CHECK_TESTSUITE_ROOT/.testsuite_delete"
  if { [ file isfile $del_file_name ] == 1 } {
     set del_file [ open $del_file_name "r" ]
     while { [gets $del_file line] >= 0 } {
        if { [ file isfile $line ] == 1 } {
           file delete $line
        }
     }
     close $del_file
     file delete $del_file_name     
  } 
}

#****** check/execute_setup_cleanup_function() *********************************
#  NAME
#     execute_setup_cleanup_function() -- execute a setup/cleanup function
#
#  SYNOPSIS
#     execute_setup_cleanup_function { func_name type } 
#
#  FUNCTION
#     execute_setup_cleanup_function is used to execute a setup/cleanup
#     function for a check and/or a check level.
#
#  INPUTS
#     func_name - name of the procedure to execute
#     type      - descriptive text (e.g. "setup_level", or "cleanup")
#
#  RESULT
#     0 - failure
#     1 - ok
#     2 - empty function name
#
#*******************************************************************************
proc execute_setup_cleanup_function {func_name type} {
   global CHECK_OUTPUT CHECK_CUR_PROC_RESULTS

   set ret 1

   # if no setup/cleanup function is set, func_name will be ""
   if { $func_name == "" } {
      set ret 2
   }

   if {$ret == 1} {
      # check, if the function exists
      if { [info procs $func_name] != $func_name } {
         set ret 0
         add_proc_error "execute_setup_cleanup_function" -2 "$type procedure \"$func_name\" doesn't exist"
      }
   }

   # remember the number of stored results (errors) for this check
   # if it increases during execution of func_name, we will treat this as an error
   set num_proc_results 0
   if {[info exists CHECK_CUR_PROC_RESULTS]} {
      set num_proc_results [llength $CHECK_CUR_PROC_RESULTS]
   }

   # execute the setup/cleanup function
   if {$ret == 1} {
      puts $CHECK_OUTPUT "starting $type function $func_name"
      set CHECK_CUR_PROC_NAME $func_name
      set catch_return [ catch { $func_name } catch_message ]
      # catch returnes an error - may be a TCL error
      if { $catch_return != 0 } {
         add_proc_error "run_test" "-2" "$type function \"$func_name\" failed:\n$catch_message" 
         set ret 0
      } else {
         # function returns not 0 - setup/cleanup function failed
         if { $catch_message != 0 } {
            add_proc_error "run_test" "-2" "setup function \"$func_name\" didn't return 0:\n$catch_message"
            set ret 0
         }
      }
   }

   # check if error occured during execution of the setup/cleanup function
   if {$ret == 1} {
      set new_proc_results 0
      if {[info exists CHECK_CUR_PROC_RESULTS]} {
         set new_proc_results [llength $CHECK_CUR_PROC_RESULTS]
      }
      # CHECK_CUR_PROC_RESULTS contains error codes as well as OK status (0)
      # search for entries != 0, if found, treat as error
      if {$num_proc_results < $new_proc_results} {
         for {set i $num_proc_results} {$i < $new_proc_results} {incr i} {
            set proc_result [lindex $CHECK_CUR_PROC_RESULTS $i]
            if {$proc_result != 0} {
               set ret 0
               break
            }
         }
      }
   }

   return $ret
}

# run test
#                                                             max. column:     |
#****** check/run_test() ******
# 
#  NAME
#     run_test -- ??? 
#
#  SYNOPSIS
#     run_test { path runcompleted {run_single_test "all"} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     runcompleted            - ??? 
#     {run_single_test "all"} - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test {path runcompleted {run_single_test "all"} { send_mail_report 1 } } {
   global ts_config  

  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
  global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
  global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS check_root_access_needs
  global CHECK_CURRENT_WORKING_DIR check_highest_level check_init_level_procedure CHECK_ACT_LEVEL
  global CHECK_PRODUCT_TYPE CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT CHECK_TESTSUITE_ROOT
  global check_category CHECK_GROUP
  global check_setup_function check_cleanup_function check_setup_level_function check_cleanup_level_function

  cd $CHECK_CURRENT_WORKING_DIR

  set do_only_one_test 0

  set CHECK_ACTUAL_TEST_PATH $path

  set check_name          ""
  set check_category      ""
  set check_needs         ""
  set check_functions     ""
  set check_setup_function ""
  set check_cleanup_function ""
  set check_setup_level_function ""
  set check_cleanup_level_function ""
  set check_highest_level 0
  set check_init_level_procedure "--"
  set check_root_access_needs   "no" 

  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
  if { [string compare $run_single_test "all"] != 0 } {
     set do_only_one_test 1
     puts $CHECK_OUTPUT "running only test \"$run_single_test\""
     set check_functions "$run_single_test"
  }

  if { ( [string compare -nocase "yes" $check_root_access_needs] == 0) && ([have_root_passwd] == -1 ) } {
     puts $CHECK_OUTPUT "test needs root access ..."
     set_root_passwd
  }

  # first check the dependencies
  
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  puts $CHECK_OUTPUT ">>> $check_name"
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  debug_puts "file: $path/check.exp"


  set result [validate_needs $check_needs]

  debug_puts "needs returned $result"
  debug_puts "highest level of test is $check_highest_level"

  if { $result != 0 } {
     puts $CHECK_OUTPUT "dependencies ($check_needs) not fulfilled! Stop!"
     set check_errstr ""
     set check_errno ""
     foreach elem $check_functions {
        lappend check_errstr "{run_test|dependencies not fulfilled!|$check_name|run_test}"
        lappend check_errno "-1"
     }

     for {set level 0} {$level <= $check_highest_level} {incr level 1} {
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  == 0 } { 
            delete_result $path 0 $level 
         }
       } else { 
         delete_result $path 0 $level
       }
     }
     return -2  ;# dependencies not fulfilled
  }

  set nr_errors 0
  set nr_warnings 0
  set nr_already_done 0
  set nr_new_done 0
  set my_current_runlevel 0
  set do_send_mail 0
  set no_level_calls 0 
  set no_of_test_runs 0

   set immediate_return 0

   # check if this test is enabled for the actual runlevel, test is already done, ...
   for {set level 0} { $level <= $check_highest_level} {incr level 1} {

      # check if this is a global enabled level
      if {[is_level_enabled $level] == -1 } {
         continue
      } 

      # check test's init level procedure return value
      if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
      }

      # check if test was already running
      if { $runcompleted == 0 } {
         if { ( [file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"] == 1) } {
            continue 
         }
         if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$check_name.res.$level"] == 1) } {
            continue  
         }
      }
      incr no_of_test_runs 1
   }

   if { $no_of_test_runs == 0 } {
      # no active runlevel for this check, return 2
      return 2 
   }

   # check the number of busy rlogin sessions
   # it should be 0
   set num_busy_sessions_before_check [get_busy_spawn_rlogin_sessions]
   if {$num_busy_sessions_before_check > 0} {
      set session_info [dump_spawn_rlogin_sessions 0]
      add_proc_error "run_test" -3 "We have $num_busy_sessions_before_check busy rlogin sessions before starting test $check_name ($path).\nThis may indicate a problem (missing close_spawn_session call in previous check).\n\n$session_info"
   }

   set setup_ret [execute_setup_cleanup_function $check_setup_function "setup"]
   if {!$setup_ret} {
      set immediate_return -1
   }

   if { $immediate_return == 0 } {
  for {set level 0} { $level <= $check_highest_level} {incr level 1} {
     if {[is_level_enabled $level] == -1 } {
        continue
     } 
     set my_current_runlevel $level
     if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
     }
     puts $CHECK_OUTPUT "\n----------------------------------------------"
     puts $CHECK_OUTPUT "-> enter check level $level"

     if { $do_only_one_test == 0 } {
        set back [run_test_level $path $runcompleted $level]
        debug_puts "level $level return value: $back"
        incr no_level_calls 1
     } else {
        set back [run_test_level $path $runcompleted $level 0 ]
        debug_puts "level $level return value of test $run_single_test: $back"
        incr no_level_calls 1
     }

     if { [string first "unknown" $CHECK_GROUP] >= 0 } {
         add_proc_error "run_test" -1 "CHECK_GROUP set to unknown, test was $path in level $level"
     }

     if {$back == -101  } { 
        incr nr_errors 1
        debug_puts "--> TCL ERROR in check $path in level $level <--"
        set immediate_return -101
        break
     }
     if {$back == -1} {
        incr nr_errors 1     ;# we had an error
        debug_puts "--> ERROR in check $path in level $level <--"
        set immediate_return -1
        break
     }
     if {$back == -2} {
        incr nr_warnings 1     ;# check can not run
        debug_puts "--> check $path in level $level: can't start test <--"
     }
     if {$back == 0} {
        set do_send_mail 1  ;# a successfull test run
        incr nr_new_done 1
        debug_puts "no errors"
     } 

     if {$back == 1} {
        debug_puts "check already done"
        incr nr_already_done 1
     }
     debug_puts "calls=$no_level_calls, already done=$nr_already_done"
  }
   }

   # if we have a specific cleanup function: execute it
   set cleanup_ret [execute_setup_cleanup_function $check_cleanup_function "cleanup"]
   if {!$cleanup_ret} {
      set immediate_return -1
   }

   # check the number of busy rlogin sessions
   # it should be 0, or at least not higher than before starting test
   set num_busy_sessions_after_check [get_busy_spawn_rlogin_sessions]
   if {$num_busy_sessions_before_check < $num_busy_sessions_after_check} {
      set session_info [dump_spawn_rlogin_sessions 0]
      close_open_rlogin_sessions
      add_proc_error "run_test" -1 "Session leak in check $check_name ($path)!\nWe have $num_busy_sessions_after_check busy rlogin sessions after starting the test.\nBefore the test, we had $num_busy_sessions_before_check busy sessions.\nMake sure the test closes all opened sessions again!\n\n$session_info\nClosing all sessions now to prepare clean reconnect."
      incr nr_errors
   }

   if { $immediate_return != 0 } {
      return $immediate_return
   }

  if { $nr_already_done == $no_level_calls } {
     return 1  ;# was done time before
  }
  
  if { $send_mail_report != 1 } {
     set do_send_mail 0
  }

  if { $nr_errors == 0 && $nr_warnings == 0 } {
     if { $do_send_mail == 1 } {
        set mail_body "Successfully performed check $check_name in directory\n$path\n"
        set mail_body "${mail_body}Date: [ exec date ]\n\n"
        set mail_body "${mail_body}product type:     $CHECK_PRODUCT_TYPE\n"
        set mail_body "${mail_body}product feature:  $ts_config(product_feature)\n"
        set mail_body "${mail_body}product version:  $CHECK_PRODUCT_VERSION_NUMBER\n"
        set mail_body "${mail_body}product root:     $CHECK_PRODUCT_ROOT\n"
        set mail_body "${mail_body}cell:             $ts_config(cell)\n"
        set mail_body "${mail_body}runlevel:         [get_run_level_name $my_current_runlevel]\n"
        set mail_body "${mail_body}max. runlevel:    [get_run_level_name $check_highest_level]\n"
        set mail_body "${mail_body}dependencies:     $check_needs\n"
        set mail_body "${mail_body}check functions:  \n"
        foreach elem $check_functions {
           set mail_body "${mail_body}                   $elem\n"
        } 
        set mail_body "${mail_body}init level proc:  $check_init_level_procedure\n"
        mail_report "testsuite success - $check_name" $mail_body
     }
     return 0
  } else {
     if { $nr_errors == 0 } {
        return -3 ;# we had warnings
     }
     return -1
  }
}

#                                                             max. column:     |
#****** check/clean_up_globals() ******
# 
#  NAME
#     clean_up_globals -- ??? 
#
#  SYNOPSIS
#     clean_up_globals { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_globals {} {
  global check_init_level_procedure check_name check_description check_highest_level
  global check_needs check_functions check_errno check_errstr check_category
 
  if { [ info exists check_category ] } {
     unset check_category 
  }

  if { [ info exists check_description] } {
     unset check_description 
  }


  set check_name        ""                 ;# name of actual check module 
  set check_needs       ""          ;# dependencies of this check (name of other check)
  set check_functions   ""          ;# functions to call (in order)
  set check_init_level_procedure "--"   ;# name of procedure to call before starting level run
  set check_errno      -1          ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
  set check_errstr       ""          ;# short error description in text form  
  set check_highest_level 0        ;# here a check can define his check levels count 0 ... 
}

# show test description
#                                                             max. column:     |
#****** check/show_test() ******
# 
#  NAME
#     show_test -- ??? 
#
#  SYNOPSIS
#     show_test { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_test {path full} {
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_errno check_needs check_highest_level 
  global check_init_level_procedure CHECK_ACT_LEVEL check_category

  clean_up_globals  

  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
  puts "===============================================================================" 
  puts "name:         | $check_name"
  puts -nonewline "categories:   | "
  foreach cat $check_category {
     puts -nonewline "$cat "
  }
  puts ""
  puts "===============================================================================" 

  if { $full == 1} {
    puts "filename:     | [ format_output "              | " 61 $path/$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT ]"

    puts "===============================================================================" 
    for {set i 0} {$i <= $check_highest_level} {incr i 1} {
       set blank ""
       if { $i <= 99} {
         set blank " "
       }
       if { $i <= 9 } {
         set blank "  "
       } 

       set do_print 0
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
          set CHECK_ACT_LEVEL $i
          if { [$check_init_level_procedure ]  == 0 } { 
             set do_print 1
          } 
       } else {
          set do_print 1
       }
       if { $do_print == 1 } { 
          puts "run level ${blank}$i |"
          puts "description:  | [ format_output "              | " 61 $check_description($i)]"
          puts "==============================================================================="
       }
      

    }

    puts "dependencies: |"
    foreach element $check_needs {
      puts "              | [ format_output "              | " 61 $element]"
    }
    puts "==============================================================================="
  }
}

#                                                             max. column:     |
#****** check/select_runlevel() ******
# 
#  NAME
#     select_runlevel -- ??? 
#
#  SYNOPSIS
#     select_runlevel { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc select_runlevel {} {
     global CHECK_ENABLED_RUNLEVELS CHECK_ENABLED_CATEGORIES CHECK_CHECKTREE_ROOT

     set data ""
     set my_cats [get_checktree_categories "root"]

     while { $data != 0 } {
       
        clear_screen
        print_menu_header
        set selected_levels ""
        foreach elem $CHECK_ENABLED_RUNLEVELS {
           set a_level [ get_run_level_name $elem ] 
  
           if { [string first $a_level $selected_levels ] < 0 } {
              set selected_levels "$selected_levels $a_level"
           } 
        }

        puts "\nplease select/unselect new runlevels/categories: \n"
        puts "(0) return to previous menu\n"

        puts "runlevels:\n"
        puts "(1) short  (   0 min - 15 min / run level   0 -  99 )"
        puts "(2) medium (  16 min -  1 h   / run level 100 - 199 )"
        puts "(3) long   (   1 h   -  4 h   / run level 200 - 299 )"
        puts "(4) day    ( > 4 h   - 24 h   / run level 300 - 399 )"
        puts "(5) week   ( >24 h            / run level 400 - 499 )\n"
        puts "categories:\n"
        set numbs 6
        foreach elem $my_cats {
           puts "($numbs) $elem"
           incr numbs 1
        }

        set data [wait_for_enter 1]
        if { $data <= 5 && $data > 0 } {
           incr data -1
           set in 0
           if { $data <= 4 && $data >= 0 } {
              foreach x $CHECK_ENABLED_RUNLEVELS {
                 if { $x == [ expr ( $data * 100 ) ] } {
                    set in 1
                 }      
              }
           }
   
           if { $data <= 4 && $data >= 0 } {
             if {$in == 0} {
               lappend CHECK_ENABLED_RUNLEVELS [ expr ( $data * 100 )] 
             } else {
               set new_enabled_runlevels ""
               foreach x $CHECK_ENABLED_RUNLEVELS {
                  if { $x != [ expr ( $data * 100 ) ] } { 
                     lappend new_enabled_runlevels $x
                  }
               }
               set CHECK_ENABLED_RUNLEVELS $new_enabled_runlevels
             } 
           }
           incr data 1
        } else {
           # categories
           set max_number [llength $my_cats]
           incr max_number 5
           if { $data > $max_number || $data <= 5  } {
              continue
           }   
           set my_cat [ expr ( $data - 6 ) ]   
           set new_cat [ lindex $my_cats $my_cat ]
           set cat_pos [ lsearch $CHECK_ENABLED_CATEGORIES  $new_cat ]
           if { $cat_pos != -1 } {
              set CHECK_ENABLED_CATEGORIES [ lreplace $CHECK_ENABLED_CATEGORIES $cat_pos $cat_pos ]
           } else {
              lappend CHECK_ENABLED_CATEGORIES $new_cat
           }
        }
     } 
}
proc check_display {} {
     global CHECK_DISPLAY_OUTPUT CHECK_CORE_MASTER CHECK_USER 

     if { [ string compare $CHECK_DISPLAY_OUTPUT "undefined" ] == 0 } {
        puts "no debug x display set"
        return -1
     } 
     start_remote_prog "$CHECK_CORE_MASTER" "$CHECK_USER" "/usr/bin/X11/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user $CHECK_USER from host $CHECK_CORE_MASTER"    
         return -1
     }

     if { [ have_root_passwd ] != 0 } {
         set_root_passwd
     }
     start_remote_prog "$CHECK_CORE_MASTER" "root" "/usr/bin/X11/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user root from host $CHECK_CORE_MASTER"    
         return -1
     }
     return 0
}


proc set_command_line_options {} {
     global CHECK_ENABLED_RUNLEVELS CHECK_ENABLED_CATEGORIES CHECK_CHECKTREE_ROOT 
     global CHECK_SGE_DEBUG_LEVEL check_use_installed_system
     global master_debug schedd_debug do_not_update CHECK_DISPLAY_OUTPUT daemon_debug
     set data ""
     while { $data != 0 } {
        clear_screen
        print_menu_header
        puts "\nplease select/unselect command line options: \n"
        puts "(0) return to previous menu\n"

        puts "options:\n"


        if { $master_debug == 0 } {
           set md_flag "off"
        } else {
           set md_flag "on"
        }
        if { $schedd_debug == 0 } {
           set sd_flag "off"
        } else {
           set sd_flag "on"
        }
        if { $do_not_update == 0 } {
           set nu_flag "off"
        } else {
           set nu_flag "on"
        }

        if { $check_use_installed_system == 0 } {
           set re_init_flag "off"
        } else {
           set re_init_flag "on"
        }

        puts "(1) master_debug    : $md_flag"
        puts "(2) schedd_debug    : $sd_flag"
        puts "(3) SGE_DEBUG_LEVEL : $CHECK_SGE_DEBUG_LEVEL"
        puts "(4) no_update       : $nu_flag"
        puts "(5) re_init         : $re_init_flag"

        set data [wait_for_enter 1]
        if { $data <= 2 && $data > 0 } {
        }
        switch $data {
           "1" { 
              puts "master_debug" 
              if { $master_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set master_debug 1
              } else {
                 set master_debug 0
              }
           }
           "2" {
              puts "schedd_debug" 
              if { $schedd_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set schedd_debug 1
              } else {
                 set schedd_debug 0
              }
           }
           "3" {
               puts "enter new SGE_DEBUG_LEVEL: "
               set CHECK_SGE_DEBUG_LEVEL [wait_for_enter 1]
           }
           "4" {
               if { $do_not_update == 0 } {
                  set do_not_update 1
               } else { 
                  set do_not_update 0
               }
           }
           "5" {
              if { $check_use_installed_system == 0 } {
                 set check_use_installed_system 1
              } else {
                 set check_use_installed_system 0
              }
           }
        }

        if { $schedd_debug == 0 && $master_debug == 0 } {
           set daemon_debug 1
        } else {
           set daemon_debug 0
        }
     } 
}

#****** check/get_max_level_count() ********************************************
#  NAME
#     get_max_level_count() -- get runleves of check
#
#  SYNOPSIS
#     get_max_level_count { path } 
#
#  FUNCTION
#     This function returns all runlevel numbers for the check specified by
#     its testsuite path.
#
#  INPUTS
#     path - full path name of check
#
#  RESULT
#     a list of runlevel numbers
#
#*******************************************************************************
proc get_max_level_count {path} {
  global CHECK_ACT_LEVEL
  global ts_checktree
 
  set check_directories [get_tests_from_checktree $path]
  set max_level {}
  foreach elem $check_directories {
     set nr $ts_checktree($elem)
     if { [string compare $ts_checktree($nr,check_init_level_procedure) "--" ] != 0 } {
        for {set x 0 } {$x <= $ts_checktree($nr,check_highest_level)} {incr x 1 } {
           set CHECK_ACT_LEVEL $x
           if { [$ts_checktree($nr,check_init_level_procedure)]  == 0 } {
              if { [lsearch $max_level $x] < 0 } {
                 lappend max_level $x
              }
           }
        } 
     }
  }  
  return $max_level
}

proc get_checktree_max_level_count {path} {
  global CHECK_ACT_LEVEL
  global ts_checktree
 
  if { [info exists ts_checktree($path)] }  {
     set nr $ts_checktree($path)
     return $ts_checktree($nr,max_level_count)
  }
  return ""
}






proc get_checktree_categories {path} {
  global ts_checktree
 
  set check_directories [get_tests_from_checktree $path]
  set back {}
  foreach elem $check_directories {
     set nr $ts_checktree($elem)
     if { [info exists ts_checktree($nr,check_category)] } {
        foreach elem $ts_checktree($nr,check_category) {
           if { [ lsearch -exact $back $elem ] == -1 } {
              lappend back $elem
           }
        }
     }
  }
  set back [lsort $back]
  return $back
}




# show test descriptons (of all subtests)
#                                                             max. column:     |
#****** check/show_tests() ******
# 
#  NAME
#     show_tests -- ??? 
#
#  SYNOPSIS
#     show_tests { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_tests {path full} {
  global ts_checktree

  set check_directories [get_tests_from_checktree $path]

  foreach elem $check_directories {
     clear_screen
     show_test $elem $full
     wait_for_enter
  }  
}

proc change_dir { { have_input "" } } {
  global CHECK_ACT_PATH ts_checktree CHECK_OUTPUT

  set index_start 1

  if { $have_input == "" } {
     print_menu_header
  }

  set dirs [ get_checktree_dir_names $CHECK_ACT_PATH 0]

  set count 1 

  if {[string compare $CHECK_ACT_PATH "root"] != 0 } {
    if { $have_input == "" } {
       puts "($count) - up"
    }
    incr count 1
    incr index_start 1
  }
  if { $have_input == "" } {
     puts "($count) - stay"
  }
  incr count 1
  incr index_start 1

  foreach elem $dirs {
     # puts "($count) - go to \"$elem\""
     set newdir($count) $elem
     incr count 1
  }

  if { $have_input == "" } {
     puts -nonewline "\nEnter number or a subdirectory name:\n> "
     set input [wait_for_enter 1] 
  } else {
     set input $have_input
  }


  # here we have an input
  for { set i 0 } { $i < [llength $dirs] } { incr i 1 } {
     if { [file tail [lindex $dirs $i]] == $input || [lindex $dirs $i] == $input } {
        set input $i 
        incr input $index_start
     }
  }

  # here input contains the number (switch to newdir($input)
  if { $input == ".." }  {
     if { $have_input == "" } {
        puts "go to upper dir ..."
     }
     if { [info exists ts_checktree($CHECK_ACT_PATH)] } {
        set nr $ts_checktree($CHECK_ACT_PATH)
        set updir $ts_checktree($nr,upper_nrs); 
        set CHECK_ACT_PATH $ts_checktree($updir,dir_name)
     }
     return
  }

  if { [info exists newdir($input)] == 1 } {
     if { $have_input == "" } {
        puts "go to dir $newdir($input) ..."
     }
     set CHECK_ACT_PATH "$newdir($input)"
     return
  }

  if { [info exists ts_checktree($input)] == 1 } {
     set CHECK_ACT_PATH $ts_checktree($ts_checktree($input),dir_name)
     return
  }

  # here we try to find check names and dir names
  set matches {}
  # here we try to find a test name
  for {set i 0} {$i< $ts_checktree(act_nr)} {incr i 1} {
     if { $ts_checktree($i,test_available) == 1 } {
        if { $ts_checktree($i,check_name) == $input } {
           set found 0
           foreach elem $matches {
              if { $elem == $i } {
                 set found 1
              }
           }
           if { $found == 0 } {
              lappend matches $i
           }
        }
     }
     if { [file tail $ts_checktree($i,dir_name)] == $input } {
        set found 0
        foreach elem $matches {
           if { $elem == $i } {
              set found 1
           }
        }
        if { $found == 0 } {
           lappend matches $i
        }
     }
  }

  if { [llength $matches] == 1 } {
     set CHECK_ACT_PATH $ts_checktree($matches,dir_name)
     return
  } 

  if { $matches > 1 } {
     puts "found [llength $matches] matches for \"$input\" ..."
     if {[info exists selection]} {
        unset selection
     }
     for {set i 0} {$i< [llength $matches]} {incr i 1} {
        set text ""
        if { $ts_checktree($i,test_available) == 1 } {
           if { $ts_checktree($i,check_name) == $input} {
              set text "check name"
           }
        }
        if { $text == "" } {
           set text "directory name"
        }
        puts " ([expr ( $i + 1 )]) => via $text: $ts_checktree([lindex $matches $i],dir_name)"
        set selection([expr ( $i + 1 )]) $ts_checktree([lindex $matches $i],dir_name)
     }

     puts -nonewline "\nEnter number:\n> "
     set input [wait_for_enter 1] 
     if { [info exists selection($input)] } {
        set CHECK_ACT_PATH $selection($input)
        return
     }
  }
  puts "no match!"
  wait_for_enter
}


#                                                             max. column:     |
#****** check/get_run_level_name() ******
# 
#  NAME
#     get_run_level_name -- ??? 
#
#  SYNOPSIS
#     get_run_level_name { level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_run_level_name { level } {
  
  if { $level >= 400 } {
     return "week"
  }

  if { $level >= 300 } {
     return "day"
  }

  if { $level >= 200 } {
     return "long"
  }

  if { $level >= 100 } {
     return "medium"
  }

  if { $level >= 00 } {
     return "short"
  }
  return ""
}
# time in minutes
proc get_run_level_time { level } {
  
  if { $level >= 400 } {
     return [expr (48 * 60)]
  }

  if { $level >= 300 } {
     return [expr (14 * 60)]
  }

  if { $level >= 200 } {
     return [expr (2 * 60)]
  }

  if { $level >= 100 } {
     return 30
  }

  if { $level >= 00 } {
     return 10
  }
  return 0
}


#                                                             max. column:     |
#****** check/clear_screen() ******
# 
#  NAME
#     clear_screen -- ??? 
#
#  SYNOPSIS
#     clear_screen { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clear_screen {} {
  set clear_sequence [ format "%c%c%c%c%c%c%c" 0x1b 0x5b 0x48 0x1b 0x5b 0x32 0x4a 0x00 ]
  puts -nonewline $clear_sequence
}

#                                                             max. column:     |
#****** check/print_menu_header() ******
# 
#  NAME
#     print_menu_header -- ??? 
#
#  SYNOPSIS
#     print_menu_header { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_menu_header {} {
  global CHECK_ACT_PATH CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_ENABLED_RUNLEVELS CHECK_PRODUCT_VERSION_NUMBER
  global CHECK_ENABLED_CATEGORIES CHECK_USER CHECK_GROUP
  global ts_config ts_checktree

  clear_screen
  set_users_environment $CHECK_HOST env 1
  get_version_info
  puts "===============================================================================" 

  puts " system version     :  $CHECK_PRODUCT_VERSION_NUMBER ($ts_config(gridengine_version))"
  puts " feature            :  $ts_config(product_feature)"
  puts " current dir        :  [ format_output "                       " 54 $CHECK_ACT_PATH ]"

  set dirs [ get_checktree_dir_names $CHECK_ACT_PATH ]
  lappend dirs $CHECK_ACT_PATH
  set test_counts ""
  set test_text ""
  set time_count 0
  foreach elem $dirs {
     set test_name ""
     set check_directories [get_tests_from_checktree $elem]
     set count 0
     foreach test $check_directories {
        if { [is_category_enabled $test] == 0 } {
           set run_test_ok 0
           set tests_runlevels [get_checktree_levels $test]
            
           # test if the check was already successful
           set test_name [get_check_name $test]
           set global_test_name $test_name
           foreach tests_runlevel $tests_runlevels {
              if { [ is_level_enabled $tests_runlevel ] == 0 } {
                 set state_text "done"
                 if { ( [file isfile "$CHECK_RESULT_DIR/$global_test_name.res.$tests_runlevel"] != 1) } {
                    if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$global_test_name.res.$tests_runlevel"] != 1) } {
                       set run_test_ok 1
                       incr time_count [get_run_level_time $tests_runlevel] 
                       set state_text "on"
                    }
                 }
              } else {
                 set state_text "off"
              }
              if { [string first [get_run_level_name $tests_runlevel] $test_name] < 0 } {
                 append test_name " [get_run_level_name $tests_runlevel]=$state_text"
              }
           }
           if { $run_test_ok == 1 } {
              # we have to run this check
              incr count 1  
           }
        } else {
           set test_name [get_check_name $test]
           append test_name " (category not enabled)"  
        }
     }
     if { $count > 9 } {
        set blank " "
     } else {
        set blank "  "
     }
     lappend test_counts "$count"

     # do we have a test in local directory?
     set we_have_a_test 0
     if { [info exists ts_checktree($CHECK_ACT_PATH)] } {
        set nr $ts_checktree($CHECK_ACT_PATH)
        if { $ts_checktree($nr,test_available) == 1 } {
           set we_have_a_test 1
        }
     }

     if { $elem == $CHECK_ACT_PATH } {
        if { $we_have_a_test == 1 } {
           lappend test_text   " test name: $test_name"
        }
     } else {
        if { $elem != $CHECK_ACT_PATH } {
           lappend test_text   "${blank}${count} test(s) available in subdir: [file tail $elem]"
        }
     }
  }

  set test_count [llength $test_counts]
  puts "==============================================================================="


  set possible_levels ""

  foreach elem [get_checktree_max_level_count $CHECK_ACT_PATH] {
     set a_level [ get_run_level_name $elem ] 
     if { [string first $a_level $possible_levels ] < 0 } {
        set possible_levels "$possible_levels $a_level"
     } 
  }
  set possible_levels [lsort $possible_levels]
  puts " max. runlevel      :  $possible_levels"  

  set selected_levels ""
  set CHECK_ENABLED_RUNLEVELS [ lsort $CHECK_ENABLED_RUNLEVELS  ]
  foreach elem $CHECK_ENABLED_RUNLEVELS {
     set a_level [ get_run_level_name $elem ] 

     if { [string first $a_level $selected_levels ] < 0 } {
        set selected_levels "$selected_levels $a_level"
     } 
  } 

  set selected_levels [ lsort $selected_levels ]
  puts " selected runlevels :  $selected_levels"
  set my_cats [get_checktree_categories $CHECK_ACT_PATH]
  puts -nonewline " categories         :  "
  foreach elem $my_cats {
     puts -nonewline "$elem "
  }
  puts ""

  puts -nonewline " selected categories:  "
  set CHECK_ENABLED_CATEGORIES [ lsort $CHECK_ENABLED_CATEGORIES]
  foreach elem $CHECK_ENABLED_CATEGORIES {
     puts -nonewline "$elem "
  }
  puts ""
  set hours [ expr ( $time_count / 60 ) ]
  set minutes [ expr (  $time_count % 60 ) ]
  puts " est. run time      :  $hours h $minutes m"
  puts "===============================================================================" 
  foreach elem $test_text {
     puts $elem
  }
  puts "===============================================================================" 
}

#                                                             max. column:     |
#****** check/wait_for_enter() ******
# 
#  NAME
#     wait_for_enter -- ??? 
#
#  SYNOPSIS
#     wait_for_enter { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_enter { {no_text 0} } {
   global CHECK_OUTPUT CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
   flush $CHECK_OUTPUT

   if { $no_text == 0 } {
      puts "\npress enter..."
   }
   set output ""
   set en_result [ catch {
      set output [eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/wait_for_enter.sh"]
   } catch_output ]
   return [string trim $output]
}

#                                                             max. column:     |
#****** check/wait_for_start_time() ******
# 
#  NAME
#     wait_for_start_time -- ??? 
#
#  SYNOPSIS
#     wait_for_start_time { substring } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     substring - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_start_time { substring } {
   puts "wait for start time: \"$substring\""
   while { 1 } {
      set date_output [ exec date "+%D %H:%M" ]
      puts -nonewline "\r$date_output"
      flush stdout
      if { [string compare $date_output $substring] == 0 } {
         break; 
      }
      sleep 30
   }
   puts ""
}

# returns -1: error
# returns 0 : no error
proc prepare_packages { } {
   global ts_config
   global CHECK_PACKAGE_DIRECTORY CHECK_OUTPUT CHECK_DEFAULTS_FILE
   global CHECK_PRODUCT_ROOT CHECK_JOB_OUTPUT_DIR CHECK_HOST CHECK_PACKAGE_TYPE
   global CHECK_USER CHECK_PRODUCT_TYPE CHECK_CORE_EXECD CHECK_PROTOCOL_DIR
   global CHECK_GROUP check_name CHECK_CUR_PROC_NAME

   set check_name "prepare_packages"
   set CHECK_CUR_PROC_NAME "prepare_packages"


   #do pre checks like in compile
   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           return -1
      } 
   }

   set have_tar 0
   set have_zip 0
   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_tar ] == 0 } {
      puts $CHECK_OUTPUT "found tar files"
      set have_tar 1
   }

   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_zip ] == 0 } {
      puts $CHECK_OUTPUT "found zip files"
      set have_zip 1
   }

   if { $have_tar == 0 && $CHECK_PACKAGE_TYPE == "tar" } {
      add_proc_error "prepare_packages" -1 "not all tar files available"
      return -1
   }

   if { $have_zip == 0 && $CHECK_PACKAGE_TYPE == "zip" } {
      add_proc_error "prepare_packages" -1 "not all zip files available"
      return -1
   }


   if { $have_tar == 1 && $CHECK_PACKAGE_TYPE == "tar" } {

      # shutdown eventually running system
      shutdown_core_system

      set tar_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both tar ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
      if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
      puts $result
      catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
      puts $result

      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)" } 
      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common" } 

      # copy pos. host_aliases file to new product root /cell/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $CHECK_PRODUCT_ROOT
      } 
      puts $CHECK_OUTPUT ""

      # gunzip package files
      puts $CHECK_OUTPUT "gunzip package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "gunzip" "$CHECK_PRODUCT_ROOT/$file"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # extract package files
      puts $CHECK_OUTPUT "extract package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         set result [ start_remote_prog $CHECK_HOST $CHECK_USER "cd" "$CHECK_PRODUCT_ROOT ; tar -xvf $CHECK_PRODUCT_ROOT/$file_no_gz" ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""
     
      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $tar_files { 
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         delete_file $CHECK_PRODUCT_ROOT/$file_no_gz
      } 
      puts $CHECK_OUTPUT ""

      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $CHECK_PRODUCT_ROOT/utilbin ]
      
      set local_host_arch [ resolve_arch $CHECK_HOST ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $CHECK_HOST not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $CHECK_CORE_EXECD {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in tar files, please add tar file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for tar architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   if { $have_zip == 1 && $CHECK_PACKAGE_TYPE == "zip" } {

      # shutdown eventually running system
      shutdown_core_system

      set zip_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both zip ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
      if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
      puts $result
      catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
      puts $result

      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)" } 
      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common" } 

      # copy pos. host_aliases file to new product root /$SGE_CELL/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      if { [catch { file mkdir "$CHECK_PRODUCT_ROOT/tmp_zip_copy" }] != 0 } {
         puts $CHECK_OUTPUT "could not create directory \"$CHECK_PRODUCT_ROOT/tmp_zip_copy\""
         return -1    
      }
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $CHECK_PRODUCT_ROOT/tmp_zip_copy
      } 
      puts $CHECK_OUTPUT ""

      
      # unzip package files
      puts $CHECK_OUTPUT "unzip package files ..."
      set i 0
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "unzip" "$CHECK_PRODUCT_ROOT/tmp_zip_copy/$file" "-d" "$CHECK_PRODUCT_ROOT/tmp_zip_copy"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $zip_files { 
         delete_file $CHECK_PRODUCT_ROOT/tmp_zip_copy/$file
      } 
      puts $CHECK_OUTPUT ""


      # now check if packages are already installed and remove installed ones
      set package_names [ get_dir_names $CHECK_PRODUCT_ROOT/tmp_zip_copy ]
      puts -nonewline $CHECK_OUTPUT "Found following packages:"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT " $pkg" 
      }
      puts $CHECK_OUTPUT "\n"
      set user_key "unknown"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT "Checking if package \"$pkg\" is already installed on host \"$CHECK_HOST\" ... "
         set output [ start_remote_prog $CHECK_HOST "root" "pkginfo" "$pkg" ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT "not installed"
         } else {
            puts $CHECK_OUTPUT "already installed."
            puts $CHECK_OUTPUT "\n$output\n"
            puts $CHECK_OUTPUT "Press \"yes\" to uninstall ALL packages listed above or \"no\" to continue ..."
            if { $user_key == "unknown" } {
               set user_key [ wait_for_enter 1 ]
            }
            if { $user_key == "yes" } {
               puts $CHECK_OUTPUT "removing package \"$pkg\" ..."
               set output [ start_remote_prog $CHECK_HOST "root" "pkgrm" "-n $pkg" ]
               puts $CHECK_OUTPUT $output
               if { $prg_exit_state != 0 } {
                  puts $CHECK_OUTPUT "error uninstalling package \"$pkg\""
                   puts $CHECK_OUTPUT "stop package installation"
                   return -1
               }
            } else {
               puts $CHECK_OUTPUT "will NOT remove package \"\""
               puts $CHECK_OUTPUT "stop package installation"
               return -1
            }
         }
      }
      
      # now install the packages ...
      set send_speed .1
      set send_slow "1 $send_speed"
      foreach pkg $package_names {
         set id [open_remote_spawn_process "$CHECK_HOST" "root" "pkgadd" "-d $CHECK_PRODUCT_ROOT/tmp_zip_copy $pkg" ]
         log_user 1
         set sp_id [ lindex $id 1 ]
         set timeout 60
         set do_stop 0
         set exit_state 1
         while { $do_stop == 0 } {
            flush $CHECK_OUTPUT
            expect {
               -i $sp_id full_buffer { 
                  add_proc_error "prepare_packages" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id timeout {
                  add_proc_error "prepare_packages" -1 "unexpected timeout"
                  close_spawn_process $id
                  return -1
               } 
               -i $sp_id eof {
                  set exit_state [close_spawn_process $id]
                  set do_stop 1
               } 
               -i $sp_id "_exit_status_:*\n" {
                  set buf $expect_out(buffer)
                  set s_start [ string first "(" $buf ]
                  set s_end [ string first ")" $buf ]
                  incr s_start 1
                  incr s_end -1
                  set exit_state [ string range $buf $s_start $s_end ]
                  puts $CHECK_OUTPUT "exit state is: \"$exit_state\""
                  close_spawn_process $id
                  set do_stop 1
               }
               -i $sp_id "default /gridware/sge*]" {
                  flush $CHECK_OUTPUT
                  if { [ string length $CHECK_PRODUCT_ROOT ] >= 5  } {
                     send -s -i $sp_id "$CHECK_PRODUCT_ROOT\n"
                  } else {
                     add_proc_error "prepare_packages" -1 "can't use product root directory (shorter than 5 chars)"
                     close_spawn_process $id
                     return -1
                  }
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "default sgeadmin*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "$CHECK_USER\n"   
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Do you want to install these as setuid/setgid files*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "y\n"   
                  flush $CHECK_OUTPUT
               }


               -i $sp_id "default adm*]" {
                  send -s -i $sp_id "$CHECK_GROUP\n"
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Waiting for pkgadd of*" {
                  add_proc_error "prepare_packages" -1 "$CHECK_HOST: another pkgadd session is running...\n$expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id "*\n" { 
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id default {
                  add_proc_error "prepare_packages" -1 "undefined behaviour: $expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               } 
            }
         }
         if { $exit_state != 0 } {
            add_proc_error "prepare_packages" -1 "exit state of pgkadd \"$pkg\" is $exit_state -> error"
            return -1
         }
      }
           



      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $CHECK_PRODUCT_ROOT/utilbin ]
      
      set local_host_arch [ resolve_arch $CHECK_HOST ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $CHECK_HOST not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $CHECK_CORE_EXECD {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in zip files, please add zip file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for zip architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   return -1
}
# mode : check_both, check_tar, check_zip
# get_files : no, tar, zip
proc check_packages_directory { path { mode "check_both" } { get_files "no" } } {

   global CHECK_OUTPUT CHECK_PACKAGE_TYPE

   set tar_bin_files [ get_file_names $path "sge*-bin-*.tar.gz" ] 
   set zip_bin_files [ get_file_names $path "sge*-bin-*.zip" ]      
   set tar_common_files [ get_file_names $path "sge*-common*.tar.gz" ] 
   set zip_common_files [ get_file_names $path "sge*-common*.zip" ]   
   set tar_doc_files [ get_file_names $path "sge*-doc*.tar.gz" ] 
   set zip_doc_files [ get_file_names $path "sge*-doc*.zip" ]    

   set tar_list "$tar_bin_files $tar_common_files $tar_doc_files"
   set zip_list "$zip_bin_files $zip_common_files $zip_doc_files"
     

   set nr_tar_bin_files [ llength $tar_bin_files ]
   set nr_zip_bin_files [ llength $zip_bin_files ] 
   set nr_tar_common_files [ llength $tar_common_files ]
   set nr_zip_common_files [ llength $zip_common_files ] 
   set nr_tar_doc_files [ llength $tar_doc_files ]
   set nr_zip_doc_files [ llength $zip_doc_files ] 

   set tar_complete 0
   set zip_complete 0

   if { $tar_bin_files  > 0 && $tar_common_files > 0 && $tar_doc_files > 0 } {
      set tar_complete 1
   }
   if { $zip_bin_files  > 0 && $zip_common_files > 0 && $zip_doc_files > 0 } {
      set zip_complete 1
   }

   if { $get_files == "no" } {
      puts $CHECK_OUTPUT "nr. of binary tar files: $nr_tar_bin_files"
      puts $CHECK_OUTPUT "nr. of binary zip files: $nr_zip_bin_files"
      puts $CHECK_OUTPUT "nr. of common tar files: $nr_tar_common_files"
      puts $CHECK_OUTPUT "nr. of common zip files: $nr_zip_common_files"
      puts $CHECK_OUTPUT "nr. of doc tar files: $nr_tar_doc_files"
      puts $CHECK_OUTPUT "nr. of doc zip files: $nr_zip_doc_files"
      if { $tar_complete == 1 } {
         puts $CHECK_OUTPUT "tar files complete"
      } else {
         puts $CHECK_OUTPUT "tar files INCOMPLETE"
      }
      if { $zip_complete == 1 } {
         puts $CHECK_OUTPUT "zip files complete"
      } else {
         puts $CHECK_OUTPUT "zip files INCOMPLETE"
      }
      
      if { $tar_complete == 1 && $zip_complete == 1 && $mode == "check_both" } {
         return 0
      }
      if { $tar_complete == 1 && $mode == "check_tar" } {
         return 0
      }
      if { $zip_complete == 1 && $mode == "check_zip" } {
         return 0
      }
      return -1
   } else {
      switch -- $get_files {
         "tar" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "tar files incomplete error"
                return ""
             }
             return $tar_list
         }
         "zip" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "zip files incomplete error"
                return ""
             }
             return $zip_list
         } 
      }
   }
   return -1
}
#
#                                                             max. column:     |
#
#****** check/compile_source() ******
#  NAME
#     compile_source() -- ??? 
#
#  SYNOPSIS
#     compile_source { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc compile_source { { do_only_install 0 } { do_only_hooks 0} } {
   global ts_config ts_host_config
   global CHECK_SOURCE_DIR CHECK_OUTPUT CHECK_SOURCE_HOSTNAME
   global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT
   global CHECK_HTML_DIRECTORY
   global CHECK_DEFAULTS_FILE CHECK_SOURCE_CVS_RELEASE do_not_update check_name
   global CHECK_DIST_INSTALL_OPTIONS CHECK_JOB_OUTPUT_DIR
   global CHECK_CORE_EXECD CHECK_PROTOCOL_DIR CHECK_USER CHECK_HOST check_do_clean_compile

   # settings for mail
   set check_name "compile_source"
   set CHECK_CUR_PROC_NAME "compile_source"
   if { $do_only_hooks == 0 } {
      set NFS_sleep_time 20
   } else {
      set NFS_sleep_time 0
   }

   array set report {}
   report_create "Compiling source" report
   
   report_write_html report
   
   set error_count 0
   set cvs_change_log ""

   # if we configured to install precompiled packages - stop
   if { $ts_config(package_directory) != "none" && 
        ($ts_config(package_type) == "tar" || $ts_config(package_type) == "zip") } {
           
      report_add_message report "will not compile but use precompiled packages\n"
      report_add_message report "set package_directory to \"none\" or set package_type to \"create_tar\"\n"
      report_add_message report "if compilation (and package creation) should be done"
      
      report_finish report -1
      
      return -1
   }

   # compile hosts required for master, exec, shadow, submit_only, bdb_server hosts
   set compile_hosts [compile_host_list]

   # add compile hosts for additional compile archs
   if {$ts_config(add_compile_archs) != "none"} {
      foreach arch $ts_config(add_compile_archs) {
         lappend compile_hosts [compile_search_compile_host $arch]
      }
   }

   # eliminate duplicates
   set compile_hosts [compile_unify_host_list $compile_hosts]

   # check source directory
   if { ( [ string compare $CHECK_SOURCE_DIR "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_DIR "" ] == 0 ) } {
      report_add_message report "source directory unknown - check defaults file"
      report_finish report -1 
      return -1
   }

   # check compile host
   if { ( [ string compare $CHECK_SOURCE_HOSTNAME "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_HOSTNAME "" ] == 0  ) } {          
      report_add_message report "host for cvs checkout unknown - check defaults file"
      report_finish report -1
      return -1
   }

   # check compile hosts
   if { ( [ string compare $compile_hosts "unknown" ] == 0 ) || ([ string compare $compile_hosts "" ] == 0) } {
      report_add_message report "host list to compile for unknown - check defaults file"
      report_finish report -1
      return -1
   }

   # figure out the compile archs
   set compile_arch_list ""
   foreach chost $compile_hosts {
      puts $CHECK_OUTPUT "\n-> checking architecture for host $chost ..."
      set output [ start_remote_prog $chost $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk -no-mk" prg_exit_state 60 0 "" 1 0 ]
      puts $CHECK_OUTPUT "return state: $prg_exit_state"
      if { $prg_exit_state != 0 } {
         report_add_message report "error starting \"aimk -no-mk\" on host $chost"
         report_finish report -1
         return -1
      }
      puts $CHECK_OUTPUT "host $chost will build [string trim $output] binaries"
      lappend compile_arch_list $output
   }

   # check if compile hosts are unique per arch
   foreach elem $compile_arch_list {
     set found 0
     set hostarch ""
     foreach host $compile_arch_list {
        if { [ string compare $host $elem ] == 0 }  {
           incr found 1
           set hostarch $host
        }
     }
     if { $found != 1 } {
        report_add_message report "two compile hosts have the same architecture -> error"
        report_finish report -1
        return -1
     }
   }

   # create protocol directory
   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
        report_add_message report "could not create directory \"$CHECK_PROTOCOL_DIR\""
        report_finish report -1
        return -1
      } 
   }

   # shutdown possibly running system
   shutdown_core_system $do_only_hooks

   # update sources
   if { $do_only_install != 1 } {
      set res [update_source report]      
      if { $res == 1 } {
         # after an update, do an aimk clean
         if { $do_only_hooks == 0 } {
            compile_with_aimk $compile_hosts report "compile_clean" "clean"
         } else {
            puts $CHECK_OUTPUT "Skip aimk compile, I am on do_only_hooks mode"
         }
         # execute all registered compile_clean hooks of the checktree
         set res [exec_compile_clean_hooks $compile_hosts report]
         if { $res < 0 } {
            report_add_message report "exec_compile_clean_hooks returned fatal error"
         } elseif { $res > 0 } {
            report_add_message report "$res compile_clean hooks are failed\n"
         } else {
            report_add_message report "All compile_clean hooks successfully executed\n"
         }
      
         # give NFS some rest after (probably massive) deletes
         sleep $NFS_sleep_time

         # after an update, delete macro messages file to have it updated
         set macro_messages_file [get_macro_messages_file_name]
         puts $CHECK_OUTPUT "deleting macro messages file after update!"
         puts $CHECK_OUTPUT "file: $macro_messages_file"
         if { [ file isfile $macro_messages_file] } {
            file delete $macro_messages_file
         }
         update_macro_messages_list
      } elseif { $res < 0 } {
         incr error_count
      }
   }

   if { $error_count == 0 && $check_do_clean_compile == 1 } {
      if { $do_only_hooks == 0 } {
         compile_with_aimk $compile_hosts report "compile_clean" "clean"
      } else {
         puts $CHECK_OUTPUT "Skip aimk compile, I am on do_only_hooks mode"
      }
      # execute all registered compile_hooks of the checktree
      set res [exec_compile_clean_hooks $compile_hosts report]
      if { $res < 0 } {
         report_add_message report "exec_compile_clean_hooks returned fatal error"
      } elseif { $res > 0 } {
         report_add_message report "$res compile_clean hooks are failed\n"
      } else {
         report_add_message report "All compile_clean hooks successfully executed\n"
      }

      # give NFS some rest after (probably massive) deletes
      sleep $NFS_sleep_time

   }

   if { $error_count > 0 } {
      puts $CHECK_OUTPUT "Skip compile due to previous errors\n"
   } elseif { $do_only_install != 1 } {
      if { $do_only_hooks == 0 } {
         if { [compile_depend $compile_hosts report] != 0 } {
            incr error_count
         } 
      } else {
         puts $CHECK_OUTPUT "Skip aimk compile, I am on do_only_hooks mode"
      }
      if { $error_count == 0 } {
         # depend was successfull - sleep a bit so let nfs settle down
         sleep $NFS_sleep_time

         # start build process
         if { $do_only_hooks == 0 } {
            if {[compile_with_aimk $compile_hosts report "compile"] != 0} {
               incr error_count
            }
         } else {
            puts $CHECK_OUTPUT "Skip aimk compile, I am on do_only_hooks mode"
         }
         if { $error_count == 0 } {
            # new all registered compile_hooks of the checktree
            set res [exec_compile_hooks $compile_hosts report]
            if { $res < 0 } {
               puts $CHECK_OUTPUT "exec_compile_hooks returned fatal error\n"
               incr error_count
            } elseif { $res > 0 } {
               puts $CHECK_OUTPUT "$res compile hooks are failed\n"
               incr error_count
            } else {
               puts $CHECK_OUTPUT "All compile hooks successfully executed\n"
            }
         }
      }
   } else {
      puts $CHECK_OUTPUT "Skip compile, I am on do_install mode\n"
   }

   # install to $CHECK_PRODUCT_ROOT
   if { $error_count == 0 } {
      report_add_message report "Installing binaries ...."
      report_write_html report
     
      # We need to evaluate the architectures to install.
      # We might have cached architecture strings from an old
      # $SGE_ROOT/util/arch. Clear the cache and resolve 
      # architecture names using dist/util/arch script.
      resolve_arch_clear_cache
      set arch_list {}
      set compiled_mail_architectures ""
      puts -nonewline $CHECK_OUTPUT "\narchitectures: "
      foreach elem $compile_hosts {
         set output [resolve_arch $elem 1]
         lappend arch_list $output 
         puts -nonewline $CHECK_OUTPUT "$output "
         append compiled_mail_architectures "\n$elem ($output)"
      }
      puts ""
      
      if { $do_only_hooks == 0 } {
         if { [ install_binaries $do_only_install $arch_list report] != 0 } {
            report_add_message report "install_binaries failed\n"
            incr error_count
         } 
      } else {
         puts $CHECK_OUTPUT "Skip aimk compile, I am on do_only_hooks mode"
      }
      if { $error_count == 0 } {
         # new all registered compile_hooks of the checktree
         set res [exec_install_binaries_hooks $arch_list report]
         if { $res < 0 } {
            report_add_message report "exec_install_binaries_hooks returned fatal error\n"
            incr error_count
         } elseif { $res > 0 } {
            report_add_message report "$res install_binaries hooks are failed\n"
            incr error_count
         } else {
            report_add_message report "All install_binaries hooks successfully executed\n"
         }
      }
   } else {
      report_add_message report "Skip installation due to previous error\n"
   }

   if { $error_count > 0 } {
      report_add_message report "Error occured during compilation or pre-installation of binaries"
      report_finish report -1 
      return -1
   }
   
   report_add_message report "Successfully compiled and pre-installed following architectures:"
   report_add_message report "${compiled_mail_architectures}\n"
   
   report_add_message report "init_core_system check will install the $CHECK_PRODUCT_TYPE execd at:"
   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      report_add_message report "$elem ($host_arch)"
   }
   if { [string compare $cvs_change_log "" ] != 0 } {
      report_clear_messages report
      report_add_message report "$mail_body \n\n Update output:\n$cvs_change_log\n\n"
   }
   
   report_finish report 0

   # try to resolve hostnames in settings file
   set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
   if { $catch_return != 0 } { 
        puts "could not copy defaults file"
        return -1
   }

   # if required, build distribution
   build_distribution $arch_list
   
   return 0
}

proc build_distribution { arch_list } {
   global ts_config CHECK_OUTPUT CHECK_HOST CHECK_USER
   global CHECK_SOURCE_DIR 
   
   if { $ts_config(package_type) == "create_tar" &&
        $ts_config(package_directory) != "none" } {
      
      
      puts $CHECK_OUTPUT "creating tar packages"  
      # distribution will be created using mk_dist
      # figure out which commandline options to use
      set args ""
      append args "-vdir $ts_config(product_root)"             ;# find the distrib here
      append args " -version $ts_config(source_cvs_release)"   ;# for package names
      append args " -basedir $ts_config(package_directory)"    ;# destination dir
      append args " -bin -common"                              ;# which packages

      if { $ts_config(gridengine_version) == 53 } {
         if { $ts_config(product_type) == "sgeee" } {
            append args " -sgeee"
         }
      }

      if { ! [file isdirectory $ts_config(package_directory)] } {
         file mkdir $ts_config(package_directory)
      }

      puts $CHECK_OUTPUT "starting mk_dist $args $arch_list"
      # start mk_dist
      set open_spawn [ open_remote_spawn_process $CHECK_HOST $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./scripts/mk_dist $args $arch_list" ]
      set sp_id [ lindex $open_spawn 1 ]
      set timeout -1
      set done 0
      while { $done != 1 } {
         expect_user {
            -i $sp_id full_buffer {
               puts $CHECK_OUTPUT "testsuite - compile_source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id "_exit_status_" {
               set done 1
            }
            -i $sp_id eof {
               set done 1
            }
            -i $sp_id "*\n" {
               puts $CHECK_OUTPUT $expect_out(0,string)
            }
         }
      }
      close_spawn_process $open_spawn
      puts $CHECK_OUTPUT ""
   }
}

proc install_binaries { do_only_install arch_list a_report } {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT
   global ts_config CHECK_JOB_OUTPUT_DIR CHECK_SOURCE_DIR CHECK_DIST_INSTALL_OPTIONS
   global CHECK_HOST CHECK_USER CHECK_CORE_EXECD
   
   upvar $a_report report
   set was_error 0

   set task_nr [ report_create_task report "install_binaries" $CHECK_HOST ]
   
   # install to $CHECK_PRODUCT_ROOT
   set var_name "SGE_ROOT"
   if { $ts_config(gridengine_version) == 53 } {
      if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0 } {
         set link_name "myinst"
         set sgeee_param "-sgeee"
      } else {
         set link_name "myinst"
         set sgeee_param ""
      }
   }
   report_task_add_message report $task_nr "\nusing environment variable \"$var_name\""

   # copy pos. host_aliases file to trash_
   if { [ file isfile "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases"] == 1 } {
      report_task_add_message report $task_nr "saving host_aliases file ..."
      catch { exec "cp" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
      puts $result
      report_task_add_message report $task_nr $result
   } 

   # now delete install directory
   report_task_add_message report $task_nr "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
   if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
      add_proc_error "compile_source" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
      report_task_add_message report $task_nr "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
      report_finish_task report $task_nr -1
      return -1
   }
 
   # wait for nfs updates
   after 5000

   catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
   report_task_add_message report $task_nr $result
   catch { exec "touch" "$CHECK_PRODUCT_ROOT"  } result
   report_task_add_message report $task_nr $result
   catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
   report_task_add_message report $task_nr $result
 
   if { $ts_config(gridengine_version) == 53 } {
      report_task_add_message report $task_nr "\ncreating link \"$link_name\""
      set return_state [ catch { eval exec ln -s $CHECK_SOURCE_DIR/scripts/distinst $CHECK_SOURCE_DIR/$link_name } output ]
   }

 
   report_task_add_message report $task_nr "\ninstalling product binaries"
   
   if { $ts_config(gridengine_version) == 53 } {
      set open_spawn [ open_remote_spawn_process $CHECK_HOST $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; $var_name=$CHECK_PRODUCT_ROOT ; export $var_name ; ./$link_name $sgeee_param $CHECK_DIST_INSTALL_OPTIONS $arch_list" ]
   } else {
      set open_spawn [ open_remote_spawn_process $CHECK_HOST $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; $var_name=$CHECK_PRODUCT_ROOT ; export $var_name ; ./scripts/distinst -local -noexit $CHECK_DIST_INSTALL_OPTIONS $arch_list" ]
   }
   set sp_id [ lindex $open_spawn 1 ]
   set timeout -1
   set done 0
   while { $done != 1 } {
      expect_user {
         -i $sp_id full_buffer {
            report_task_add_message report $task_nr "testsuite - compile_source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "Base directory:" {
             send -i $sp_id "y\n"
         }
         -i $sp_id "overriding mode" {
             send -i $sp_id "y\n"
         }
         -i $sp_id "_exit_status_" {
            set done 1
         }
         -i $sp_id eof {
            set done 1
         }
         -i $sp_id "*\n" {
            report_task_add_message report $task_nr $expect_out(0,string)
         }
      }
   }
   close_spawn_process $open_spawn
   puts $CHECK_OUTPUT ""

   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem 1]
      if { ([string compare $host_arch ""] != 0) && ([string compare $host_arch "unknown" ] != 0) } {
         report_task_add_message report $task_nr " arch on host $elem is $host_arch - successfully installed binaries"
      } else {
         report_task_add_message report $task_nr " error installing binaries for host $elem"
         set was_error 1
      }
   }
   

   catch { file mkdir "$CHECK_PRODUCT_ROOT/man" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/catman" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common" } 

  
   # copy pos. host_aliases file to new product root /$SGE_CELL/common
   if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 } {
        report_task_add_message report $task_nr "restoring host_aliases file ..."
        catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" } result
        report_task_add_message report $task_nr $result
   }
  
   # copy source/dist/util/arch to $SGE_ROOT/util.
   # When we compiled our own binaries (including non distributed architectures like 
   # lx26-x86 or hp11-64, source/dist/util/arch will give us the correct arch strings.
   set arch_script_src "$CHECK_SOURCE_DIR/dist/util/arch"
   set arch_script_dst "$CHECK_PRODUCT_ROOT/util/arch"
   report_task_add_message report $task_nr "installing $arch_script_src ..."
   catch { exec cp $arch_script_src $arch_script_dst} result
 
   # done - final error handling
   if { $was_error } {
      report_finish_task report $task_nr -1
   } else {
      report_finish_task report $task_nr 0
   }
   return $was_error
}


#****** check/compile_with_aimk() **************************************************
#  NAME
#    compile_with_aimk() -- compile with aimk
#
#  SYNOPSIS
#    compile_with_aimk { host_list report task_name { aimk_options "" } } 
#
#  FUNCTION
#     Start the aimk parallel on some hosts
#
#  INPUTS
#    host_list --  list of host where aimk should be started
#    a_report    --  the report object
#    task_name --  name of the task in the report object
#    aimk_options -- aimk options
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc compile_with_aimk { host_list a_report task_name { aimk_options "" }  } {
   global CHECK_OUTPUT CHECK_USER
   global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_SOURCE_DIR
   global CHECK_HTML_DIRECTORY CHECK_PROTOCOL_DIR
   global do_only_install
   
   upvar $a_report report
   set num 0
   set my_compile_options [get_compile_options_string]
   if { [string length $aimk_options] > 0 } {
      append my_compile_options " $aimk_options"
   }
   
   set num 0
 
   array set host_array {}
   
   set cvs_tag "maintrunk"
   if { [ file isfile "${CHECK_SOURCE_DIR}/CVS/Tag" ] } {
      set cvs_tag "no_tag_dir" 
      set tag_state [ catch { eval exec "cat ${CHECK_SOURCE_DIR}/CVS/Tag" } cvs_tag ]
   }

   # we'll pass a build number into aimk to distinguish our binaries
   # from official builds.
   set build_number [get_build_number]

   set table_row 2
   foreach elem $host_list {
      # we have to make sure that the build number is compiled into 
      # the object code (therefore delete the appropriate object module).
      delete_build_number_object $elem $build_number

      # compile the staff
      puts $CHECK_OUTPUT "-> starting $task_name on host $elem ..."

      set prog "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/remotecompile.sh"
      set par1 "$CHECK_SOURCE_DIR"
      set par2 "-DDAILY_BUILD_NUMBER=$build_number $my_compile_options"
      
      puts $CHECK_OUTPUT "$prog $par1 '$par2'"
      set open_spawn [ open_remote_spawn_process $elem $CHECK_USER $prog "$par1 '$par2'" 0 "" 0 ]
      set spawn_id [lindex $open_spawn 1]
      
      set host_array($spawn_id,host) $elem
      set host_array($spawn_id,task_nr) [ report_create_task report $task_name $elem ]      
      set host_array($spawn_id,open_spawn) $open_spawn 
      lappend spawn_list $spawn_id
      incr num 1
   }  
  
   puts $CHECK_OUTPUT "now waiting for end of compile ..." 
   set timeout 300
   set done_count 0
   log_user 0

   set show_info 1
   set output_buff ""
   
   set org_spawn_list $spawn_list
   
   while { [llength $spawn_list] > 0 } {
      if {[info exists spawn_id]} {
         unset spawn_id
      }
      
      if { $show_info == 1 } {
         clear_screen
         puts $CHECK_OUTPUT "============================================"
         puts $CHECK_OUTPUT "open compile connections: "
         foreach spawn_id $spawn_list {
            puts -nonewline $CHECK_OUTPUT "$host_array($spawn_id,host) "
         }
         puts $CHECK_OUTPUT "\n============================================"
         puts $CHECK_OUTPUT $output_buff
         set show_info 1
      }

      expect {
         -i $spawn_list full_buffer {
         }
         -i $spawn_list timeout {
            set spawn_id $expect_out(spawn_id)
            set host_array($spawn_id,bad_compile) 1
            
            report_task_add_message report $host_array($spawn_id,task_nr) "got timeout for host \"$host_array($spawn_id,host)\""
            
            close_spawn_process $host_array($spawn_id,open_spawn)
            set host_array($spawn_id,open_spawn) "--"
            set index [lsearch -exact $spawn_list $spawn_id]
            set spawn_list [lreplace $spawn_list $index $index]
         }
         -i $spawn_list eof {
            set spawn_id $expect_out(spawn_id)
            set host_array($spawn_id,bad_compile) 1
            
            report_task_add_message report $host_array($spawn_id,task_nr) "got eof for host \"$host_array($spawn_id,host)\""
            
            close_spawn_process $host_array($spawn_id,open_spawn)
            set host_array($spawn_id,open_spawn) "--"
            set index [lsearch -exact $spawn_list $spawn_id]
            set spawn_list [lreplace $spawn_list $index $index]
         }
         -i $spawn_list "remotecompile * aimk compile error" {
            
            set spawn_id $expect_out(spawn_id)
            
            set host_array($spawn_id,bad_compile) 1
            
            report_task_add_message report $host_array($spawn_id,task_nr) $expect_out(0,string)
            
            close_spawn_process $host_array($spawn_id,open_spawn)
            set host_array($spawn_id,open_spawn) "--"
            set index [lsearch -exact $spawn_list $spawn_id]
            set spawn_list [lreplace $spawn_list $index $index]
            
         }
         -i $spawn_list "remotecompile * aimk no errors" {
            set spawn_id $expect_out(spawn_id)
            report_task_add_message report $host_array($spawn_id,task_nr) $expect_out(0,string)
            set host_array($spawn_id,bad_compile) 0
            
            close_spawn_process $host_array($spawn_id,open_spawn)
            set host_array($spawn_id,open_spawn) "--"
            set index [lsearch -exact $spawn_list $spawn_id]
            set spawn_list [lreplace $spawn_list $index $index]
            
         }
         -i $spawn_list "*\n" {
            set spawn_id $expect_out(spawn_id)
            report_task_add_message report $host_array($spawn_id,task_nr) $expect_out(0,string)
            set show_info 1
            set output_buff ""
            append output_buff "\n$host_array($spawn_id,host):\n"
            append output_buff "$expect_out(0,string)"
         }
      }
   }
   log_user 1
   
   set compile_error 0
   foreach spawn_id $org_spawn_list {
      if { $host_array($spawn_id,bad_compile) != 0 } {
         puts $CHECK_OUTPUT "\n=============\ncompile error on host $host_array($spawn_id,host):\n=============\n"
         report_finish_task report $host_array($spawn_id,task_nr) 1
         set compile_error 1
      } else {
         report_finish_task report $host_array($spawn_id,task_nr) 0
      }
   }

   return $compile_error
}

#****** check/get_build_number() ***********************************************
#  NAME
#     get_build_number() -- create a build number
#
#  SYNOPSIS
#     get_build_number { } 
#
#  FUNCTION
#     Creates a build number.
#     Currently, we use the date (formatted as yyyymmdd) as build number.
#
#  INPUTS
#
#  RESULT
#     build number
#*******************************************************************************
proc get_build_number {} {
   set build [clock format [clock seconds] -format "%Y%m%d" -gmt 1]
   return $build
}

#****** check/delete_build_number_object() *************************************
#  NAME
#     delete_build_number_object() -- delete object code containing build num
#
#  SYNOPSIS
#     delete_build_number_object { host build } 
#
#  FUNCTION
#     The function deletes the object code file from the build directory
#     which has the build number compiled in.
#
#     Currently this is the file sge_feature.o.
#
#     As we use the date as build number, the file is only deleted - and
#     therefore will be rebuilt with a new build number - when it has been
#     created or modified earlier than today.
#
#  INPUTS
#     host  - the host for whose architecture the object module will be deleted
#     build - the build number
#*******************************************************************************
proc delete_build_number_object {host build} {
   global ts_config

   set arch [resolve_build_arch $host]
   set filename "$ts_config(source_dir)/$arch/sge_feature.o"

   # only delete the file, if it is older than 00:00 today
   if {[file exists $filename]} {
      set midnight [clock scan $build -gmt 1]
      if {[file mtime $filename] < $midnight} {
         file delete $filename
      }
   }
}

#****** check/update_source() ******************************************************
#  NAME
#    update_source()
#
#  SYNOPSIS
#    update_source { a_html_body } 
#
#  FUNCTION
#     Updates the sources at CHECK_SOURCE_DIR
#     The cvs commands is executed at CHECK_SOURCE_HOSTNAME
#     For the result a report is emailed
#  INPUTS
#    a_html_body   -- html body where error messages will be appended
#    a_mail_body   -- mail body where error messages will be appended
#  RESULT
#     0  --  no update has been executed
#     1  --  update has been executed 
#     <0 --  failure 
#  EXAMPLE
#
#
#  NOTES
#     calls exit if the sources of the testsuite are updated
#
#  BUGS
#
#  SEE ALSO
#     check/compile_source
#******
proc update_source { a_report } {
   global do_not_update
   
   upvar $a_report report
   if { $do_not_update == 0 } {
      global CHECK_OUTPUT CHECK_SOURCE_HOSTNAME CHECK_USER
      global CHECK_SOURCE_DIR CHECK_OUTPUT
      
      set tries 1

      set output ""
      set update_ok 0
      set prg_exit_state 0
      set conflict_files {}
      
      set task_nr [report_create_task report "cvs_update" $CHECK_SOURCE_HOSTNAME]
      
      while { $tries <= 3 && $update_ok == 0 } {
         
         report_task_add_message report $task_nr "------------------------------------------"
         report_task_add_message report $task_nr "$tries. cvs update try ..."
         report_task_add_message report $task_nr "updating gridengine directory $CHECK_SOURCE_DIR/.. on host $CHECK_SOURCE_HOSTNAME ..."
         
         set open_spawn [ open_remote_spawn_process $CHECK_SOURCE_HOSTNAME $CHECK_USER "cd" "$CHECK_SOURCE_DIR/.. ; cvs -q -z 9 update -dP"]
         set spawn_list [lindex $open_spawn 1]
         
         set frame_work_script_update 0
         set testsuite_update 0
         set cvs_change_log ""
         
         set cvs_output [ open "$CHECK_SOURCE_DIR/cvs_update.log.[timestamp]" "w" ]
         
         set use_output 0
         set timeout 600

         expect {
            -i $spawn_list full_buffer {
               report_task_add_message report $task_nr "full_buffer error on cvs update"
            }
            -i $spawn_list timeout {
               report_task_add_message report $task_nr "got timeout on cvs update"
            }
            -i $spawn_list eof {
               report_task_add_message report $task_nr "got eof on cvs update"
            }
            -i $spawn_list "_exit_status_:(*)" {  
               set use_output 0
               set prg_exit_state [get_string_value_between "_exit_status_:(" ")" $expect_out(0,string)]
               report_task_add_message report $task_nr "cvs update exited with status $prg_exit_state"
               if { $prg_exit_state != 0 } {
                  set update_ok 0
               } else {
                  set update_ok 1
               }
            }
            -i $spawn_list "_start_mark_:(0)" {
               set use_output 1
               report_task_add_message report $task_nr "cd $CHECK_SOURCE_DIR/.. ; cvs -q -z 9 update -dP"
               exp_continue
            }
            -i $spawn_list -re {^C .*?\n} { ;# conflict files
               if { $use_output == 1 } {
                  set elem [string trimright $expect_out(buffer) "\n\r"]
                  report_task_add_message report $task_nr "$elem"
                  
                  set len [string length $elem]
                  set confict_file [string range $elem 2 $len]
                  lappend conflict_files $confict_file
               }
               exp_continue
            }
            -i $spawn_list -re {^.*?\n} {
               if { $use_output } {
                  set elem [string trimright $expect_out(buffer) "\n\r"]
                  report_task_add_message report $task_nr "$elem"
                  puts $cvs_output "$elem"

                  if { ([string range $elem 0 2 ] != "cvs") && ([string range $elem 0 0] != "?") } {
                     report_task_add_message report $task_nr "$elem"
                     append cvs_change_log "$elem\n"
                     if { [ string first "testsuite/check.exp" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
                        set frame_work_script_update 1
                     }
                     if { [ string first "testsuite/tcl_files" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
                        set testsuite_update 1
                     }
                  } 
               }
               exp_continue
            }
         }

         flush $cvs_output
         close $cvs_output
         close_spawn_process $open_spawn
         incr tries 1
         if { [ llength $conflict_files ] > 0 } {
            # we have conflict do not continue
            break
         }
         if { $update_ok == 0 } {
            sleep 60
         }
      }

      if { [llength $conflict_files] > 0 } {
         report_add_message report "CVS Update Error: The following files contains conflicts:\n"
         foreach elem $conflict_files {
            report_add_message report "   $elem"
         }
         report_add_message report "\n Please resolve these conflicts!!!\n"
         report_finish_task report $task_nr -1
         return -1
      }
      
      if { $update_ok != 1 } {
         report_add_message report "CVS Update Error: cvs update failed three times!!!\n"
         report_finish_task report $task_nr -1
         return -1
      }

      # if the testsuite itself has been update, require restart
      if { $frame_work_script_update == 1 } {
         report_add_message report "CVS Update: TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!\n"
         report_finish_task report $task_nr 0
         report_finish report 0
         exit 1 
      }
      if { $testsuite_update == 1 } {
         report_add_message report "CVS Update Warning: testsuite source procedures were updated!!!"
         report_add_message report "                    Resourcing it !!!\n"
      }
      report_finish_task report $task_nr 0
      return 1
   } else {
      return 0
   }
}

#****** check/compile_depend() **************************************************
#  NAME
#    compile_depend() -- ???
#
#  SYNOPSIS
#    compile_depend { } 
#
#  FUNCTION
#     Executes scripts/zero-depend, aimk --only-depend and aimk depend
#     on a preferred compile host
#
#  INPUTS
#    compile_hosts -- list of compile hosts
#    a_html_body   -- html body buffer for reporting
#
#  RESULT
#     0  -  on success
#     -1 -  on failure
#
#  EXAMPLE
#
#  NOTES
#
#  BUGS
#
#  SEE ALSO
#*******************************************************************************
proc compile_depend { compile_hosts a_report } {
   
   global ts_host_config CHECK_USER CHECK_SOURCE_DIR
   global CHECK_OUTPUT
   
   upvar $a_report report
  
   # we prefer building the dependencies on a sol-sparc64 host
   # to avoid automounter issues like having a heading /tmp_mnt in paths
   set depend_host_name [lindex $compile_hosts 0] 
   foreach help_host $compile_hosts {
      set help_arch [host_conf_get_arch $help_host]
      if { [ string compare $help_arch "solaris64"] == 0 || 
           [ string compare $help_arch "sol-sparc64"] == 0 } {
         puts $CHECK_OUTPUT "using host $help_host to create dependencies"
         set depend_host_name $help_host
      }
   }

   set task_nr [report_create_task report "zerodepend" $depend_host_name]
   
   # clean dependency files (zerodepend)
   
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "-> starting scripts/zerodepend on host $depend_host_name ..."
   set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; scripts/zerodepend" prg_exit_state 60 0 "" 1 0 ]
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "return state: $prg_exit_state"
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "output:\n$output"
   report_task_add_message report $task_nr "------------------------------------------"
   
   report_finish_task report $task_nr $prg_exit_state
   if { $prg_exit_state != 0 } {
      report_add_message report "------------------------------------------"
      report_add_message report "Error: scripts/zerodepend (exit code $prg_exit_state)"
      report_add_message report "------------------------------------------"
      return -1
   }
   

   set task_nr [report_create_task report "only_depend" $depend_host_name]
   # build the depencency building program
   set my_compile_options [get_compile_options_string]
   report_task_add_message report $task_nr "-> starting aimk -only-depend on host $depend_host_name ..."

   set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk -only-depend" prg_exit_state 60 0 "" 1 0 ]
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "return state: $prg_exit_state"
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "output:\n$output"
   report_task_add_message report $task_nr "------------------------------------------"
   report_finish_task report $task_nr $prg_exit_state
   if { $prg_exit_state != 0 } {
      report_add_message report "------------------------------------------"
      report_add_message report "Error: aimk -only-depend failed (exit code $prg_exit_state)"
      report_add_message report "------------------------------------------"
      return -1
   }

   # build the dependencies
   set task_nr [report_create_task report "depend" $depend_host_name]
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "-> starting aimk $my_compile_options depend on host $depend_host_name ..."
   set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk $my_compile_options depend" prg_exit_state 60 0 "" 1 0 ]
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "return state: $prg_exit_state"
   report_task_add_message report $task_nr "------------------------------------------"
   report_task_add_message report $task_nr "output:\n$output"
   report_task_add_message report $task_nr "------------------------------------------"

   report_finish_task report $task_nr $prg_exit_state
   if { $prg_exit_state != 0 } {
      report_add_message report "------------------------------------------"
      report_add_message report "Error: aimk depend failed (exit code $prg_exit_state)"
      report_add_message report "------------------------------------------"
      return -1
   }

   return 0
}
#                                                             max. column:     |
#****** check/run_all_at_starttime() ******
# 
#  NAME
#     run_all_at_starttime -- ??? 
#
#  SYNOPSIS
#     run_all_at_starttime { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_all_at_starttime {} {

   global CHECK_ACT_PATH CHECK_REPORT_FILE CHECK_CHECKTREE_ROOT

   set start_time 0
   set should_we_compile 0

   print_menu_header
   if { [ ask_user_yes_or_no " Do you want to enter a special starttime (y/N) ? " ] } {
      puts "\n now it is: [exec date "+%D %H:%M" ]"
      set start_time [ get_user_input "    Please enter start time : " ]
      puts "\n testsuite will start at \"$start_time\""
   } else {
      
      puts "\n testsuite will run continuously"
   }

   if { [ ask_user_yes_or_no "\n\n Should the testsuite update, compile and install before testing (y/N) ? " ] } {
      set should_we_compile 1
      puts "\n testsuite will update, compile and install the latest source code"
   } else {
      puts "\n testsuite will use the current installation"
   }

   if { [ ask_user_yes_or_no "\n\n Are this settings correct (y/N) ? " ] == 0 } {
      puts "\n testsuite will return to the main menue, please"
      return
   }

   set_root_passwd
 

   if { $start_time != 0 } {
      wait_for_start_time $start_time
   }
   delete_tests $CHECK_ACT_PATH
   if { $should_we_compile == 1 } {
#     remove_old_cvs_tree
      set back [ compile_source ]
      if { $back != 0 } {
         puts "error in compile_source - stop"
         exit -1
      }
      set saved_path $CHECK_ACT_PATH
      set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"
      set back [ run_test $CHECK_ACT_PATH 1 ]
      if { $back != 0 } {
         puts "error in test install_core_system - stop"
         exit -1
      }
      set CHECK_ACT_PATH $saved_path
   }
   run_tests $CHECK_ACT_PATH 0
   create_report ${CHECK_REPORT_FILE}.ok 0
   create_report ${CHECK_REPORT_FILE}.failed 1

   wait_for_enter
}

#****** check/do_wait() ********************************************************
#  NAME
#     do_wait() -- wait for x seconds (and print .)
#
#  SYNOPSIS
#     do_wait { time } 
#
#  INPUTS
#     time - time in seconds
#
#*******************************************************************************
proc do_wait { time } {

   set timestart [ timestamp ]
   while { 1 } {
       if { [ expr ( [ timestamp  ] - $timestart ) ] >= $time } {
         puts ""
         return
       }
       puts -nonewline "."
       flush stdout
       sleep 1
   }
}

#                                                             max. column:     |
#****** check/get_user_input() ******
# 
#  NAME
#     get_user_input -- ??? 
#
#  SYNOPSIS
#     get_user_input { what } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     what - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_user_input { what } {
   puts -nonewline $what
   flush stdout 
   set myinput [wait_for_enter 1]
   return $myinput
}


#****** check/restart_debug_daemons() ******************************************
#  NAME
#     restart_debug_daemons() -- used for menu point 20/21
#
#  SYNOPSIS
#     restart_debug_daemons { { shutdown 0 } } 
#
#  FUNCTION
#     This procedure will shutdown and restart the qmaster and scheduler
#
#  INPUTS
#     { shutdown 0 } - 0 -> do shutdown (otherwise only do starup)
#
#*******************************************************************************
proc restart_debug_daemons { { shutdown 0 } } {
   global daemon_debug master_debug schedd_debug
   global CHECK_CORE_MASTER

   if { [ have_root_passwd ] != 0 } {
      set_root_passwd
   }
   if { $shutdown == 0 } {
      get_config config_tmp
      if { [info exists config_tmp(qmaster_spool_dir) ] != 1 } { 
         return 
      }
      shutdown_master_and_scheduler $CHECK_CORE_MASTER $config_tmp(qmaster_spool_dir) 
   }
   startup_qmaster 
   wait_for_load_from_all_queues 300 
}

#                                                             max. column:     |
#****** check/ask_user_yes_or_no() ******
# 
#  NAME
#     ask_user_yes_or_no -- ??? 
#
#  SYNOPSIS
#     ask_user_yes_or_no { question } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     question - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc ask_user_yes_or_no { question } {
  
   puts -nonewline $question
   flush stdout 
   set myinput [wait_for_enter 1]

   if { [ string compare -nocase $myinput "yes" ] == 0 } {
       return 1
   }
   if { [ string compare -nocase $myinput "y" ] == 0 } {
       return 1
   }
   return 0
}

# select action
#                                                             max. column:     |
#****** check/menu() ******
# 
#  NAME
#     menu -- ??? 
#
#  SYNOPSIS
#     menu { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc menu {} {
   global ts_config
  global CHECK_ACT_PATH CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_ENABLED_RUNLEVELS CHECK_PRODUCT_VERSION_NUMBER CHECK_SETUP_NAMES
  global daemon_debug CHECK_DEBUG_LEVEL CHECK_DEFAULTS_FILE CHECK_DO_SETUP
  global CHECK_PACKAGE_DIRECTORY CHECK_SETUP_CHANGES CHECK_PACKAGE_TYPE
  global check_reinit_on_tcl_error ts_checktree CHECK_ENABLED_CATEGORIES

  delete_temp_script_files

  print_menu_header
 
  puts "  (0) select runlevels/categories"
  puts "  (2) run not completed tests (including subdirectories)"
  puts "  (3) show test descriptions"
  puts "  (4) exit (press ^C to exit without shutdown of the cluster)"
  puts "  (5) show completed test list"
  puts "  (6) show not completed test list"
  puts "  (7) reset completed test list (for all subdirectories)"
  puts "  (8) create check report"
  puts "  (9) run all tests at a special starttime"
  if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
     puts " (10) use file \"${CHECK_HOST}.checklog\" for output" 
  } else {
     puts " (10) use \"stdout\" for output"
  }

  set localtest -1
  if {[info exists ts_checktree($CHECK_ACT_PATH)]} {
     set local_dir_nr $ts_checktree($CHECK_ACT_PATH)
     if { $ts_checktree($local_dir_nr,test_available) == 1 } {
        set localtest 0
     }
  }

  if { $localtest >= 0 } {
    puts " (11) show test descriptions of local test"
    puts " (12) run local test"
    puts " (13) run local test continously"
  }
    puts "===============================================================================" 
    puts " (19) install system"
    puts " (20) shutdown and restart master and scheduler"
    puts " (21) only start master and scheduler daemons"
    puts " (22) check messages files of execds and qmaster"
    if { $CHECK_PACKAGE_DIRECTORY == "none" } {
       puts " (23) compile source code and pre install binaries"
    } else {
       puts " (23) install product packages"
    }
    puts " (24) do (23), then (2)"
    puts " (25) set testsuite debug level (current value: $CHECK_DEBUG_LEVEL)"
    puts " (26) enter testsuite setup" 
    puts " (27) set command line options"
    puts " (28) restart cluster"
    puts " (29) check spool directory content"
    puts " (30) re-read checktree and re-source tcl-files"
    puts " (31) search for old sge_processes on configured hosts"
    puts " (32) dump status of all rlogin connections"
    puts " (40) initialize code coverage checking"
    puts " (41) delete code coverage data"
    puts " (42) dump code coverage analysis"
    puts " (50) only compile hooks and pre install"

   puts "\nYou can select a menu number,"
   puts "enter a relative/absolute path or \"..\" to switch the directory."
   puts "You can also enter a test name to switch directly to the test directory."
   puts -nonewline "\n> "

  set input [wait_for_enter 1]; 

#  clear_screen

  switch -- $input {
     "19" {
           set org_categories $CHECK_ENABLED_CATEGORIES
           set CHECK_ENABLED_CATEGORIES "INSTALL"
           set runcompleted 1
           run_tests "root" $runcompleted
           set CHECK_ENABLED_CATEGORIES $org_categories
           wait_for_enter
         }
    "20" { restart_debug_daemons } 
    "21" { restart_debug_daemons 1 }
    "22" { set output [check_messages_files]
           puts $CHECK_OUTPUT $output
           wait_for_enter
         }
    "23" { 
            if { [have_root_passwd] == -1 } {
                  puts $CHECK_OUTPUT "need root access ..."
                  set_root_passwd
            }

            if { $ts_config(package_directory) == "none" ||
                 $ts_config(package_type) == "create_tar" } {
               # we compile the source and do a scripts/distinst
               set back [compile_source]
                
                if { $back != 0 } {
                   puts "--> error compiling and pre installing source code"
                } else {
                   puts "--> source code compiled and pre installed"
                }
                wait_for_enter
                
            } else {
               # we have product packages
                set back [prepare_packages]
                if { $back != 0 } {
                   puts "--> error installing product packages"
                } else {
                   puts "--> product packages pre installed"
                }
                wait_for_enter
            }
            
         }
    "24" {
          if { [have_root_passwd] == -1 } {
                puts $CHECK_OUTPUT "need root access ..."
                set_root_passwd
           }
           set back [compile_source]
           if { $back != 0 } {
              puts "--> error compiling and pre installing source code"
              wait_for_enter
           } else {
              puts "--> source code compiled and pre installed"
              run_tests $CHECK_ACT_PATH 0
              wait_for_enter
           }
         }
    "25" {  incr CHECK_DEBUG_LEVEL 1 
            if  { $CHECK_DEBUG_LEVEL > 2 } {
                set CHECK_DEBUG_LEVEL 0
            } 
         }
    "26" {  
            modify_setup2
            wait_for_enter
         }
    "27" {
         set_command_line_options
    }
    "28" {
         startup_core_system
    }
    "29" {
         check_local_spool_directories 1
         wait_for_enter
    }
    "30" {
         source_tcl_files
         build_checktree
         wait_for_enter
    }
    "31" {
         seek_and_desroy_sge_processes
    }
    "32" {
         dump_spawn_rlogin_sessions
         wait_for_enter
    }
    "40" {
         coverage_initialize
         wait_for_enter
    }
    "41" {
         coverage_initialize 1
         wait_for_enter
    } 
    "42" {
         coverage_analyis
         wait_for_enter
    }
    "50" { 
            if { [have_root_passwd] == -1 } {
                  puts $CHECK_OUTPUT "need root access ..."
                  set_root_passwd
            }
            set back [compile_source 0 1]
             
            if { $back != 0 } {
               puts "--> error compiling and pre installing source code"
            } else {
               puts "--> source code compiled and pre installed"
            }
            wait_for_enter
         }

    "0" { select_runlevel }
    "2" { set saved_check_reinit_on_tcl_error $check_reinit_on_tcl_error 
          set check_reinit_on_tcl_error 1
          run_tests $CHECK_ACT_PATH 0
          set check_reinit_on_tcl_error $saved_check_reinit_on_tcl_error
          wait_for_enter
        }
    "3" { show_tests $CHECK_ACT_PATH 1
        }
    "4" { puts "bye!\n"; 
          shutdown_core_system;
          if { [string compare "stdout" $CHECK_OUTPUT ] != 0 } {
             close $CHECK_OUTPUT
          } 
          exit 0; 
        }
    "5" { set total1 [print_results $CHECK_CORE_RESULT_DIR stdout]
          set total2 [print_results $CHECK_RESULT_DIR stdout]
          puts stdout "Total number of test functions: [expr ($total1 + $total2) ]"
          wait_for_enter
        }
    "6" { print_results $CHECK_CORE_BAD_RESULT_DIR stdout
          print_results $CHECK_BAD_RESULT_DIR stdout
          wait_for_enter
        }
    "7" { delete_tests $CHECK_ACT_PATH
          wait_for_enter
        }
    "8" { 
          if {[ file isfile "${CHECK_REPORT_FILE}.ok" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.ok"
          }
          if {[ file isfile "${CHECK_REPORT_FILE}.failed" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.failed"
          }
          create_report "${CHECK_REPORT_FILE}.ok" 0
          create_report "${CHECK_REPORT_FILE}.failed"  1
          wait_for_enter
        }
    "9" {
          run_all_at_starttime
          wait_for_enter
        }
    "10" {
           if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
              set CHECK_OUTPUT [open "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.checklog" "w"]  
           } else {
              close $CHECK_OUTPUT
              set CHECK_OUTPUT stdout
           }
           

         }
    "11" {
          if {$localtest >= 0} {
            puts "local test description ..."
            show_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
        }
    "12" {
          if {$localtest >= 0} {
            puts "running local test ..."
            run_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
         }
    "13" {
            if {$localtest >= 0} {
               while { 1 == 1 } {
                  puts "running local test ..."
                  run_test $CHECK_ACT_PATH 1
                  create_report ${CHECK_REPORT_FILE}.ok 0
                  create_report ${CHECK_REPORT_FILE}.failed 1
               } 
            }
         }
     default {
        if { $input != "" } {
           change_dir $input
        }
     }
   }
   menu
}

proc update_compile_html_output { content } {
   global CHECK_HTML_DIRECTORY CHECK_OUTPUT
   if { $CHECK_HTML_DIRECTORY != "" } { 
      puts $CHECK_OUTPUT "-> UPDATING HTML FILES IN DIRECTORY: \"$CHECK_HTML_DIRECTORY\""
      puts $CHECK_OUTPUT "-> UPDATING file index.html"
      generate_html_file "$CHECK_HTML_DIRECTORY/index.html" "Nightly Build Compile Results" $content
   }
}

proc get_shared_lib_path { host name path } {

   global CHECK_PRODUCT_ROOT
   upvar $name var_name
   upvar $path var_value

   set host_arch [resolve_arch $host ]
   set var_name [get_shared_lib_path_variable_name $host_arch]
   if { [info exists CHECK_PRODUCT_ROOT ] } {
      set var_value $CHECK_PRODUCT_ROOT/lib/$host_arch
   } else {
      set var_value ""
   }
}


proc get_shared_lib_path_variable_name { arch } {
   set name ""
   switch -exact $arch {
      aix41 -
      aix42 -
      aix43 {
         set name LIBPATH
      }
      hp10 -
      hp11 {
         set name SHLIB_PATH
      }
      default {
         set name LD_LIBRARY_PATH
      }
   }
   return $name
}

proc setup_shared_lib_path {} {
   global env CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global be_quiet

   set name [get_shared_lib_path_variable_name $CHECK_ARCH]
   if { [info exists env($name)] } {
      set env($name) "$env($name):$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   } else {
      set env($name) "$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   }
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT "   set environment variable $name to $env($name)"
   }
}

proc source_tcl_files {} {
   global ts_config

   if [info exists ts_config] {
      set libdir "$ts_config(testsuite_root_dir)/tcl_files"
   } else {
      set libdir "tcl_files"
   }

   # these files have to be version independent
   source $libdir/version.tcl
   source $libdir/config.tcl

   # now we have a ts_config (before reading config file with "" as version)
   # and can use the ts_source command
   # all the following library files may be version dependent
   ts_source $libdir/config_user
   ts_source $libdir/config_host

   ts_source $libdir/compile
   ts_source $libdir/file_procedures
   ts_source $libdir/gettext_procedures
   ts_source $libdir/remote_procedures
   ts_source $libdir/control_procedures
   ts_source $libdir/coverage
   ts_source $libdir/parser
   ts_source $libdir/parser_xml
   ts_source $libdir/sge_config
   ts_source $libdir/sge_procedures
   ts_source $libdir/sge_job
   ts_source $libdir/sge_queue
   ts_source $libdir/sge_project
   ts_source $libdir/sge_sched_conf
   ts_source $libdir/sge_checkpoint
   ts_source $libdir/sge_pe	
   ts_source $libdir/sge_host
   ts_source $libdir/sge_calendar
   ts_source $libdir/sge_qconf_config
   ts_source $libdir/sge_users	
   ts_source $libdir/sge_userset	
   ts_source $libdir/sge_sharetree	
   ts_source $libdir/sge_event_client	
   ts_source $libdir/sge_limit_rules
   
   ts_source $libdir/checktree_helper
   ts_source $libdir/report_procedures
   
   # source a user private tcl file, e.g. to contain a 
   # inhouse_cluster_post_install function
   ts_source $libdir/private
}

#                                                             max. column:     |
#****** check/build_java_env_list() ******
# 
#  NAME
#     build_java_env_list -- Build a list of CHECK_* variables into jvm switches
#
#  SYNOPSIS
#     build_java_env_list {} 
#
#  FUNCTION
#     This function builds a list of JVM switches which will set system
#     properties corresponding to various bits of information that only the test
#     suite knows.  These system properties are read by the
#     com.sun.grid.Settings class in the classes/test directory.
#
#  RESULT
#     A string containing -D switches for relevant system properties
#
#  SEE ALSO
#     classes/test/com/sun/grid/Settings.java
#*******************************
proc build_java_env_list {} {
   global CHECK_USER CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST CHECK_TESTSUITE_ROOT CHECK_CURRENT_WORKING_DIR
   global CHECK_SCRIPT_FILE_DIR CHECK_CHECKTREE_ROOT
   global CHECK_PRODUCT_VERSION_NUMBER
   global env ts_config

   set env_list "-Dgets.user=\"$CHECK_USER\""
   set env_list "$env_list -Dgets.test_path=\"$CHECK_ACTUAL_TEST_PATH\""
   set env_list "$env_list -Dgets.sge_root=\"$CHECK_PRODUCT_ROOT\""
   set env_list "$env_list -Dgets.arch=\"$CHECK_ARCH\""
   set env_list "$env_list -Dgets.hostname=\"$CHECK_HOST\""
   set env_list "$env_list -Dgets.gets_root=\"$CHECK_TESTSUITE_ROOT\""
   set env_list "$env_list -Dgets.cwd=\"$CHECK_CURRENT_WORKING_DIR\""
   set env_list "$env_list -Dgets.scripts_dir=\"$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR\""
   set env_list "$env_list -Dgets.checktree_root=\"$CHECK_CHECKTREE_ROOT\""
   set env_list "$env_list -Dgets.pid=\"[getpid]\""
   set env_list "$env_list -Dgets.home_dir=\"$env(HOME)\""
   set env_list "$env_list -Dgets.version=\"$CHECK_PRODUCT_VERSION_NUMBER\""

   return $env_list
}

# Main programm:

set do_kill           0
set do_install        0
set do_compile        0
set do_not_update     0
set do_all            0
set do_one_test       0
set do_category       0
set do_nomain         0
set do_prog_start     0
set do_only_reset_config 0
set do_only_diff_macros 0
set be_quiet          0
set fast_setup        0
set CHECK_CUR_PROC_NAME "main"
set check_name "main"
set CHECK_ACTUAL_TEST_PATH "not in testmode"
set mail_subject "testsuite error - main"
set mail_body    "date: [exec date]\n:\n"

# for some reason, we need this with SuSE 10 expect 5.43.0
fconfigure stdin -blocking TRUE

for { set i 0 } { $i < $argc } { incr i } {
   if {([string compare [lindex $argv $i] "--setup"] == 0) || ([string compare [lindex $argv $i] "setup"] == 0) } {
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return == 0 } { 
        set CHECK_DO_SETUP 1 
      } else {
        puts "could not copy defaults file"
      }
      continue
   }
   
   if {([string compare [lindex $argv $i] "--quiet"] == 0) || ([string compare [lindex $argv $i] "quiet"] == 0) } {
      set be_quiet 1
      continue
   }

   if {([string compare [lindex $argv $i] "--fast_setup"] == 0) || ([string compare [lindex $argv $i] "fast_setup"] == 0) } {
      set fast_setup 1
      continue
   }

   if {([string compare [lindex $argv $i] "--close_rlogin"] == 0) || ([string compare [lindex $argv $i] "close_rlogin"] == 0) } {
      set do_close_rlogin 1
      continue
   }
   

   if {([string compare [lindex $argv $i] "--help"] == 0) || ([string compare [lindex $argv $i] "help"] == 0) } {
      puts "usage: expect check.exp \[options\]"
      puts "\noptions are:"
      puts "help                  show this"
      puts ""
      puts "setup_help            show setup informations"
      puts ""
      puts "check_macros DUMPFILE_A DUMPFILE_B IGNORE_BACKSLASH"
      puts "                      check if all message macros from DUMPFILE_A are in DUMPFILE_B and compare"
      puts "                      the messages. If IGNORE_BACKSLASH is set to 0 backslashes at the end of"
      puts "                      a message macro not ignored. If set to 1 the backslashes are removed before"
      puts "                      comparing the messages."
      puts ""
      puts "install               just install core system and exit"
      puts ""
      puts "kill                  shutdown cluster"
      puts ""
      puts "setup                 run setup"
      puts ""
      puts "file FILE             use FILE as defaults file"
      puts ""
      puts "re_init               use already installed system (will only shutdown/reconfigure the cluster!)"
      puts "                      when test install_core_system is called or install option is set"
      puts ""
      puts "re_init_on_tcl_error  reinitialize cluster when tcl error occurs"
      puts ""
      puts "compile               checkout source code and recompile"
      puts ""
      puts "no_update             do not update source when compile option is used"
      puts ""
      puts "all RUNLEVEL          run every test automatically up to runlevel RUNLEVEL"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "check PATH RUNLEVEL   run test in checktree sub-path automatically up to runlevel"
      puts "                      RUNLEVEL. PATH is as check sub-path, relative to checktree."
      puts "                      If PATH begins with \"/\" then the path is used absolute"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "execute_func ARGS     just run this procedure with given arguments"
      puts "                      (all arguments after this keyword are used as function call)"
      puts "                      e.g.: .. no_update execute_func compare_dump_data_file arg1 arg2"
      puts ""
      puts "category CAT_LIST     set users category list (COMPATIBILITY SYSTEM \[...\])"
      puts "                      (CAT_LIST must be 1 single parameter, must be quoted"
      puts "                       when using more than one category)"
      puts "" 
      puts "no_main               don't run main part (usefull for sourceing this file)"
      puts ""
      puts "no_main2              don't run main part and don't do setup"
      puts "                      (usefull for sourceing this file)"
      puts ""
      puts "reset_conf            reset test cluster"
      puts ""
      puts "debug LEVEL           run testsuite in debuglevel 0,1 or 2"
      puts "                      0=no debug, 1=more output, 2=1+user response"
      puts ""
      puts "quiet                 no output on setup"
      puts ""
      puts "fast_setup            suppress configuration checks at startup (setup phase)"
      puts ""
      puts "no_local_spool        ignore local spool directories from host configuration file"
      puts ""
      puts "compile_clean         force aimk clean when no_update option is set at compile time"
      puts ""
      puts "mfile FILE            write all mails into file FILE (when mail is enabled)"
      puts ""
      puts "html_dir              write testsuite html files into that directory"
      puts ""
      puts "close_rlogin          don't let rlogin connections open for next command (per default the testsuite"
      puts "                      not close a rlogin connection. The testsuite will reuse the open connection"
      puts "                      for a later remote command. Use close_rlogin if the number of open file "
      puts "                      descriptors is low on your system)"
      puts ""
      puts "master_debug          procedure startup_qmaster will startup qmaster"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "schedd_debug          procedure startup_qmaster will startup schedduler"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "display DISPLAY       set display for daemon debug windows"
      puts ""
      puts "coverage <type(s)>    with code coverage analysis, type =\"tcov|insure|emma\""
      puts "coverage_dir <dir>    directory for test coverage profiles"

      exit 1
   }

   if {([string compare [lindex $argv $i] "--setup_help"] == 0) || ([string compare [lindex $argv $i] "setup_help"] == 0) } {
      show_setup_information
      exit 1
   }

   if {([string compare [lindex $argv $i] "--check_macros"] == 0) || ([string compare [lindex $argv $i] "check_macros"] == 0) } {
      incr i
      set global_macro_file1 [lindex $argv $i]
      incr i
      set global_macro_file2 [lindex $argv $i]
      incr i
      set global_macro_ignore_flag [lindex $argv $i]
      if { $global_macro_ignore_flag == ""  } {
         set global_macro_ignore_flag 0
      }
      puts $CHECK_OUTPUT "checking difference for \n\"$global_macro_file1\"\n and \n\"$global_macro_file2\""
      if { $global_macro_ignore_flag != 0 } {
         puts $CHECK_OUTPUT "ignoring backslashes at the end of macros"
      } else {
         puts $CHECK_OUTPUT "don't ignore backslashes at the end of macros"
      }

      set do_only_diff_macros 1
   }

   
   if { ( [string compare [lindex $argv $i] "--no_local_spool"] == 0 ) || ([string compare [lindex $argv $i] "no_local_spool"] == 0) } {
      set check_do_not_use_spool_config_entries 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile_clean"] == 0 ) || ([string compare [lindex $argv $i] "compile_clean"] == 0) } {
      set check_do_clean_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init"] == 0 ) || ([string compare [lindex $argv $i] "re_init"] == 0) } {
      set check_use_installed_system 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init_on_tcl_error"] == 0 ) || ([string compare [lindex $argv $i] "re_init_on_tcl_error"] == 0) } {
      set check_reinit_on_tcl_error 1
      continue
   }


   if { ( [string compare [lindex $argv $i] "--master_debug"] == 0 ) || ([string compare [lindex $argv $i] "master_debug"] == 0) } {
      set master_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--schedd_debug"] == 0 ) || ([string compare [lindex $argv $i] "schedd_debug"] == 0) } {
      set schedd_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--display"] == 0 ) || ([string compare [lindex $argv $i] "display"] == 0) } {
      incr i
      set CHECK_DISPLAY_OUTPUT [lindex $argv $i]
      continue
   }

   


   if { ( [string compare [lindex $argv $i] "--kill"] == 0 ) || ([string compare [lindex $argv $i] "kill"] == 0) } {
      set do_kill 1
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--mfile"] == 0 ) || ([string compare [lindex $argv $i] "mfile"] == 0) } {
      incr i
      set CHECK_MAIL_OUTPUT_FILE [lindex $argv $i]
      if { [llength $CHECK_MAIL_OUTPUT_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"mfile\" option without filename!"
         exit -1 
      }
      if { ([ string first "/" $CHECK_MAIL_OUTPUT_FILE ] < 0) && ([ string first "\/" $CHECK_MAIL_OUTPUT_FILE ] < 0)} {
          set CHECK_MAIL_OUTPUT_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_MAIL_OUTPUT_FILE"
      }
      set write_mail_to_file 1
      puts $CHECK_OUTPUT " ---> writing all mails into \"$CHECK_MAIL_OUTPUT_FILE\" ! <---"
      if {[file exists $CHECK_MAIL_OUTPUT_FILE]} {
         file rename -force $CHECK_MAIL_OUTPUT_FILE "$CHECK_MAIL_OUTPUT_FILE.bak"
      }
      set mf [open $CHECK_MAIL_OUTPUT_FILE "w"]
      puts $mf "This file contains testsuite mail contents"
      close $mf
      continue
   }
 
   if { ( [string compare [lindex $argv $i] "--file"] == 0 ) || ([string compare [lindex $argv $i] "file"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_DEFAULTS_FILE [ string trim $help_var ]

      if { [llength $CHECK_DEFAULTS_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"file\" option without filename!"
         exit -1 
      }

      if { ([ string first "/" $CHECK_DEFAULTS_FILE ] != 0) } {
          set CHECK_DEFAULTS_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_DEFAULTS_FILE"
      }
      
      puts $CHECK_OUTPUT "using configuration file \"$CHECK_DEFAULTS_FILE\""
      continue
   }

   if { ( [string compare [lindex $argv $i] "--html_dir"] == 0 ) || ([string compare [lindex $argv $i] "html_dir"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_HTML_DIRECTORY [ string trim $help_var ]

      if { [llength $CHECK_HTML_DIRECTORY] != 1 } {
         puts $CHECK_OUTPUT "can't use \"html_dir\" option without filename!"
         exit -1 
      }
      puts $CHECK_OUTPUT " ---> using \"$CHECK_HTML_DIRECTORY\" for HTML output <---"
      continue
   }

  
   

   if { ( [string compare [lindex $argv $i] "--install"] == 0 ) || ([string compare [lindex $argv $i] "install"] == 0 ) } {
      set do_install 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile"] == 0 ) || ([string compare [lindex $argv $i] "compile"] == 0 ) } {
      set do_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_update"] == 0 ) || ([string compare [lindex $argv $i] "no_update"] == 0 ) } {
      set do_not_update 1
      continue
   }

   
   
   if { ( [string compare [lindex $argv $i] "--reset_conf"] == 0 ) || ([string compare [lindex $argv $i] "reset_conf"] == 0 ) } {
      set do_only_reset_config 1
      set check_use_installed_system 1
      continue
   }
  
   if { ( [string compare [lindex $argv $i] "--coverage"] == 0 ) || ([string compare [lindex $argv $i] "coverage"] == 0 ) } {
      incr i
      set help_var [lindex $argv $i]
      set help_var [string trim $help_var]
      foreach cov $help_var {
         if {$cov == "tcov" || $cov == "insure" || $cov == "emma"} {
            lappend CHECK_COVERAGE $cov
            puts $CHECK_OUTPUT " ---> doing code coverage analysis with \"$cov\" <---"
         } else {
            puts $CHECK_OUTPUT "invalid coverage method $cov"
         }
      }
      continue
   }

   if { ( [string compare [lindex $argv $i] "--coverage_dir"] == 0 ) || ([string compare [lindex $argv $i] "coverage_dir"] == 0 ) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_COVERAGE_DIR [ string trim $help_var ]

      if { [llength $CHECK_COVERAGE_DIR] != 1 } {
         puts $CHECK_OUTPUT "can't use \"profile_dir\" option without filename!"
         exit -1 
      }

      puts $CHECK_OUTPUT " ---> using \"$CHECK_COVERAGE_DIR\" for coverage profiles <---"
      continue
   }

   if { ( [string compare [lindex $argv $i] "--check"] == 0 ) || ([string compare [lindex $argv $i] "check"] == 0 ) } {
      set do_one_test 1
      set ru_lev [ expr ( 1 + $i ) ]
      set do_one_test_name [ lindex $argv $ru_lev ]
      set ru_lev [ expr ( 2 + $i ) ] 
      set do_one_test_level [lindex $argv $ru_lev]
      puts $CHECK_OUTPUT "path: $do_one_test_name"
      puts $CHECK_OUTPUT "level: $do_one_test_level"
      if { [ llength $do_one_test_level ] != 1 || [ llength $do_one_test_name ] != 1} {
         puts $CHECK_OUTPUT "used check parameter without runlevel or checkname"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used check parameter without runlevel or checkname" 
         exit -1
      }
      incr i
      continue
   } 
   if { ( [string compare [lindex $argv $i] "--all"] == 0 ) || ([string compare [lindex $argv $i] "all"] == 0 ) } {
      set do_all 1
      set ru_lev [ expr (1 + $i) ] 
      set do_all_runlevel [lindex $argv $ru_lev]
      if { [ llength $do_all_runlevel ] != 1 } {
         puts $CHECK_OUTPUT "used all parameter without runlevel"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used all parameter without runlevel" 
         exit -1
      }
      incr i
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--category"] == 0 ) || ([string compare [lindex $argv $i] "category"] == 0 ) } {
      set do_category 1
      set ru_lev [ expr (1 + $i) ] 
      set do_category_list [lindex $argv $ru_lev]
      if { [ llength $do_category_list ] == 0 } {
         puts $CHECK_OUTPUT "used category parameter without category list"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used category parameter without category list" 
         exit -1
      }
      incr i
      continue
   }


   if { ( [string compare [lindex $argv $i] "--debug"] == 0 ) || ([string compare [lindex $argv $i] "debug"] == 0 ) } {
      set deb_lev [ expr (1 + $i) ] 
      set CHECK_DEBUG_LEVEL [lindex $argv $deb_lev]

      debug_puts "debuglevel is $CHECK_DEBUG_LEVEL"
      incr i
      continue
   }
   if { ( [string compare [lindex $argv $i] "--execute_func"] == 0 ) || ([string compare [lindex $argv $i] "execute_func"] == 0 ) } {
      set exec_args ""
      for { incr i 1 } { $i < $argc } { incr i } {
         lappend exec_args [lindex $argv $i]
      }
      set do_prog_start 1
      break
   }

   if { ( [string compare [lindex $argv $i] "--no_main"] == 0 ) || ([string compare [lindex $argv $i] "no_main"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_main2"] == 0 ) || ([string compare [lindex $argv $i] "no_main2"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      puts "no_main2 active"
      return
   }
}

if {$CHECK_COVERAGE != {} && $CHECK_COVERAGE_DIR == ""} {
   puts $CHECK_OUTPUT "please specify a coverage profile directory with the option coverage_dir"
   exit -1
}

# load defaults file
#__setup   ;# old setup

source_tcl_files

if { $do_only_diff_macros == 1 } {
   exit [diff_macro_files $global_macro_file1 $global_macro_file2 $global_macro_ignore_flag]
}

setup2
source_tcl_files

# fill sge_config array with minimal information
bootstrap_sge_config

if { $do_category == 1 } {
   set CHECK_ENABLED_CATEGORIES $do_category_list
}
set CHECK_ACT_PATH "root"


set mail_body "$mail_body product version is [get_version_info]\n"
set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"


if { $no_action == 1 } {
  puts $CHECK_OUTPUT "CHECK_GROUP=$CHECK_GROUP"
  puts "No action flag is set -> exit 1"
  exit 1
}

if { $do_prog_start == 1 } {
   puts $CHECK_OUTPUT "starting $exec_args ..."
   set exit_value [eval $exec_args]
   puts $exit_value
   exit 0
}

if { $check_reinit_on_tcl_error == 1 } {
   set_root_passwd   
}

if { $do_compile } {
   if { [have_root_passwd] == -1 } {
         puts $CHECK_OUTPUT "need root access ..."
         set_root_passwd
   }

   if { [ compile_source ] != 0 } {
      exit -1
   } else {
      exit 0
   }
}

if { $do_one_test } {
   # ts_checktree ok
   if { [string first "/" $do_one_test_name] == 0 || [string first "\\" $do_one_test_name] == 0 } {
      set CHECK_ACT_PATH "$do_one_test_name"
   } else {
      set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/$do_one_test_name"
   }
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   set selected_levels ""
   set CHECK_ENABLED_RUNLEVELS ""
   for {set i 0} {$i<= $do_one_test_level} {incr i 1} {
      lappend CHECK_ENABLED_RUNLEVELS [ expr ( $i * 100 )  ]
   }
 
   delete_tests $CHECK_ACT_PATH
   # print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0
}

if { $do_all } {
   # ts_checktree ok
   set CHECK_ACT_PATH "root"
   delete_tests $CHECK_ACT_PATH
   set CHECK_ACT_PATH "root"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   set selected_levels ""
   set CHECK_ENABLED_RUNLEVELS ""
   for {set i 0} {$i<= $do_all_runlevel} {incr i 1} {
      lappend CHECK_ENABLED_RUNLEVELS [ expr ( $i * 100 )  ]
   }

   print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0
} 

if { $do_install } {
   # ts_checktree ok
   puts "installing core system on host $CHECK_HOST ..."
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
   run_test $CHECK_ACT_PATH 1
   exit 0 
}

if { $do_kill } {
   shutdown_core_system
   exit 0   
}


if { $do_only_reset_config == 1 } {
  set result 1
  # ts_checktree ok
  set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"
  run_test $CHECK_ACT_PATH 1 "setup_queues" 0
  run_test $CHECK_ACT_PATH 1 "setup_testcheckpointobject" 0
  run_test $CHECK_ACT_PATH 1 "setup_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_execd_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestproject" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestpe" 0
  run_test $CHECK_ACT_PATH 1 "setup_deadlineuser" 0
  run_test $CHECK_ACT_PATH 1 "setup_schedconf" 0
  run_test $CHECK_ACT_PATH 1 "setup_default_calendars" 0
  run_test $CHECK_ACT_PATH 1 "setup_inhouse_cluster" 0
 
  puts "configuration reset done" 
  exit $result
}


 
if {$do_nomain == 0} {
  if { $daemon_debug != 0 } {
     if { [check_display] != 0 } {
        exit 1
     }
  }
#  puts "please press <RETURN>"
#  wait_for_enter 1
  menu 
}
