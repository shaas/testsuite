<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="christian reissmann">
   <meta name="GENERATOR" content="Mozilla/4.76C-CCK-MCD Netscape [en] (X11; U; SunOS 5.8 sun4u) [Netscape]">
</head>
<body>

<h1>
<a NAME="Menu"></a></h1>

<center>
<h1>
<sup><font color="#330000"><font size=+4>The Grid Engine Testsuite</font></font></sup></h1></center>

<hr WIDTH="100%">
<br><font size=+2><a href="#read this document">Who should read this document</a></font>
<p><font size=+2><a href="#Objectives of the testsuite">Objectives of the
Testsuite</a></font>
<p><font size=+2><a href="#Security Implications">Security Implications</a></font>
<p><font size=+2><a href="#Usage outline">Usage Outline</a></font>
<p><font size=+2><a href="#Configuration">Configuration</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#binary-path.conf">binary-path.conf</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#gid-range.conf">gid-range.conf</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#loadsensor.conf">loadsensor.conf</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#local-spool.conf">local-spool.conf</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#Setup Configuration">Setup
Configuration</a></font>
<p><font size=+2><a href="#Internal test suite illustration">Internal testsuite
illustration</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#Internal - structure">Structure</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#Path/File variables">Path/File
variables</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#test system specific variables">Test
system specific variables</a></font>
<p><font size=+2><a href="#Implementation Approach">Implementation Approach</a></font>
<p><font size=+2><a href="#About TCL">About TCL</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - syntax">Syntax</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Procedures">Procedures</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - manipulate lists">Lists</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Srings">Srings</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Arrays">Arrays</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Info command">Info
command</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Catch command">Catch
command</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - upvar command">Upvar
command</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Procedure lists">Procedure
lists</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - file IO">File
I/O</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - other file commands">more
File commands</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#TCL - Environment variables">Environment
variables</a>&nbsp;</font> <a href="#Menu">Menu</a>
<p><font size=+2><a href="#About Expect">About Expect</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#Expect - Expect">expect</a></font>
<br><font size=+2>&nbsp;&nbsp;&nbsp;&nbsp; </font><font size=+1><a href="#Expect - send">send</a></font>
<p>
<hr WIDTH="100%">
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>
<hr WIDTH="100%"><a NAME="read this document"></a>
<h1>
<sup><font color="#000000">Who should read this document</font></sup></h1>
<sup><font color="#000000"><font size=+1>This document should be read by
Grid Engine developers and by engineers being attached to quality assurance
for the Grid Engine software.&nbsp; You should read it if you want to test
the functionality of a Grid Engine version, especially after enhancements
have been made. If you are going to make enhancements, you also should
look for ways to include tests for the capabilities you have added or modified.
Finally, if you are fixing bugs, we ask you to consider adding a test which
would have found each bug you are fixing, thereby ensuring that bugs do
not reoccur.</font></font></sup>
<p><sup><font color="#000000"><font size=+1>The testsuite is written in
TCL and Expect, so this document also contains a brief introduction of
the&nbsp; scripting language and the expect extensions allowing you to
enhance the testsuite even if you are not familiar with TCL or Expect.</font></font></sup>
<br>&nbsp;
<br>&nbsp;
<p>
<hr WIDTH="100%"><a NAME="Objectives of the testsuite"></a>
<h1>
Objectives of the testsuite</h1>

<p><br><sup><font color="#000000"><font size=+1>Testing a complex client
server software with many options and features like Grid Engine can be
a very time consuming and error prone task. It certainly can be considered
impossible to guarantee that a system like Grid Engine can be tested to
be absolutely bug free via any kind of tests, be they automatic or manual.
However, the testsuite presented here is a big step towards providing a
considerable level of confidence in the quality of the software in such
a short time and with so much convenience that tests can be run overnight
- every night, if desired.</font></font></sup>
<p><font size=+1>On the more practical level, the testsuite aims at fulfilling
the following objectives:</font>
<p><font size=+1>1) Previous release features should also run and work
correctly in new software releases.</font>
<br><font size=+1>2) Well known bugs should not re-emerge in newer software
releases.</font>
<br><font size=+1>3) Automated tests help to save time &amp; money.</font>
<br><font size=+1>4) Daily builds on different hardware and operating systems
help to detect platform problems earlier.</font>
<br>&nbsp;
<p>
<hr WIDTH="100%">
<h1>
<a NAME="Security Implications"></a>Security Implications</h1>
<font color="#330000"><font size=+1>The testsuite has three run modes:</font></font>
<br>&nbsp;
<h2>
<font color="#330000"><font size=+1>User mode</font></font></h2>

<blockquote><font color="#330000"><font size=+1>The testsuite will install
the Grid Engine / Grid Engine Enterprise Edition using a nonpriviledged
user account. This means no root access is used. The testsuite will run
with the permissions of the user who starts the testsuite. This mode can
be reached, when the user who starts the testsuite doesn't enter the root
password and just presses return, when he is asked for it at startup. Not
all tests will run in this mode.</font></font></blockquote>

<h2>
<font color="#330000"><font size=+1>Root User mode</font></font></h2>

<blockquote><font color="#330000"><font size=+1>The testsuite will install
the Grid Engine / Grid Engine Enterprise Edition as root user. The user
who start the testsuite have to enter the root password (which should be
the same on all cluster hosts). The password is stored into a global variable
and automatically sent to any login-request when root access is needed.
In this mode all tests are available. The testsuite is written in a script
language, so e.g. if any unauthorized persion is changing the script and
dumping the root password to a file, he has full access to your system.
Use this mode only for a isolated cluster behind a firewall.</font></font></blockquote>

<h2>
<font color="#330000"><font size=+1>SSH mode (secure shell mode)</font></font></h2>

<blockquote><font color="#330000"><font size=+1>The testsuite will execute
ssh -l root &lt;hostname> to have root access on a certain host. The ssh-keys
must allow the testsuite user to become root without typing the root password.
This means the testsuite user can become root when the system admin adds
the testsuite user public key to his "authorized_keys" file - be careful
when you configure the ssh accounts! This is a security problem! Please
consult the SSH manual for more secure shell setup information. In this
mode all tests are available and no interactive question must be answered.</font></font></blockquote>
<font color="#330000"><font size=+1>For best security and full test access
the SSH mode is suggested.</font></font>
<br>&nbsp;
<br>&nbsp;
<h1>

<hr WIDTH="100%"><a NAME="Usage outline"></a>Usage outline</h1>
<font size=+1>There is a testsuite framework script which allows you to
setup, configure and operate your test environment interactively. You have
to have Tcl/Tk 8.3.2 (or higher) and Expect 5.32.2 (or higher) installed
properly at your site before you can start the framework script.</font>
<p><font size=+1>The framework script"check.exp" can be found in the testsuite
root directory, which is located in gridengine/testsuite after checking
out the Grid Engine source code. It also contains all other testsuite source
code. You have to make sure that this directory can be reached by any host
in the test cluster you intend to use. Such a directory normally will have
to reside on a filesystem shared via NFS.</font>
<p><font size=+1>To invoke the framework script help output, change to
the testsuite root directory and type the following command:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">[24] expect check.exp help</font></tt>
<br><tt><font color="#FFFFFF">[25] usage: expect check.exp [options]</font></tt>
<p><tt><font color="#FFFFFF">options are:</font></tt>
<br><tt><font color="#FFFFFF">help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
show this</font></tt>
<br><tt><font color="#FFFFFF">install&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
just install core system and exit</font></tt>
<br><tt><font color="#FFFFFF">setup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
remove defaults file and run setup</font></tt>
<br><tt><font color="#FFFFFF">file FILE&nbsp;&nbsp;&nbsp;&nbsp; use FILE
as defaults file</font></tt>
<br><tt><font color="#FFFFFF">re_init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
use allready installed system (will only shutdown/reconfigure the cluster!)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
when test install_core_system is called or install option is set</font></tt>
<br><tt><font color="#FFFFFF">compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
checkout source code and recompile</font></tt>
<br><tt><font color="#FFFFFF">all RUNLEVEL&nbsp; run every test automatically
up to runlevel RUNLEVEL</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(RUNLEVEL is a value from 0=short tests, up to 4=week tests)</font></tt>
<br><tt><font color="#FFFFFF">no_main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
don't run main part (usefull for sourceing this file)</font></tt>
<br><tt><font color="#FFFFFF">test_perm&nbsp;&nbsp;&nbsp;&nbsp; test remote
shell and user permissions on each cluster host</font></tt>
<br><tt><font color="#FFFFFF">debug LEVEL&nbsp;&nbsp; run testsuite in
debuglevel 0,1 or 2</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0=no debug, 1=more output, 2=1+user response</font></tt>
<br><tt><font color="#FFFFFF">quiet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no output on setup</font></tt>
<br><font color="#FFFFFF">&nbsp;</font></td>
</tr>
</table></center>

<p><font size=+1>Before starting the framework test script, a setup of
the configuration files ( <a href="#binary-path.conf">binary-path.conf</a>
,&nbsp; <a href="#gid-range.conf">gid-range.conf</a> ,&nbsp; <a href="#loadsensor.conf">loadsensor.conf</a>&nbsp;
and&nbsp; <a href="#local-spool.conf">local-spool.conf</a>&nbsp; ) is neccessary.
The framework test script needs also a cluster configuration settings file,
called defaults file. When the framework test script ist started the first
time and no defaults file was found (or defined with the "file" option
parameter), the testsuite will run the "setup" option parameter. The user
has to setup the <a href="#Cluster configuration settings parameter">cluster
configuration settings</a>, after that the answers are stored in a file
called "defaults.sav" (defaults file).</font>
<p><font size=+1>The information stored in the defaults file is specific
to a particular test environment and may change whenever you decide to
test another version of Grid Engine or when you change the test cluster,
for example. More than one defaults file containing the above information
can be maintained. The testsuite framework script option "file" can be
used to select the defaults configuration.</font>
<p><font size=+1>In order to let the testsuite run via an cronjob table
entry (this means update the code, build the binaries, pre-install the
binaries, install the cluster software, run some/all tests) it is necessary
to install the ssh (secure shell) functionality on each execution/master
host. The ssh option serves as a bypass for interactive login sequences
asking for the root password. This is a security issue! Please refer to
the section "<a href="#Security Implications">Security Implications</a>"
below.</font>
<p><font size=+1>After setting up the configuration, the setup procedure
tries to resolve the given hostnames by using programs being part of the
Grid Engine binary set. On the first startup, this resolving will fail
because the necessary utility binaries will not have been compiled by then.
If this is the case you should confirm the correctness of the setup with
"y" nevertheless. After that, the testsuite should be re-started again
using the "compile" option. After completion of the compile step, the setup
procedure will be invoked again utilizing the previously defined parameters,
resolving the missing hostnames and storing the completed configuration.</font>
<p><font size=+1>Now the user can start tests.</font>
<p><b><font size=+1>A detailed step by step course for a testsuite setup
can be found at&nbsp; <a href="#Setup Configuration">Setup Configuration</a>
.</font></b>
<br>&nbsp;
<p>
<hr WIDTH="100%"><a NAME="Configuration"></a>
<h1>
Configuration</h1>
<font size=+1>Before starting any test runs it is necessary to setup the
testsuite configuration. The testsuite root directory contains a subdirectory
called "demo_config_dir". These files contain a default configuration.
Edit the configuration files as described below.</font>
<br>&nbsp;
<p><a NAME="binary-path.conf"></a>
<pre>binary-path.conf</pre>
<font size=+1>The testsuite is using full binary path names to start programms.
Here the user can set the correct binary pathes for every cluster host.
The testsuite needs two binaries at this time: expect and vim. The expect
version should be 5.31.5 or greater. The vim binary path can also point
to a vi binary.</font>
<p><font size=+1>The first column of each line is the hostname on which
the binary exists. The entry "all" can be used to setup a binary for every
host in the cluster.</font>
<p><font size=+1>The second column is the binary name used from the testsuite
to resolve the correct path.</font>
<p><font size=+1>The third column is the binary the testsuite should use
instead of the name in the second column. The full path is expected. The
testsuite is using its own architecture variable. You can use "$ARCH" to
insert the architecture name on the host (given at the first column) in
the path. (The $ARCH values of your hosts are shown after compiling your
cluster software)</font>
<p><font size=+1>examples:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">all expect /vol2/TCL831/$ARCH/bin/expect</font></tt>
<br><tt><font color="#FFFFFF">all vim /vol2/tools/common/$ARCH/bin/vim</font></tt>
<br><tt><font color="#FFFFFF">expo1 expect /vol2/TCL831/solaris64/bin/expect</font></tt>
<br><tt><font color="#FFFFFF">expo1 vim /usr/bin/vi</font></tt></td>
</tr>
</table></center>

<hr WIDTH="100%">
<br><a NAME="gid-range.conf"></a>
<pre>gid-range.conf</pre>
<font size=+1>Each Grid Engine Cluster must have it's own gid range for
it's jobs. The gid&nbsp; range is used to attach a certain gid to the processes
of a job to control this job. Please look at the cluster software documentation
for more explanation about gid ranges.</font>
<br><font size=+1>The testsuite will append automatically any new system
that is started by the testsuite to this file and generate an default gid-range.
So no manual edit of this file is necessary.</font>
<br><font size=+1>A cluster is identified by the login of the user starting
the testsuite and the COMMD_PORT number defined for the cluster.</font><font size=+1></font>
<p>
<hr WIDTH="100%">
<br><a NAME="loadsensor.conf"></a>
<pre>loadsensor.conf</pre>

<p><br><font size=+1>This configuration file is used to set the path to
eventually used loadsensor files. The execution daemon on some architectures
need an external loadsensor binary to get the actual load values of its
host. The testsuite will install the loadsensor automatically when the
loadsensor.conf file has an entry for this architecture.</font>
<p><font size=+1>The first column of each line is the architecture string
for which a loadsensor should be installed.</font>
<p><font size=+1>The second column is the full path to the loadsensor.</font>
<p><font size=+1>examples:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">aix42 /apath/aix42/qloadsensor.aix42</font></tt>
<br><tt><font color="#FFFFFF">aix43 /apath/aix43/qloadsensor.aix43</font></tt></td>
</tr>
</table></center>

<p><font size=+1>For more information about loadsensors, please look into
your cluster software documentation.</font>
<br>
<hr WIDTH="100%">
<br><a NAME="local-spool.conf"></a>
<pre>local-spool.conf</pre>
<font size=+1>The "local-spool.conf" file must be generated manually. This
file defines the local spool directory of each host entry (if no file is
found by the testsuite, no local spool directories will be used). The first
column in the file is a host name (where an execution or master daemon
should be installed) and the second column is the path to a local directory
on this host. In this directory the testsuite will generate a subdirectory
for the COMMD_PORT number of the new cluster system, tested by the testsuite.
In the subdirectory of each number resides the local spool directory of
the execution and/or master daemon.</font>
<p><font size=+1>The location of the spool directories is per default in
the cell definition directory where the cluster software is installed (e.g.
/GE/default/spool/$hostname or /GE/default/spool/qmaster). This is a global
shared directory (NFS). If the network traffic should be reduced it is
usefull to set a local spool directory for each execution host.</font>
<p><font size=+1>examples:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">expo1 /usr/tmp/testsuite</font></tt>
<br><tt><font color="#FFFFFF">expo2 /scratch/testsuite</font></tt></td>
</tr>
</table></center>

<hr WIDTH="100%">
<br><a NAME="Setup Configuration"></a>
<pre>Setup configuration</pre>
<font size=+1>After the configuration of the testsuite configuration files,
a typical first startup would look like this:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">[38] cd [your testsuite root directory]</font></tt>
<br><tt><font color="#FFFFFF">[39] expect check.exp</font></tt></td>
</tr>
</table></center>

<p><font size=+1>After typing return the testsuite is looking for the defaults.sav
file. If it doesn't exist it will call the setup procedure. After that
a vi (vim) is started and the user can change the default values:</font>
<dl>&nbsp;
<center><table BORDER WIDTH="80%" NOSAVE >
<tr VALIGN=CENTER NOSAVE>
<td NOSAVE><a NAME="Cluster configuration settings parameter"></a><tt><b>Cluster
configuration settings parameter</b> (defaults.sav)</tt></td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><b><tt>Description</tt></b></div>
</td>
</tr>

<tr NOSAVE>
<td NOSAVE>
<div STYLE="font-style: normal; text-decoration: none"><tt>testsuite_root_directory</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Path to the
testsuite root directory. This directory must be available from all hosts
in the cluster. Default is the current working directory, when starting
the testsuite framework script.</tt></div>
</td>
</tr>

<tr NOSAVE>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>testsuite_config_dir</tt></div>
</td>

<td WIDTH="40%" NOSAVE>
<div STYLE="margin-bottom: 0in; font-style: normal; text-decoration: none"><tt>Path
to the configuration files (binary-path.conf, gid-range.conf, loadsensor.conf,</tt></div>

<div STYLE="font-style: normal; text-decoration: none"><tt>local-spool.conf).
This directory must be available from all hosts in the cluster.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>checktree_root_directory</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Path to the
checktree. "checktree" is per default a subdirectory of testsuite_root_directory
and it conaints all tests. Every "check.exp" file in each subdirectory
is interpreted as test. This directory must be available from all hosts
in the cluster.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>results_root_directory</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Path to a directory
where the results of each test are stored. Each defaults.sav file should
have its own results_root_directory. The lockfile of a testsuite run is
also stored into this directory. So if you want to run more than one testsuite
at the same time for different clusters it is absolutely necessary to create
a results_root_directory for every cluster. This directory must be available
from all hosts in the cluster. (The performance tests will save their results
in the subdirectory protocols).</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>qmaster_host</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The host name
of the qmaster host of the test cluster (This must be the host where the
testsuite is started on).&nbsp;</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>list_of_execution_hosts</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>A blank seperated
list of execution host names. The first entry is the name of the qmaster
host, because on the qmaster host also an execution daemon is installed.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>processors_on_each_execution_host</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>A blank seperated
list of numbers. Each number matches the number of processors on each execution
host, named in the list_of_execution_hosts parameter.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>commd_portnumber</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The port number
used for TCP/IP connection of the communication daemons. (COMMD_PORT environment
variable)</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>product_type</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Type of the
cluster software. "sge" for a Grid Engine system and "sgeee" for a Grid
Engine Enterprise Edition system (default is "sge").</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>product_root_directory</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Path to the
directory where the cluster software should be installed. This directory
must be available from all hosts in the cluster. (This is the $SGE_ROOT
directory)</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>source_root_directory</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Path to the
directory with the source code of the cluster software (used for the compile
option). The compile option will CVS update the source code in the "gridengine/source"
directory (use "compile no_update" to skip the CVS update).</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>cvs_hostname</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The host where
the "cvs update" command should be started (rsh access required).</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>cvs_release_tag</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The cvs release
tag of the source (default is "maintrunc"). Use "cvs log" comand to find
out more about available tags.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>list_of_compile_hosts</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>A blank separated
list of host names where the cluster software should be compiled on (rsh
access required).&nbsp;</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>first_foreign_system_username</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The user name
of an additional cluster user. This should not be the user name of the
testsuite user (who starts the testsuite). Some tests will check whether
the sheperd daemon will set the correct user account.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>second_foreign_system_username</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The user name
of a second additional cluster user. This should not be the user name of
the testsuite user (who starts the testsuite). Some tests will check whether
the sheperd daemon will set the correct user account.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>first_foreign_system_groupname</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The group name
of an additional cluster user. This should not be the group of the testsuite
user (who starts the testsuite). Some tests will check whether the sheperd
daemon will set the correct user group.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>second_foreign_system_groupname</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The group name
of a second additional cluster user. This should not be the group of the
testsuite user (who starts the testsuite). Some tests will check whether
the sheperd daemon will set the correct user group.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>default_domain</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>Used at installation
time of the cluster. The value for default_domain (look into cluster documentation
for more information about that). Default is "none" (recommended).</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>mailx_hostname</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>The testsuite
can send error, warning and report mails. It will use the mailx binary
to do this. mailx_hostname is the host name on which the mailx binary should
be used (rsh required).</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>mail_to</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>E-Mail address
of the recipent of error-, warning- and report mails. (Default is "none",
this means mail sending is disabled)</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>mail_cc</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>CC addresses
for mail reports. (Default is "none")</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>enable_error_mails</tt></div>
</td>

<td WIDTH="475">
<div STYLE="margin-bottom: 0in; font-style: normal; text-decoration: none"><tt>"1":
the testsuite will send error- ,warning- and report mail messages.(default)</tt></div>

<div STYLE="font-style: normal; text-decoration: none"><tt>"0": the testsuite
will only send report mail messages.</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>max_run_all_mails</tt></div>
</td>

<td WIDTH="475">
<div STYLE="font-style: normal; text-decoration: none"><tt>This is the
maximum error/warning count for mail sending. Not more mails than the value
of max_run_all_mails is set to are sent in one testsuite "run all test"
run (Default is 400).</tt></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="261">
<div STYLE="font-style: normal; text-decoration: none"><tt>use_ssh</tt></div>
</td>

<td WIDTH="475">
<div STYLE="margin-bottom: 0in; font-style: normal; text-decoration: none"><tt>"1":
use ssh for login</tt></div>

<div STYLE="font-style: normal; text-decoration: none"><tt>"0": use expect
and send password on "login:" question. (default)</tt></div>
</td>
</tr>
</table></center>
</dl>

<p><br><font size=+1>After setting the correct values exit the vi with
":wq". The testsuite will try to resolve the hostnames and will report
some errors at the first startup:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">"architecture or file "&lt;product_root_directory>/util/arch"
not found",</font></tt>
<br><tt><font color="#FFFFFF">proc reslove_host - gethostname error or
file "&lt;product_root_directory>/utilbin/unknown/gethostname" not found</font></tt></td>
</tr>
</table></center>

<p><font size=+1>This is because the system is not compiled and installed
at this time. The user has to review the settings and answer the question
with "y" if everything is ok.</font>
<p><font size=+1>If no installed system was configured the following screen
display should appear:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#CCCCCC">===============================================================================</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;system version&nbsp;&nbsp;&nbsp; :&nbsp;
system not installed - run compile option first</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;current dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; /homedir/myusername/docu_test_src/testsuite/checktree</font></tt>
<br><tt><font color="#CCCCCC">===============================================================================</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;max. runlevel&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; short medium long week</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;selected runlevels:&nbsp; short medium
long day week</font></tt>
<br><tt><font color="#CCCCCC">===============================================================================</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; 1 test(s) available in subdir: functional</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; 1 test(s) available in subdir: install_core_system</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; 1 test(s) available in subdir: performance</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;10 test(s) available in subdir: system_tests</font></tt>
<br><tt><font color="#CCCCCC">===============================================================================</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;13 test(s) available in current subdirs</font></tt>
<br><tt><font color="#CCCCCC">===============================================================================</font></tt>
<p><tt><font color="#CCCCCC">&nbsp; (0) select runlevels</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (1) change dir</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (2) run not completed tests (including
subdirectories)</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (3) show test descriptions</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (4) exit (press ^C to exit without
shutdown of the cluster)</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (5) show completed test list</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (6) show not completed test list</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (7) reset completed test list (for
all subdirectories)</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (8) create check report</font></tt>
<br><tt><font color="#CCCCCC">&nbsp; (9) run all tests continuously</font></tt>
<br><tt><font color="#CCCCCC">&nbsp;(10) use file "unknown.checklog" for
output</font></tt></td>
</tr>
</table></center>

<p><font size=+1>The first line in the main menu shows the installed cluster
software version or the reason why the the system version can not be found.
The next line displays the actual path in the checktree. The max. runlevel
line shows all runlevels used in tests implemented in the subdirectories.
The different runlevels are described in the chapter "Structure". Per default
all possible runlevels are selected. This means that all possible tests
will run when choosing e.g. the 2nd menu point.</font>
<p><font size=+1>(0) - select runlevels:</font>
<br><font size=+1>The user can select the runlevels he wants to run. When
choosing "select runlevels" the following screen display will appear:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">===============================================================</font></tt>
<br><tt><font color="#FFFFFF">selected runlevels:&nbsp; short medium long
day week</font></tt>
<br><tt><font color="#FFFFFF">===============================================================</font></tt>
<br>&nbsp;
<p><tt><font color="#FFFFFF">please select/unselect new runlevels:&nbsp;</font></tt>
<p><tt><font color="#FFFFFF">(0) short&nbsp; (&nbsp;&nbsp; 0 min - 15 min
/ run level&nbsp;&nbsp; 0 -&nbsp; 99 )</font></tt>
<br><tt><font color="#FFFFFF">(1) medium (&nbsp; 16 min -&nbsp; 1 h&nbsp;&nbsp;
/ run level 100 - 199 )</font></tt>
<br><tt><font color="#FFFFFF">(2) long&nbsp;&nbsp; (&nbsp;&nbsp; 1 h&nbsp;&nbsp;
-&nbsp; 4 h&nbsp;&nbsp; / run level 200 - 299 )</font></tt>
<br><tt><font color="#FFFFFF">(3) day&nbsp;&nbsp;&nbsp; ( > 4 h&nbsp;&nbsp;
- 24 h&nbsp;&nbsp; / run level 300 - 399 )</font></tt>
<br><tt><font color="#FFFFFF">(4) week&nbsp;&nbsp; ( >24 h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/ run level 400 - 499 )</font></tt>
<p><tt><font color="#FFFFFF">(5) return to previous menu</font></tt></td>
</tr>
</table></center>

<p><font size=+1>(1) - change dir:</font>
<br><font size=+1>Select this to walk through the checktree structure in
order to select a single test or a special subtree.</font>
<p><font size=+1>(2) - run not completed tests</font>
<br><font size=+1>This menu point will run all selected runlevel tests
in each subdirectory. When a test starts the framework will generate a
file called "testsuite_lockfile". This is to make sure that only one test
will run at the same time.</font>
<p><font size=+1>(3) - show test descriptions</font>
<br><font size=+1>Shows all test descriptions (from all tests in the subdirectories)</font>
<p><font size=+1>(4) - exit</font>
<br><font size=+1>Shutdown the tested cluster system and exit. If no "install_core_system"
test was run before, some error output may appear (If the cluster system
should not get a shutdown, the testsuite framework can be stopped with
"CTRL + C" in the main menu).</font>
<br><font size=+1>Each test will try to write a new file called "testsuite_lockfile"
in the check result directory. This should prevent running more than one
test at the same time. While a testsuite_lockfile is existent no test will
run.)</font>
<p><font size=+1>(5) - show completed test list</font>
<br><font size=+1>Show the list of successfully completed tests</font>
<p><font size=+1>(6) - show not completed test list</font>
<br><font size=+1>Show the list of unsucessfully or uncompleted tests</font>
<p><font size=+1>(7) - reset completed test list (for all subdirectories)</font>
<br><font size=+1>Set the status of all tests in this and in all subdirectories
to uncompleted</font>
<p><font size=+1>(8) - create check report</font>
<br><font size=+1>Creates a good and a bad result report for the host running
the testsuite in the test result path. The testsuite will report the exact
position of the report files.</font>
<p><font size=+1>(9) - run continuously</font>
<br><font size=+1>Like (2), but creates a report at the end of all tests
and starts up again</font>
<p><font size=+1>(10) - use logfile for output (HOST.checklog)</font>
<br><font size=+1>This will put all the output from the testsuite framework
into a file called HOSTNAME.checklog. The file is stored in the test result
path.</font>
<p><font size=+1>If the testsuite is showing "system not installed - run
compile option first" at the system version line the user can press "CTRL
- C" to stop the testsuite and restart the testsuite with the command:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">[74] expect check.exp compile</font></tt></td>
</tr>
</table></center>

<p><font size=+1>The testsuite will compile the cluster software on each
host in the list_of_compile_hosts. After that the binaries are installed
at the product_root_directory. After the installation of the binaries the
testsuite will resolve each hostname and complete the setup procedure which
had errors at the first run. If no errors occur the testsuite can be restarted.
The screen should show the following display:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;system version&nbsp;&nbsp;&nbsp; :&nbsp;
system not running - run install test first</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;current dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; /homedir/myusername/docu_test_src/testsuite/checktree</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;max. runlevel&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; short medium long week</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;selected runlevels:&nbsp; short medium
long day week</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; 1 test(s) available in subdir: functional</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; 1 test(s) available in subdir: install_core_system</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; 1 test(s) available in subdir: performance</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;10 test(s) available in subdir: system_tests</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;13 test(s) available in current subdirs</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<p><tt><font color="#FFFFFF">&nbsp; (0) select runlevels</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (1) change dir</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (2) run not completed tests (including
subdirectories)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (3) show test descriptions</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (4) exit (press ^C to exit without
shutdown of the cluster)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (5) show completed test list</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (6) show not completed test list</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (7) reset completed test list (for
all subdirectories)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (8) create check report</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (9) run all tests continuously</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(10) use file "ahostname.checklog"
for output</font></tt></td>
</tr>
</table></center>

<p><font size=+1>Nearly all tests need a running cluster software system.
The test called "install_core_system" will install it. So mostly all tests
have the dependency "install_core_system" which means that the test won't
run until the test "install_core_system" was successfully performed. Initially,
we haven't installed the core system, so we can only run tests that don't
need it. Change to the directory "../checktree/system_tests/utilbin/loadcheck".
The following lines will appear:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;system version&nbsp;&nbsp;&nbsp; :&nbsp;
system not running - run install test first</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;current dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; /homedir/myusername/docu_test_src/testsuite/checktree/sys</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tem_tests/utilbin/loadcheck</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;max. runlevel&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; short</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;selected runlevels:&nbsp; short medium
long day week</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; 0 test(s) available in current subdirs</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<p><tt><font color="#FFFFFF">&nbsp; (0) select runlevels</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (1) change dir</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (2) run not completed tests (including
subdirectories)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (3) show test descriptions</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (4) exit (press ^C to exit without
shutdown of the cluster)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (5) show completed test list</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (6) show not completed test list</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (7) reset completed test list (for
all subdirectories)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (8) create check report</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (9) run all tests continuously</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(10) use file "myhostname.checklog"
for output</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(11) show test descriptions of local
test</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(12) run local test</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(13) run local test continously</font></tt></td>
</tr>
</table></center>

<p><font size=+1>A successful run (no. 12 + enter) of the current test
should have following output:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">running local test ...</font></tt>
<br><tt><font color="#FFFFFF">deleting old temp script files ...</font></tt>
<br><tt><font color="#FFFFFF">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>></font></tt>
<br><tt><font color="#FFFFFF">>>> loadcheck</font></tt>
<br><tt><font color="#FFFFFF">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>></font></tt>
<p><tt><font color="#FFFFFF">----------------------------------------------->
enter check level 0</font></tt>
<br><tt><font color="#FFFFFF">waiting for lock ...</font></tt>
<br><tt><font color="#FFFFFF">starting test functions (runlevel is 0)...</font></tt>
<p><tt><font color="#FFFFFF">>>>>>>>>>>>>>>>>>>>>>></font></tt>
<br><tt><font color="#FFFFFF">check_numb_proc</font></tt>
<br><tt><font color="#FFFFFF">runlevel: short(0)</font></tt>
<br><tt><font color="#FFFFFF">>>>>>>>>>>>>>>>>>>>>>></font></tt>
<br><tt><font color="#FFFFFF">expo1: Expected processors: 1</font></tt>
<br><tt><font color="#FFFFFF">expo1: read processors:&nbsp;&nbsp;&nbsp;&nbsp;
1</font></tt>
<br><tt><font color="#FFFFFF">S U C C E S S F U L L Y performed "loadcheck"
in run level 0 !</font></tt>
<br><tt><font color="#FFFFFF">saving results for loadcheck (level 0) ...</font></tt>
<br><tt><font color="#FFFFFF">&lt;results_dir>/expo1.completed</font></tt>
<br><tt><font color="#FFFFFF">&lt;results_dir>/expo1.uncompleted</font></tt>
<br><tt><font color="#FFFFFF">Looking for creation of the file "&lt;results_dir>/expo1.uncompleted/loadcheck.res.0"
...</font></tt>
<br><tt><font color="#FFFFFF">Looking for deletion of the file "&lt;results_dir>/expo1.uncompleted/loadcheck.res.0"
...</font></tt>
<p><tt><font color="#FFFFFF">set state of "loadcheck" for level 0 to completed
!</font></tt>
<br><tt><font color="#FFFFFF">removing lockfile "&lt;results_dir>/testsuite_lockfile"</font></tt>
<br><tt><font color="#FFFFFF">testsuite unlocked!</font></tt>
<br><tt><font color="#FFFFFF">--> mail_report - no mail address</font></tt>
<p><tt><font color="#FFFFFF">press enter...</font></tt></td>
</tr>
</table></center>

<p><font size=+1>Now lets install the the cluster software. Go to the directory
../checktree/install_core_system and start the test. After starting the
test the user is asked for the root password. This is because the install_core_system
test needs root access. The root password is stored in a global variable,
so if it was entered once the testsuite will not ask again for it until
the next restart of the whole testsuite. This is of course a security problem,
look at "<a href="#Security Implications">Security Implications</a>" for
more information. If the user doesn't enter the root password the testsuite
can not run all tests. After running the install_core_system test the testsuite
screen output should look like that:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;system version&nbsp;&nbsp;&nbsp; :&nbsp;
Grid Engine 5.3</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;current dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; /homedir/myusername/docu_test_src/testsuite/checktree/ins</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tall_core_system</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;max. runlevel&nbsp;&nbsp;&nbsp;&nbsp;
:&nbsp; short</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;selected runlevels:&nbsp; short medium
long day week</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; 0 test(s) available in current subdirs</font></tt>
<br><tt><font color="#FFFFFF">===============================================================================</font></tt>
<p><tt><font color="#FFFFFF">&nbsp; (0) select runlevels</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (1) change dir</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (2) run not completed tests (including
subdirectories)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (3) show test descriptions</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (4) exit (press ^C to exit without
shutdown of the cluster)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (5) show completed test list</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (6) show not completed test list</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (7) reset completed test list (for
all subdirectories)</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (8) create check report</font></tt>
<br><tt><font color="#FFFFFF">&nbsp; (9) run all tests continuously</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(10) use file "ahostname.checklog"
for output</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(11) show test descriptions of local
test</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(12) run local test</font></tt>
<br><tt><font color="#FFFFFF">&nbsp;(13) run local test continously</font></tt></td>
</tr>
</table></center>

<p>
<hr WIDTH="100%"><a NAME="Internal test suite illustration"></a>
<h1>
Internal testsuite illustration</h1>
<font size=+1>This chapter shows the internal structure of the testsuite.
It is recommended to read the chapter "About Tcl" and About "Expect" to
get a short insight into the programming language before reading this.</font>
<p><font size=+1>The chapter "<a href="#Implementation Approach">Implementation
approach</a>" later will show exactly how to integrate a new test by writing
a short test example.</font>
<br>
<hr WIDTH="100%">
<br><a NAME="Internal - structure"></a>
<pre><font size=+1>Structure</font></pre>
<font size=+1>The testsuite's framework is written in Tcl (Tool command
language) and its Expect&nbsp; (A Tcl-based toolkit for automating interactive
programs) extensions. In order to make it simple to integrate new test
procedures, each test has its own directory in a hierarchy structure called
"checktree". Each directory can have a file named "check.exp", which is
a Tcl/Expect script containing one or more test procedures. These scripts
are sourced from the testsuite's framework script which also calls the
test procedures.</font>
<p><font size=+1>The subdirectory "install_core_system" from the "checktree"
directory is used for the installation and set-up of the cluster system
to test.</font>
<br><font size=+1>The framework script will parse the directory structure
and display all available system tests.</font>
<br>&nbsp;
<p><font size=+1>Each test script must setup the following variables:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#FFFFFF" NOSAVE >
<tr NOSAVE>
<td NOSAVE><b><tt><font color="#3333FF"># globals to define:</font></tt></b>
<br><tt><font color="#330000"><b>global</b> check_name check_description
check_needs</font></tt>
<br><tt><font color="#330000"><b>global</b> check_functions check_errno
check_errstr</font></tt>
<br><tt><font color="#330000"><b>global</b> check_init_level_procedure
check_highest_level</font></tt>
<br><tt><font color="#330000"><b>global</b> check_root_access_needs</font></tt>
<p><b><tt><font color="#3333FF"># this is check specific</font></tt></b>
<br><tt><font color="#330000"><b>set</b> check_root_access_needs </font><font color="#990000">"yes"</font></tt>
<br><tt><font color="#330000"><b>set</b> check_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#990000">"qconf"</font></tt>
<br><tt><font color="#330000"><b>set</b> check_description(0)&nbsp; </font><font color="#990000">"test
qconf -aq and qconf -dq switch"</font></tt>
<br><tt><font color="#330000"><b>set</b> check_needs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#990000">"init_core_system qstat qsub"</font></tt>
<br><tt><font color="#330000"><b>set</b> check_functions&nbsp;&nbsp; </font><font color="#990000">"addqueue
submitjob checkjob removequeue"</font></tt>
<br><tt><font color="#330000"><b>set</b> check_errno&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#990000">"-1"&nbsp;</font><font color="#330000">&nbsp;&nbsp;
<b>;# 0 -> OK , != 0 means error</b></font></tt>
<br><tt><font color="#330000"><b>set</b> check_errstr&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#990000">"was never running"</font><b><font color="#330000">;#
string for error description</font></b></tt>
<br><tt><font color="#330000"><b>set</b> check_init_level_procedure </font><font color="#990000">"onlevelchange"</font></tt>
<br><tt><font color="#330000"><b>set</b> check_highest_level&nbsp; </font><font color="#3333FF">0</font></tt></td>
</tr>
</table></center>

<p><font size=+1>The initial value "-1" for the variable "check_errno"
is shown for the sake of completeness (The testsuite will set it automatically
to "-1", when starting a new test). A test is stored as "successfully performed"
when the value of "check_errno" is "0". So if a test does not explicitly
set "check_errno" to "0" the test will never run successfully. This strategy
prevents that a test programmer forgets to set the correct result state.</font>
<p><b><i><u><font size=+1>check_root_access_needs</font></u></i></b>
<br><font size=+1>This variable should be set to "yes" when the test needs
root permissions. If the variable is not set or set to "" the testsuite
will not ask for the root password. Once the root password is known the
testsuite won't ask again for it.</font><font size=+1></font>
<p><b><i><u><font size=+1>check_name</font></u></i></b>
<br><font size=+1>Unique name of the test. Each "check.exp" file must have
it's own name.</font>
<p><b><i><u><font size=+1>check_description</font></u></i></b>
<br><font size=+1>Short verbal test description array for each runlevel.
Each array address (number in brackets) should contains a short string
which describes the test runlevel.</font>
<p><b><i><u><font size=+1>check_needs</font></u></i></b>
<br><font size=+1>The name of the tests which should run before this one.&nbsp;
This is to define dependencies on other tests.</font>
<p><b><i><u><font size=+1>check_functions</font></u></i></b>
<br><font size=+1>This is a space seperated list of procedure names. Each
procedure is called by the framework script in the given order. Each procedure
should perform a test and at last set the "check_errno" and "check_errstr"
variables.</font>
<p><b><i><u><font size=+1>check_errno and check_errstr</font></u></i></b>
<br><font size=+1>Any test procedure can set the values check_errno and
check_errstr. If a procedure successfully performed&nbsp; its test, it
should set check_errno to "0" and put a comment like "no errors" into check_errstr.
If check_errno is not set to "0" the framework script will report the check_errstr
content and store the test in the directory for failed checks. The following
table will show the different meanings of the check_errno value.</font>
<br>&nbsp;
<center><table BORDER COLS=2 WIDTH="400" NOSAVE >
<tr NOSAVE>
<td NOSAVE>
<center><b>$check_errno</b></center>
</td>

<td>
<center><b>meaning</b></center>
</td>
</tr>

<tr>
<td>
<center>0</center>
</td>

<td>no errors</td>
</tr>

<tr>
<td>
<center>-1</center>
</td>

<td>error, but testsuite will run till end</td>
</tr>

<tr>
<td>
<center>-2</center>
</td>

<td>error, stop current test</td>
</tr>

<tr>
<td>
<center>-3</center>
</td>

<td>warning message (stop at next runlevel)</td>
</tr>
</table></center>

<p><font size=+1>It is very important that the check_errstr variable will
report the verbal error reasons, because the testsuite will show this reasons
to the testsuite user. If the check_errstr is accurately described, the
user will easier find an error.</font>
<p><font size=+1>The programmer can set the two variables by using the
procedure set_error. The first parameter is the number for the check_errno,
the second parameter is the error text for check_errstr.</font>
<p><b><i><u><font size=+1>check_init_level_procedure</font></u></i></b>
<br><font size=+1>The testsuite can run each test in a different check
level. The lowest check level number is 0. Each check can define its own
highest check level (variable check_highest_level). If the test programmer
defines a check_init_level_procedure the testsuite framework will call
this procedure before running each procedure in check_functions. So the
programmer can change some values for each level test run. The global variable
CHECK_ACT_LEVEL shows the current run level of the testsuite.</font>
<p><b><font size=+1>The check_init_level_procedure must return "-1" if
a check level is not implemented or "0" when the check can run the level.
Each test script must have at least a run level "0" to test its functional
behavior.</font></b>
<p><font size=+1>If the test does not define check_highest_level and check_init_level_procedure
the testsuite will <b>only call run level 0.</b></font>
<br>&nbsp;
<p><b><i><u><font size=+1>check_highest_level</font></u></i></b>
<br><font size=+1>If a test can run with e.g. 2 different setups the check_highest_level
should be set to 1. Of course this makes only sense when a check_init_level_procedure
is defined.</font>
<p><font size=+1>The two main characteristics of a test are its runtime
and its category. The test category is defined by the position in the checktree
<a href="checktree.jpg">hierarchy</a>.</font>
<p><font size=+1>The tests runtime is defined by the use of different run
levels. The table below shows a guideline for test levels:</font>
<br>&nbsp;
<center><table BORDER COLS=2 WIDTH="400" NOSAVE >
<tr NOSAVE>
<td NOSAVE>
<center><b>run level</b></center>
</td>

<td>
<center><b>test time</b></center>
</td>
</tr>

<tr>
<td>
<center>0-99</center>
</td>

<td>
<center>0-15 min.</center>
</td>
</tr>

<tr>
<td>
<center>100-199</center>
</td>

<td>
<center>16 min. - 1h</center>
</td>
</tr>

<tr>
<td>
<center>200-299</center>
</td>

<td>
<center>1h - 4h</center>
</td>
</tr>

<tr>
<td>
<center>300-399</center>
</td>

<td>
<center>4h - 24h</center>
</td>
</tr>

<tr>
<td>
<center>400-499</center>
</td>

<td>
<center>> 24h</center>
</td>
</tr>
</table></center>

<hr WIDTH="100%">
<p><a NAME="Path/File variables"></a>
<pre><font size=+1>File and path variables</font></pre>

<dl>&nbsp;
<center><table BORDER CELLPADDING=4 COLS=2 WIDTH="80%" NOSAVE >
<tr VALIGN=TOP NOSAVE>
<td WIDTH="249" NOSAVE><font size=+1>CHECK_TESTSUITE_ROOT</font></td>

<td WIDTH="487"><font size=+1>path to the testsuite directory</font></td>
</tr>

<tr>
<td WIDTH="249" NOSAVE><font size=+1>CHECK_CHECKTREE_ROOT</font></td>

<td WIDTH="487"><font size=+1>path where checktree resides</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_RESULT_DIR</font></td>

<td WIDTH="487"><font size=+1>check result directory for host specific
tests which had no errors.</font></td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td WIDTH="249" NOSAVE><font size=+1>CHECK_BAD_RESULT_DIR</font></td>

<td WIDTH="487"><font size=+1>check result directory for failed host specific
tests or such tests which wasn't started.</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_CORE_RESULT_DIR</font></td>

<td WIDTH="487"><font size=+1>same meaning as $CHECK_BAD_RESULT_DIR, but
not host specific. Some tests like the install_core_system test are effective
for the whole cluster.&nbsp;</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_CORE_BAD_RESULT_DIR</font></td>

<td WIDTH="487"><font size=+1>same meaning as $CHECK_BAD_RESULT_DIR, but
not host specific. Some tests like the install_core_system test are effective
for the whole cluster.&nbsp;</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_PROTOCOL_DIR</font></td>

<td WIDTH="487"><font size=+1>directory for test protocols, log files,
etc.</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_ACTUAL_TEST_PATH</font></td>

<td WIDTH="487"><font size=+1>directory of currently running test</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_PRODUCT_ROOT</font></td>

<td WIDTH="487"><font size=+1>path to Grid Engine system ($SGE_ROOT)</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_OUTPUT</font></td>

<td WIDTH="487"><font size=+1>output channel ( e.g. stdout, filepointer)
for test debug output (puts $CHECK_OUTPUT "error ..")</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_CURRENT_WORKING_DIR</font></td>

<td WIDTH="487"><font size=+1>current working directory ( same as echo
PWD)</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_SPOOL_DIR_CONFIG_FILE</font></td>

<td WIDTH="487"><font size=+1>file for local spooldirs in $CHECK_CONFIG_DIR
path</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_BINARY_DIR_CONFIG_FILE</font></td>

<td WIDTH="487"><font size=+1>file for binary directories in $CHECK_CONFIG_DIR</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_LOADSENSOR_DIR_CONFIG_FILE</font></td>

<td WIDTH="487"><font size=+1>file for architecture specific loadsensor
binaries in $CHECK_CONFIG_DIR</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_CONFIG_DIR</font></td>

<td WIDTH="487"><font size=+1>global configuration testsuite directory</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_TCL_SCRIPTFILE_DIR</font></td>

<td WIDTH="487"><font size=+1>testsuite's subdir for tcl files&nbsp;</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_SCRIPT_FILE_DIR</font></td>

<td WIDTH="487"><font size=+1>testsuite's subdir for script files</font></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="249"><font size=+1>CHECK_DEFAULT_DOMAIN</font></td>

<td WIDTH="487"><font size=+1>default domain name for install_core_system
test&nbsp;</font></td>
</tr>
</table></center>

<hr WIDTH="100%"></dl>

<dl><a NAME="test system specific variables"></a>
<pre><font size=+1>Test system variables</font></pre>

<center><table BORDER CELLPADDING=4 WIDTH="80%" NOSAVE >
<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_PRODUCT_VERSION_NUMBER</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>version string of the
system to test ( first line of qstat -help)</font></div>
</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td WIDTH="255" NOSAVE>
<div STYLE="text-decoration: none"><font size=+1>CHECK_PRODUCT_TYPE</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>"sge" or "sgeee"</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_COMMD_PORT</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>equal to $COMMD_PORT</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_ARCH</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>system architecture (e.g.
solaris64)</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_USER</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>user who started the test</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_GROUP</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>group of user who started
the test</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_HOST</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>system hostname (e.g.
etna5 )</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_CORE_EXECD</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>known execd hostnames</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_CORE_MASTER</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>qmaster hostname</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_CORE_PROCESSORS</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>number of processors on
each execution host (in order of $CHECK_CORE_EXECD)</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_ACT_LEVEL</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>actual check level ( value
from 0 up to xxx )</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_SOURCE_DIR</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>path to source code directory
(gridengine/source)</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_SOURCE_HOSTNAME</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>name of host with cvs
installed on</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_SOURCE_COMPILE_HOSTS</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>list of hostnames on which
the source should be compiled</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_FIRST_FOREIGN_SYSTEM_USER</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>other system user for
e.g. submitting jobs</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_SECOND_FOREIGN_SYSTEM_USER</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>other system user for
e.g. submitting jobs</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_FIRST_FOREIGN_SYSTEM_GROUP</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>other system group</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_SECOND_FOREIGN_SYSTEM_GROUP</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>other system group</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_MAILX_HOST</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>host where the mailx binary
is available</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_REPORT_EMAIL_TO</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>mail reports/errors to
this email-account</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_REPORT_EMAIL_CC</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>cc reports/errors to this
email-accounts</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_USE_SSH</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>enable/disable use of
ssh (0 = disable), default is "disable"</font></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="255">
<div STYLE="text-decoration: none"><font size=+1>CHECK_ADMIN_USER_SYSTEM</font></div>
</td>

<td WIDTH="482">
<div STYLE="text-decoration: none"><font size=+1>0=root password is set/
1= no root password set</font></div>
</td>
</tr>
</table></center>
</dl>
<font size=+1>There are some more global definitions, but they are not
so important for test programmers. Please refer to the comment at the beginning
of the "check.exp" file in the testsuite's root directory for all global
definitions.</font>
<br>&nbsp;
<br>&nbsp;
<p>
<hr WIDTH="100%"><a NAME="About TCL"></a>
<h1>
About Tcl</h1>
<font size=+1>This chapter should give a small summary of the relevant
Tcl language syntax. The following lines are original Tcl command line
Syntax. A ";#" within a line is interpreted as comment, as well as a "#"&nbsp;
at the start of a line.</font>
<br>
<hr WIDTH="100%">
<br><a NAME="TCL - syntax"></a>
<pre><font size=+1>Tcl Syntax</font></pre>
<b><tt><font size=+1># here some Tcl commands:</font></tt></b>
<p><tt><font size=+1>set x "hello world!"&nbsp; <b>;# set variable x to
hello world! (" are omitted)</b></font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># a semicolon (;) is used to separate commands</font></tt></b>
<br><b><tt><font size=+1># commands between "[" and "]" brackets are interpreted.
The command before "["</font></tt></b>
<br><b><tt><font size=+1># will get the result.</font></tt></b>
<br><b><tt><font size=+1># the next three commands have the same result
(3 x "hello world!")</font></tt></b>
<p><tt><font size=+1>tcl> puts $x ; puts [set x] ; puts stdout [set x];</font></tt>
<br><tt><font size=+1>hello world!</font></tt>
<br><tt><font size=+1>hello world!</font></tt>
<br><tt><font size=+1>hello world!</font></tt>
<br><tt><font size=+1>tcl></font></tt>
<p><b><tt><font size=+1># if you want to calculate, use the expr command:</font></tt></b>
<br><tt><font size=+1>puts [expr ( 1 + 4)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b>;# Output: 5</b></font></tt>
<br><tt><font size=+1>puts [ expr ( [expr (1 + 4 ) ] + 4 ) ] <b>;# Output:
9</b></font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># values between "{" and "}" brackets are not interpreted</font></tt></b>
<br><tt><font size=+1>puts "hallo $x"&nbsp;&nbsp;&nbsp; <b>;# output: hallo
hello world!</b></font></tt>
<br><tt><font size=+1>puts {"hallo $x"}&nbsp; <b>;# output: "hallo $x"</b></font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># while loop and incr example</font></tt></b>
<br><b><tt><font size=+1># use incr to increase or decrease a variable</font></tt></b>
<br><tt><font size=+1>set count 0</font></tt>
<br><tt><font size=+1>set backcount 0</font></tt>
<br><tt><font size=+1>while { $count &lt; 5} {</font></tt>
<br><tt><font size=+1>&nbsp; incr count 1</font></tt>
<br><tt><font size=+1>&nbsp; incr backcount -1</font></tt>
<br><tt><font size=+1>&nbsp; puts "$count,$backcount"</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>>1,-1</font></tt>
<br><tt><font size=+1>>2,-2</font></tt>
<br><tt><font size=+1>>3,-3</font></tt>
<br><tt><font size=+1>>4,-4</font></tt>
<br><tt><font size=+1>>5,-5</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># for loop</font></tt></b>
<br><b><tt><font size=+1># initialization, stop criteria, increment</font></tt></b>
<br><tt><font size=+1>for {} {1} {} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
endless loop</b></font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>for {set count 2} { $count > 0 } { incr count -1 }
{</font></tt>
<br><tt><font size=+1>&nbsp; puts "count is \"$count\""</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>>count is "2"</font></tt>
<br><tt><font size=+1>>count is "1"</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># else ... (like "C")</font></tt></b>
<br><tt><font size=+1>if { $a == 1 } {</font></tt>
<br><tt><font size=+1>&nbsp; puts "a is 1"</font></tt>
<br><tt><font size=+1>} else {</font></tt>
<br><tt><font size=+1>&nbsp; puts "a is not 1"</font></tt>
<br><tt><font size=+1>}</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># switch</font></tt></b>
<br><tt><font size=+1>switch -- $count {</font></tt>
<br><tt><font size=+1>&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { puts
"count is 0" }</font></tt>
<br><tt><font size=+1>&nbsp; default { puts "default" }</font></tt>
<br><tt><font size=+1>}</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># break; continue; have the same meaning in loops
as in the "C" language</font></tt></b>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - Procedures"></a>
<pre><font size=+1>Procedures</font></pre>
<font size=+1>You can define procedures with the following syntax:</font>
<br>&nbsp;
<p><tt><font size=+1>proc test { name } {</font></tt>
<br><tt><font size=+1>&nbsp; puts "name is \"$name\""</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>tcl>test me</font></tt>
<br><tt><font size=+1>name is "me"</font></tt>
<p><font size=+1>Once, a procedure is declared (or sourced) you can use
it. The source command is used to load a tcl script file into the name
space. Once a tcl script is sourced every procedure in it is available:</font>
<p><b><tt><font size=+1># the source command:</font></tt></b>
<br><tt><font size=+1>source /tmp/myprocedures.tcl</font></tt>
<p><font size=+1>Procedures can be called recursively. Values can be returned
with the return command. You can use a global variable to stop the recursive
walk.</font>
<br>&nbsp;
<p><b><tt><font size=+1># simple recursive procedure</font></tt></b>
<br>&nbsp;
<p><tt><font size=+1>global runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
define the global variable runs</b></font></tt>
<p><tt><font size=+1>proc callme { call } {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; global runs&nbsp;&nbsp;&nbsp; <b>;#
you want to acces the global variable runs</b></font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; puts "this is call $call"</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; set back ""</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; if { $call &lt; $runs } {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set back [callme [
expr ( $call + 1 ) ]]</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $back</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; } else {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $call</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; }</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt>The output will look like follows:</tt>
<p><tt><font size=+1>tcl> set runs 5</font></tt>
<br><tt><font size=+1>tcl> callme 0</font></tt>
<br><tt><font size=+1>this is call 0</font></tt>
<br><tt><font size=+1>this is call 1</font></tt>
<br><tt><font size=+1>this is call 2</font></tt>
<br><tt><font size=+1>this is call 3</font></tt>
<br><tt><font size=+1>this is call 4</font></tt>
<br><tt><font size=+1>this is call 5</font></tt>
<br><tt><font size=+1>5</font></tt>
<br><tt><font size=+1>tcl></font></tt>
<p><font size=+1>A script can stop its run with the exit command:</font>
<p><tt><font size=+1>exit 1&nbsp; <b>;# stop script with exit code 1</b></font></tt>
<br>&nbsp;
<p><font size=+1>Tcl has powerful list procedures. A list is a string with
separate entries. Tcl uses {...} to separate each entry if more than one
space character is in it.</font>
<p><b><tt><font size=+1># define a list with 3 entries</font></tt></b>
<br><tt><font size=+1>set list "hello you {&nbsp;&nbsp;&nbsp;&nbsp; out
there }"</font></tt>
<p><b><tt><font size=+1># show list entry no. 3</font></tt></b>
<br><tt><font size=+1>puts [ lindex $list 2 ]&nbsp;&nbsp; ;# start from
"0"</font></tt>
<p><tt>The output will look like follows:</tt>
<p><tt><font size=+1>>&nbsp;&nbsp; out there</font></tt>
<br>&nbsp;
<p><font size=+1>Here some primary list procedures:</font>
<p><tt><font size=+1>llength "abc d"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
returns "2"</b></font></tt>
<br><tt><font size=+1>lindex&nbsp; "a b c" 0&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
returns "a"</b></font></tt>
<br><tt><font size=+1>lrange&nbsp; "a b c" 0 1&nbsp;&nbsp;&nbsp; <b>;#
returns "a b"&nbsp;&nbsp; (sublist)</b></font></tt>
<br>&nbsp;
<p><font size=+1>put out whole list with the foreach command:</font>
<p><tt><font size=+1>foreach elem $list {</font></tt>
<br><tt><font size=+1>&nbsp; puts $elem</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>>hello</font></tt>
<br><tt><font size=+1>>you</font></tt>
<br><tt><font size=+1>>&nbsp;&nbsp; out there</font></tt>
<br>
<hr WIDTH="100%">
<br><a NAME="TCL - manipulate lists"></a>
<pre><font size=+1>Procedures to manipulate lists</font></pre>

<p><br><font size=+1>append a list to another:</font>
<p><tt><font size=+1>set new_list [ concat $list $list]</font></tt>
<br>&nbsp;
<p><font size=+1>print out the new list:</font>
<p><tt><font size=+1>puts $new_list</font></tt>
<br><tt><font size=+1>>hello you {&nbsp;&nbsp;&nbsp;&nbsp; out there }
hello you {&nbsp;&nbsp;&nbsp;&nbsp; out there }</font></tt>
<br>&nbsp;
<p><font size=+1>append element to list (this manipulates the list directly),
don't use the "$" sign</font>
<p><tt><font size=+1>lappend list "what's up"</font></tt>
<p><tt><font size=+1>puts $list</font></tt>
<br><tt><font size=+1>>hello you {&nbsp;&nbsp;&nbsp;&nbsp; out there }
{what's up}</font></tt>
<br>&nbsp;
<p><font size=+1>insert element into a list:</font>
<p><b><tt><font size=+1># 3 is the index of where the "." should be</font></tt></b>
<br><tt><font size=+1>linsert $list 3 "."</font></tt>
<br><tt><font size=+1>>hello you {&nbsp;&nbsp;&nbsp;&nbsp; out there }
. {what's up}</font></tt>
<br>&nbsp;
<p><font size=+1>replace one or more elements:</font>
<p><tt><font size=+1># this replaces the elements 3 to 3 with !</font></tt>
<br><tt><font size=+1>lreplace $list 3 3 "!"</font></tt>
<br><tt><font size=+1>>hello you {&nbsp;&nbsp;&nbsp;&nbsp; out there }
! {what's up}</font></tt>
<br>&nbsp;
<p><font size=+1>search elements (wildcards are allowed until switch -exact):</font>
<p><tt><font size=+1>lsearch $list "?ou"&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
returns 2</b></font></tt>
<br><tt><font size=+1>lsearch -exact $list "you"&nbsp;&nbsp; <b>;# returns
2</b></font></tt>
<br>&nbsp;
<p><font size=+1>sort elements:</font>
<p><b><tt><font size=+1># sort switches are -integer -real -decreasing
-increasing</font></tt></b>
<p><tt><font size=+1>set list "1 5 6 4 3"</font></tt>
<p><tt><font size=+1>>lsort -increasing $list <b>;# (default)</b></font></tt>
<br><tt><font size=+1>1 3 4 5 6</font></tt>
<p><tt><font size=+1>>lsort -decreasing $list</font></tt>
<br><tt><font size=+1>6 5 4 3 1</font></tt>
<p><tt><font size=+1>> set list "1.5 1.3 1.4 2.3"</font></tt>
<br><tt><font size=+1>1.5 1.3 1.4 2.3</font></tt>
<p><tt><font size=+1>> lsort -real $list</font></tt>
<br><tt><font size=+1>1.3 1.4 1.5 2.3</font></tt>
<p><tt><font size=+1>> lsort -integer $list</font></tt>
<br><tt><font size=+1>expected integer but got "1.5"</font></tt>
<br>&nbsp;
<p><font size=+1>split and join lists:</font>
<p><tt><font size=+1>split "1:2:3:4" ":"</font></tt>
<br><tt><font size=+1>>1 2 3 4</font></tt>
<p><tt><font size=+1>join "1 2 3 4 ":"</font></tt>
<br><tt><font size=+1>>1:2:3:4</font></tt>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - Srings"></a>
<pre><font size=+1>String procedures</font></pre>
<b><tt><font size=+1># example for string compare</font></tt></b>
<br><tt><font size=+1>if { [ string compare "ja" "ja" ] == 0 } {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; puts "strings are equal"</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><b><tt><font size=+1># other commands</font></tt></b>
<br><tt><font size=+1>string compare&nbsp;&nbsp; $a&nbsp;&nbsp;&nbsp;&nbsp;
$b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
compare strings</b></font></tt>
<br><tt><font size=+1>string first&nbsp;&nbsp;&nbsp;&nbsp; "uu"&nbsp;&nbsp;
"uunet.uu"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;# result 0 (first
positon of "uu")</b></font></tt>
<br><tt><font size=+1>string last&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "uu"&nbsp;&nbsp;
"uunet.uu"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;# result 6 (last
position of "uu")</b></font></tt>
<br><tt><font size=+1>string length&nbsp;&nbsp;&nbsp; "foo"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>
;# result 3</b></font></tt>
<br><tt><font size=+1>string index&nbsp;&nbsp;&nbsp;&nbsp; "foo"&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>
;# result o</b></font></tt>
<br><tt><font size=+1>string range&nbsp;&nbsp;&nbsp;&nbsp; "foo"&nbsp;
1 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>
;# result oo</b></font></tt>
<br><tt><font size=+1>string tolower&nbsp;&nbsp; "FOO"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>
;# result foo</b></font></tt>
<br><tt><font size=+1>string toupper&nbsp;&nbsp; "foo"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>;# result FOO</b></font></tt>
<br><tt><font size=+1>string trim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;
foo&nbsp;&nbsp;&nbsp;&nbsp; do&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>
;# result "foo&nbsp;&nbsp;&nbsp;&nbsp; do"</b></font></tt>
<br><tt><font size=+1>string trimleft&nbsp; "&nbsp; foo&nbsp;&nbsp;&nbsp;&nbsp;
do&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b> ;# result
"foo&nbsp;&nbsp;&nbsp;&nbsp; do&nbsp;&nbsp; "</b></font></tt>
<br><tt><font size=+1>string trimright "&nbsp; foo&nbsp;&nbsp;&nbsp;&nbsp;
do&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b> ;# result
"&nbsp; foo&nbsp;&nbsp;&nbsp;&nbsp; do"</b></font></tt>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - Arrays"></a>
<pre><font size=+1>Arrays in Tcl</font></pre>
<font size=+1>Arrays in Tcl are variables with "(" ")" brackets behind
them. Here some examples:</font>
<p><tt><font size=+1>set uid(0) "root"</font></tt>
<br><tt><font size=+1>set uid(1) "mike"</font></tt>
<br><tt><font size=+1>set uid(2) "ralf"</font></tt>
<p><font size=+1>The term inside the brackets identifies the value and
can also be a string:</font>
<p><tt><font size=+1>set uid(root) "0"</font></tt>
<br><tt><font size=+1>set uid(mike) "1"</font></tt>
<p><font size=+1>Arrays can also have more dimensions:</font>
<p><tt><font size=+1>set user(name,0) "mike"</font></tt>
<br><tt><font size=+1>set user(name,1) "mike@balrog"</font></tt>
<p><font size=+1>Get the size of an array and more ...:</font>
<p><tt><font size=+1>array size user&nbsp;&nbsp;&nbsp; ;# returns "2"</font></tt>
<br><tt><font size=+1>array names user&nbsp;&nbsp; ;# returns "name,0 name,1"</font></tt>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - Info command"></a>
<pre><font size=+1>The info command</font></pre>
<font size=+1>With the info exists command you can find out if a variable
is visible in the local name space:</font>
<p><tt><font size=+1>info exists list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
returns 1</b></font></tt>
<br><tt><font size=+1>info exists something&nbsp;&nbsp;&nbsp; <b>;# returns
0</b></font></tt>
<p><font size=+1>More info commands (see man page for details) :</font>
<p><tt><font size=+1>info locals</font></tt>
<br><tt><font size=+1>info globals</font></tt>
<br><tt><font size=+1>info vars</font></tt>
<br><tt><font size=+1>info procs</font></tt>
<br><tt><font size=+1>info level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
returns the local name space level depth (0 = global level)</b></font></tt>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - Catch command"></a>
<pre><font size=+1>The catch command</font></pre>
<font size=+1>If a command error appears, Tcl has the default behavior
to terminate the script and show the error message including a stack trace.
The catch command is used to prevent abnormal script termination in case
of an error.</font>
<p><tt><font size=+1>set result [ catch { exec date } output ]</font></tt>
<p><font size=+1>catch returns 0 if the command between the "{}" brackets
completed correctly. Otherwise the result variable has the value 1. The
output variable will get the output of the command. So if the date program
is
not found the error information is stored in output and the script will
not terminate.</font>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - Procedure lists"></a>
<pre><font size=+1>Procedure lists</font></pre>
<font size=+1>It is possible to store procedure names in a list and call
the procedure referenced in the variable value. The eval command is useful
to hack up procedure calls with arguments (e.g. "test 4") in single arguments.</font>
<p><tt><font size=+1>set my_procedures "{test 4} testit"</font></tt>
<p><tt><font size=+1>eval [lindex $my_procedures 0]&nbsp;&nbsp;&nbsp; <b>;#
call test procedure</b></font></tt>
<br><tt><font size=+1>[lindex $my_procedures 1]&nbsp;&nbsp;&nbsp; <b>;#
call testit procedure (without arguments)</b></font></tt>
<br>
<hr WIDTH="100%">
<br><a NAME="TCL - upvar command"></a>
<pre><font size=+1>The upvar command</font></pre>
<font size=+1>The upvar command is used to have access to one of the callers
variable name space.</font>
<p><tt><font size=+1>proc print_name {} {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; upvar name l_name</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp; puts $l_name</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>set name "hello world!"</font></tt>
<br><tt><font size=+1>print_name</font></tt>
<p><tt><font size=+1>>hello_world</font></tt>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - file IO"></a>
<pre><font size=+1>File I/O in Tcl</font></pre>
<b><tt><font size=+1># write in file</font></tt></b>
<br><tt><font size=+1>set save_list "lothar joachim andy"</font></tt>
<br><tt><font size=+1>set output [open "file" "w"]</font></tt>
<br><tt><font size=+1>puts $output "$save_list"</font></tt>
<br><tt><font size=+1>flush $output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>;# write output immediately to file</b></font></tt>
<br><tt><font size=+1>close $output</font></tt>
<p><b><tt><font size=+1># read from file</font></tt></b>
<br><tt><font size=+1>set input [open "file" "r"]</font></tt>
<br><tt><font size=+1>gets $input load_list&nbsp;&nbsp;&nbsp;&nbsp; <b>;#
returns number of bytes read</b></font></tt>
<br><tt><font size=+1>close $input</font></tt>
<br><tt><font size=+1>puts $load_list</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># look for end of file</font></tt></b>
<br><tt><font size=+1>while { [eof $input] != 1 }&nbsp;&nbsp;&nbsp; <b>;#
eof returns 1 if end of file is reached</b></font></tt>
<p><b><tt><font size=+1># get file names in local directory</font></tt></b>
<br><tt><font size=+1>tcl> glob *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>;# returns all files matching * (each file)</b></font></tt>
<br><tt><font size=+1>CVS check.exp readme.txt checktree remoteinstall.csh
results</font></tt>
<p><tt><font size=+1>tcl>glob *.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>;# returns only readme.txt</b></font></tt>
<br><tt><font size=+1>readme.txt</font></tt>
<p>
<hr WIDTH="100%">
<br><a NAME="TCL - other file commands"></a>
<pre><font size=+1>Other useful file commands:</font></pre>
<tt><font size=+1>file dirname&nbsp;&nbsp; "/usr/local/bin/xterm" <b>;#
returns "/usr/local/bin"</b></font></tt>
<br><tt><font size=+1>file tail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/usr/local/bin/xterm"
<b>;#
returns "xterm"</b></font></tt>
<br><tt><font size=+1>file extension "/usr/local/bin/settings.csh" <b>;#
returns ".csh"</b></font></tt>
<br><tt><font size=+1>file rootname&nbsp; "/usr/local/bin/settings.csh"
<b>;#
returns "/usr/local/bin/settings"</b></font></tt>
<p><tt><font size=+1>file isdirectory "results"&nbsp;&nbsp;&nbsp; <b>;#
returns 1 if "results" is a directory, else 0</b></font></tt>
<br><tt><font size=+1>file isfile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "readme.txt"
<b>;#
returns 1 if file , else 0</b></font></tt>
<br><tt><font size=+1>file executable&nbsp; <b>#; for more information
look at the man pages ....</b></font></tt>
<br><tt><font size=+1>file exists</font></tt>
<br><tt><font size=+1>file owned</font></tt>
<br><tt><font size=+1>file readable</font></tt>
<br><tt><font size=+1>file writeable</font></tt>
<br><tt><font size=+1>file size</font></tt>
<br><tt><font size=+1>file atime</font></tt>
<br><tt><font size=+1>file mtime</font></tt>
<br><tt><font size=+1>file type</font></tt>
<br><tt><font size=+1>file readlink</font></tt>
<br><tt><font size=+1>file stat</font></tt>
<br><tt><font size=+1>file lstat</font></tt>
<br>
<hr WIDTH="100%">
<br><a NAME="TCL - Environment variables"></a>
<pre><font size=+1>Access to the environment variables in Tcl</font></pre>
<font size=+1>The user's environment variables are stored in the array
"env":</font>
<p><tt><font size=+1>proc print_PATH {} {</font></tt>
<p><tt><font size=+1>&nbsp; global env</font></tt>
<p><tt><font size=+1>&nbsp; puts [set env(PATH)]&nbsp;&nbsp;<b> ;# a call
to set VARIABLE without a value will just</b></font></tt>
<br><tt><font size=+1>&nbsp;<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;# return the content of VARIABLE!</b></font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>;# [set env(PATH)] is equal to $env(PATH)</b></font></tt>
<p><tt><font size=+1>}</font></tt>
<p><b><tt><font size=+1>#get a list of all set environment variables:</font></tt></b>
<br><tt><font size=+1>set local_environment [array names env]</font></tt>
<p><b><tt><font size=+1>#show each value</font></tt></b>
<br><tt><font size=+1>foreach elem $local_environment {</font></tt>
<br><tt><font size=+1>&nbsp; puts "$elem is set to [set env($elem)]"</font></tt>
<br><tt><font size=+1>}</font></tt>
<p><tt><font size=+1>>SGE_ROOT is set to /homedir/myusername/test/v502a</font></tt>
<br><tt><font size=+1>>LD_LIBRARY_PATH is set to /usr/sgitcl/lib</font></tt>
<br><tt><font size=+1>>...</font></tt>
<p><b><tt><font size=+1>#set or change the value of an environment variable</font></tt></b>
<br><tt><font size=+1>set env(PATH) ".:[set env(PATH)]"&nbsp;<b>&nbsp;
;# prepend current directory</b></font></tt>
<br>&nbsp;
<p>
<hr WIDTH="100%"><a NAME="About Expect"></a>
<h1>
About Expect</h1>

<p><br><font size=+1>The testsuite uses the tcl extensions from the expect
toolkit. Important are the commands spawn (start an application), expect
(wait for special output from the application) and send (send input to
the application).</font>
<p><font size=+1>To start an application under the control of expect use
the following procedures:</font>
<p><font size=+1>- proc open_spawn_process {args}</font>
<p><font size=+1>and</font>
<p><font size=+1>- proc close_spawn_process { id }</font>
<br>&nbsp;
<p><font size=+1>Here is a small example of how to use these procedures:</font>
<p><tt><font size=+1>proc addqueue {} {</font></tt>
<br><tt><font size=+1>&nbsp; global CHECK_INSTALLED_SYSTEM CHECK_ARCH CHECK_HOST
env</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># set default EDITOR environment to vi (qconf will
start the $EDITOR application)</font></tt></b>
<br><tt><font size=+1>&nbsp; set env(EDITOR) "vi"</font></tt>
<br><tt><font size=+1>&nbsp; set id [ open_spawn_process "$CHECK_INSTALLED_SYSTEM/bin/$CHECK_ARCH/qconf"
"-aq"]</font></tt>
<br><tt><font size=+1>&nbsp; set timeout 30&nbsp;&nbsp; ;# wait max. 30
seconds for qconf's vi start</font></tt>
<br><tt><font size=+1>&nbsp; expect ".*"</font></tt>
<br>&nbsp;
<p><b><tt><font size=+1># now we can send some vi commands (qconf is starting
the vi):</font></tt></b>
<br><tt><font size=+1>&nbsp; send ":%s/qname.*template.*$/qname&nbsp;&nbsp;
${CHECK_HOST}.qtest/\n"</font></tt>
<br><tt><font size=+1>&nbsp; send ":%s/hostname.*unknown.*$/hostname&nbsp;&nbsp;
$CHECK_HOST/\n"</font></tt>
<br><tt><font size=+1>&nbsp; send ":%s/load_thresholds.*np_load_avg.*$/load_thresholds&nbsp;&nbsp;
np_load_avg=5.00/\n"</font></tt>
<br><tt><font size=+1>&nbsp; send ":wq\n"</font></tt>
<p><tt><font size=+1>&nbsp; set timeout 30</font></tt>
<p><tt><font size=+1>&nbsp; expect {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeout {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set_error -1 "got timeout"</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "added*\"${CHECK_HOST}.qtest\""
{</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set_error 0 "no errors"</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "queue*exists" {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set_error -1 "queue \"${CHECK_HOST}.qtest\" already exists"</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default {</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set_error -1 "could not add queue"</font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt>
<br><tt><font size=+1>&nbsp; }</font></tt>
<p><tt><font size=+1>&nbsp; close_spawn_process $id</font></tt>
<br><tt><font size=+1>}</font></tt>
<p>
<hr WIDTH="100%">
<p><a NAME="Expect - Expect"></a>
<pre><font size=+1>expect</font></pre>
<font size=+1>Once an application is started with the open_spawn_process
procedure (calls spawn) you can scan the interactive output of the application
with the expect command. There are many special characters for pattern
searching ($ - end of line, ^ - beginning of line ["Exploring Expect" from
Don Libes, O'Reilly &amp; Associates, Inc., page 73 ff. ] describes this
in detail):</font>
<p><tt><font size=+1>expect "^log*\n"&nbsp;&nbsp;&nbsp; <b>;# look for
"log" at beginning of the line followed by</b></font></tt>
<br><tt><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>;# arbitrary characters and a closing "\n"</b></font></tt>
<br>&nbsp;
<p><font size=+1>The expect call above returns when the application outputs
something like that:</font>
<p><tt><font size=+1>time:&nbsp; 19</font></tt>
<br><tt><font size=+1>login: tom</font></tt>
<br><tt><font size=+1>usage: 12</font></tt>
<p><font size=+1>When expect gets the second line ("login: tom\n") the
expect command returns and the tcl script will continue. All output of
the application is stored in the variable expect_out(buffer). All output
that matched the expected pattern is stored in the variable expect_out(0,string).
Please refer to the man pages of expect for more information.</font>
<p><font size=+1>The timeout variable is useful to interrupt a not matching
expression. If timeout is set to a value greater than "0" the expect call
will return after $timeout seconds. "-1" means no timeout and "0" returns
immediately. timeout is also a keyword for an expect { } case segment.</font>
<p><font size=+1>Other keywords for the expect {} case segment:</font>
<p><font size=+1>timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - perform timeout
specific action</font>
<br><font size=+1>eof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- perform action on end of file (application terminates)</font>
<br><font size=+1>default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - perform
default action</font>
<br>
<hr WIDTH="100%">
<br><a NAME="Expect - send"></a>
<pre><font size=+1>send</font></pre>

<p><br><font size=+1>If it is neccessary to reply to an application the
send command is used. The example above sends some vi command strings.</font>
<br>&nbsp;
<br>&nbsp;
<p>
<hr WIDTH="100%"><a NAME="Implementation Approach"></a>
<br>&nbsp;
<h1>
Implementation approach</h1>

<p><br><font size=+1>In this chapter a simple test is developed and integrated
into the testsuite. The first thing to do is to find the correct position
for the test in the "checktree". If no test category ("functional", "install_core_system",
"performance", "system_tests") is matching a new directory must be created:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">[40] pwd</font></tt>
<br><tt><font color="#FFFFFF">/homedir/myusername/src/testsuite/checktree</font></tt>
<br><tt><font color="#FFFFFF">[41] mkdir practice</font></tt>
<br><tt><font color="#FFFFFF">[42] ls</font></tt>
<br><tt><font color="#FFFFFF">CVS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install_core_system&nbsp; practice</font></tt>
<br><tt><font color="#FFFFFF">functional&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
performance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; system_tests</font></tt>
<br><tt><font color="#FFFFFF">[43] cd practice/</font></tt>
<br><tt><font color="#FFFFFF">[45] mkdir simple</font></tt>
<br><tt><font color="#FFFFFF">[47] cd simple</font></tt>
<br><tt><font color="#FFFFFF">[49] vi check.exp</font></tt></td>
</tr>
</table></center>

<p><font size=+1>A "check.exp" file must define some global variables:</font>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#FFFFFF" NOSAVE >
<tr NOSAVE>
<td NOSAVE><b><tt><font color="#3333FF"># define global variable in this
namespace</font></tt></b>
<br><tt><b>global</b> check_name</tt>
<br><tt><b>global</b> check_description</tt>
<br><tt><b>global</b> check_needs</tt>
<br><tt><b>global</b> check_functions</tt>
<br><tt><b>global</b> check_errno</tt>
<br><tt><b>global</b> check_errstr</tt>
<br><tt><b>global</b> check_highest_level</tt>
<br><tt><b>global</b> check_init_level_procedure</tt>
<br><tt><b>global</b> check_root_access_needs</tt>
<br>&nbsp;
<p><b><tt><font color="#3333FF"># no, we don't need rood access</font></tt></b>
<br><tt><b>set</b> check_root_access_needs <font color="#CC0000">""</font></tt>
<p><b><tt><font color="#3333FF"># define a level initialization procedure:</font></tt></b>
<br><tt><b>set</b> check_init_level_procedure <font color="#CC0000">"init_level"</font></tt>
<p><b><tt><font color="#3333FF"># define test's name and run level descriptions</font></tt></b>
<br><tt><b>set</b> check_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"simple_test"</font></tt>
<br><tt><b>set</b> check_highest_level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#3333FF">5</font></tt>
<br><tt><b>set</b> check_description(0)&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"default
runlevel test"</font>&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#3333FF">;#
run level 0 description</font></b></tt>
<br><tt><b>set</b> check_description(5)&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"another
simple dummy test"</font> <b><font color="#3333FF">;# run level 5 description</font></b></tt>
<p><b><tt><font color="#3333FF"># define test's dependencies</font></tt></b>
<br><tt><b>set</b> check_needs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">""
</font><b><font color="#3333FF">;#
just a list of "check_name" names of other test</font></b></tt>
<p><b><tt><font color="#3333FF"># define test's procedure order</font></tt></b>
<br><tt><b>set</b> check_functions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"create_file"</font></tt>
<br><tt><b>lappend</b> check_functions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"check_time"</font></tt></td>
</tr>
</table></center>

<p><font size=+1>The example above defines a test which has a run level
initialization procedure ("init_level"), two run levels (0 and 5), without
any dependencies and two test procedures ("create_file" and "check_time").</font>
<p><font size=+1>The test programmer has to implement now the three procedures
"init_level", "create_file" and "check_time".</font>
<br>&nbsp;
<p><b><i><u><font size=+1>Procedure "init_level":</font></u></i></b>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#FFFFFF" NOSAVE >
<tr NOSAVE>
<td NOSAVE><b><tt><font color="#3333FF"># test's own globals:</font></tt></b>
<br><tt><b>global</b> sleep_time</tt>
<p><b><tt><font color="#3333FF"># run level initialization</font></tt></b>
<br><tt><b>proc</b> init_level {} {</tt>
<br><tt>&nbsp; <b>global</b> CHECK_ACT_LEVEL sleep_time</tt>
<p><tt>&nbsp; <b>switch</b> -- $CHECK_ACT_LEVEL {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"0"</font> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>set</b> sleep_time
<font color="#3333FF">10
<b>;#
run level 0</b></font></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#CC0000">"5"</font> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>set</b> sleep_time
<font color="#3333FF">60<b>;#
run level 5</b></font></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; <b>return</b> -1&nbsp; <b><font color="#3333FF">;# no other
level</font></b></tt>
<br><tt>}</tt></td>
</tr>
</table></center>

<p><font size=+1>The procedure is called before any other "check_function".
It will return the value "0" if the current level is supported. Otherwise
the procedure returns "-1". The global variable "sleep_time" is set to
"10" in run level "0" and to "60" in run level "5". The main test procedures
(listed in the global "check_function") will use the "sleep_time" variable.</font>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><b><i><u><font size=+1>Procedure "create_file":</font></u></i></b>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#FFFFFF" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><b><font color="#330000">proc</font></b> create_file {}
{</tt>
<p><tt>&nbsp;&nbsp; <b>global</b> sleep_time CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT</tt>
<br>&nbsp;
<p><tt>&nbsp;&nbsp; <b>puts</b> $CHECK_OUTPUT <font color="#CC0000">"writing
file ..."</font></tt>
<p><tt>&nbsp;&nbsp; <b><font color="#3333FF"># get unix timestamp</font></b></tt>
<br><tt>&nbsp;&nbsp; <b>set</b> actual_time [timestamp]</tt>
<p><tt>&nbsp;&nbsp; <b><font color="#3333FF"># open file "testfile" in
current testpath for writing</font></b></tt>
<br><tt>&nbsp;&nbsp; <b>if</b> { [ catch { open <font color="#CC0000">"$CHECK_ACTUAL_TEST_PATH/testfile"
"w"</font> } file ] != 0 } {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_error -2 <font color="#CC0000">"can't
open file for writing"</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b></tt>
<br><tt>&nbsp;&nbsp; }</tt>
<p><tt><font color="#3333FF">&nbsp;&nbsp;<b> # write timestamp into file</b></font></tt>
<br><tt>&nbsp;&nbsp; <b>puts</b> $file $actual_time</tt>
<p><tt>&nbsp;<font color="#3333FF">&nbsp;<b> # close file</b></font></tt>
<br><tt>&nbsp;&nbsp; <b>close</b> $file</tt>
<br>&nbsp;
<p><tt>&nbsp;&nbsp; <b>puts</b> $CHECK_OUTPUT <font color="#CC0000">"sleeping
$sleep_time seconds ..."</font></tt>
<p><tt><font color="#3333FF">&nbsp;&nbsp; <b># wait time for this level</b></font></tt>
<br><tt>&nbsp;&nbsp; sleep $sleep_time</tt>
<p><tt>&nbsp;&nbsp; set_error 0 <font color="#CC0000">"no errors"</font></tt>
<br><tt>}</tt>
<br>&nbsp;</td>
</tr>
</table></center>

<p><font size=+1>This procedure opens a file in the current checktree path
and writes the actual unix time stamp in it. If an error occurs in the
file open process the procedure will set the check_errstr state to -2 (
failed, stop ) and return. After writing the file it will sleep the number
of seconds defined for this run level and return the check_errstr state
0 (no error).</font>
<br>&nbsp;
<p><b><i><u><font size=+1>Procedure "check_time"</font></u></i></b>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#FFFFFF" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><b>proc</b> check_time {} {</tt>
<br><tt>&nbsp;&nbsp; <b>global</b> sleep_time CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT</tt>
<p><tt>&nbsp;&nbsp; <b>puts</b> $CHECK_OUTPUT <font color="#CC0000">"reading
file ..."</font></tt>
<p><tt>&nbsp;<font color="#3333FF">&nbsp; <b># open file "testfile" in
current testpath for reading</b></font></tt>
<br><tt>&nbsp;&nbsp; <b>if</b> { [ catch { open <font color="#CC0000">"$CHECK_ACTUAL_TEST_PATH/testfile"
"r"</font> } file ] != 0 } {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_error -2 <font color="#CC0000">"can't
open file for reading"</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b></tt>
<br><tt>&nbsp;&nbsp; }</tt>
<p><tt>&nbsp;&nbsp;<font color="#3333FF"> <b># timestamp from file</b></font></tt>
<br><tt>&nbsp;&nbsp; <b>gets</b> $file write_time</tt>
<p><tt>&nbsp;<font color="#3333FF">&nbsp; <b># close file</b></font></tt>
<br><tt>&nbsp;&nbsp; <b>close</b> $file</tt>
<p><tt>&nbsp;<font color="#3333FF">&nbsp; <b># get unix timestamp</b></font></tt>
<br><tt>&nbsp;&nbsp; <b>set</b> actual_time [timestamp]</tt>
<p><tt>&nbsp;&nbsp; <b>puts</b> $CHECK_OUTPUT <font color="#CC0000">"write_time:
$write_time"</font></tt>
<br><tt>&nbsp;&nbsp; <b>puts</b> $CHECK_OUTPUT <font color="#CC0000">"actual_time:
$actual_time"</font></tt>
<p><tt><font color="#3333FF">&nbsp;&nbsp; <b># set test results</b></font></tt>
<br><tt>&nbsp;&nbsp; set_error 0 <font color="#CC0000">"no errors"</font></tt>
<br><tt>&nbsp;&nbsp; <b>if</b> { [ expr ( $actual_time - $write_time )
]&nbsp; &lt; $sleep_time } {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_error -1 <font color="#CC0000">"time
error"</font></tt>
<br><tt>&nbsp;&nbsp; }</tt>
<br><tt>}</tt></td>
</tr>
</table></center>

<p><font size=+1>This procedure will reopen the file written by the procedure
"create_file" and store the content into the variable "write_time". It
also gets the "actual_time" by calling tcl's timestamp procedure. If the
timestamp in the file is younger than the actual time the check_errstr
state is set to -1 (error, continue).</font>
<br>&nbsp;
<br>&nbsp;
<p><b><i><u><font size=+1>Start the new "check.exp" test</font></u></i></b>
<p><font size=+1>To start the new test the subdirectory "../checktree/practice/simple"
has to be the current working directory. Selecting "run local test" will
start one testrun with all the enabled run levels. The output should look
like this:</font>
<br>&nbsp;
<center><table BORDER COLS=1 WIDTH="80%" BGCOLOR="#330000" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt><font color="#FFFFFF">12</font></tt>
<br><tt><font color="#FFFFFF">running local test ...</font></tt>
<br><tt><font color="#FFFFFF">----------------------------------------------</font></tt>
<p><tt><font color="#FFFFFF">checking dependencies of "simple_test" in
"/homedir/myusername/src/testsuite/checktree/practice/simple" ...</font></tt>
<br>&nbsp;
<p><tt><font color="#FFFFFF">-> enter check level 0</font></tt>
<br><tt><font color="#FFFFFF">-> lock_testsuite: pid=25935 host=MYHOSTNAME
user=myusername</font></tt>
<br><tt><font color="#FFFFFF">waiting for lock ...</font></tt>
<br><tt><font color="#FFFFFF">new lockfile written! Testing for correct
lock ...</font></tt>
<br><tt><font color="#FFFFFF">waiting to get lock</font></tt>
<br><tt><font color="#FFFFFF">file size is: 18</font></tt>
<br><tt><font color="#FFFFFF">waiting to get lock</font></tt>
<br><tt><font color="#FFFFFF">file size is: 18</font></tt>
<br><tt><font color="#FFFFFF">lock success!</font></tt>
<br><tt><font color="#FFFFFF">OK - starting test functions (runlevel is
0)...</font></tt>
<p><tt><font color="#FFFFFF">calling init level function "init_level" ...</font></tt>
<p><tt><font color="#FFFFFF">starting function "create_file" in runlevel
0</font></tt>
<br><tt><font color="#FFFFFF">writing file ...</font></tt>
<br><tt><font color="#FFFFFF">sleeping 10 seconds ...</font></tt>
<br><tt><font color="#FFFFFF">status:&nbsp; procedure create_file: no errors</font></tt>
<p><tt><font color="#FFFFFF">starting function "check_time" in runlevel
0</font></tt>
<br><tt><font color="#FFFFFF">reading file ...</font></tt>
<br><tt><font color="#FFFFFF">write_time: 963924383</font></tt>
<br><tt><font color="#FFFFFF">actual_time: 963924393</font></tt>
<br><tt><font color="#FFFFFF">status:&nbsp; procedure check_time: no errors</font></tt>
<br><tt><font color="#FFFFFF">S U C C E S S F U L L Y performed "simple_test"
in run level 0 !</font></tt>
<br><tt><font color="#FFFFFF">saving results for simple_test (level 0)
...</font></tt>
<br><tt><font color="#FFFFFF">/homedir/myusername/src/testsuite/results/MYHOSTNAME.completed</font></tt>
<br><tt><font color="#FFFFFF">/homedir/myusername/src/testsuite/results/MYHOSTNAME.uncompleted</font></tt>
<br><tt><font color="#FFFFFF">testsuite unlocked!</font></tt>
<br>&nbsp;
<p><tt><font color="#FFFFFF">-> enter check level 5</font></tt>
<br><tt><font color="#FFFFFF">-> lock_testsuite: pid=25935 host=MYHOSTNAME
user=myusername</font></tt>
<br><tt><font color="#FFFFFF">waiting for lock ...</font></tt>
<br><tt><font color="#FFFFFF">new lockfile written! Testing for correct
lock ...</font></tt>
<br><tt><font color="#FFFFFF">waiting to get lock</font></tt>
<br><tt><font color="#FFFFFF">file size is: 18</font></tt>
<br><tt><font color="#FFFFFF">waiting to get lock</font></tt>
<br><tt><font color="#FFFFFF">file size is: 18</font></tt>
<br><tt><font color="#FFFFFF">lock success!</font></tt>
<br><tt><font color="#FFFFFF">OK - starting test functions (runlevel is
5)...</font></tt>
<p><tt><font color="#FFFFFF">calling init level function "init_level" ...</font></tt>
<p><tt><font color="#FFFFFF">starting function "create_file" in runlevel
5</font></tt>
<br><tt><font color="#FFFFFF">writing file ...</font></tt>
<br><tt><font color="#FFFFFF">sleeping 60 seconds ...</font></tt>
<br><tt><font color="#FFFFFF">status:&nbsp; procedure create_file: no errors</font></tt>
<p><tt><font color="#FFFFFF">starting function "check_time" in runlevel
5</font></tt>
<br><tt><font color="#FFFFFF">reading file ...</font></tt>
<br><tt><font color="#FFFFFF">write_time: 963924410</font></tt>
<br><tt><font color="#FFFFFF">actual_time: 963924470</font></tt>
<br><tt><font color="#FFFFFF">status:&nbsp; procedure check_time: no errors</font></tt>
<br><tt><font color="#FFFFFF">S U C C E S S F U L L Y performed "simple_test"
in run level 5 !</font></tt>
<br><tt><font color="#FFFFFF">saving results for simple_test (level 5)
...</font></tt>
<br><tt><font color="#FFFFFF">/homedir/myusername/src/testsuite/results/MYHOSTNAME.completed</font></tt>
<br><tt><font color="#FFFFFF">/homedir/myusername/src/testsuite/results/MYHOSTNAME.uncompleted</font></tt>
<br><tt><font color="#FFFFFF">testsuite unlocked!</font></tt>
<p><tt><font color="#FFFFFF">press enter...</font></tt></td>
</tr>
</table></center>

<br>&nbsp;
<p>
<hr WIDTH="100%">
<center>
<p>Copyright 2001 Sun Microsystems, Inc. All rights reserved.</center>

</body>
</html>
