#!/vol2/TCL_TK/glinux/bin/expect
# ___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2006 by Sun Microsystems, Inc
#
#  All Rights Reserved.
#
##########################################################################
# ___INFO__MARK_END__


# source version dependent parts of the installation
global CHECK_ACTUAL_TEST_PATH CHECK_TESTSUITE_INSTALL_MODE

global check_name check_description check_needs check_functions
global check_root_access_needs check_category      
global check_use_installed_system check_init_level_procedure

# This file shows some check spezific things
set check_root_access_needs      "yes"
set check_name                   "hedeby_install"
set check_category               "INSTALL COMPATIBILITY SYSTEM L10N VERIFIED"
set check_description(0)         "install hedeby system components and start them up"
set check_needs                  "init_core_system"
set check_highest_level          0 
set check_init_level_procedure   "hedeby_install_init_level"
set check_functions              {}  ;# functions to call (in order)
set check_setup_function "hedeby_install_setup"
set check_cleanup_function "hedeby_install_cleanup"

lappend check_functions "hedeby_shutdown_system"
lappend check_functions "hedeby_remove_preferences"
lappend check_functions "hedeby_install_master_host"
lappend check_functions "hedeby_startup_master_host"
lappend check_functions "hedeby_install_managed_hosts"
lappend check_functions "hedeby_startup_managed_hosts"
lappend check_functions "hedeby_add_ge_services"
lappend check_functions "hedeby_startup_ge_services"
lappend check_functions "hedeby_add_spare_pool_resources"
lappend check_functions "hedeby_check_resources"
lappend check_functions "hedeby_check_services"



# ---------------------------------------------------------------------------------
# here the tests begin ....

global install_current_cluster_config

proc hedeby_install_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" {
         return 0
      }
   }
   return -1
}

proc hedeby_install_setup {} {
   global CHECK_OUTPUT
   global install_current_cluster_config
   global install_user

   set install_current_cluster_config [get_current_cluster_config_nr]

   set install_user [get_hedeby_startup_user]

   # print out system information:
   puts $CHECK_OUTPUT "======================================="
   puts $CHECK_OUTPUT "sys_name:          [get_hedeby_system_name]"
   puts $CHECK_OUTPUT "installation mode: [get_hedeby_pref_type]"
   puts $CHECK_OUTPUT "admin user:        [get_hedeby_admin_user]"
   puts $CHECK_OUTPUT "======================================="


}

proc hedeby_install_cleanup {} {
   global CHECK_OUTPUT
   global install_current_cluster_config 

   # set the current cluster config to the one used when starting
   # the test
   set_current_cluster_config_nr $install_current_cluster_config
}


proc hedeby_add_spare_pool_resources {} {
   global hedeby_config
   global CHECK_OUTPUT 
   global CHECK_USER

   foreach host $hedeby_config(hedeby_host_resources) {
      set exit_state [add_host_resource $host "spare_pool"]
      ts_log_fine "exit_state: $exit_state"
   }
}

proc hedeby_check_services {} {
   global hedeby_config

   # set timeout for this check
   set mytimeout [timestamp]
   incr mytimeout 60  ;# 60 seconds

   set ge_hosts [get_hedeby_default_services service_names]
   set s_names {}
   foreach geh $ge_hosts {
      lappend s_names $service_names(service,$geh)
   }
   set error_text ""
   # now set expected service states
   set expected_service_states "RUNNING"
   set expected_component_states "STARTED"
   lappend s_names "spare_pool"
   set service_names(master_host,spare_pool) $hedeby_config(hedeby_master_host)

   while { [timestamp] < $mytimeout } {
      ts_log_fine "obtaining service information ..."
      set ret [get_service_info]
      if {$ret != 0} {
         ts_log_severe "get_service_info() returned $ret"
         return
      }

      # now check the service states
      set error_text ""
      foreach service $s_names {

         # check service availability
         ts_log_fine "checking service \"$service\" ..."
         if {[lsearch $service_info(service_list) $service] < 0} {
            append error_text "Service \"$service\" not found!\n"
            ts_log_fine "   service not found!"
         } else {
            ts_log_fine "   service found!"
         }
         # ceck component state
         if {[info exists service_info($service,cstate)]} {
            if {$service_info($service,cstate) != $expected_component_states} {
               append error_text "Service \"$service\" component state is \"$service_info($service,cstate)\""
               append error_text ", should be \"$expected_component_states\"\n"
               ts_log_fine "   component state \"$service_info($service,cstate)\" - error"
            } else {
               ts_log_fine "   component state \"$service_info($service,cstate)\" - ok"
            }
         } else {
            append error_text "cannot get component state for service \"$service\"\n"
            ts_log_fine "cannot get component state for service \"$service\""
         }

         # check service host
         if {[info exists service_info($service,host)]} {
            set service_info_host [resolve_host $service_info($service,host)]
            set expected_host $service_names(master_host,$service)
            if {$service_info_host != $expected_host} {
               append error_text "Service \"$service\" is running on host \"$service_info_host\""
               append error_text ", should be \"$expected_host\"\n"
               ts_log_fine "   is running on host \"$service_info_host\" - error"
            } else {
               ts_log_fine "   is running on host \"$service_info_host\" - ok"
            }
         } else {
            append error_text "cannot get host for service \"$service\"\n"
            ts_log_fine "cannot get host for service \"$service\""
         }

         # check service state
         if {[info exists service_info($service,sstate)]} {
            if {$service_info($service,sstate) != $expected_service_states} {
               append error_text "Service \"$service\" service state is \"$service_info($service,sstate)\""
               append error_text ", should be \"$expected_service_states\"\n"
               ts_log_fine "   service state \"$service_info($service,sstate)\" - error"
            } else {
               ts_log_fine "   service state \"$service_info($service,sstate)\" - ok"
            }
         } else {
            append error_text "cannot get service state for service \"$service\"\n"
            ts_log_fine "cannot get service state for service \"$service\""
         }


      }
      if {$error_text == ""} {
         break  ;# fine no errors skip timeout loop
      }
      after 1000
      ts_log_fine "retry"
   }
   if {$error_text != ""} {
      append error_text "timeout waiting for correct service information!\n"
      ts_log_severe $error_text
   }
}

proc hedeby_check_resources {} {
   global hedeby_config
   global CHECK_OUTPUT 
   global CHECK_USER

   set ret [get_resource_info]
   if {$ret != 0} {
      ts_log_severe "get_resource_info() returned $ret"
      return
   }

   if {[llength $res_list_not_uniq] > 0} {
      ts_log_severe "got not ambiguous resources"
      return
   }

   set ge_hosts [get_hedeby_default_services service_names]

   set error_text ""
   foreach res $res_list {
      ts_log_fine "checking resource \"$res\" ..."
     
      # check if we have more than one entry in lists
      if {[llength $res_info($res,type)] != 1} {
         append error_text "resource \"$res\" flag list should contain 1 elem, but it has [llength $res_info($res,type)] (\"$res_info($res,type)\")\n"
      }

      
      # service
      set service [lindex $res_info($res,service) 0]
      ts_log_fine "   resource assigned to service \"$res_info($res,service)\""
      if {[info exists service_names(service,$res)]} {
         if { $service != $service_names(service,$res) } {
            append error_text "resource \"$res\" should be assigned to \"$service_names(service,$res)\" but is assigned to \"$service\"\n"
         }
      } else {
         # it might be an execd or spare_pool
         if {[info exists service_names(execd_hosts,$service)]} {
            # must be execd
            set execd_list $service_names(execd_hosts,$service)
            if {[lsearch -exact $execd_list $res] < 0} {
               append error_text "wrong assignment of resource \"$res\" to service \"$service\"\n"
            } else {
               ts_log_fine "   found resource \"$res\" in execd list of service \"$service\": $execd_list"
            }
         } else {
            # must be spare_pool
            if { $service != "spare_pool" } {
               append error_text "resource \"$res\" should be assigned to \"spare_pool\" but is assigned to \"$service\"\n"
            }
         }
      }

      # state ASSIGNED
      set state [lindex $res_info($res,state) 0]
      ts_log_fine "   resource has state \"$state\""
      if {$state != "ASSIGNED"} {
         append error_text "resource \"$res\" should have state \"ASSIGNED\" but it's state is \"$res_info($res,state)\"\n"
      }

      # flags "" or "S" (static) for services
      set flags [lindex $res_info($res,flags) 0]
      ts_log_fine "   resource has flags \"$flags\""
      if {[lsearch -exact $ge_hosts $res] >= 0} {
         # this is ge master host assume "S" for static flag
         if {$flags != "S"} {
            append error_text "resource \"$res\" should have flags \"S\", but it's flags are \"$res_info($res,flags)\"\n"
         }
      } else {
         # this is regular resource expect no flag
         if {$flags != ""} {
            append error_text "resource \"$res\" should have emty flags, but it's flags are \"$res_info($res,flags)\"\n"
         }
      }

   }
   if { $error_text != "" } {
      ts_log_severe $error_text
   }


   # test resource properties 
   # hardwareCpuArchitecture=x86
   # hardwareCpuCount=2
   # operatingSystemName=Linux
   # operatingSystemRelease=24
   # resourceHostname=sowa.germany.sun.com
   # resourceIPAddress=129.157.141.63

}



# TODO: startup rp_vm on the ge adapter hosts!
proc hedeby_startup_ge_services {} {
   global CHECK_OUTPUT
   global hedeby_config
   global install_user
   global install_current_cluster_config
 
   set pref_type [get_hedeby_pref_type]
   set sys_name [get_hedeby_system_name]
   set admin_user [get_hedeby_admin_user]

   set ge_hosts [get_hedeby_default_services service_names]
   ts_log_fine "got following GE hosts: $ge_hosts"
   set rp_vms_to_start {}
   foreach ge_host $ge_hosts {
      # master host has already running rp_vm
      if {$ge_host != $hedeby_config(hedeby_master_host)} {
         if {[lsearch -exact $rp_vms_to_start $ge_host] < 0} {
            lappend rp_vms_to_start $ge_host
         }
      } else {
         ts_log_fine "shutting down hedeby master host \"$ge_host\" ..."
         shutdown_hedeby_hosts "master" $ge_host $install_user 
         ts_log_fine "starting up hedeby master host \"$ge_host\" ..."
         startup_hedeby_hosts  "master" $ge_host $install_user

         # TODO: This does not work if component was added to running jvm !!!
         #ts_log_fine "starting component \"$service_names(service,$ge_host)\" on hedeby master host"
         #set sdmadm_command "-p $pref_type -s $sys_name suc -h $ge_host -c $service_names(service,$ge_host)"
         #sdmadm_command $ge_host [get_hedeby_admin_user] $sdmadm_command
      }
   }
   ts_log_fine "starting rp_vm on hosts: $rp_vms_to_start"

   foreach host $rp_vms_to_start {
      set task_info($host,expected_output) ""
      set task_info($host,sdmadm_command) "-p $pref_type -s $sys_name suj -j rp_vm"
   }
   start_parallel_sdmadm_command rp_vms_to_start [get_hedeby_admin_user] task_info
}


proc hedeby_add_ge_services {} {
   global hedeby_config
   global CHECK_OUTPUT CHECK_DEBUG_LEVEL
   global install_current_cluster_config
   global install_user

   # first calculate spooldirs
   set ge_hosts [get_hedeby_default_services service_names]
   set managed_host_list [get_all_hedeby_managed_hosts]
   foreach host $managed_host_list {
      if {[info exists service_names(ts_cluster_nr,$host)]} {
         # use spool dir for execds
         set ts_cluster_nr $service_names(ts_cluster_nr,$host)
         set_current_cluster_config_nr $ts_cluster_nr  
         set spool_dir [get_local_spool_dir $host "execd" 0]
         set_current_cluster_config_nr $install_current_cluster_config
      } else {
        # use spool dir for hedeby resources
         set spool_dir [get_local_spool_dir $host "execd" 0]
      }
      if { [info exists spool($spool_dir)] == 0 } {
         set spool($spool_dir) $host 
      } else {
         set spool($spool_dir) "$spool($spool_dir) $host"
      }
   }

   set spool_dirs [array names spool]
   foreach spd $spool_dirs {
      puts $CHECK_OUTPUT "spool dir \"$spd\" used for hosts \"$spool($spd)\""
   }
   

   # TODO: use -start option to startup ge services if possible
   set cluster 0
   set execute_user [get_hedeby_admin_user]
   while { [set_current_cluster_config_nr $cluster] == 0 } {
      get_current_cluster_config_array ts_config
      set host $ts_config(master_host)
      puts $CHECK_OUTPUT "adding GE service \"$ts_config(cluster_name)\" for cluster #$cluster on qmaster host \"$host\" ..."
      set arguments "-s [get_hedeby_system_name] ags -h $host -j rp_vm -s $ts_config(cluster_name)"
      set ispid [hedeby_mod_setup $host $execute_user $arguments error_text]

      set master_port $ts_config(commd_port)
      set execd_port $master_port
      incr execd_port 1
      set admin_user [get_hedeby_admin_user]

      set sequence {}
      lappend sequence "[format "%c" 27]" ;# ESC

      if {$ts_config(jmx_ssl) == "true"} {
         set hedeby_user [get_hedeby_admin_user]
         set keystore_file "/var/sgeCA/port${ts_config(commd_port)}/$ts_config(cell)/userkeys/$hedeby_user/keystore"
         ts_log_fine "using keystore file: \"$keystore_file\""
         lappend sequence ":%s#keystore=\"\"#keystore=\"$keystore_file\"#\n"
         lappend sequence ":%s/password=\"\"/password=\"$ts_config(jmx_ssl_keystore_pw)\"/\n"
      } else {
         lappend sequence ":%s/password=\"\"/password=\"password\"/\n"
         lappend sequence ":%s/keystore=\"\"/keystore=\"keystorefile\"/\n"
         ts_log_config "installing GE adapter without jmx_ssl not supported!"
      }
      lappend sequence ":%s/username=\"username\"/username=\"$admin_user\"/\n"
      lappend sequence ":%s/jmxPort=\"0\"/jmxPort=\"$ts_config(jmx_port)\"/\n"
      lappend sequence ":%s/execdPort=\"0\"/execdPort=\"$execd_port\"/\n"
      lappend sequence ":%s/masterPort=\"0\"/masterPort=\"$master_port\"/\n"
      lappend sequence ":%s/cell=\"default\"/cell=\"$ts_config(cell)\"/\n"
      set path [split $ts_config(product_root) {/}]
      set sge_root_val [join $path {\/}]
      lappend sequence ":%s/root=\"\"/root=\"$sge_root_val\"/\n"
      lappend sequence ":%s/clusterName=\"sge\"/clusterName=\"$ts_config(cluster_name)\"/\n"

      
#     now delete <slos>...</slos> and enter new slos
      lappend sequence "[format "%c" 27]" ;# ESC
      lappend sequence "/<common:slos>\n"
      lappend sequence "ma/<\\/common:slos>\n:'a,.d\n"
      lappend sequence "i"
      lappend sequence "<common:slos>\n"
      lappend sequence "<common:slo xsi:type=\"common:FixedUsageSLOConfig\" urgency=\"50\" name=\"fixed_usage\"/>\n"
      lappend sequence "</common:slos>\n"
      lappend sequence "[format "%c" 27]" ;# ESC


#     now we setup execd install settings (local spool dir filter)
      lappend sequence "/ge_adapter:execd\n"
      lappend sequence "ma/\\/>\n:'a,.d\n"
      lappend sequence "i"
      foreach spd $spool_dirs {
      #   puts $CHECK_OUTPUT "spool dir \"$spd\" used for hosts \"$spool($spd)\""
         lappend sequence "<ge_adapter:execd adminUsername=\"root\" defaultDomain=\"\" ignoreFQDN=\"true\" rcScript=\"false\" adminHost=\"true\"\n"
         lappend sequence "submitHost=\"true\" cleanupDefault=\"false\">\n"
         lappend sequence "<ge_adapter:filter>\n"
         set isFirst 1
         foreach host $spool($spd) {
            if { $isFirst == 0 } {
               lappend sequence " | "
            }
            lappend sequence "resourceHostname = \"$host\"\n"
            set isFirst 0
         }
         lappend sequence "</ge_adapter:filter>\n"
         lappend sequence "<ge_adapter:localSpoolDir>$spd</ge_adapter:localSpoolDir>\n"
         lappend sequence "</ge_adapter:execd>\n"
         lappend sequence "\n"
      }
      lappend sequence "[format "%c" 27]" ;# ESC

      hedeby_mod_sequence $ispid $sequence error_text
      set output [hedeby_mod_cleanup $ispid error_text]
      ts_log_fine "exit_status: $prg_exit_state"
      if { $prg_exit_state == 0 } {
         ts_log_fine "output: \n$output"
      }
      incr cluster 1
   }
   set_current_cluster_config_nr $install_current_cluster_config
}

proc hedeby_shutdown_system {} {
   # shutdown possible running system ...
   if { [shutdown_hedeby] != 0 } {
      add_proc_error "hedeby_shutdown_system" -2 "error shutting down hedeby system. skip hard here."
      return
   }
}

proc hedeby_remove_preferences {} {

   # remove system from preferences ... 
   #    we don't want a error reporting, because
   #    the system might not be installed at all
   remove_hedeby_preferences 0
}

proc hedeby_install_master_host {} {
   global CHECK_OUTPUT
   global hedeby_config
   global install_user
   global certificate_creation_time_on_master_host

   puts $CHECK_OUTPUT "installing hedeby master host on host \"$hedeby_config(hedeby_master_host)\""

   # first we make sure to work on the first cluster config
   set_current_cluster_config_nr 0
   get_current_cluster_config_array ts_config

   # now setup some basics ...
   # full path to sdmadm binary (script)
   set sdmadm_path [get_hedeby_binary_path "sdmadm" $install_user]

   # get distribution path
   set dist_path $hedeby_config(hedeby_product_root)

   # create and/or delete local spool directory for hedeby master host ...
   # (the spool_dir itself should not be existing)
   set spool_dir [cleanup_hedeby_local_spool_dir $hedeby_config(hedeby_master_host)]
   

   # get CS prot
   set cs_port $hedeby_config(hedeby_cs_port)

   set hedeby_system_name [get_hedeby_system_name]

   # ca setup ... 
   set ca_admin_mail $ts_config(report_mail_to)
   set ca_location "Regensburg"
   set ca_country  "DE"
   set ca_org      "Sun Microsystems"
   set ca_org_unit "Hedeby system $hedeby_system_name"
   set ca_state    "Germany"
   set sge_root $ts_config(product_root)

   # ssl disabled
   set ssl_disabled $hedeby_config(security_disable)

   puts $CHECK_OUTPUT "==Install params==========================="
   puts $CHECK_OUTPUT "sdmadm_path:      $sdmadm_path"
   puts $CHECK_OUTPUT "dist_path:        $dist_path" 
   puts $CHECK_OUTPUT "spool_dir:        $spool_dir"
   puts $CHECK_OUTPUT "cs_port:          $cs_port"
   puts $CHECK_OUTPUT "sge_root:         $sge_root"
   puts $CHECK_OUTPUT "   ca_admin_mail: $ca_admin_mail"
   puts $CHECK_OUTPUT "   ca_location:   $ca_location"
   puts $CHECK_OUTPUT "   ca_country:    $ca_country"
   puts $CHECK_OUTPUT "   ca_org:        $ca_org"
   puts $CHECK_OUTPUT "   ca_org_unit:   $ca_org_unit"
   puts $CHECK_OUTPUT "   ca_state:      $ca_state"
   puts $CHECK_OUTPUT "ssl disabled:     $ssl_disabled"
   puts $CHECK_OUTPUT "======================================="

   # install new system ...
   set arguments "-s $hedeby_system_name\
                  -p [get_hedeby_pref_type]\
                  imsth\
                  -ca_admin_mail \"$ca_admin_mail\"\
                  -ca_state \"$ca_state\"\
                  -ca_country \"$ca_country\"\
                  -ca_location \"$ca_location\"\
                  -ca_org_unit \"$ca_org_unit\"\
                  -ca_org \"$ca_org\"\
                  -au [get_hedeby_admin_user]\
                  -d $dist_path\
                  -cs_port $cs_port\
                  -l $spool_dir\
                  -sge_root $sge_root"

   if { $ssl_disabled == "true" } {
      append arguments " -nossl"
   }

   set install_master_output [sdmadm_command $hedeby_config(hedeby_master_host) $install_user $arguments]
   if { $prg_exit_state != 0 } {
      add_proc_error "hedeby_install_master_host" -1 "$hedeby_config(hedeby_master_host)($install_user): sdmadm $arguments failed:\n$install_master_output"
   }
   # save certificate creation time to be able to check if the certs are 
   # valid on remote managed hosts when installing manages hosts later
   set certificate_creation_time_on_master_host [get_remote_time $hedeby_config(hedeby_master_host)]
}


proc hedeby_startup_master_host {} {
   global CHECK_OUTPUT
   global hedeby_config
   global install_user

   if { [startup_hedeby_hosts "master" $hedeby_config(hedeby_master_host) $install_user] != 0} {
      add_proc_error "hedeby_startup_master_host" -2 "error starting master host \"$hedeby_config(hedeby_master_host)\"!\nSkip hard here."
      return
   }
}


proc hedeby_startup_managed_hosts {} {
   global CHECK_OUTPUT
   global hedeby_config
   global install_user

   startup_hedeby_hosts "managed" [get_all_hedeby_managed_hosts] $install_user
}


proc hedeby_install_managed_hosts {} {
   global CHECK_OUTPUT
   global hedeby_config
   global install_user
   global certificate_creation_time_on_master_host

   # first we make sure to work on the first cluster config
   set_current_cluster_config_nr 0
   get_current_cluster_config_array ts_config

   # full path to sdmadm binary (script)
   set sdmadm_path [get_hedeby_binary_path "sdmadm" $install_user]

   # get distribution path
   set dist_path $hedeby_config(hedeby_product_root)

   # get CS port
   set cs_url [get_hedeby_cs_url]

   # set sge_root
   set sge_root $ts_config(product_root)

   # ssl disabled
   set ssl_disabled $hedeby_config(security_disable)

   # TODO: switch between interactive and copy cert mode when installing managed hosts

   # TODO: remove check spooldir uniq code if hedeby supports different spool dirs in user pref mode!
   if {[get_hedeby_pref_type] == "user"} {
      set check_dirs 1
   } else {
      set check_dirs 0
   }

   # first get tmp keystore and cacert files
   # the tmp files are deleted with the next test!
   puts $CHECK_OUTPUT "copy ca certificate and admin keystore ..."
   set ca_file [get_tmp_file_name "" "ca"]
   set admin_keystore_file [get_tmp_file_name "" "keystore"]
   set master_spool_dir [get_hedeby_local_spool_dir $hedeby_config(hedeby_master_host)]
   set admin_user [get_hedeby_admin_user]
   set cp_keystore_cmd "$master_spool_dir ; cp ./security/users/$admin_user.keystore $admin_keystore_file ; cp ./security/ca/ca_top/cacert.pem $ca_file"
   set result [start_remote_prog "$hedeby_config(hedeby_master_host)" $install_user "cd" "$cp_keystore_cmd"]
   puts $CHECK_OUTPUT "   copy ca result:"
   puts $CHECK_OUTPUT "   $result"
   puts $CHECK_OUTPUT "   admin_keystore file should be at:\n   $admin_keystore_file"
   puts $CHECK_OUTPUT "   ca cert file should be at:\n   $ca_file"
   puts $CHECK_OUTPUT ""
 
   puts $CHECK_OUTPUT "==Install params for all managed hosts=="
   puts $CHECK_OUTPUT "sdmadm_path:      $sdmadm_path"
   puts $CHECK_OUTPUT "dist_path:        $dist_path" 
   puts $CHECK_OUTPUT "cs_url:           $cs_url"
   puts $CHECK_OUTPUT "ssl disabled:     $ssl_disabled"
   puts $CHECK_OUTPUT "========================================"


   set managed_host_list [get_all_hedeby_managed_hosts]

   if { $check_dirs } {
      puts $CHECK_OUTPUT "checking for unique local spool dir for user pref install mode ..."
      set my_spool_text ""
      foreach managed_host $managed_host_list {
         # TODO: remove check spooldir uniq code if hedeby supports different spool dirs in user pref mode!
         set mHostSpoolDir [get_hedeby_local_spool_dir $managed_host]
         if { $master_spool_dir != $mHostSpoolDir } {
            append my_spool_text "local spool dir not unique for user pref mode!\n"
            append my_spool_text "Host \"$managed_host\" is using spool dir:\n\"$mHostSpoolDir\"\n"
            append my_spool_text "master spool dir is:\n\"$master_spool_dir\"\n\n"
         }
      }
      if { $my_spool_text != "" } {
         add_proc_error "hedeby_install_managed_hosts" -2 $my_spool_text
         return
      }
      puts $CHECK_OUTPUT ""
   }

   foreach managed_host $managed_host_list {
      # create and/or delete local spool directory for hedeby master host ...
      # (the spool_dir itself should not be existing)

      puts $CHECK_OUTPUT "\nCleaning up local spool dir on host $managed_host ..."
      set managed_host_sdmadm_arguments($managed_host,spool_dir) [cleanup_hedeby_local_spool_dir $managed_host]
      puts $CHECK_OUTPUT "   using spool dir:\n   $managed_host_sdmadm_arguments($managed_host,spool_dir)"
   }

   foreach managed_host $managed_host_list {
      puts $CHECK_OUTPUT "Checking NFS availability of ca and keystore file on host $managed_host ..."
      # check that NFS has transported the keystore and cacert file to the managed host ...
      wait_for_remote_file $managed_host $install_user $admin_keystore_file
      wait_for_remote_file $managed_host $install_user $ca_file

      # check that managed host time is older than creation time of certificates ...
      set local_time [get_remote_time $managed_host]
      while { $local_time < $certificate_creation_time_on_master_host } {
         set time_diff [expr ( $local_time - $certificate_creation_time_on_master_host )]
         puts $CHECK_OUTPUT "time difference between certificate creation time on master host \"$hedeby_config(hedeby_master_host)\" and managed host \"$managed_host\": $time_diff"
         after 2000
         set local_time [get_remote_time $managed_host]
      }
   }

   puts $CHECK_OUTPUT "Starting parallel managed host installation ..."
   foreach managed_host $managed_host_list {
      # install new system ...
      set arguments "-s [get_hedeby_system_name]\
                     -p [get_hedeby_pref_type]\
                     -k $admin_keystore_file\
                     -cc $ca_file\
                     imgdh\
                     -au [get_hedeby_admin_user]\
                     -d $dist_path\
                     -l $managed_host_sdmadm_arguments($managed_host,spool_dir)\
                     -cs_url $cs_url"

      if { $ssl_disabled == "true" } {
         append arguments " -nossl"
      }
      # TODO: make installation of managed host interactive - we have to trust the certificate in a question
      set task_info($managed_host,expected_output) ""
      set task_info($managed_host,sdmadm_command) $arguments
   }

   set error_text [start_parallel_sdmadm_command managed_host_list $install_user task_info]
   
   foreach managed_host $managed_host_list {
      set exit_state $task_info($managed_host,exit_status)
      set output $task_info($managed_host,output)
      debug_puts "----------------------------------"
      debug_puts "managed_host: $managed_host"
      debug_puts "exit status: $exit_state"
      debug_puts "output:\n$output"
      debug_puts "----------------------------------"
   }

   if { $error_text != "" } {
      add_proc_error "hedeby_install_managed_hosts" -1 $error_text
   }
}

